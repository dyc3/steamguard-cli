// This file is generated by rust-protobuf 3.1.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `econ_gcmessages.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_1_0;

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgApplyAutograph)
pub struct CMsgApplyAutograph {
    // message fields
    // @@protoc_insertion_point(field:CMsgApplyAutograph.autograph_item_id)
    pub autograph_item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgApplyAutograph.item_item_id)
    pub item_item_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgApplyAutograph.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgApplyAutograph {
    fn default() -> &'a CMsgApplyAutograph {
        <CMsgApplyAutograph as ::protobuf::Message>::default_instance()
    }
}

impl CMsgApplyAutograph {
    pub fn new() -> CMsgApplyAutograph {
        ::std::default::Default::default()
    }

    // optional uint64 autograph_item_id = 1;

    pub fn autograph_item_id(&self) -> u64 {
        self.autograph_item_id.unwrap_or(0)
    }

    pub fn clear_autograph_item_id(&mut self) {
        self.autograph_item_id = ::std::option::Option::None;
    }

    pub fn has_autograph_item_id(&self) -> bool {
        self.autograph_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_autograph_item_id(&mut self, v: u64) {
        self.autograph_item_id = ::std::option::Option::Some(v);
    }

    // optional uint64 item_item_id = 2;

    pub fn item_item_id(&self) -> u64 {
        self.item_item_id.unwrap_or(0)
    }

    pub fn clear_item_item_id(&mut self) {
        self.item_item_id = ::std::option::Option::None;
    }

    pub fn has_item_item_id(&self) -> bool {
        self.item_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_item_id(&mut self, v: u64) {
        self.item_item_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "autograph_item_id",
            |m: &CMsgApplyAutograph| { &m.autograph_item_id },
            |m: &mut CMsgApplyAutograph| { &mut m.autograph_item_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_item_id",
            |m: &CMsgApplyAutograph| { &m.item_item_id },
            |m: &mut CMsgApplyAutograph| { &mut m.item_item_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgApplyAutograph>(
            "CMsgApplyAutograph",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgApplyAutograph {
    const NAME: &'static str = "CMsgApplyAutograph";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.autograph_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.item_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.autograph_item_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.item_item_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.autograph_item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.item_item_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgApplyAutograph {
        CMsgApplyAutograph::new()
    }

    fn clear(&mut self) {
        self.autograph_item_id = ::std::option::Option::None;
        self.item_item_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgApplyAutograph {
        static instance: CMsgApplyAutograph = CMsgApplyAutograph {
            autograph_item_id: ::std::option::Option::None,
            item_item_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgApplyAutograph {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgApplyAutograph").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgApplyAutograph {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgApplyAutograph {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgEconPlayerStrangeCountAdjustment)
pub struct CMsgEconPlayerStrangeCountAdjustment {
    // message fields
    // @@protoc_insertion_point(field:CMsgEconPlayerStrangeCountAdjustment.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgEconPlayerStrangeCountAdjustment.strange_count_adjustments)
    pub strange_count_adjustments: ::std::vec::Vec<cmsg_econ_player_strange_count_adjustment::CStrangeCountAdjustment>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgEconPlayerStrangeCountAdjustment.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgEconPlayerStrangeCountAdjustment {
    fn default() -> &'a CMsgEconPlayerStrangeCountAdjustment {
        <CMsgEconPlayerStrangeCountAdjustment as ::protobuf::Message>::default_instance()
    }
}

impl CMsgEconPlayerStrangeCountAdjustment {
    pub fn new() -> CMsgEconPlayerStrangeCountAdjustment {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CMsgEconPlayerStrangeCountAdjustment| { &m.account_id },
            |m: &mut CMsgEconPlayerStrangeCountAdjustment| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "strange_count_adjustments",
            |m: &CMsgEconPlayerStrangeCountAdjustment| { &m.strange_count_adjustments },
            |m: &mut CMsgEconPlayerStrangeCountAdjustment| { &mut m.strange_count_adjustments },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgEconPlayerStrangeCountAdjustment>(
            "CMsgEconPlayerStrangeCountAdjustment",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgEconPlayerStrangeCountAdjustment {
    const NAME: &'static str = "CMsgEconPlayerStrangeCountAdjustment";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.strange_count_adjustments.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.strange_count_adjustments {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.strange_count_adjustments {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgEconPlayerStrangeCountAdjustment {
        CMsgEconPlayerStrangeCountAdjustment::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.strange_count_adjustments.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgEconPlayerStrangeCountAdjustment {
        static instance: CMsgEconPlayerStrangeCountAdjustment = CMsgEconPlayerStrangeCountAdjustment {
            account_id: ::std::option::Option::None,
            strange_count_adjustments: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgEconPlayerStrangeCountAdjustment {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgEconPlayerStrangeCountAdjustment").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgEconPlayerStrangeCountAdjustment {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgEconPlayerStrangeCountAdjustment {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgEconPlayerStrangeCountAdjustment`
pub mod cmsg_econ_player_strange_count_adjustment {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:CMsgEconPlayerStrangeCountAdjustment.CStrangeCountAdjustment)
    pub struct CStrangeCountAdjustment {
        // message fields
        // @@protoc_insertion_point(field:CMsgEconPlayerStrangeCountAdjustment.CStrangeCountAdjustment.event_type)
        pub event_type: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgEconPlayerStrangeCountAdjustment.CStrangeCountAdjustment.item_id)
        pub item_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgEconPlayerStrangeCountAdjustment.CStrangeCountAdjustment.adjustment)
        pub adjustment: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgEconPlayerStrangeCountAdjustment.CStrangeCountAdjustment.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CStrangeCountAdjustment {
        fn default() -> &'a CStrangeCountAdjustment {
            <CStrangeCountAdjustment as ::protobuf::Message>::default_instance()
        }
    }

    impl CStrangeCountAdjustment {
        pub fn new() -> CStrangeCountAdjustment {
            ::std::default::Default::default()
        }

        // optional uint32 event_type = 1;

        pub fn event_type(&self) -> u32 {
            self.event_type.unwrap_or(0)
        }

        pub fn clear_event_type(&mut self) {
            self.event_type = ::std::option::Option::None;
        }

        pub fn has_event_type(&self) -> bool {
            self.event_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_event_type(&mut self, v: u32) {
            self.event_type = ::std::option::Option::Some(v);
        }

        // optional uint64 item_id = 2;

        pub fn item_id(&self) -> u64 {
            self.item_id.unwrap_or(0)
        }

        pub fn clear_item_id(&mut self) {
            self.item_id = ::std::option::Option::None;
        }

        pub fn has_item_id(&self) -> bool {
            self.item_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_item_id(&mut self, v: u64) {
            self.item_id = ::std::option::Option::Some(v);
        }

        // optional uint32 adjustment = 3;

        pub fn adjustment(&self) -> u32 {
            self.adjustment.unwrap_or(0)
        }

        pub fn clear_adjustment(&mut self) {
            self.adjustment = ::std::option::Option::None;
        }

        pub fn has_adjustment(&self) -> bool {
            self.adjustment.is_some()
        }

        // Param is passed by value, moved
        pub fn set_adjustment(&mut self, v: u32) {
            self.adjustment = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "event_type",
                |m: &CStrangeCountAdjustment| { &m.event_type },
                |m: &mut CStrangeCountAdjustment| { &mut m.event_type },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "item_id",
                |m: &CStrangeCountAdjustment| { &m.item_id },
                |m: &mut CStrangeCountAdjustment| { &mut m.item_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "adjustment",
                |m: &CStrangeCountAdjustment| { &m.adjustment },
                |m: &mut CStrangeCountAdjustment| { &mut m.adjustment },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CStrangeCountAdjustment>(
                "CMsgEconPlayerStrangeCountAdjustment.CStrangeCountAdjustment",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for CStrangeCountAdjustment {
        const NAME: &'static str = "CStrangeCountAdjustment";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.event_type = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    24 => {
                        self.adjustment = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.event_type {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.item_id {
                my_size += ::protobuf::rt::uint64_size(2, v);
            }
            if let Some(v) = self.adjustment {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.event_type {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.item_id {
                os.write_uint64(2, v)?;
            }
            if let Some(v) = self.adjustment {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CStrangeCountAdjustment {
            CStrangeCountAdjustment::new()
        }

        fn clear(&mut self) {
            self.event_type = ::std::option::Option::None;
            self.item_id = ::std::option::Option::None;
            self.adjustment = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CStrangeCountAdjustment {
            static instance: CStrangeCountAdjustment = CStrangeCountAdjustment {
                event_type: ::std::option::Option::None,
                item_id: ::std::option::Option::None,
                adjustment: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for CStrangeCountAdjustment {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgEconPlayerStrangeCountAdjustment.CStrangeCountAdjustment").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for CStrangeCountAdjustment {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for CStrangeCountAdjustment {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgRequestItemPurgatory_FinalizePurchase)
pub struct CMsgRequestItemPurgatory_FinalizePurchase {
    // message fields
    // @@protoc_insertion_point(field:CMsgRequestItemPurgatory_FinalizePurchase.item_ids)
    pub item_ids: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgRequestItemPurgatory_FinalizePurchase.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRequestItemPurgatory_FinalizePurchase {
    fn default() -> &'a CMsgRequestItemPurgatory_FinalizePurchase {
        <CMsgRequestItemPurgatory_FinalizePurchase as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRequestItemPurgatory_FinalizePurchase {
    pub fn new() -> CMsgRequestItemPurgatory_FinalizePurchase {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "item_ids",
            |m: &CMsgRequestItemPurgatory_FinalizePurchase| { &m.item_ids },
            |m: &mut CMsgRequestItemPurgatory_FinalizePurchase| { &mut m.item_ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgRequestItemPurgatory_FinalizePurchase>(
            "CMsgRequestItemPurgatory_FinalizePurchase",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgRequestItemPurgatory_FinalizePurchase {
    const NAME: &'static str = "CMsgRequestItemPurgatory_FinalizePurchase";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint64_into(&mut self.item_ids)?;
                },
                8 => {
                    self.item_ids.push(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.item_ids {
            my_size += ::protobuf::rt::uint64_size(1, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.item_ids {
            os.write_uint64(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRequestItemPurgatory_FinalizePurchase {
        CMsgRequestItemPurgatory_FinalizePurchase::new()
    }

    fn clear(&mut self) {
        self.item_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRequestItemPurgatory_FinalizePurchase {
        static instance: CMsgRequestItemPurgatory_FinalizePurchase = CMsgRequestItemPurgatory_FinalizePurchase {
            item_ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgRequestItemPurgatory_FinalizePurchase {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgRequestItemPurgatory_FinalizePurchase").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgRequestItemPurgatory_FinalizePurchase {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgRequestItemPurgatory_FinalizePurchase {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgRequestItemPurgatory_FinalizePurchaseResponse)
pub struct CMsgRequestItemPurgatory_FinalizePurchaseResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgRequestItemPurgatory_FinalizePurchaseResponse.result)
    pub result: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgRequestItemPurgatory_FinalizePurchaseResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRequestItemPurgatory_FinalizePurchaseResponse {
    fn default() -> &'a CMsgRequestItemPurgatory_FinalizePurchaseResponse {
        <CMsgRequestItemPurgatory_FinalizePurchaseResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRequestItemPurgatory_FinalizePurchaseResponse {
    pub fn new() -> CMsgRequestItemPurgatory_FinalizePurchaseResponse {
        ::std::default::Default::default()
    }

    // optional uint32 result = 1;

    pub fn result(&self) -> u32 {
        self.result.unwrap_or(0)
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: u32) {
        self.result = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &CMsgRequestItemPurgatory_FinalizePurchaseResponse| { &m.result },
            |m: &mut CMsgRequestItemPurgatory_FinalizePurchaseResponse| { &mut m.result },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgRequestItemPurgatory_FinalizePurchaseResponse>(
            "CMsgRequestItemPurgatory_FinalizePurchaseResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgRequestItemPurgatory_FinalizePurchaseResponse {
    const NAME: &'static str = "CMsgRequestItemPurgatory_FinalizePurchaseResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRequestItemPurgatory_FinalizePurchaseResponse {
        CMsgRequestItemPurgatory_FinalizePurchaseResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRequestItemPurgatory_FinalizePurchaseResponse {
        static instance: CMsgRequestItemPurgatory_FinalizePurchaseResponse = CMsgRequestItemPurgatory_FinalizePurchaseResponse {
            result: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgRequestItemPurgatory_FinalizePurchaseResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgRequestItemPurgatory_FinalizePurchaseResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgRequestItemPurgatory_FinalizePurchaseResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgRequestItemPurgatory_FinalizePurchaseResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgRequestItemPurgatory_RefundPurchase)
pub struct CMsgRequestItemPurgatory_RefundPurchase {
    // message fields
    // @@protoc_insertion_point(field:CMsgRequestItemPurgatory_RefundPurchase.item_id)
    pub item_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgRequestItemPurgatory_RefundPurchase.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRequestItemPurgatory_RefundPurchase {
    fn default() -> &'a CMsgRequestItemPurgatory_RefundPurchase {
        <CMsgRequestItemPurgatory_RefundPurchase as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRequestItemPurgatory_RefundPurchase {
    pub fn new() -> CMsgRequestItemPurgatory_RefundPurchase {
        ::std::default::Default::default()
    }

    // optional uint64 item_id = 1;

    pub fn item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_id",
            |m: &CMsgRequestItemPurgatory_RefundPurchase| { &m.item_id },
            |m: &mut CMsgRequestItemPurgatory_RefundPurchase| { &mut m.item_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgRequestItemPurgatory_RefundPurchase>(
            "CMsgRequestItemPurgatory_RefundPurchase",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgRequestItemPurgatory_RefundPurchase {
    const NAME: &'static str = "CMsgRequestItemPurgatory_RefundPurchase";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.item_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRequestItemPurgatory_RefundPurchase {
        CMsgRequestItemPurgatory_RefundPurchase::new()
    }

    fn clear(&mut self) {
        self.item_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRequestItemPurgatory_RefundPurchase {
        static instance: CMsgRequestItemPurgatory_RefundPurchase = CMsgRequestItemPurgatory_RefundPurchase {
            item_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgRequestItemPurgatory_RefundPurchase {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgRequestItemPurgatory_RefundPurchase").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgRequestItemPurgatory_RefundPurchase {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgRequestItemPurgatory_RefundPurchase {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgRequestItemPurgatory_RefundPurchaseResponse)
pub struct CMsgRequestItemPurgatory_RefundPurchaseResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgRequestItemPurgatory_RefundPurchaseResponse.result)
    pub result: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgRequestItemPurgatory_RefundPurchaseResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRequestItemPurgatory_RefundPurchaseResponse {
    fn default() -> &'a CMsgRequestItemPurgatory_RefundPurchaseResponse {
        <CMsgRequestItemPurgatory_RefundPurchaseResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRequestItemPurgatory_RefundPurchaseResponse {
    pub fn new() -> CMsgRequestItemPurgatory_RefundPurchaseResponse {
        ::std::default::Default::default()
    }

    // optional uint32 result = 1;

    pub fn result(&self) -> u32 {
        self.result.unwrap_or(0)
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: u32) {
        self.result = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &CMsgRequestItemPurgatory_RefundPurchaseResponse| { &m.result },
            |m: &mut CMsgRequestItemPurgatory_RefundPurchaseResponse| { &mut m.result },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgRequestItemPurgatory_RefundPurchaseResponse>(
            "CMsgRequestItemPurgatory_RefundPurchaseResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgRequestItemPurgatory_RefundPurchaseResponse {
    const NAME: &'static str = "CMsgRequestItemPurgatory_RefundPurchaseResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRequestItemPurgatory_RefundPurchaseResponse {
        CMsgRequestItemPurgatory_RefundPurchaseResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRequestItemPurgatory_RefundPurchaseResponse {
        static instance: CMsgRequestItemPurgatory_RefundPurchaseResponse = CMsgRequestItemPurgatory_RefundPurchaseResponse {
            result: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgRequestItemPurgatory_RefundPurchaseResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgRequestItemPurgatory_RefundPurchaseResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgRequestItemPurgatory_RefundPurchaseResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgRequestItemPurgatory_RefundPurchaseResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgCraftingResponse)
pub struct CMsgCraftingResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgCraftingResponse.item_ids)
    pub item_ids: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgCraftingResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgCraftingResponse {
    fn default() -> &'a CMsgCraftingResponse {
        <CMsgCraftingResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgCraftingResponse {
    pub fn new() -> CMsgCraftingResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "item_ids",
            |m: &CMsgCraftingResponse| { &m.item_ids },
            |m: &mut CMsgCraftingResponse| { &mut m.item_ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgCraftingResponse>(
            "CMsgCraftingResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgCraftingResponse {
    const NAME: &'static str = "CMsgCraftingResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint64_into(&mut self.item_ids)?;
                },
                8 => {
                    self.item_ids.push(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.item_ids {
            my_size += ::protobuf::rt::uint64_size(1, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.item_ids {
            os.write_uint64(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgCraftingResponse {
        CMsgCraftingResponse::new()
    }

    fn clear(&mut self) {
        self.item_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgCraftingResponse {
        static instance: CMsgCraftingResponse = CMsgCraftingResponse {
            item_ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgCraftingResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgCraftingResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgCraftingResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgCraftingResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCRequestStoreSalesData)
pub struct CMsgGCRequestStoreSalesData {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCRequestStoreSalesData.version)
    pub version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCRequestStoreSalesData.currency)
    pub currency: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCRequestStoreSalesData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCRequestStoreSalesData {
    fn default() -> &'a CMsgGCRequestStoreSalesData {
        <CMsgGCRequestStoreSalesData as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCRequestStoreSalesData {
    pub fn new() -> CMsgGCRequestStoreSalesData {
        ::std::default::Default::default()
    }

    // optional uint32 version = 1;

    pub fn version(&self) -> u32 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u32) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional uint32 currency = 2;

    pub fn currency(&self) -> u32 {
        self.currency.unwrap_or(0)
    }

    pub fn clear_currency(&mut self) {
        self.currency = ::std::option::Option::None;
    }

    pub fn has_currency(&self) -> bool {
        self.currency.is_some()
    }

    // Param is passed by value, moved
    pub fn set_currency(&mut self, v: u32) {
        self.currency = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &CMsgGCRequestStoreSalesData| { &m.version },
            |m: &mut CMsgGCRequestStoreSalesData| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "currency",
            |m: &CMsgGCRequestStoreSalesData| { &m.currency },
            |m: &mut CMsgGCRequestStoreSalesData| { &mut m.currency },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCRequestStoreSalesData>(
            "CMsgGCRequestStoreSalesData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCRequestStoreSalesData {
    const NAME: &'static str = "CMsgGCRequestStoreSalesData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.version = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.currency = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.currency {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.version {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.currency {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCRequestStoreSalesData {
        CMsgGCRequestStoreSalesData::new()
    }

    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.currency = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCRequestStoreSalesData {
        static instance: CMsgGCRequestStoreSalesData = CMsgGCRequestStoreSalesData {
            version: ::std::option::Option::None,
            currency: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCRequestStoreSalesData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCRequestStoreSalesData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCRequestStoreSalesData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCRequestStoreSalesData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCRequestStoreSalesDataResponse)
pub struct CMsgGCRequestStoreSalesDataResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCRequestStoreSalesDataResponse.sale_price)
    pub sale_price: ::std::vec::Vec<cmsg_gcrequest_store_sales_data_response::Price>,
    // @@protoc_insertion_point(field:CMsgGCRequestStoreSalesDataResponse.version)
    pub version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCRequestStoreSalesDataResponse.expiration_time)
    pub expiration_time: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCRequestStoreSalesDataResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCRequestStoreSalesDataResponse {
    fn default() -> &'a CMsgGCRequestStoreSalesDataResponse {
        <CMsgGCRequestStoreSalesDataResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCRequestStoreSalesDataResponse {
    pub fn new() -> CMsgGCRequestStoreSalesDataResponse {
        ::std::default::Default::default()
    }

    // optional uint32 version = 2;

    pub fn version(&self) -> u32 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u32) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional uint32 expiration_time = 3;

    pub fn expiration_time(&self) -> u32 {
        self.expiration_time.unwrap_or(0)
    }

    pub fn clear_expiration_time(&mut self) {
        self.expiration_time = ::std::option::Option::None;
    }

    pub fn has_expiration_time(&self) -> bool {
        self.expiration_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expiration_time(&mut self, v: u32) {
        self.expiration_time = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "sale_price",
            |m: &CMsgGCRequestStoreSalesDataResponse| { &m.sale_price },
            |m: &mut CMsgGCRequestStoreSalesDataResponse| { &mut m.sale_price },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &CMsgGCRequestStoreSalesDataResponse| { &m.version },
            |m: &mut CMsgGCRequestStoreSalesDataResponse| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "expiration_time",
            |m: &CMsgGCRequestStoreSalesDataResponse| { &m.expiration_time },
            |m: &mut CMsgGCRequestStoreSalesDataResponse| { &mut m.expiration_time },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCRequestStoreSalesDataResponse>(
            "CMsgGCRequestStoreSalesDataResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCRequestStoreSalesDataResponse {
    const NAME: &'static str = "CMsgGCRequestStoreSalesDataResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.sale_price.push(is.read_message()?);
                },
                16 => {
                    self.version = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.expiration_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.sale_price {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.expiration_time {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.sale_price {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.version {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.expiration_time {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCRequestStoreSalesDataResponse {
        CMsgGCRequestStoreSalesDataResponse::new()
    }

    fn clear(&mut self) {
        self.sale_price.clear();
        self.version = ::std::option::Option::None;
        self.expiration_time = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCRequestStoreSalesDataResponse {
        static instance: CMsgGCRequestStoreSalesDataResponse = CMsgGCRequestStoreSalesDataResponse {
            sale_price: ::std::vec::Vec::new(),
            version: ::std::option::Option::None,
            expiration_time: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCRequestStoreSalesDataResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCRequestStoreSalesDataResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCRequestStoreSalesDataResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCRequestStoreSalesDataResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgGCRequestStoreSalesDataResponse`
pub mod cmsg_gcrequest_store_sales_data_response {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:CMsgGCRequestStoreSalesDataResponse.Price)
    pub struct Price {
        // message fields
        // @@protoc_insertion_point(field:CMsgGCRequestStoreSalesDataResponse.Price.item_def)
        pub item_def: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCRequestStoreSalesDataResponse.Price.price)
        pub price: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGCRequestStoreSalesDataResponse.Price.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Price {
        fn default() -> &'a Price {
            <Price as ::protobuf::Message>::default_instance()
        }
    }

    impl Price {
        pub fn new() -> Price {
            ::std::default::Default::default()
        }

        // optional uint32 item_def = 1;

        pub fn item_def(&self) -> u32 {
            self.item_def.unwrap_or(0)
        }

        pub fn clear_item_def(&mut self) {
            self.item_def = ::std::option::Option::None;
        }

        pub fn has_item_def(&self) -> bool {
            self.item_def.is_some()
        }

        // Param is passed by value, moved
        pub fn set_item_def(&mut self, v: u32) {
            self.item_def = ::std::option::Option::Some(v);
        }

        // optional uint32 price = 2;

        pub fn price(&self) -> u32 {
            self.price.unwrap_or(0)
        }

        pub fn clear_price(&mut self) {
            self.price = ::std::option::Option::None;
        }

        pub fn has_price(&self) -> bool {
            self.price.is_some()
        }

        // Param is passed by value, moved
        pub fn set_price(&mut self, v: u32) {
            self.price = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "item_def",
                |m: &Price| { &m.item_def },
                |m: &mut Price| { &mut m.item_def },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "price",
                |m: &Price| { &m.price },
                |m: &mut Price| { &mut m.price },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Price>(
                "CMsgGCRequestStoreSalesDataResponse.Price",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Price {
        const NAME: &'static str = "Price";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.item_def = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.price = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.item_def {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.price {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.item_def {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.price {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Price {
            Price::new()
        }

        fn clear(&mut self) {
            self.item_def = ::std::option::Option::None;
            self.price = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Price {
            static instance: Price = Price {
                item_def: ::std::option::Option::None,
                price: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Price {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgGCRequestStoreSalesDataResponse.Price").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Price {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Price {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCRequestStoreSalesDataUpToDateResponse)
pub struct CMsgGCRequestStoreSalesDataUpToDateResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCRequestStoreSalesDataUpToDateResponse.version)
    pub version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCRequestStoreSalesDataUpToDateResponse.expiration_time)
    pub expiration_time: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCRequestStoreSalesDataUpToDateResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCRequestStoreSalesDataUpToDateResponse {
    fn default() -> &'a CMsgGCRequestStoreSalesDataUpToDateResponse {
        <CMsgGCRequestStoreSalesDataUpToDateResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCRequestStoreSalesDataUpToDateResponse {
    pub fn new() -> CMsgGCRequestStoreSalesDataUpToDateResponse {
        ::std::default::Default::default()
    }

    // optional uint32 version = 1;

    pub fn version(&self) -> u32 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u32) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional uint32 expiration_time = 2;

    pub fn expiration_time(&self) -> u32 {
        self.expiration_time.unwrap_or(0)
    }

    pub fn clear_expiration_time(&mut self) {
        self.expiration_time = ::std::option::Option::None;
    }

    pub fn has_expiration_time(&self) -> bool {
        self.expiration_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expiration_time(&mut self, v: u32) {
        self.expiration_time = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &CMsgGCRequestStoreSalesDataUpToDateResponse| { &m.version },
            |m: &mut CMsgGCRequestStoreSalesDataUpToDateResponse| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "expiration_time",
            |m: &CMsgGCRequestStoreSalesDataUpToDateResponse| { &m.expiration_time },
            |m: &mut CMsgGCRequestStoreSalesDataUpToDateResponse| { &mut m.expiration_time },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCRequestStoreSalesDataUpToDateResponse>(
            "CMsgGCRequestStoreSalesDataUpToDateResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCRequestStoreSalesDataUpToDateResponse {
    const NAME: &'static str = "CMsgGCRequestStoreSalesDataUpToDateResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.version = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.expiration_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.expiration_time {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.version {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.expiration_time {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCRequestStoreSalesDataUpToDateResponse {
        CMsgGCRequestStoreSalesDataUpToDateResponse::new()
    }

    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.expiration_time = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCRequestStoreSalesDataUpToDateResponse {
        static instance: CMsgGCRequestStoreSalesDataUpToDateResponse = CMsgGCRequestStoreSalesDataUpToDateResponse {
            version: ::std::option::Option::None,
            expiration_time: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCRequestStoreSalesDataUpToDateResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCRequestStoreSalesDataUpToDateResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCRequestStoreSalesDataUpToDateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCRequestStoreSalesDataUpToDateResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCToGCPingRequest)
pub struct CMsgGCToGCPingRequest {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToGCPingRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCPingRequest {
    fn default() -> &'a CMsgGCToGCPingRequest {
        <CMsgGCToGCPingRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCPingRequest {
    pub fn new() -> CMsgGCToGCPingRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToGCPingRequest>(
            "CMsgGCToGCPingRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToGCPingRequest {
    const NAME: &'static str = "CMsgGCToGCPingRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCPingRequest {
        CMsgGCToGCPingRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCPingRequest {
        static instance: CMsgGCToGCPingRequest = CMsgGCToGCPingRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToGCPingRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToGCPingRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToGCPingRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCPingRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCToGCPingResponse)
pub struct CMsgGCToGCPingResponse {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToGCPingResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCPingResponse {
    fn default() -> &'a CMsgGCToGCPingResponse {
        <CMsgGCToGCPingResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCPingResponse {
    pub fn new() -> CMsgGCToGCPingResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToGCPingResponse>(
            "CMsgGCToGCPingResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToGCPingResponse {
    const NAME: &'static str = "CMsgGCToGCPingResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCPingResponse {
        CMsgGCToGCPingResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCPingResponse {
        static instance: CMsgGCToGCPingResponse = CMsgGCToGCPingResponse {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToGCPingResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToGCPingResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToGCPingResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCPingResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCToGCGetUserSessionServer)
pub struct CMsgGCToGCGetUserSessionServer {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToGCGetUserSessionServer.account_id)
    pub account_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToGCGetUserSessionServer.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCGetUserSessionServer {
    fn default() -> &'a CMsgGCToGCGetUserSessionServer {
        <CMsgGCToGCGetUserSessionServer as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCGetUserSessionServer {
    pub fn new() -> CMsgGCToGCGetUserSessionServer {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CMsgGCToGCGetUserSessionServer| { &m.account_id },
            |m: &mut CMsgGCToGCGetUserSessionServer| { &mut m.account_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToGCGetUserSessionServer>(
            "CMsgGCToGCGetUserSessionServer",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToGCGetUserSessionServer {
    const NAME: &'static str = "CMsgGCToGCGetUserSessionServer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCGetUserSessionServer {
        CMsgGCToGCGetUserSessionServer::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCGetUserSessionServer {
        static instance: CMsgGCToGCGetUserSessionServer = CMsgGCToGCGetUserSessionServer {
            account_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToGCGetUserSessionServer {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToGCGetUserSessionServer").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToGCGetUserSessionServer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCGetUserSessionServer {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCToGCGetUserSessionServerResponse)
pub struct CMsgGCToGCGetUserSessionServerResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToGCGetUserSessionServerResponse.server_steam_id)
    pub server_steam_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToGCGetUserSessionServerResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCGetUserSessionServerResponse {
    fn default() -> &'a CMsgGCToGCGetUserSessionServerResponse {
        <CMsgGCToGCGetUserSessionServerResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCGetUserSessionServerResponse {
    pub fn new() -> CMsgGCToGCGetUserSessionServerResponse {
        ::std::default::Default::default()
    }

    // optional fixed64 server_steam_id = 1;

    pub fn server_steam_id(&self) -> u64 {
        self.server_steam_id.unwrap_or(0)
    }

    pub fn clear_server_steam_id(&mut self) {
        self.server_steam_id = ::std::option::Option::None;
    }

    pub fn has_server_steam_id(&self) -> bool {
        self.server_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_steam_id(&mut self, v: u64) {
        self.server_steam_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_steam_id",
            |m: &CMsgGCToGCGetUserSessionServerResponse| { &m.server_steam_id },
            |m: &mut CMsgGCToGCGetUserSessionServerResponse| { &mut m.server_steam_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToGCGetUserSessionServerResponse>(
            "CMsgGCToGCGetUserSessionServerResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToGCGetUserSessionServerResponse {
    const NAME: &'static str = "CMsgGCToGCGetUserSessionServerResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.server_steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.server_steam_id {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.server_steam_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCGetUserSessionServerResponse {
        CMsgGCToGCGetUserSessionServerResponse::new()
    }

    fn clear(&mut self) {
        self.server_steam_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCGetUserSessionServerResponse {
        static instance: CMsgGCToGCGetUserSessionServerResponse = CMsgGCToGCGetUserSessionServerResponse {
            server_steam_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToGCGetUserSessionServerResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToGCGetUserSessionServerResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToGCGetUserSessionServerResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCGetUserSessionServerResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCToGCGetUserServerMembers)
pub struct CMsgGCToGCGetUserServerMembers {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToGCGetUserServerMembers.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToGCGetUserServerMembers.max_spectators)
    pub max_spectators: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToGCGetUserServerMembers.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCGetUserServerMembers {
    fn default() -> &'a CMsgGCToGCGetUserServerMembers {
        <CMsgGCToGCGetUserServerMembers as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCGetUserServerMembers {
    pub fn new() -> CMsgGCToGCGetUserServerMembers {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 max_spectators = 2;

    pub fn max_spectators(&self) -> u32 {
        self.max_spectators.unwrap_or(0)
    }

    pub fn clear_max_spectators(&mut self) {
        self.max_spectators = ::std::option::Option::None;
    }

    pub fn has_max_spectators(&self) -> bool {
        self.max_spectators.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_spectators(&mut self, v: u32) {
        self.max_spectators = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CMsgGCToGCGetUserServerMembers| { &m.account_id },
            |m: &mut CMsgGCToGCGetUserServerMembers| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "max_spectators",
            |m: &CMsgGCToGCGetUserServerMembers| { &m.max_spectators },
            |m: &mut CMsgGCToGCGetUserServerMembers| { &mut m.max_spectators },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToGCGetUserServerMembers>(
            "CMsgGCToGCGetUserServerMembers",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToGCGetUserServerMembers {
    const NAME: &'static str = "CMsgGCToGCGetUserServerMembers";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.max_spectators = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.max_spectators {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.max_spectators {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCGetUserServerMembers {
        CMsgGCToGCGetUserServerMembers::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.max_spectators = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCGetUserServerMembers {
        static instance: CMsgGCToGCGetUserServerMembers = CMsgGCToGCGetUserServerMembers {
            account_id: ::std::option::Option::None,
            max_spectators: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToGCGetUserServerMembers {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToGCGetUserServerMembers").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToGCGetUserServerMembers {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCGetUserServerMembers {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCToGCGetUserServerMembersResponse)
pub struct CMsgGCToGCGetUserServerMembersResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToGCGetUserServerMembersResponse.member_account_id)
    pub member_account_id: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToGCGetUserServerMembersResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCGetUserServerMembersResponse {
    fn default() -> &'a CMsgGCToGCGetUserServerMembersResponse {
        <CMsgGCToGCGetUserServerMembersResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCGetUserServerMembersResponse {
    pub fn new() -> CMsgGCToGCGetUserServerMembersResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "member_account_id",
            |m: &CMsgGCToGCGetUserServerMembersResponse| { &m.member_account_id },
            |m: &mut CMsgGCToGCGetUserServerMembersResponse| { &mut m.member_account_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToGCGetUserServerMembersResponse>(
            "CMsgGCToGCGetUserServerMembersResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToGCGetUserServerMembersResponse {
    const NAME: &'static str = "CMsgGCToGCGetUserServerMembersResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.member_account_id)?;
                },
                8 => {
                    self.member_account_id.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.member_account_id {
            my_size += ::protobuf::rt::uint32_size(1, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.member_account_id {
            os.write_uint32(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCGetUserServerMembersResponse {
        CMsgGCToGCGetUserServerMembersResponse::new()
    }

    fn clear(&mut self) {
        self.member_account_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCGetUserServerMembersResponse {
        static instance: CMsgGCToGCGetUserServerMembersResponse = CMsgGCToGCGetUserServerMembersResponse {
            member_account_id: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToGCGetUserServerMembersResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToGCGetUserServerMembersResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToGCGetUserServerMembersResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCGetUserServerMembersResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgLookupMultipleAccountNames)
pub struct CMsgLookupMultipleAccountNames {
    // message fields
    // @@protoc_insertion_point(field:CMsgLookupMultipleAccountNames.accountids)
    pub accountids: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgLookupMultipleAccountNames.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgLookupMultipleAccountNames {
    fn default() -> &'a CMsgLookupMultipleAccountNames {
        <CMsgLookupMultipleAccountNames as ::protobuf::Message>::default_instance()
    }
}

impl CMsgLookupMultipleAccountNames {
    pub fn new() -> CMsgLookupMultipleAccountNames {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "accountids",
            |m: &CMsgLookupMultipleAccountNames| { &m.accountids },
            |m: &mut CMsgLookupMultipleAccountNames| { &mut m.accountids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgLookupMultipleAccountNames>(
            "CMsgLookupMultipleAccountNames",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgLookupMultipleAccountNames {
    const NAME: &'static str = "CMsgLookupMultipleAccountNames";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.accountids)?;
                },
                8 => {
                    self.accountids.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::vec_packed_uint32_size(1, &self.accountids);
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_repeated_packed_uint32(1, &self.accountids)?;
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgLookupMultipleAccountNames {
        CMsgLookupMultipleAccountNames::new()
    }

    fn clear(&mut self) {
        self.accountids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgLookupMultipleAccountNames {
        static instance: CMsgLookupMultipleAccountNames = CMsgLookupMultipleAccountNames {
            accountids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgLookupMultipleAccountNames {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgLookupMultipleAccountNames").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgLookupMultipleAccountNames {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgLookupMultipleAccountNames {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgLookupMultipleAccountNamesResponse)
pub struct CMsgLookupMultipleAccountNamesResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgLookupMultipleAccountNamesResponse.accounts)
    pub accounts: ::std::vec::Vec<cmsg_lookup_multiple_account_names_response::Account>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgLookupMultipleAccountNamesResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgLookupMultipleAccountNamesResponse {
    fn default() -> &'a CMsgLookupMultipleAccountNamesResponse {
        <CMsgLookupMultipleAccountNamesResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgLookupMultipleAccountNamesResponse {
    pub fn new() -> CMsgLookupMultipleAccountNamesResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "accounts",
            |m: &CMsgLookupMultipleAccountNamesResponse| { &m.accounts },
            |m: &mut CMsgLookupMultipleAccountNamesResponse| { &mut m.accounts },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgLookupMultipleAccountNamesResponse>(
            "CMsgLookupMultipleAccountNamesResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgLookupMultipleAccountNamesResponse {
    const NAME: &'static str = "CMsgLookupMultipleAccountNamesResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.accounts.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.accounts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.accounts {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgLookupMultipleAccountNamesResponse {
        CMsgLookupMultipleAccountNamesResponse::new()
    }

    fn clear(&mut self) {
        self.accounts.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgLookupMultipleAccountNamesResponse {
        static instance: CMsgLookupMultipleAccountNamesResponse = CMsgLookupMultipleAccountNamesResponse {
            accounts: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgLookupMultipleAccountNamesResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgLookupMultipleAccountNamesResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgLookupMultipleAccountNamesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgLookupMultipleAccountNamesResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgLookupMultipleAccountNamesResponse`
pub mod cmsg_lookup_multiple_account_names_response {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:CMsgLookupMultipleAccountNamesResponse.Account)
    pub struct Account {
        // message fields
        // @@protoc_insertion_point(field:CMsgLookupMultipleAccountNamesResponse.Account.accountid)
        pub accountid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgLookupMultipleAccountNamesResponse.Account.persona)
        pub persona: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgLookupMultipleAccountNamesResponse.Account.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Account {
        fn default() -> &'a Account {
            <Account as ::protobuf::Message>::default_instance()
        }
    }

    impl Account {
        pub fn new() -> Account {
            ::std::default::Default::default()
        }

        // optional uint32 accountid = 1;

        pub fn accountid(&self) -> u32 {
            self.accountid.unwrap_or(0)
        }

        pub fn clear_accountid(&mut self) {
            self.accountid = ::std::option::Option::None;
        }

        pub fn has_accountid(&self) -> bool {
            self.accountid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_accountid(&mut self, v: u32) {
            self.accountid = ::std::option::Option::Some(v);
        }

        // optional string persona = 2;

        pub fn persona(&self) -> &str {
            match self.persona.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_persona(&mut self) {
            self.persona = ::std::option::Option::None;
        }

        pub fn has_persona(&self) -> bool {
            self.persona.is_some()
        }

        // Param is passed by value, moved
        pub fn set_persona(&mut self, v: ::std::string::String) {
            self.persona = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_persona(&mut self) -> &mut ::std::string::String {
            if self.persona.is_none() {
                self.persona = ::std::option::Option::Some(::std::string::String::new());
            }
            self.persona.as_mut().unwrap()
        }

        // Take field
        pub fn take_persona(&mut self) -> ::std::string::String {
            self.persona.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "accountid",
                |m: &Account| { &m.accountid },
                |m: &mut Account| { &mut m.accountid },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "persona",
                |m: &Account| { &m.persona },
                |m: &mut Account| { &mut m.persona },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Account>(
                "CMsgLookupMultipleAccountNamesResponse.Account",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Account {
        const NAME: &'static str = "Account";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.accountid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.persona = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.accountid {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.persona.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.accountid {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.persona.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Account {
            Account::new()
        }

        fn clear(&mut self) {
            self.accountid = ::std::option::Option::None;
            self.persona = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Account {
            static instance: Account = Account {
                accountid: ::std::option::Option::None,
                persona: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Account {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgLookupMultipleAccountNamesResponse.Account").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Account {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Account {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCToGCGrantSelfMadeItemToAccount)
pub struct CMsgGCToGCGrantSelfMadeItemToAccount {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToGCGrantSelfMadeItemToAccount.item_def_index)
    pub item_def_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToGCGrantSelfMadeItemToAccount.accountid)
    pub accountid: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToGCGrantSelfMadeItemToAccount.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCGrantSelfMadeItemToAccount {
    fn default() -> &'a CMsgGCToGCGrantSelfMadeItemToAccount {
        <CMsgGCToGCGrantSelfMadeItemToAccount as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCGrantSelfMadeItemToAccount {
    pub fn new() -> CMsgGCToGCGrantSelfMadeItemToAccount {
        ::std::default::Default::default()
    }

    // optional uint32 item_def_index = 1;

    pub fn item_def_index(&self) -> u32 {
        self.item_def_index.unwrap_or(0)
    }

    pub fn clear_item_def_index(&mut self) {
        self.item_def_index = ::std::option::Option::None;
    }

    pub fn has_item_def_index(&self) -> bool {
        self.item_def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_def_index(&mut self, v: u32) {
        self.item_def_index = ::std::option::Option::Some(v);
    }

    // optional uint32 accountid = 2;

    pub fn accountid(&self) -> u32 {
        self.accountid.unwrap_or(0)
    }

    pub fn clear_accountid(&mut self) {
        self.accountid = ::std::option::Option::None;
    }

    pub fn has_accountid(&self) -> bool {
        self.accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid(&mut self, v: u32) {
        self.accountid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_def_index",
            |m: &CMsgGCToGCGrantSelfMadeItemToAccount| { &m.item_def_index },
            |m: &mut CMsgGCToGCGrantSelfMadeItemToAccount| { &mut m.item_def_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "accountid",
            |m: &CMsgGCToGCGrantSelfMadeItemToAccount| { &m.accountid },
            |m: &mut CMsgGCToGCGrantSelfMadeItemToAccount| { &mut m.accountid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToGCGrantSelfMadeItemToAccount>(
            "CMsgGCToGCGrantSelfMadeItemToAccount",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToGCGrantSelfMadeItemToAccount {
    const NAME: &'static str = "CMsgGCToGCGrantSelfMadeItemToAccount";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_def_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.accountid = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_def_index {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.accountid {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.item_def_index {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.accountid {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCGrantSelfMadeItemToAccount {
        CMsgGCToGCGrantSelfMadeItemToAccount::new()
    }

    fn clear(&mut self) {
        self.item_def_index = ::std::option::Option::None;
        self.accountid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCGrantSelfMadeItemToAccount {
        static instance: CMsgGCToGCGrantSelfMadeItemToAccount = CMsgGCToGCGrantSelfMadeItemToAccount {
            item_def_index: ::std::option::Option::None,
            accountid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToGCGrantSelfMadeItemToAccount {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToGCGrantSelfMadeItemToAccount").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToGCGrantSelfMadeItemToAccount {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCGrantSelfMadeItemToAccount {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCToGCThankedByNewUser)
pub struct CMsgGCToGCThankedByNewUser {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToGCThankedByNewUser.new_user_accountid)
    pub new_user_accountid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToGCThankedByNewUser.thanked_user_accountid)
    pub thanked_user_accountid: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToGCThankedByNewUser.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCThankedByNewUser {
    fn default() -> &'a CMsgGCToGCThankedByNewUser {
        <CMsgGCToGCThankedByNewUser as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCThankedByNewUser {
    pub fn new() -> CMsgGCToGCThankedByNewUser {
        ::std::default::Default::default()
    }

    // optional uint32 new_user_accountid = 1;

    pub fn new_user_accountid(&self) -> u32 {
        self.new_user_accountid.unwrap_or(0)
    }

    pub fn clear_new_user_accountid(&mut self) {
        self.new_user_accountid = ::std::option::Option::None;
    }

    pub fn has_new_user_accountid(&self) -> bool {
        self.new_user_accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_new_user_accountid(&mut self, v: u32) {
        self.new_user_accountid = ::std::option::Option::Some(v);
    }

    // optional uint32 thanked_user_accountid = 2;

    pub fn thanked_user_accountid(&self) -> u32 {
        self.thanked_user_accountid.unwrap_or(0)
    }

    pub fn clear_thanked_user_accountid(&mut self) {
        self.thanked_user_accountid = ::std::option::Option::None;
    }

    pub fn has_thanked_user_accountid(&self) -> bool {
        self.thanked_user_accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_thanked_user_accountid(&mut self, v: u32) {
        self.thanked_user_accountid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "new_user_accountid",
            |m: &CMsgGCToGCThankedByNewUser| { &m.new_user_accountid },
            |m: &mut CMsgGCToGCThankedByNewUser| { &mut m.new_user_accountid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "thanked_user_accountid",
            |m: &CMsgGCToGCThankedByNewUser| { &m.thanked_user_accountid },
            |m: &mut CMsgGCToGCThankedByNewUser| { &mut m.thanked_user_accountid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToGCThankedByNewUser>(
            "CMsgGCToGCThankedByNewUser",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToGCThankedByNewUser {
    const NAME: &'static str = "CMsgGCToGCThankedByNewUser";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.new_user_accountid = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.thanked_user_accountid = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.new_user_accountid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.thanked_user_accountid {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.new_user_accountid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.thanked_user_accountid {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCThankedByNewUser {
        CMsgGCToGCThankedByNewUser::new()
    }

    fn clear(&mut self) {
        self.new_user_accountid = ::std::option::Option::None;
        self.thanked_user_accountid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCThankedByNewUser {
        static instance: CMsgGCToGCThankedByNewUser = CMsgGCToGCThankedByNewUser {
            new_user_accountid: ::std::option::Option::None,
            thanked_user_accountid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToGCThankedByNewUser {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToGCThankedByNewUser").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToGCThankedByNewUser {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCThankedByNewUser {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCShuffleCrateContents)
pub struct CMsgGCShuffleCrateContents {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCShuffleCrateContents.crate_item_id)
    pub crate_item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCShuffleCrateContents.user_code_string)
    pub user_code_string: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCShuffleCrateContents.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCShuffleCrateContents {
    fn default() -> &'a CMsgGCShuffleCrateContents {
        <CMsgGCShuffleCrateContents as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCShuffleCrateContents {
    pub fn new() -> CMsgGCShuffleCrateContents {
        ::std::default::Default::default()
    }

    // optional uint64 crate_item_id = 1;

    pub fn crate_item_id(&self) -> u64 {
        self.crate_item_id.unwrap_or(0)
    }

    pub fn clear_crate_item_id(&mut self) {
        self.crate_item_id = ::std::option::Option::None;
    }

    pub fn has_crate_item_id(&self) -> bool {
        self.crate_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_crate_item_id(&mut self, v: u64) {
        self.crate_item_id = ::std::option::Option::Some(v);
    }

    // optional string user_code_string = 2;

    pub fn user_code_string(&self) -> &str {
        match self.user_code_string.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_user_code_string(&mut self) {
        self.user_code_string = ::std::option::Option::None;
    }

    pub fn has_user_code_string(&self) -> bool {
        self.user_code_string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_code_string(&mut self, v: ::std::string::String) {
        self.user_code_string = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_code_string(&mut self) -> &mut ::std::string::String {
        if self.user_code_string.is_none() {
            self.user_code_string = ::std::option::Option::Some(::std::string::String::new());
        }
        self.user_code_string.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_code_string(&mut self) -> ::std::string::String {
        self.user_code_string.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "crate_item_id",
            |m: &CMsgGCShuffleCrateContents| { &m.crate_item_id },
            |m: &mut CMsgGCShuffleCrateContents| { &mut m.crate_item_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "user_code_string",
            |m: &CMsgGCShuffleCrateContents| { &m.user_code_string },
            |m: &mut CMsgGCShuffleCrateContents| { &mut m.user_code_string },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCShuffleCrateContents>(
            "CMsgGCShuffleCrateContents",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCShuffleCrateContents {
    const NAME: &'static str = "CMsgGCShuffleCrateContents";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.crate_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    self.user_code_string = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.crate_item_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.user_code_string.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.crate_item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.user_code_string.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCShuffleCrateContents {
        CMsgGCShuffleCrateContents::new()
    }

    fn clear(&mut self) {
        self.crate_item_id = ::std::option::Option::None;
        self.user_code_string = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCShuffleCrateContents {
        static instance: CMsgGCShuffleCrateContents = CMsgGCShuffleCrateContents {
            crate_item_id: ::std::option::Option::None,
            user_code_string: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCShuffleCrateContents {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCShuffleCrateContents").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCShuffleCrateContents {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCShuffleCrateContents {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCQuestObjective_Progress)
pub struct CMsgGCQuestObjective_Progress {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCQuestObjective_Progress.quest_id)
    pub quest_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCQuestObjective_Progress.quest_attrib_index)
    pub quest_attrib_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCQuestObjective_Progress.delta)
    pub delta: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCQuestObjective_Progress.owner_steamid)
    pub owner_steamid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCQuestObjective_Progress.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCQuestObjective_Progress {
    fn default() -> &'a CMsgGCQuestObjective_Progress {
        <CMsgGCQuestObjective_Progress as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCQuestObjective_Progress {
    pub fn new() -> CMsgGCQuestObjective_Progress {
        ::std::default::Default::default()
    }

    // optional uint64 quest_id = 1;

    pub fn quest_id(&self) -> u64 {
        self.quest_id.unwrap_or(0)
    }

    pub fn clear_quest_id(&mut self) {
        self.quest_id = ::std::option::Option::None;
    }

    pub fn has_quest_id(&self) -> bool {
        self.quest_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quest_id(&mut self, v: u64) {
        self.quest_id = ::std::option::Option::Some(v);
    }

    // optional uint32 quest_attrib_index = 2;

    pub fn quest_attrib_index(&self) -> u32 {
        self.quest_attrib_index.unwrap_or(0)
    }

    pub fn clear_quest_attrib_index(&mut self) {
        self.quest_attrib_index = ::std::option::Option::None;
    }

    pub fn has_quest_attrib_index(&self) -> bool {
        self.quest_attrib_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quest_attrib_index(&mut self, v: u32) {
        self.quest_attrib_index = ::std::option::Option::Some(v);
    }

    // optional uint32 delta = 3;

    pub fn delta(&self) -> u32 {
        self.delta.unwrap_or(0)
    }

    pub fn clear_delta(&mut self) {
        self.delta = ::std::option::Option::None;
    }

    pub fn has_delta(&self) -> bool {
        self.delta.is_some()
    }

    // Param is passed by value, moved
    pub fn set_delta(&mut self, v: u32) {
        self.delta = ::std::option::Option::Some(v);
    }

    // optional fixed64 owner_steamid = 4;

    pub fn owner_steamid(&self) -> u64 {
        self.owner_steamid.unwrap_or(0)
    }

    pub fn clear_owner_steamid(&mut self) {
        self.owner_steamid = ::std::option::Option::None;
    }

    pub fn has_owner_steamid(&self) -> bool {
        self.owner_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner_steamid(&mut self, v: u64) {
        self.owner_steamid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "quest_id",
            |m: &CMsgGCQuestObjective_Progress| { &m.quest_id },
            |m: &mut CMsgGCQuestObjective_Progress| { &mut m.quest_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "quest_attrib_index",
            |m: &CMsgGCQuestObjective_Progress| { &m.quest_attrib_index },
            |m: &mut CMsgGCQuestObjective_Progress| { &mut m.quest_attrib_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "delta",
            |m: &CMsgGCQuestObjective_Progress| { &m.delta },
            |m: &mut CMsgGCQuestObjective_Progress| { &mut m.delta },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "owner_steamid",
            |m: &CMsgGCQuestObjective_Progress| { &m.owner_steamid },
            |m: &mut CMsgGCQuestObjective_Progress| { &mut m.owner_steamid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCQuestObjective_Progress>(
            "CMsgGCQuestObjective_Progress",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCQuestObjective_Progress {
    const NAME: &'static str = "CMsgGCQuestObjective_Progress";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.quest_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.quest_attrib_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.delta = ::std::option::Option::Some(is.read_uint32()?);
                },
                33 => {
                    self.owner_steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.quest_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.quest_attrib_index {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.delta {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.owner_steamid {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.quest_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.quest_attrib_index {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.delta {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.owner_steamid {
            os.write_fixed64(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCQuestObjective_Progress {
        CMsgGCQuestObjective_Progress::new()
    }

    fn clear(&mut self) {
        self.quest_id = ::std::option::Option::None;
        self.quest_attrib_index = ::std::option::Option::None;
        self.delta = ::std::option::Option::None;
        self.owner_steamid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCQuestObjective_Progress {
        static instance: CMsgGCQuestObjective_Progress = CMsgGCQuestObjective_Progress {
            quest_id: ::std::option::Option::None,
            quest_attrib_index: ::std::option::Option::None,
            delta: ::std::option::Option::None,
            owner_steamid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCQuestObjective_Progress {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCQuestObjective_Progress").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCQuestObjective_Progress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCQuestObjective_Progress {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCQuestObjective_PointsChange)
pub struct CMsgGCQuestObjective_PointsChange {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCQuestObjective_PointsChange.quest_id)
    pub quest_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCQuestObjective_PointsChange.owner_steamid)
    pub owner_steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCQuestObjective_PointsChange.update_base_points)
    pub update_base_points: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgGCQuestObjective_PointsChange.points_0)
    pub points_0: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCQuestObjective_PointsChange.points_1)
    pub points_1: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCQuestObjective_PointsChange.points_2)
    pub points_2: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCQuestObjective_PointsChange.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCQuestObjective_PointsChange {
    fn default() -> &'a CMsgGCQuestObjective_PointsChange {
        <CMsgGCQuestObjective_PointsChange as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCQuestObjective_PointsChange {
    pub fn new() -> CMsgGCQuestObjective_PointsChange {
        ::std::default::Default::default()
    }

    // optional uint64 quest_id = 1;

    pub fn quest_id(&self) -> u64 {
        self.quest_id.unwrap_or(0)
    }

    pub fn clear_quest_id(&mut self) {
        self.quest_id = ::std::option::Option::None;
    }

    pub fn has_quest_id(&self) -> bool {
        self.quest_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quest_id(&mut self, v: u64) {
        self.quest_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 owner_steamid = 4;

    pub fn owner_steamid(&self) -> u64 {
        self.owner_steamid.unwrap_or(0)
    }

    pub fn clear_owner_steamid(&mut self) {
        self.owner_steamid = ::std::option::Option::None;
    }

    pub fn has_owner_steamid(&self) -> bool {
        self.owner_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner_steamid(&mut self, v: u64) {
        self.owner_steamid = ::std::option::Option::Some(v);
    }

    // optional bool update_base_points = 5;

    pub fn update_base_points(&self) -> bool {
        self.update_base_points.unwrap_or(false)
    }

    pub fn clear_update_base_points(&mut self) {
        self.update_base_points = ::std::option::Option::None;
    }

    pub fn has_update_base_points(&self) -> bool {
        self.update_base_points.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_base_points(&mut self, v: bool) {
        self.update_base_points = ::std::option::Option::Some(v);
    }

    // optional uint32 points_0 = 6;

    pub fn points_0(&self) -> u32 {
        self.points_0.unwrap_or(0)
    }

    pub fn clear_points_0(&mut self) {
        self.points_0 = ::std::option::Option::None;
    }

    pub fn has_points_0(&self) -> bool {
        self.points_0.is_some()
    }

    // Param is passed by value, moved
    pub fn set_points_0(&mut self, v: u32) {
        self.points_0 = ::std::option::Option::Some(v);
    }

    // optional uint32 points_1 = 7;

    pub fn points_1(&self) -> u32 {
        self.points_1.unwrap_or(0)
    }

    pub fn clear_points_1(&mut self) {
        self.points_1 = ::std::option::Option::None;
    }

    pub fn has_points_1(&self) -> bool {
        self.points_1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_points_1(&mut self, v: u32) {
        self.points_1 = ::std::option::Option::Some(v);
    }

    // optional uint32 points_2 = 8;

    pub fn points_2(&self) -> u32 {
        self.points_2.unwrap_or(0)
    }

    pub fn clear_points_2(&mut self) {
        self.points_2 = ::std::option::Option::None;
    }

    pub fn has_points_2(&self) -> bool {
        self.points_2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_points_2(&mut self, v: u32) {
        self.points_2 = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "quest_id",
            |m: &CMsgGCQuestObjective_PointsChange| { &m.quest_id },
            |m: &mut CMsgGCQuestObjective_PointsChange| { &mut m.quest_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "owner_steamid",
            |m: &CMsgGCQuestObjective_PointsChange| { &m.owner_steamid },
            |m: &mut CMsgGCQuestObjective_PointsChange| { &mut m.owner_steamid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "update_base_points",
            |m: &CMsgGCQuestObjective_PointsChange| { &m.update_base_points },
            |m: &mut CMsgGCQuestObjective_PointsChange| { &mut m.update_base_points },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "points_0",
            |m: &CMsgGCQuestObjective_PointsChange| { &m.points_0 },
            |m: &mut CMsgGCQuestObjective_PointsChange| { &mut m.points_0 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "points_1",
            |m: &CMsgGCQuestObjective_PointsChange| { &m.points_1 },
            |m: &mut CMsgGCQuestObjective_PointsChange| { &mut m.points_1 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "points_2",
            |m: &CMsgGCQuestObjective_PointsChange| { &m.points_2 },
            |m: &mut CMsgGCQuestObjective_PointsChange| { &mut m.points_2 },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCQuestObjective_PointsChange>(
            "CMsgGCQuestObjective_PointsChange",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCQuestObjective_PointsChange {
    const NAME: &'static str = "CMsgGCQuestObjective_PointsChange";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.quest_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                33 => {
                    self.owner_steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                40 => {
                    self.update_base_points = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.points_0 = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.points_1 = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.points_2 = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.quest_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.owner_steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.update_base_points {
            my_size += 1 + 1;
        }
        if let Some(v) = self.points_0 {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.points_1 {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.points_2 {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.quest_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.owner_steamid {
            os.write_fixed64(4, v)?;
        }
        if let Some(v) = self.update_base_points {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.points_0 {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.points_1 {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.points_2 {
            os.write_uint32(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCQuestObjective_PointsChange {
        CMsgGCQuestObjective_PointsChange::new()
    }

    fn clear(&mut self) {
        self.quest_id = ::std::option::Option::None;
        self.owner_steamid = ::std::option::Option::None;
        self.update_base_points = ::std::option::Option::None;
        self.points_0 = ::std::option::Option::None;
        self.points_1 = ::std::option::Option::None;
        self.points_2 = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCQuestObjective_PointsChange {
        static instance: CMsgGCQuestObjective_PointsChange = CMsgGCQuestObjective_PointsChange {
            quest_id: ::std::option::Option::None,
            owner_steamid: ::std::option::Option::None,
            update_base_points: ::std::option::Option::None,
            points_0: ::std::option::Option::None,
            points_1: ::std::option::Option::None,
            points_2: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCQuestObjective_PointsChange {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCQuestObjective_PointsChange").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCQuestObjective_PointsChange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCQuestObjective_PointsChange {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCQuestComplete_Request)
pub struct CMsgGCQuestComplete_Request {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCQuestComplete_Request.quest_id)
    pub quest_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCQuestComplete_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCQuestComplete_Request {
    fn default() -> &'a CMsgGCQuestComplete_Request {
        <CMsgGCQuestComplete_Request as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCQuestComplete_Request {
    pub fn new() -> CMsgGCQuestComplete_Request {
        ::std::default::Default::default()
    }

    // optional uint64 quest_id = 1;

    pub fn quest_id(&self) -> u64 {
        self.quest_id.unwrap_or(0)
    }

    pub fn clear_quest_id(&mut self) {
        self.quest_id = ::std::option::Option::None;
    }

    pub fn has_quest_id(&self) -> bool {
        self.quest_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quest_id(&mut self, v: u64) {
        self.quest_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "quest_id",
            |m: &CMsgGCQuestComplete_Request| { &m.quest_id },
            |m: &mut CMsgGCQuestComplete_Request| { &mut m.quest_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCQuestComplete_Request>(
            "CMsgGCQuestComplete_Request",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCQuestComplete_Request {
    const NAME: &'static str = "CMsgGCQuestComplete_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.quest_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.quest_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.quest_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCQuestComplete_Request {
        CMsgGCQuestComplete_Request::new()
    }

    fn clear(&mut self) {
        self.quest_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCQuestComplete_Request {
        static instance: CMsgGCQuestComplete_Request = CMsgGCQuestComplete_Request {
            quest_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCQuestComplete_Request {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCQuestComplete_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCQuestComplete_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCQuestComplete_Request {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCQuestCompleted)
pub struct CMsgGCQuestCompleted {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCQuestCompleted.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCQuestCompleted {
    fn default() -> &'a CMsgGCQuestCompleted {
        <CMsgGCQuestCompleted as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCQuestCompleted {
    pub fn new() -> CMsgGCQuestCompleted {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCQuestCompleted>(
            "CMsgGCQuestCompleted",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCQuestCompleted {
    const NAME: &'static str = "CMsgGCQuestCompleted";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCQuestCompleted {
        CMsgGCQuestCompleted::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCQuestCompleted {
        static instance: CMsgGCQuestCompleted = CMsgGCQuestCompleted {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCQuestCompleted {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCQuestCompleted").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCQuestCompleted {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCQuestCompleted {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCQuestObjective_RequestLoanerItems)
pub struct CMsgGCQuestObjective_RequestLoanerItems {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCQuestObjective_RequestLoanerItems.quest_id)
    pub quest_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCQuestObjective_RequestLoanerItems.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCQuestObjective_RequestLoanerItems {
    fn default() -> &'a CMsgGCQuestObjective_RequestLoanerItems {
        <CMsgGCQuestObjective_RequestLoanerItems as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCQuestObjective_RequestLoanerItems {
    pub fn new() -> CMsgGCQuestObjective_RequestLoanerItems {
        ::std::default::Default::default()
    }

    // optional uint64 quest_id = 1;

    pub fn quest_id(&self) -> u64 {
        self.quest_id.unwrap_or(0)
    }

    pub fn clear_quest_id(&mut self) {
        self.quest_id = ::std::option::Option::None;
    }

    pub fn has_quest_id(&self) -> bool {
        self.quest_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quest_id(&mut self, v: u64) {
        self.quest_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "quest_id",
            |m: &CMsgGCQuestObjective_RequestLoanerItems| { &m.quest_id },
            |m: &mut CMsgGCQuestObjective_RequestLoanerItems| { &mut m.quest_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCQuestObjective_RequestLoanerItems>(
            "CMsgGCQuestObjective_RequestLoanerItems",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCQuestObjective_RequestLoanerItems {
    const NAME: &'static str = "CMsgGCQuestObjective_RequestLoanerItems";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.quest_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.quest_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.quest_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCQuestObjective_RequestLoanerItems {
        CMsgGCQuestObjective_RequestLoanerItems::new()
    }

    fn clear(&mut self) {
        self.quest_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCQuestObjective_RequestLoanerItems {
        static instance: CMsgGCQuestObjective_RequestLoanerItems = CMsgGCQuestObjective_RequestLoanerItems {
            quest_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCQuestObjective_RequestLoanerItems {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCQuestObjective_RequestLoanerItems").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCQuestObjective_RequestLoanerItems {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCQuestObjective_RequestLoanerItems {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCQuestObjective_RequestLoanerResponse)
pub struct CMsgGCQuestObjective_RequestLoanerResponse {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCQuestObjective_RequestLoanerResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCQuestObjective_RequestLoanerResponse {
    fn default() -> &'a CMsgGCQuestObjective_RequestLoanerResponse {
        <CMsgGCQuestObjective_RequestLoanerResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCQuestObjective_RequestLoanerResponse {
    pub fn new() -> CMsgGCQuestObjective_RequestLoanerResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCQuestObjective_RequestLoanerResponse>(
            "CMsgGCQuestObjective_RequestLoanerResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCQuestObjective_RequestLoanerResponse {
    const NAME: &'static str = "CMsgGCQuestObjective_RequestLoanerResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCQuestObjective_RequestLoanerResponse {
        CMsgGCQuestObjective_RequestLoanerResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCQuestObjective_RequestLoanerResponse {
        static instance: CMsgGCQuestObjective_RequestLoanerResponse = CMsgGCQuestObjective_RequestLoanerResponse {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCQuestObjective_RequestLoanerResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCQuestObjective_RequestLoanerResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCQuestObjective_RequestLoanerResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCQuestObjective_RequestLoanerResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgCraftCollectionUpgrade)
pub struct CMsgCraftCollectionUpgrade {
    // message fields
    // @@protoc_insertion_point(field:CMsgCraftCollectionUpgrade.item_id)
    pub item_id: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgCraftCollectionUpgrade.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgCraftCollectionUpgrade {
    fn default() -> &'a CMsgCraftCollectionUpgrade {
        <CMsgCraftCollectionUpgrade as ::protobuf::Message>::default_instance()
    }
}

impl CMsgCraftCollectionUpgrade {
    pub fn new() -> CMsgCraftCollectionUpgrade {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "item_id",
            |m: &CMsgCraftCollectionUpgrade| { &m.item_id },
            |m: &mut CMsgCraftCollectionUpgrade| { &mut m.item_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgCraftCollectionUpgrade>(
            "CMsgCraftCollectionUpgrade",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgCraftCollectionUpgrade {
    const NAME: &'static str = "CMsgCraftCollectionUpgrade";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint64_into(&mut self.item_id)?;
                },
                8 => {
                    self.item_id.push(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.item_id {
            my_size += ::protobuf::rt::uint64_size(1, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.item_id {
            os.write_uint64(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgCraftCollectionUpgrade {
        CMsgCraftCollectionUpgrade::new()
    }

    fn clear(&mut self) {
        self.item_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgCraftCollectionUpgrade {
        static instance: CMsgCraftCollectionUpgrade = CMsgCraftCollectionUpgrade {
            item_id: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgCraftCollectionUpgrade {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgCraftCollectionUpgrade").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgCraftCollectionUpgrade {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgCraftCollectionUpgrade {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgCraftHalloweenOffering)
pub struct CMsgCraftHalloweenOffering {
    // message fields
    // @@protoc_insertion_point(field:CMsgCraftHalloweenOffering.tool_id)
    pub tool_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgCraftHalloweenOffering.item_id)
    pub item_id: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgCraftHalloweenOffering.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgCraftHalloweenOffering {
    fn default() -> &'a CMsgCraftHalloweenOffering {
        <CMsgCraftHalloweenOffering as ::protobuf::Message>::default_instance()
    }
}

impl CMsgCraftHalloweenOffering {
    pub fn new() -> CMsgCraftHalloweenOffering {
        ::std::default::Default::default()
    }

    // optional uint64 tool_id = 1;

    pub fn tool_id(&self) -> u64 {
        self.tool_id.unwrap_or(0)
    }

    pub fn clear_tool_id(&mut self) {
        self.tool_id = ::std::option::Option::None;
    }

    pub fn has_tool_id(&self) -> bool {
        self.tool_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tool_id(&mut self, v: u64) {
        self.tool_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tool_id",
            |m: &CMsgCraftHalloweenOffering| { &m.tool_id },
            |m: &mut CMsgCraftHalloweenOffering| { &mut m.tool_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "item_id",
            |m: &CMsgCraftHalloweenOffering| { &m.item_id },
            |m: &mut CMsgCraftHalloweenOffering| { &mut m.item_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgCraftHalloweenOffering>(
            "CMsgCraftHalloweenOffering",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgCraftHalloweenOffering {
    const NAME: &'static str = "CMsgCraftHalloweenOffering";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.tool_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    is.read_repeated_packed_uint64_into(&mut self.item_id)?;
                },
                16 => {
                    self.item_id.push(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.tool_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        for value in &self.item_id {
            my_size += ::protobuf::rt::uint64_size(2, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.tool_id {
            os.write_uint64(1, v)?;
        }
        for v in &self.item_id {
            os.write_uint64(2, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgCraftHalloweenOffering {
        CMsgCraftHalloweenOffering::new()
    }

    fn clear(&mut self) {
        self.tool_id = ::std::option::Option::None;
        self.item_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgCraftHalloweenOffering {
        static instance: CMsgCraftHalloweenOffering = CMsgCraftHalloweenOffering {
            tool_id: ::std::option::Option::None,
            item_id: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgCraftHalloweenOffering {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgCraftHalloweenOffering").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgCraftHalloweenOffering {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgCraftHalloweenOffering {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgCraftCommonStatClock)
pub struct CMsgCraftCommonStatClock {
    // message fields
    // @@protoc_insertion_point(field:CMsgCraftCommonStatClock.tool_id)
    pub tool_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgCraftCommonStatClock.item_id)
    pub item_id: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgCraftCommonStatClock.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgCraftCommonStatClock {
    fn default() -> &'a CMsgCraftCommonStatClock {
        <CMsgCraftCommonStatClock as ::protobuf::Message>::default_instance()
    }
}

impl CMsgCraftCommonStatClock {
    pub fn new() -> CMsgCraftCommonStatClock {
        ::std::default::Default::default()
    }

    // optional uint64 tool_id = 1;

    pub fn tool_id(&self) -> u64 {
        self.tool_id.unwrap_or(0)
    }

    pub fn clear_tool_id(&mut self) {
        self.tool_id = ::std::option::Option::None;
    }

    pub fn has_tool_id(&self) -> bool {
        self.tool_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tool_id(&mut self, v: u64) {
        self.tool_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tool_id",
            |m: &CMsgCraftCommonStatClock| { &m.tool_id },
            |m: &mut CMsgCraftCommonStatClock| { &mut m.tool_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "item_id",
            |m: &CMsgCraftCommonStatClock| { &m.item_id },
            |m: &mut CMsgCraftCommonStatClock| { &mut m.item_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgCraftCommonStatClock>(
            "CMsgCraftCommonStatClock",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgCraftCommonStatClock {
    const NAME: &'static str = "CMsgCraftCommonStatClock";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.tool_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    is.read_repeated_packed_uint64_into(&mut self.item_id)?;
                },
                16 => {
                    self.item_id.push(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.tool_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        for value in &self.item_id {
            my_size += ::protobuf::rt::uint64_size(2, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.tool_id {
            os.write_uint64(1, v)?;
        }
        for v in &self.item_id {
            os.write_uint64(2, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgCraftCommonStatClock {
        CMsgCraftCommonStatClock::new()
    }

    fn clear(&mut self) {
        self.tool_id = ::std::option::Option::None;
        self.item_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgCraftCommonStatClock {
        static instance: CMsgCraftCommonStatClock = CMsgCraftCommonStatClock {
            tool_id: ::std::option::Option::None,
            item_id: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgCraftCommonStatClock {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgCraftCommonStatClock").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgCraftCommonStatClock {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgCraftCommonStatClock {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCQuestDiscard_Request)
pub struct CMsgGCQuestDiscard_Request {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCQuestDiscard_Request.quest_id)
    pub quest_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCQuestDiscard_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCQuestDiscard_Request {
    fn default() -> &'a CMsgGCQuestDiscard_Request {
        <CMsgGCQuestDiscard_Request as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCQuestDiscard_Request {
    pub fn new() -> CMsgGCQuestDiscard_Request {
        ::std::default::Default::default()
    }

    // optional uint64 quest_id = 1;

    pub fn quest_id(&self) -> u64 {
        self.quest_id.unwrap_or(0)
    }

    pub fn clear_quest_id(&mut self) {
        self.quest_id = ::std::option::Option::None;
    }

    pub fn has_quest_id(&self) -> bool {
        self.quest_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quest_id(&mut self, v: u64) {
        self.quest_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "quest_id",
            |m: &CMsgGCQuestDiscard_Request| { &m.quest_id },
            |m: &mut CMsgGCQuestDiscard_Request| { &mut m.quest_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCQuestDiscard_Request>(
            "CMsgGCQuestDiscard_Request",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCQuestDiscard_Request {
    const NAME: &'static str = "CMsgGCQuestDiscard_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.quest_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.quest_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.quest_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCQuestDiscard_Request {
        CMsgGCQuestDiscard_Request::new()
    }

    fn clear(&mut self) {
        self.quest_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCQuestDiscard_Request {
        static instance: CMsgGCQuestDiscard_Request = CMsgGCQuestDiscard_Request {
            quest_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCQuestDiscard_Request {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCQuestDiscard_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCQuestDiscard_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCQuestDiscard_Request {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EGCItemMsg)
pub enum EGCItemMsg {
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCBase)
    k_EMsgGCBase = 1000,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCSetSingleItemPosition)
    k_EMsgGCSetSingleItemPosition = 1001,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCCraft)
    k_EMsgGCCraft = 1002,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCCraftResponse)
    k_EMsgGCCraftResponse = 1003,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCDelete)
    k_EMsgGCDelete = 1004,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCVerifyCacheSubscription)
    k_EMsgGCVerifyCacheSubscription = 1005,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCNameItem)
    k_EMsgGCNameItem = 1006,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCUnlockCrate)
    k_EMsgGCUnlockCrate = 1007,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCUnlockCrateResponse)
    k_EMsgGCUnlockCrateResponse = 1008,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCPaintItem)
    k_EMsgGCPaintItem = 1009,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCPaintItemResponse)
    k_EMsgGCPaintItemResponse = 1010,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCGoldenWrenchBroadcast)
    k_EMsgGCGoldenWrenchBroadcast = 1011,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCMOTDRequest)
    k_EMsgGCMOTDRequest = 1012,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCMOTDRequestResponse)
    k_EMsgGCMOTDRequestResponse = 1013,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCNameBaseItem)
    k_EMsgGCNameBaseItem = 1019,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCNameBaseItemResponse)
    k_EMsgGCNameBaseItemResponse = 1020,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCRemoveSocketItem_DEPRECATED)
    k_EMsgGCRemoveSocketItem_DEPRECATED = 1021,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCRemoveSocketItemResponse_DEPRECATED)
    k_EMsgGCRemoveSocketItemResponse_DEPRECATED = 1022,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCCustomizeItemTexture)
    k_EMsgGCCustomizeItemTexture = 1023,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCCustomizeItemTextureResponse)
    k_EMsgGCCustomizeItemTextureResponse = 1024,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCUseItemRequest)
    k_EMsgGCUseItemRequest = 1025,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCUseItemResponse)
    k_EMsgGCUseItemResponse = 1026,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCRespawnPostLoadoutChange)
    k_EMsgGCRespawnPostLoadoutChange = 1029,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCRemoveItemName)
    k_EMsgGCRemoveItemName = 1030,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCRemoveItemPaint)
    k_EMsgGCRemoveItemPaint = 1031,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCGiftWrapItem)
    k_EMsgGCGiftWrapItem = 1032,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCGiftWrapItemResponse)
    k_EMsgGCGiftWrapItemResponse = 1033,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCDeliverGift)
    k_EMsgGCDeliverGift = 1034,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCDeliverGiftResponseReceiver)
    k_EMsgGCDeliverGiftResponseReceiver = 1036,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCUnwrapGiftRequest)
    k_EMsgGCUnwrapGiftRequest = 1037,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCUnwrapGiftResponse)
    k_EMsgGCUnwrapGiftResponse = 1038,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCSetItemStyle)
    k_EMsgGCSetItemStyle = 1039,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCUsedClaimCodeItem)
    k_EMsgGCUsedClaimCodeItem = 1040,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCSortItems)
    k_EMsgGCSortItems = 1041,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGC_RevolvingLootList_DEPRECATED)
    k_EMsgGC_RevolvingLootList_DEPRECATED = 1042,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCLookupAccount)
    k_EMsgGCLookupAccount = 1043,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCLookupAccountResponse)
    k_EMsgGCLookupAccountResponse = 1044,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCLookupAccountName)
    k_EMsgGCLookupAccountName = 1045,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCLookupAccountNameResponse)
    k_EMsgGCLookupAccountNameResponse = 1046,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCUpdateItemSchema)
    k_EMsgGCUpdateItemSchema = 1049,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCRequestInventoryRefresh)
    k_EMsgGCRequestInventoryRefresh = 1050,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCRemoveCustomTexture)
    k_EMsgGCRemoveCustomTexture = 1051,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCRemoveCustomTextureResponse)
    k_EMsgGCRemoveCustomTextureResponse = 1052,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCRemoveMakersMark)
    k_EMsgGCRemoveMakersMark = 1053,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCRemoveMakersMarkResponse)
    k_EMsgGCRemoveMakersMarkResponse = 1054,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCRemoveUniqueCraftIndex)
    k_EMsgGCRemoveUniqueCraftIndex = 1055,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCRemoveUniqueCraftIndexResponse)
    k_EMsgGCRemoveUniqueCraftIndexResponse = 1056,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCSaxxyBroadcast)
    k_EMsgGCSaxxyBroadcast = 1057,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCBackpackSortFinished)
    k_EMsgGCBackpackSortFinished = 1058,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCAdjustItemEquippedState)
    k_EMsgGCAdjustItemEquippedState = 1059,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCCollectItem)
    k_EMsgGCCollectItem = 1061,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCItemAcknowledged)
    k_EMsgGCItemAcknowledged = 1062,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCPresets_SelectPresetForClass)
    k_EMsgGCPresets_SelectPresetForClass = 1063,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCPresets_SetItemPosition)
    k_EMsgGCPresets_SetItemPosition = 1064,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGC_ReportAbuse)
    k_EMsgGC_ReportAbuse = 1065,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGC_ReportAbuseResponse)
    k_EMsgGC_ReportAbuseResponse = 1066,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCPresets_SelectPresetForClassReply)
    k_EMsgGCPresets_SelectPresetForClassReply = 1067,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCNameItemNotification)
    k_EMsgGCNameItemNotification = 1068,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCClientDisplayNotification)
    k_EMsgGCClientDisplayNotification = 1069,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCApplyStrangePart)
    k_EMsgGCApplyStrangePart = 1070,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGC_IncrementKillCountAttribute)
    k_EMsgGC_IncrementKillCountAttribute = 1071,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGC_IncrementKillCountResponse)
    k_EMsgGC_IncrementKillCountResponse = 1072,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCRemoveStrangePart)
    k_EMsgGCRemoveStrangePart = 1073,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCResetStrangeScores)
    k_EMsgGCResetStrangeScores = 1074,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCGiftedItems)
    k_EMsgGCGiftedItems = 1075,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCApplyUpgradeCard)
    k_EMsgGCApplyUpgradeCard = 1077,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCRemoveUpgradeCard)
    k_EMsgGCRemoveUpgradeCard = 1078,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCApplyStrangeRestriction)
    k_EMsgGCApplyStrangeRestriction = 1079,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCClientRequestMarketData)
    k_EMsgGCClientRequestMarketData = 1080,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCClientRequestMarketDataResponse)
    k_EMsgGCClientRequestMarketDataResponse = 1081,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCApplyXifier)
    k_EMsgGCApplyXifier = 1082,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCApplyXifierResponse)
    k_EMsgGCApplyXifierResponse = 1083,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGC_TrackUniquePlayerPairEvent)
    k_EMsgGC_TrackUniquePlayerPairEvent = 1084,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCFulfillDynamicRecipeComponent)
    k_EMsgGCFulfillDynamicRecipeComponent = 1085,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCFulfillDynamicRecipeComponentResponse)
    k_EMsgGCFulfillDynamicRecipeComponentResponse = 1086,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCSetItemEffectVerticalOffset)
    k_EMsgGCSetItemEffectVerticalOffset = 1087,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCSetHatEffectUseHeadOrigin)
    k_EMsgGCSetHatEffectUseHeadOrigin = 1088,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCItemEaterRecharger)
    k_EMsgGCItemEaterRecharger = 1089,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCItemEaterRechargerResponse)
    k_EMsgGCItemEaterRechargerResponse = 1090,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCApplyBaseItemXifier)
    k_EMsgGCApplyBaseItemXifier = 1091,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCApplyClassTransmogrifier)
    k_EMsgGCApplyClassTransmogrifier = 1092,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCApplyHalloweenSpellbookPage)
    k_EMsgGCApplyHalloweenSpellbookPage = 1093,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCRemoveKillStreak)
    k_EMsgGCRemoveKillStreak = 1094,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCRemoveKillStreakResponse)
    k_EMsgGCRemoveKillStreakResponse = 1095,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCTFSpecificItemBroadcast)
    k_EMsgGCTFSpecificItemBroadcast = 1096,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGC_IncrementKillCountAttribute_Multiple)
    k_EMsgGC_IncrementKillCountAttribute_Multiple = 1097,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCDeliverGiftResponseGiver)
    k_EMsgGCDeliverGiftResponseGiver = 1098,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCSetItemPositions)
    k_EMsgGCSetItemPositions = 1100,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCLookupMultipleAccountNames)
    k_EMsgGCLookupMultipleAccountNames = 1101,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCLookupMultipleAccountNamesResponse)
    k_EMsgGCLookupMultipleAccountNamesResponse = 1102,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCTradingBase)
    k_EMsgGCTradingBase = 1500,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCTrading_InitiateTradeRequest)
    k_EMsgGCTrading_InitiateTradeRequest = 1501,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCTrading_InitiateTradeResponse)
    k_EMsgGCTrading_InitiateTradeResponse = 1502,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCTrading_StartSession)
    k_EMsgGCTrading_StartSession = 1503,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCTrading_SessionClosed)
    k_EMsgGCTrading_SessionClosed = 1509,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCTrading_CancelSession)
    k_EMsgGCTrading_CancelSession = 1510,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCTrading_InitiateTradeRequestResponse)
    k_EMsgGCTrading_InitiateTradeRequestResponse = 1514,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCServerBrowser_FavoriteServer)
    k_EMsgGCServerBrowser_FavoriteServer = 1601,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCServerBrowser_BlacklistServer)
    k_EMsgGCServerBrowser_BlacklistServer = 1602,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCServerRentalsBase)
    k_EMsgGCServerRentalsBase = 1700,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCItemPreviewCheckStatus)
    k_EMsgGCItemPreviewCheckStatus = 1701,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCItemPreviewStatusResponse)
    k_EMsgGCItemPreviewStatusResponse = 1702,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCItemPreviewRequest)
    k_EMsgGCItemPreviewRequest = 1703,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCItemPreviewRequestResponse)
    k_EMsgGCItemPreviewRequestResponse = 1704,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCItemPreviewExpire)
    k_EMsgGCItemPreviewExpire = 1705,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCItemPreviewExpireNotification)
    k_EMsgGCItemPreviewExpireNotification = 1706,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCItemPreviewItemBoughtNotification)
    k_EMsgGCItemPreviewItemBoughtNotification = 1708,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCDev_NewItemRequest)
    k_EMsgGCDev_NewItemRequest = 2001,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCDev_NewItemRequestResponse)
    k_EMsgGCDev_NewItemRequestResponse = 2002,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCDev_DebugRollLootRequest)
    k_EMsgGCDev_DebugRollLootRequest = 2003,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCStoreGetUserData)
    k_EMsgGCStoreGetUserData = 2500,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCStoreGetUserDataResponse)
    k_EMsgGCStoreGetUserDataResponse = 2501,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCStorePurchaseInit_DEPRECATED)
    k_EMsgGCStorePurchaseInit_DEPRECATED = 2502,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCStorePurchaseInitResponse_DEPRECATED)
    k_EMsgGCStorePurchaseInitResponse_DEPRECATED = 2503,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCStorePurchaseFinalize)
    k_EMsgGCStorePurchaseFinalize = 2512,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCStorePurchaseFinalizeResponse)
    k_EMsgGCStorePurchaseFinalizeResponse = 2513,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCStorePurchaseCancel)
    k_EMsgGCStorePurchaseCancel = 2514,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCStorePurchaseCancelResponse)
    k_EMsgGCStorePurchaseCancelResponse = 2515,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCStorePurchaseQueryTxn)
    k_EMsgGCStorePurchaseQueryTxn = 2508,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCStorePurchaseQueryTxnResponse)
    k_EMsgGCStorePurchaseQueryTxnResponse = 2509,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCStorePurchaseInit)
    k_EMsgGCStorePurchaseInit = 2510,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCStorePurchaseInitResponse)
    k_EMsgGCStorePurchaseInitResponse = 2511,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCToGCDirtySDOCache)
    k_EMsgGCToGCDirtySDOCache = 2516,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCToGCDirtyMultipleSDOCache)
    k_EMsgGCToGCDirtyMultipleSDOCache = 2517,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCToGCUpdateSQLKeyValue)
    k_EMsgGCToGCUpdateSQLKeyValue = 2518,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCToGCBroadcastConsoleCommand)
    k_EMsgGCToGCBroadcastConsoleCommand = 2521,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCServerVersionUpdated)
    k_EMsgGCServerVersionUpdated = 2522,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCApplyAutograph)
    k_EMsgGCApplyAutograph = 2523,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCToGCWebAPIAccountChanged)
    k_EMsgGCToGCWebAPIAccountChanged = 2524,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCRequestAnnouncements)
    k_EMsgGCRequestAnnouncements = 2525,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCRequestAnnouncementsResponse)
    k_EMsgGCRequestAnnouncementsResponse = 2526,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCRequestPassportItemGrant)
    k_EMsgGCRequestPassportItemGrant = 2527,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCClientVersionUpdated)
    k_EMsgGCClientVersionUpdated = 2528,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCItemPurgatory_FinalizePurchase)
    k_EMsgGCItemPurgatory_FinalizePurchase = 2531,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCItemPurgatory_FinalizePurchaseResponse)
    k_EMsgGCItemPurgatory_FinalizePurchaseResponse = 2532,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCItemPurgatory_RefundPurchase)
    k_EMsgGCItemPurgatory_RefundPurchase = 2533,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCItemPurgatory_RefundPurchaseResponse)
    k_EMsgGCItemPurgatory_RefundPurchaseResponse = 2534,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCToGCPlayerStrangeCountAdjustments)
    k_EMsgGCToGCPlayerStrangeCountAdjustments = 2535,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCRequestStoreSalesData)
    k_EMsgGCRequestStoreSalesData = 2536,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCRequestStoreSalesDataResponse)
    k_EMsgGCRequestStoreSalesDataResponse = 2537,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCRequestStoreSalesDataUpToDateResponse)
    k_EMsgGCRequestStoreSalesDataUpToDateResponse = 2538,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCToGCPingRequest)
    k_EMsgGCToGCPingRequest = 2539,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCToGCPingResponse)
    k_EMsgGCToGCPingResponse = 2540,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCToGCGetUserSessionServer)
    k_EMsgGCToGCGetUserSessionServer = 2541,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCToGCGetUserSessionServerResponse)
    k_EMsgGCToGCGetUserSessionServerResponse = 2542,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCToGCGetUserServerMembers)
    k_EMsgGCToGCGetUserServerMembers = 2543,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCToGCGetUserServerMembersResponse)
    k_EMsgGCToGCGetUserServerMembersResponse = 2544,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCToGCGrantSelfMadeItemToAccount)
    k_EMsgGCToGCGrantSelfMadeItemToAccount = 2555,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCToGCThankedByNewUser)
    k_EMsgGCToGCThankedByNewUser = 2556,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCShuffleCrateContents)
    k_EMsgGCShuffleCrateContents = 2557,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCQuestObjective_Progress)
    k_EMsgGCQuestObjective_Progress = 2558,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCQuestCompleted)
    k_EMsgGCQuestCompleted = 2559,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCApplyDuckToken)
    k_EMsgGCApplyDuckToken = 2560,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCQuestObjective_PointsChange)
    k_EMsgGCQuestObjective_PointsChange = 2562,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCQuestObjective_RequestLoanerItems)
    k_EMsgGCQuestObjective_RequestLoanerItems = 2564,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCQuestObjective_RequestLoanerResponse)
    k_EMsgGCQuestObjective_RequestLoanerResponse = 2565,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCApplyStrangeCountTransfer)
    k_EMsgGCApplyStrangeCountTransfer = 2566,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCCraftCollectionUpgrade)
    k_EMsgGCCraftCollectionUpgrade = 2567,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCCraftHalloweenOffering)
    k_EMsgGCCraftHalloweenOffering = 2568,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCQuestDiscard_Request)
    k_EMsgGCQuestDiscard_Request = 2569,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCRemoveGiftedBy)
    k_EMsgGCRemoveGiftedBy = 2570,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCRemoveGiftedByResponse)
    k_EMsgGCRemoveGiftedByResponse = 2571,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCRemoveFestivizer)
    k_EMsgGCRemoveFestivizer = 2572,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCRemoveFestivizerResponse)
    k_EMsgGCRemoveFestivizerResponse = 2573,
    // @@protoc_insertion_point(enum_value:EGCItemMsg.k_EMsgGCCraftCommonStatClock)
    k_EMsgGCCraftCommonStatClock = 2574,
}

impl ::protobuf::Enum for EGCItemMsg {
    const NAME: &'static str = "EGCItemMsg";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EGCItemMsg> {
        match value {
            1000 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCBase),
            1001 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCSetSingleItemPosition),
            1002 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCCraft),
            1003 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCCraftResponse),
            1004 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCDelete),
            1005 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCVerifyCacheSubscription),
            1006 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCNameItem),
            1007 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCUnlockCrate),
            1008 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCUnlockCrateResponse),
            1009 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCPaintItem),
            1010 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCPaintItemResponse),
            1011 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCGoldenWrenchBroadcast),
            1012 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCMOTDRequest),
            1013 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCMOTDRequestResponse),
            1019 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCNameBaseItem),
            1020 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCNameBaseItemResponse),
            1021 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRemoveSocketItem_DEPRECATED),
            1022 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRemoveSocketItemResponse_DEPRECATED),
            1023 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCCustomizeItemTexture),
            1024 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCCustomizeItemTextureResponse),
            1025 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCUseItemRequest),
            1026 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCUseItemResponse),
            1029 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRespawnPostLoadoutChange),
            1030 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRemoveItemName),
            1031 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRemoveItemPaint),
            1032 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCGiftWrapItem),
            1033 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCGiftWrapItemResponse),
            1034 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCDeliverGift),
            1036 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCDeliverGiftResponseReceiver),
            1037 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCUnwrapGiftRequest),
            1038 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCUnwrapGiftResponse),
            1039 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCSetItemStyle),
            1040 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCUsedClaimCodeItem),
            1041 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCSortItems),
            1042 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGC_RevolvingLootList_DEPRECATED),
            1043 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCLookupAccount),
            1044 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCLookupAccountResponse),
            1045 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCLookupAccountName),
            1046 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCLookupAccountNameResponse),
            1049 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCUpdateItemSchema),
            1050 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRequestInventoryRefresh),
            1051 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRemoveCustomTexture),
            1052 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRemoveCustomTextureResponse),
            1053 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRemoveMakersMark),
            1054 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRemoveMakersMarkResponse),
            1055 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRemoveUniqueCraftIndex),
            1056 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRemoveUniqueCraftIndexResponse),
            1057 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCSaxxyBroadcast),
            1058 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCBackpackSortFinished),
            1059 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCAdjustItemEquippedState),
            1061 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCCollectItem),
            1062 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCItemAcknowledged),
            1063 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCPresets_SelectPresetForClass),
            1064 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCPresets_SetItemPosition),
            1065 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGC_ReportAbuse),
            1066 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGC_ReportAbuseResponse),
            1067 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCPresets_SelectPresetForClassReply),
            1068 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCNameItemNotification),
            1069 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCClientDisplayNotification),
            1070 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCApplyStrangePart),
            1071 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGC_IncrementKillCountAttribute),
            1072 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGC_IncrementKillCountResponse),
            1073 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRemoveStrangePart),
            1074 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCResetStrangeScores),
            1075 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCGiftedItems),
            1077 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCApplyUpgradeCard),
            1078 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRemoveUpgradeCard),
            1079 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCApplyStrangeRestriction),
            1080 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCClientRequestMarketData),
            1081 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCClientRequestMarketDataResponse),
            1082 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCApplyXifier),
            1083 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCApplyXifierResponse),
            1084 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGC_TrackUniquePlayerPairEvent),
            1085 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCFulfillDynamicRecipeComponent),
            1086 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCFulfillDynamicRecipeComponentResponse),
            1087 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCSetItemEffectVerticalOffset),
            1088 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCSetHatEffectUseHeadOrigin),
            1089 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCItemEaterRecharger),
            1090 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCItemEaterRechargerResponse),
            1091 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCApplyBaseItemXifier),
            1092 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCApplyClassTransmogrifier),
            1093 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCApplyHalloweenSpellbookPage),
            1094 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRemoveKillStreak),
            1095 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRemoveKillStreakResponse),
            1096 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCTFSpecificItemBroadcast),
            1097 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGC_IncrementKillCountAttribute_Multiple),
            1098 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCDeliverGiftResponseGiver),
            1100 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCSetItemPositions),
            1101 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCLookupMultipleAccountNames),
            1102 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCLookupMultipleAccountNamesResponse),
            1500 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCTradingBase),
            1501 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCTrading_InitiateTradeRequest),
            1502 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCTrading_InitiateTradeResponse),
            1503 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCTrading_StartSession),
            1509 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCTrading_SessionClosed),
            1510 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCTrading_CancelSession),
            1514 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCTrading_InitiateTradeRequestResponse),
            1601 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCServerBrowser_FavoriteServer),
            1602 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCServerBrowser_BlacklistServer),
            1700 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCServerRentalsBase),
            1701 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCItemPreviewCheckStatus),
            1702 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCItemPreviewStatusResponse),
            1703 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCItemPreviewRequest),
            1704 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCItemPreviewRequestResponse),
            1705 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCItemPreviewExpire),
            1706 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCItemPreviewExpireNotification),
            1708 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCItemPreviewItemBoughtNotification),
            2001 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCDev_NewItemRequest),
            2002 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCDev_NewItemRequestResponse),
            2003 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCDev_DebugRollLootRequest),
            2500 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCStoreGetUserData),
            2501 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCStoreGetUserDataResponse),
            2502 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCStorePurchaseInit_DEPRECATED),
            2503 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCStorePurchaseInitResponse_DEPRECATED),
            2512 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCStorePurchaseFinalize),
            2513 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCStorePurchaseFinalizeResponse),
            2514 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCStorePurchaseCancel),
            2515 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCStorePurchaseCancelResponse),
            2508 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCStorePurchaseQueryTxn),
            2509 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCStorePurchaseQueryTxnResponse),
            2510 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCStorePurchaseInit),
            2511 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCStorePurchaseInitResponse),
            2516 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCDirtySDOCache),
            2517 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCDirtyMultipleSDOCache),
            2518 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCUpdateSQLKeyValue),
            2521 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCBroadcastConsoleCommand),
            2522 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCServerVersionUpdated),
            2523 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCApplyAutograph),
            2524 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCWebAPIAccountChanged),
            2525 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRequestAnnouncements),
            2526 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRequestAnnouncementsResponse),
            2527 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRequestPassportItemGrant),
            2528 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCClientVersionUpdated),
            2531 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCItemPurgatory_FinalizePurchase),
            2532 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCItemPurgatory_FinalizePurchaseResponse),
            2533 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCItemPurgatory_RefundPurchase),
            2534 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCItemPurgatory_RefundPurchaseResponse),
            2535 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCPlayerStrangeCountAdjustments),
            2536 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRequestStoreSalesData),
            2537 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRequestStoreSalesDataResponse),
            2538 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRequestStoreSalesDataUpToDateResponse),
            2539 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCPingRequest),
            2540 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCPingResponse),
            2541 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCGetUserSessionServer),
            2542 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCGetUserSessionServerResponse),
            2543 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCGetUserServerMembers),
            2544 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCGetUserServerMembersResponse),
            2555 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCGrantSelfMadeItemToAccount),
            2556 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCThankedByNewUser),
            2557 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCShuffleCrateContents),
            2558 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCQuestObjective_Progress),
            2559 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCQuestCompleted),
            2560 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCApplyDuckToken),
            2562 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCQuestObjective_PointsChange),
            2564 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCQuestObjective_RequestLoanerItems),
            2565 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCQuestObjective_RequestLoanerResponse),
            2566 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCApplyStrangeCountTransfer),
            2567 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCCraftCollectionUpgrade),
            2568 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCCraftHalloweenOffering),
            2569 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCQuestDiscard_Request),
            2570 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRemoveGiftedBy),
            2571 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRemoveGiftedByResponse),
            2572 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRemoveFestivizer),
            2573 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRemoveFestivizerResponse),
            2574 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCCraftCommonStatClock),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EGCItemMsg] = &[
        EGCItemMsg::k_EMsgGCBase,
        EGCItemMsg::k_EMsgGCSetSingleItemPosition,
        EGCItemMsg::k_EMsgGCCraft,
        EGCItemMsg::k_EMsgGCCraftResponse,
        EGCItemMsg::k_EMsgGCDelete,
        EGCItemMsg::k_EMsgGCVerifyCacheSubscription,
        EGCItemMsg::k_EMsgGCNameItem,
        EGCItemMsg::k_EMsgGCUnlockCrate,
        EGCItemMsg::k_EMsgGCUnlockCrateResponse,
        EGCItemMsg::k_EMsgGCPaintItem,
        EGCItemMsg::k_EMsgGCPaintItemResponse,
        EGCItemMsg::k_EMsgGCGoldenWrenchBroadcast,
        EGCItemMsg::k_EMsgGCMOTDRequest,
        EGCItemMsg::k_EMsgGCMOTDRequestResponse,
        EGCItemMsg::k_EMsgGCNameBaseItem,
        EGCItemMsg::k_EMsgGCNameBaseItemResponse,
        EGCItemMsg::k_EMsgGCRemoveSocketItem_DEPRECATED,
        EGCItemMsg::k_EMsgGCRemoveSocketItemResponse_DEPRECATED,
        EGCItemMsg::k_EMsgGCCustomizeItemTexture,
        EGCItemMsg::k_EMsgGCCustomizeItemTextureResponse,
        EGCItemMsg::k_EMsgGCUseItemRequest,
        EGCItemMsg::k_EMsgGCUseItemResponse,
        EGCItemMsg::k_EMsgGCRespawnPostLoadoutChange,
        EGCItemMsg::k_EMsgGCRemoveItemName,
        EGCItemMsg::k_EMsgGCRemoveItemPaint,
        EGCItemMsg::k_EMsgGCGiftWrapItem,
        EGCItemMsg::k_EMsgGCGiftWrapItemResponse,
        EGCItemMsg::k_EMsgGCDeliverGift,
        EGCItemMsg::k_EMsgGCDeliverGiftResponseReceiver,
        EGCItemMsg::k_EMsgGCUnwrapGiftRequest,
        EGCItemMsg::k_EMsgGCUnwrapGiftResponse,
        EGCItemMsg::k_EMsgGCSetItemStyle,
        EGCItemMsg::k_EMsgGCUsedClaimCodeItem,
        EGCItemMsg::k_EMsgGCSortItems,
        EGCItemMsg::k_EMsgGC_RevolvingLootList_DEPRECATED,
        EGCItemMsg::k_EMsgGCLookupAccount,
        EGCItemMsg::k_EMsgGCLookupAccountResponse,
        EGCItemMsg::k_EMsgGCLookupAccountName,
        EGCItemMsg::k_EMsgGCLookupAccountNameResponse,
        EGCItemMsg::k_EMsgGCUpdateItemSchema,
        EGCItemMsg::k_EMsgGCRequestInventoryRefresh,
        EGCItemMsg::k_EMsgGCRemoveCustomTexture,
        EGCItemMsg::k_EMsgGCRemoveCustomTextureResponse,
        EGCItemMsg::k_EMsgGCRemoveMakersMark,
        EGCItemMsg::k_EMsgGCRemoveMakersMarkResponse,
        EGCItemMsg::k_EMsgGCRemoveUniqueCraftIndex,
        EGCItemMsg::k_EMsgGCRemoveUniqueCraftIndexResponse,
        EGCItemMsg::k_EMsgGCSaxxyBroadcast,
        EGCItemMsg::k_EMsgGCBackpackSortFinished,
        EGCItemMsg::k_EMsgGCAdjustItemEquippedState,
        EGCItemMsg::k_EMsgGCCollectItem,
        EGCItemMsg::k_EMsgGCItemAcknowledged,
        EGCItemMsg::k_EMsgGCPresets_SelectPresetForClass,
        EGCItemMsg::k_EMsgGCPresets_SetItemPosition,
        EGCItemMsg::k_EMsgGC_ReportAbuse,
        EGCItemMsg::k_EMsgGC_ReportAbuseResponse,
        EGCItemMsg::k_EMsgGCPresets_SelectPresetForClassReply,
        EGCItemMsg::k_EMsgGCNameItemNotification,
        EGCItemMsg::k_EMsgGCClientDisplayNotification,
        EGCItemMsg::k_EMsgGCApplyStrangePart,
        EGCItemMsg::k_EMsgGC_IncrementKillCountAttribute,
        EGCItemMsg::k_EMsgGC_IncrementKillCountResponse,
        EGCItemMsg::k_EMsgGCRemoveStrangePart,
        EGCItemMsg::k_EMsgGCResetStrangeScores,
        EGCItemMsg::k_EMsgGCGiftedItems,
        EGCItemMsg::k_EMsgGCApplyUpgradeCard,
        EGCItemMsg::k_EMsgGCRemoveUpgradeCard,
        EGCItemMsg::k_EMsgGCApplyStrangeRestriction,
        EGCItemMsg::k_EMsgGCClientRequestMarketData,
        EGCItemMsg::k_EMsgGCClientRequestMarketDataResponse,
        EGCItemMsg::k_EMsgGCApplyXifier,
        EGCItemMsg::k_EMsgGCApplyXifierResponse,
        EGCItemMsg::k_EMsgGC_TrackUniquePlayerPairEvent,
        EGCItemMsg::k_EMsgGCFulfillDynamicRecipeComponent,
        EGCItemMsg::k_EMsgGCFulfillDynamicRecipeComponentResponse,
        EGCItemMsg::k_EMsgGCSetItemEffectVerticalOffset,
        EGCItemMsg::k_EMsgGCSetHatEffectUseHeadOrigin,
        EGCItemMsg::k_EMsgGCItemEaterRecharger,
        EGCItemMsg::k_EMsgGCItemEaterRechargerResponse,
        EGCItemMsg::k_EMsgGCApplyBaseItemXifier,
        EGCItemMsg::k_EMsgGCApplyClassTransmogrifier,
        EGCItemMsg::k_EMsgGCApplyHalloweenSpellbookPage,
        EGCItemMsg::k_EMsgGCRemoveKillStreak,
        EGCItemMsg::k_EMsgGCRemoveKillStreakResponse,
        EGCItemMsg::k_EMsgGCTFSpecificItemBroadcast,
        EGCItemMsg::k_EMsgGC_IncrementKillCountAttribute_Multiple,
        EGCItemMsg::k_EMsgGCDeliverGiftResponseGiver,
        EGCItemMsg::k_EMsgGCSetItemPositions,
        EGCItemMsg::k_EMsgGCLookupMultipleAccountNames,
        EGCItemMsg::k_EMsgGCLookupMultipleAccountNamesResponse,
        EGCItemMsg::k_EMsgGCTradingBase,
        EGCItemMsg::k_EMsgGCTrading_InitiateTradeRequest,
        EGCItemMsg::k_EMsgGCTrading_InitiateTradeResponse,
        EGCItemMsg::k_EMsgGCTrading_StartSession,
        EGCItemMsg::k_EMsgGCTrading_SessionClosed,
        EGCItemMsg::k_EMsgGCTrading_CancelSession,
        EGCItemMsg::k_EMsgGCTrading_InitiateTradeRequestResponse,
        EGCItemMsg::k_EMsgGCServerBrowser_FavoriteServer,
        EGCItemMsg::k_EMsgGCServerBrowser_BlacklistServer,
        EGCItemMsg::k_EMsgGCServerRentalsBase,
        EGCItemMsg::k_EMsgGCItemPreviewCheckStatus,
        EGCItemMsg::k_EMsgGCItemPreviewStatusResponse,
        EGCItemMsg::k_EMsgGCItemPreviewRequest,
        EGCItemMsg::k_EMsgGCItemPreviewRequestResponse,
        EGCItemMsg::k_EMsgGCItemPreviewExpire,
        EGCItemMsg::k_EMsgGCItemPreviewExpireNotification,
        EGCItemMsg::k_EMsgGCItemPreviewItemBoughtNotification,
        EGCItemMsg::k_EMsgGCDev_NewItemRequest,
        EGCItemMsg::k_EMsgGCDev_NewItemRequestResponse,
        EGCItemMsg::k_EMsgGCDev_DebugRollLootRequest,
        EGCItemMsg::k_EMsgGCStoreGetUserData,
        EGCItemMsg::k_EMsgGCStoreGetUserDataResponse,
        EGCItemMsg::k_EMsgGCStorePurchaseInit_DEPRECATED,
        EGCItemMsg::k_EMsgGCStorePurchaseInitResponse_DEPRECATED,
        EGCItemMsg::k_EMsgGCStorePurchaseFinalize,
        EGCItemMsg::k_EMsgGCStorePurchaseFinalizeResponse,
        EGCItemMsg::k_EMsgGCStorePurchaseCancel,
        EGCItemMsg::k_EMsgGCStorePurchaseCancelResponse,
        EGCItemMsg::k_EMsgGCStorePurchaseQueryTxn,
        EGCItemMsg::k_EMsgGCStorePurchaseQueryTxnResponse,
        EGCItemMsg::k_EMsgGCStorePurchaseInit,
        EGCItemMsg::k_EMsgGCStorePurchaseInitResponse,
        EGCItemMsg::k_EMsgGCToGCDirtySDOCache,
        EGCItemMsg::k_EMsgGCToGCDirtyMultipleSDOCache,
        EGCItemMsg::k_EMsgGCToGCUpdateSQLKeyValue,
        EGCItemMsg::k_EMsgGCToGCBroadcastConsoleCommand,
        EGCItemMsg::k_EMsgGCServerVersionUpdated,
        EGCItemMsg::k_EMsgGCApplyAutograph,
        EGCItemMsg::k_EMsgGCToGCWebAPIAccountChanged,
        EGCItemMsg::k_EMsgGCRequestAnnouncements,
        EGCItemMsg::k_EMsgGCRequestAnnouncementsResponse,
        EGCItemMsg::k_EMsgGCRequestPassportItemGrant,
        EGCItemMsg::k_EMsgGCClientVersionUpdated,
        EGCItemMsg::k_EMsgGCItemPurgatory_FinalizePurchase,
        EGCItemMsg::k_EMsgGCItemPurgatory_FinalizePurchaseResponse,
        EGCItemMsg::k_EMsgGCItemPurgatory_RefundPurchase,
        EGCItemMsg::k_EMsgGCItemPurgatory_RefundPurchaseResponse,
        EGCItemMsg::k_EMsgGCToGCPlayerStrangeCountAdjustments,
        EGCItemMsg::k_EMsgGCRequestStoreSalesData,
        EGCItemMsg::k_EMsgGCRequestStoreSalesDataResponse,
        EGCItemMsg::k_EMsgGCRequestStoreSalesDataUpToDateResponse,
        EGCItemMsg::k_EMsgGCToGCPingRequest,
        EGCItemMsg::k_EMsgGCToGCPingResponse,
        EGCItemMsg::k_EMsgGCToGCGetUserSessionServer,
        EGCItemMsg::k_EMsgGCToGCGetUserSessionServerResponse,
        EGCItemMsg::k_EMsgGCToGCGetUserServerMembers,
        EGCItemMsg::k_EMsgGCToGCGetUserServerMembersResponse,
        EGCItemMsg::k_EMsgGCToGCGrantSelfMadeItemToAccount,
        EGCItemMsg::k_EMsgGCToGCThankedByNewUser,
        EGCItemMsg::k_EMsgGCShuffleCrateContents,
        EGCItemMsg::k_EMsgGCQuestObjective_Progress,
        EGCItemMsg::k_EMsgGCQuestCompleted,
        EGCItemMsg::k_EMsgGCApplyDuckToken,
        EGCItemMsg::k_EMsgGCQuestObjective_PointsChange,
        EGCItemMsg::k_EMsgGCQuestObjective_RequestLoanerItems,
        EGCItemMsg::k_EMsgGCQuestObjective_RequestLoanerResponse,
        EGCItemMsg::k_EMsgGCApplyStrangeCountTransfer,
        EGCItemMsg::k_EMsgGCCraftCollectionUpgrade,
        EGCItemMsg::k_EMsgGCCraftHalloweenOffering,
        EGCItemMsg::k_EMsgGCQuestDiscard_Request,
        EGCItemMsg::k_EMsgGCRemoveGiftedBy,
        EGCItemMsg::k_EMsgGCRemoveGiftedByResponse,
        EGCItemMsg::k_EMsgGCRemoveFestivizer,
        EGCItemMsg::k_EMsgGCRemoveFestivizerResponse,
        EGCItemMsg::k_EMsgGCCraftCommonStatClock,
    ];
}

impl ::protobuf::EnumFull for EGCItemMsg {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EGCItemMsg").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            EGCItemMsg::k_EMsgGCBase => 0,
            EGCItemMsg::k_EMsgGCSetSingleItemPosition => 1,
            EGCItemMsg::k_EMsgGCCraft => 2,
            EGCItemMsg::k_EMsgGCCraftResponse => 3,
            EGCItemMsg::k_EMsgGCDelete => 4,
            EGCItemMsg::k_EMsgGCVerifyCacheSubscription => 5,
            EGCItemMsg::k_EMsgGCNameItem => 6,
            EGCItemMsg::k_EMsgGCUnlockCrate => 7,
            EGCItemMsg::k_EMsgGCUnlockCrateResponse => 8,
            EGCItemMsg::k_EMsgGCPaintItem => 9,
            EGCItemMsg::k_EMsgGCPaintItemResponse => 10,
            EGCItemMsg::k_EMsgGCGoldenWrenchBroadcast => 11,
            EGCItemMsg::k_EMsgGCMOTDRequest => 12,
            EGCItemMsg::k_EMsgGCMOTDRequestResponse => 13,
            EGCItemMsg::k_EMsgGCNameBaseItem => 14,
            EGCItemMsg::k_EMsgGCNameBaseItemResponse => 15,
            EGCItemMsg::k_EMsgGCRemoveSocketItem_DEPRECATED => 16,
            EGCItemMsg::k_EMsgGCRemoveSocketItemResponse_DEPRECATED => 17,
            EGCItemMsg::k_EMsgGCCustomizeItemTexture => 18,
            EGCItemMsg::k_EMsgGCCustomizeItemTextureResponse => 19,
            EGCItemMsg::k_EMsgGCUseItemRequest => 20,
            EGCItemMsg::k_EMsgGCUseItemResponse => 21,
            EGCItemMsg::k_EMsgGCRespawnPostLoadoutChange => 22,
            EGCItemMsg::k_EMsgGCRemoveItemName => 23,
            EGCItemMsg::k_EMsgGCRemoveItemPaint => 24,
            EGCItemMsg::k_EMsgGCGiftWrapItem => 25,
            EGCItemMsg::k_EMsgGCGiftWrapItemResponse => 26,
            EGCItemMsg::k_EMsgGCDeliverGift => 27,
            EGCItemMsg::k_EMsgGCDeliverGiftResponseReceiver => 28,
            EGCItemMsg::k_EMsgGCUnwrapGiftRequest => 29,
            EGCItemMsg::k_EMsgGCUnwrapGiftResponse => 30,
            EGCItemMsg::k_EMsgGCSetItemStyle => 31,
            EGCItemMsg::k_EMsgGCUsedClaimCodeItem => 32,
            EGCItemMsg::k_EMsgGCSortItems => 33,
            EGCItemMsg::k_EMsgGC_RevolvingLootList_DEPRECATED => 34,
            EGCItemMsg::k_EMsgGCLookupAccount => 35,
            EGCItemMsg::k_EMsgGCLookupAccountResponse => 36,
            EGCItemMsg::k_EMsgGCLookupAccountName => 37,
            EGCItemMsg::k_EMsgGCLookupAccountNameResponse => 38,
            EGCItemMsg::k_EMsgGCUpdateItemSchema => 39,
            EGCItemMsg::k_EMsgGCRequestInventoryRefresh => 40,
            EGCItemMsg::k_EMsgGCRemoveCustomTexture => 41,
            EGCItemMsg::k_EMsgGCRemoveCustomTextureResponse => 42,
            EGCItemMsg::k_EMsgGCRemoveMakersMark => 43,
            EGCItemMsg::k_EMsgGCRemoveMakersMarkResponse => 44,
            EGCItemMsg::k_EMsgGCRemoveUniqueCraftIndex => 45,
            EGCItemMsg::k_EMsgGCRemoveUniqueCraftIndexResponse => 46,
            EGCItemMsg::k_EMsgGCSaxxyBroadcast => 47,
            EGCItemMsg::k_EMsgGCBackpackSortFinished => 48,
            EGCItemMsg::k_EMsgGCAdjustItemEquippedState => 49,
            EGCItemMsg::k_EMsgGCCollectItem => 50,
            EGCItemMsg::k_EMsgGCItemAcknowledged => 51,
            EGCItemMsg::k_EMsgGCPresets_SelectPresetForClass => 52,
            EGCItemMsg::k_EMsgGCPresets_SetItemPosition => 53,
            EGCItemMsg::k_EMsgGC_ReportAbuse => 54,
            EGCItemMsg::k_EMsgGC_ReportAbuseResponse => 55,
            EGCItemMsg::k_EMsgGCPresets_SelectPresetForClassReply => 56,
            EGCItemMsg::k_EMsgGCNameItemNotification => 57,
            EGCItemMsg::k_EMsgGCClientDisplayNotification => 58,
            EGCItemMsg::k_EMsgGCApplyStrangePart => 59,
            EGCItemMsg::k_EMsgGC_IncrementKillCountAttribute => 60,
            EGCItemMsg::k_EMsgGC_IncrementKillCountResponse => 61,
            EGCItemMsg::k_EMsgGCRemoveStrangePart => 62,
            EGCItemMsg::k_EMsgGCResetStrangeScores => 63,
            EGCItemMsg::k_EMsgGCGiftedItems => 64,
            EGCItemMsg::k_EMsgGCApplyUpgradeCard => 65,
            EGCItemMsg::k_EMsgGCRemoveUpgradeCard => 66,
            EGCItemMsg::k_EMsgGCApplyStrangeRestriction => 67,
            EGCItemMsg::k_EMsgGCClientRequestMarketData => 68,
            EGCItemMsg::k_EMsgGCClientRequestMarketDataResponse => 69,
            EGCItemMsg::k_EMsgGCApplyXifier => 70,
            EGCItemMsg::k_EMsgGCApplyXifierResponse => 71,
            EGCItemMsg::k_EMsgGC_TrackUniquePlayerPairEvent => 72,
            EGCItemMsg::k_EMsgGCFulfillDynamicRecipeComponent => 73,
            EGCItemMsg::k_EMsgGCFulfillDynamicRecipeComponentResponse => 74,
            EGCItemMsg::k_EMsgGCSetItemEffectVerticalOffset => 75,
            EGCItemMsg::k_EMsgGCSetHatEffectUseHeadOrigin => 76,
            EGCItemMsg::k_EMsgGCItemEaterRecharger => 77,
            EGCItemMsg::k_EMsgGCItemEaterRechargerResponse => 78,
            EGCItemMsg::k_EMsgGCApplyBaseItemXifier => 79,
            EGCItemMsg::k_EMsgGCApplyClassTransmogrifier => 80,
            EGCItemMsg::k_EMsgGCApplyHalloweenSpellbookPage => 81,
            EGCItemMsg::k_EMsgGCRemoveKillStreak => 82,
            EGCItemMsg::k_EMsgGCRemoveKillStreakResponse => 83,
            EGCItemMsg::k_EMsgGCTFSpecificItemBroadcast => 84,
            EGCItemMsg::k_EMsgGC_IncrementKillCountAttribute_Multiple => 85,
            EGCItemMsg::k_EMsgGCDeliverGiftResponseGiver => 86,
            EGCItemMsg::k_EMsgGCSetItemPositions => 87,
            EGCItemMsg::k_EMsgGCLookupMultipleAccountNames => 88,
            EGCItemMsg::k_EMsgGCLookupMultipleAccountNamesResponse => 89,
            EGCItemMsg::k_EMsgGCTradingBase => 90,
            EGCItemMsg::k_EMsgGCTrading_InitiateTradeRequest => 91,
            EGCItemMsg::k_EMsgGCTrading_InitiateTradeResponse => 92,
            EGCItemMsg::k_EMsgGCTrading_StartSession => 93,
            EGCItemMsg::k_EMsgGCTrading_SessionClosed => 94,
            EGCItemMsg::k_EMsgGCTrading_CancelSession => 95,
            EGCItemMsg::k_EMsgGCTrading_InitiateTradeRequestResponse => 96,
            EGCItemMsg::k_EMsgGCServerBrowser_FavoriteServer => 97,
            EGCItemMsg::k_EMsgGCServerBrowser_BlacklistServer => 98,
            EGCItemMsg::k_EMsgGCServerRentalsBase => 99,
            EGCItemMsg::k_EMsgGCItemPreviewCheckStatus => 100,
            EGCItemMsg::k_EMsgGCItemPreviewStatusResponse => 101,
            EGCItemMsg::k_EMsgGCItemPreviewRequest => 102,
            EGCItemMsg::k_EMsgGCItemPreviewRequestResponse => 103,
            EGCItemMsg::k_EMsgGCItemPreviewExpire => 104,
            EGCItemMsg::k_EMsgGCItemPreviewExpireNotification => 105,
            EGCItemMsg::k_EMsgGCItemPreviewItemBoughtNotification => 106,
            EGCItemMsg::k_EMsgGCDev_NewItemRequest => 107,
            EGCItemMsg::k_EMsgGCDev_NewItemRequestResponse => 108,
            EGCItemMsg::k_EMsgGCDev_DebugRollLootRequest => 109,
            EGCItemMsg::k_EMsgGCStoreGetUserData => 110,
            EGCItemMsg::k_EMsgGCStoreGetUserDataResponse => 111,
            EGCItemMsg::k_EMsgGCStorePurchaseInit_DEPRECATED => 112,
            EGCItemMsg::k_EMsgGCStorePurchaseInitResponse_DEPRECATED => 113,
            EGCItemMsg::k_EMsgGCStorePurchaseFinalize => 114,
            EGCItemMsg::k_EMsgGCStorePurchaseFinalizeResponse => 115,
            EGCItemMsg::k_EMsgGCStorePurchaseCancel => 116,
            EGCItemMsg::k_EMsgGCStorePurchaseCancelResponse => 117,
            EGCItemMsg::k_EMsgGCStorePurchaseQueryTxn => 118,
            EGCItemMsg::k_EMsgGCStorePurchaseQueryTxnResponse => 119,
            EGCItemMsg::k_EMsgGCStorePurchaseInit => 120,
            EGCItemMsg::k_EMsgGCStorePurchaseInitResponse => 121,
            EGCItemMsg::k_EMsgGCToGCDirtySDOCache => 122,
            EGCItemMsg::k_EMsgGCToGCDirtyMultipleSDOCache => 123,
            EGCItemMsg::k_EMsgGCToGCUpdateSQLKeyValue => 124,
            EGCItemMsg::k_EMsgGCToGCBroadcastConsoleCommand => 125,
            EGCItemMsg::k_EMsgGCServerVersionUpdated => 126,
            EGCItemMsg::k_EMsgGCApplyAutograph => 127,
            EGCItemMsg::k_EMsgGCToGCWebAPIAccountChanged => 128,
            EGCItemMsg::k_EMsgGCRequestAnnouncements => 129,
            EGCItemMsg::k_EMsgGCRequestAnnouncementsResponse => 130,
            EGCItemMsg::k_EMsgGCRequestPassportItemGrant => 131,
            EGCItemMsg::k_EMsgGCClientVersionUpdated => 132,
            EGCItemMsg::k_EMsgGCItemPurgatory_FinalizePurchase => 133,
            EGCItemMsg::k_EMsgGCItemPurgatory_FinalizePurchaseResponse => 134,
            EGCItemMsg::k_EMsgGCItemPurgatory_RefundPurchase => 135,
            EGCItemMsg::k_EMsgGCItemPurgatory_RefundPurchaseResponse => 136,
            EGCItemMsg::k_EMsgGCToGCPlayerStrangeCountAdjustments => 137,
            EGCItemMsg::k_EMsgGCRequestStoreSalesData => 138,
            EGCItemMsg::k_EMsgGCRequestStoreSalesDataResponse => 139,
            EGCItemMsg::k_EMsgGCRequestStoreSalesDataUpToDateResponse => 140,
            EGCItemMsg::k_EMsgGCToGCPingRequest => 141,
            EGCItemMsg::k_EMsgGCToGCPingResponse => 142,
            EGCItemMsg::k_EMsgGCToGCGetUserSessionServer => 143,
            EGCItemMsg::k_EMsgGCToGCGetUserSessionServerResponse => 144,
            EGCItemMsg::k_EMsgGCToGCGetUserServerMembers => 145,
            EGCItemMsg::k_EMsgGCToGCGetUserServerMembersResponse => 146,
            EGCItemMsg::k_EMsgGCToGCGrantSelfMadeItemToAccount => 147,
            EGCItemMsg::k_EMsgGCToGCThankedByNewUser => 148,
            EGCItemMsg::k_EMsgGCShuffleCrateContents => 149,
            EGCItemMsg::k_EMsgGCQuestObjective_Progress => 150,
            EGCItemMsg::k_EMsgGCQuestCompleted => 151,
            EGCItemMsg::k_EMsgGCApplyDuckToken => 152,
            EGCItemMsg::k_EMsgGCQuestObjective_PointsChange => 153,
            EGCItemMsg::k_EMsgGCQuestObjective_RequestLoanerItems => 154,
            EGCItemMsg::k_EMsgGCQuestObjective_RequestLoanerResponse => 155,
            EGCItemMsg::k_EMsgGCApplyStrangeCountTransfer => 156,
            EGCItemMsg::k_EMsgGCCraftCollectionUpgrade => 157,
            EGCItemMsg::k_EMsgGCCraftHalloweenOffering => 158,
            EGCItemMsg::k_EMsgGCQuestDiscard_Request => 159,
            EGCItemMsg::k_EMsgGCRemoveGiftedBy => 160,
            EGCItemMsg::k_EMsgGCRemoveGiftedByResponse => 161,
            EGCItemMsg::k_EMsgGCRemoveFestivizer => 162,
            EGCItemMsg::k_EMsgGCRemoveFestivizerResponse => 163,
            EGCItemMsg::k_EMsgGCCraftCommonStatClock => 164,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EGCItemMsg {
    fn default() -> Self {
        EGCItemMsg::k_EMsgGCBase
    }
}

impl EGCItemMsg {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EGCItemMsg>("EGCItemMsg")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EGCMsgResponse)
pub enum EGCMsgResponse {
    // @@protoc_insertion_point(enum_value:EGCMsgResponse.k_EGCMsgResponseOK)
    k_EGCMsgResponseOK = 0,
    // @@protoc_insertion_point(enum_value:EGCMsgResponse.k_EGCMsgResponseDenied)
    k_EGCMsgResponseDenied = 1,
    // @@protoc_insertion_point(enum_value:EGCMsgResponse.k_EGCMsgResponseServerError)
    k_EGCMsgResponseServerError = 2,
    // @@protoc_insertion_point(enum_value:EGCMsgResponse.k_EGCMsgResponseTimeout)
    k_EGCMsgResponseTimeout = 3,
    // @@protoc_insertion_point(enum_value:EGCMsgResponse.k_EGCMsgResponseInvalid)
    k_EGCMsgResponseInvalid = 4,
    // @@protoc_insertion_point(enum_value:EGCMsgResponse.k_EGCMsgResponseNoMatch)
    k_EGCMsgResponseNoMatch = 5,
    // @@protoc_insertion_point(enum_value:EGCMsgResponse.k_EGCMsgResponseUnknownError)
    k_EGCMsgResponseUnknownError = 6,
    // @@protoc_insertion_point(enum_value:EGCMsgResponse.k_EGCMsgResponseNotLoggedOn)
    k_EGCMsgResponseNotLoggedOn = 7,
    // @@protoc_insertion_point(enum_value:EGCMsgResponse.k_EGCMsgFailedToCreate)
    k_EGCMsgFailedToCreate = 8,
}

impl ::protobuf::Enum for EGCMsgResponse {
    const NAME: &'static str = "EGCMsgResponse";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EGCMsgResponse> {
        match value {
            0 => ::std::option::Option::Some(EGCMsgResponse::k_EGCMsgResponseOK),
            1 => ::std::option::Option::Some(EGCMsgResponse::k_EGCMsgResponseDenied),
            2 => ::std::option::Option::Some(EGCMsgResponse::k_EGCMsgResponseServerError),
            3 => ::std::option::Option::Some(EGCMsgResponse::k_EGCMsgResponseTimeout),
            4 => ::std::option::Option::Some(EGCMsgResponse::k_EGCMsgResponseInvalid),
            5 => ::std::option::Option::Some(EGCMsgResponse::k_EGCMsgResponseNoMatch),
            6 => ::std::option::Option::Some(EGCMsgResponse::k_EGCMsgResponseUnknownError),
            7 => ::std::option::Option::Some(EGCMsgResponse::k_EGCMsgResponseNotLoggedOn),
            8 => ::std::option::Option::Some(EGCMsgResponse::k_EGCMsgFailedToCreate),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EGCMsgResponse] = &[
        EGCMsgResponse::k_EGCMsgResponseOK,
        EGCMsgResponse::k_EGCMsgResponseDenied,
        EGCMsgResponse::k_EGCMsgResponseServerError,
        EGCMsgResponse::k_EGCMsgResponseTimeout,
        EGCMsgResponse::k_EGCMsgResponseInvalid,
        EGCMsgResponse::k_EGCMsgResponseNoMatch,
        EGCMsgResponse::k_EGCMsgResponseUnknownError,
        EGCMsgResponse::k_EGCMsgResponseNotLoggedOn,
        EGCMsgResponse::k_EGCMsgFailedToCreate,
    ];
}

impl ::protobuf::EnumFull for EGCMsgResponse {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EGCMsgResponse").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EGCMsgResponse {
    fn default() -> Self {
        EGCMsgResponse::k_EGCMsgResponseOK
    }
}

impl EGCMsgResponse {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EGCMsgResponse>("EGCMsgResponse")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EUnlockStyle)
pub enum EUnlockStyle {
    // @@protoc_insertion_point(enum_value:EUnlockStyle.k_UnlockStyle_Succeeded)
    k_UnlockStyle_Succeeded = 0,
    // @@protoc_insertion_point(enum_value:EUnlockStyle.k_UnlockStyle_Failed_PreReq)
    k_UnlockStyle_Failed_PreReq = 1,
    // @@protoc_insertion_point(enum_value:EUnlockStyle.k_UnlockStyle_Failed_CantAfford)
    k_UnlockStyle_Failed_CantAfford = 2,
    // @@protoc_insertion_point(enum_value:EUnlockStyle.k_UnlockStyle_Failed_CantCommit)
    k_UnlockStyle_Failed_CantCommit = 3,
    // @@protoc_insertion_point(enum_value:EUnlockStyle.k_UnlockStyle_Failed_CantLockCache)
    k_UnlockStyle_Failed_CantLockCache = 4,
    // @@protoc_insertion_point(enum_value:EUnlockStyle.k_UnlockStyle_Failed_CantAffordAttrib)
    k_UnlockStyle_Failed_CantAffordAttrib = 5,
    // @@protoc_insertion_point(enum_value:EUnlockStyle.k_UnlockStyle_Failed_CantAffordGem)
    k_UnlockStyle_Failed_CantAffordGem = 6,
}

impl ::protobuf::Enum for EUnlockStyle {
    const NAME: &'static str = "EUnlockStyle";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EUnlockStyle> {
        match value {
            0 => ::std::option::Option::Some(EUnlockStyle::k_UnlockStyle_Succeeded),
            1 => ::std::option::Option::Some(EUnlockStyle::k_UnlockStyle_Failed_PreReq),
            2 => ::std::option::Option::Some(EUnlockStyle::k_UnlockStyle_Failed_CantAfford),
            3 => ::std::option::Option::Some(EUnlockStyle::k_UnlockStyle_Failed_CantCommit),
            4 => ::std::option::Option::Some(EUnlockStyle::k_UnlockStyle_Failed_CantLockCache),
            5 => ::std::option::Option::Some(EUnlockStyle::k_UnlockStyle_Failed_CantAffordAttrib),
            6 => ::std::option::Option::Some(EUnlockStyle::k_UnlockStyle_Failed_CantAffordGem),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EUnlockStyle] = &[
        EUnlockStyle::k_UnlockStyle_Succeeded,
        EUnlockStyle::k_UnlockStyle_Failed_PreReq,
        EUnlockStyle::k_UnlockStyle_Failed_CantAfford,
        EUnlockStyle::k_UnlockStyle_Failed_CantCommit,
        EUnlockStyle::k_UnlockStyle_Failed_CantLockCache,
        EUnlockStyle::k_UnlockStyle_Failed_CantAffordAttrib,
        EUnlockStyle::k_UnlockStyle_Failed_CantAffordGem,
    ];
}

impl ::protobuf::EnumFull for EUnlockStyle {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EUnlockStyle").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EUnlockStyle {
    fn default() -> Self {
        EUnlockStyle::k_UnlockStyle_Succeeded
    }
}

impl EUnlockStyle {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EUnlockStyle>("EUnlockStyle")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EItemPurgatoryResponse_Finalize)
pub enum EItemPurgatoryResponse_Finalize {
    // @@protoc_insertion_point(enum_value:EItemPurgatoryResponse_Finalize.k_ItemPurgatoryResponse_Finalize_Succeeded)
    k_ItemPurgatoryResponse_Finalize_Succeeded = 0,
    // @@protoc_insertion_point(enum_value:EItemPurgatoryResponse_Finalize.k_ItemPurgatoryResponse_Finalize_Failed_Incomplete)
    k_ItemPurgatoryResponse_Finalize_Failed_Incomplete = 1,
    // @@protoc_insertion_point(enum_value:EItemPurgatoryResponse_Finalize.k_ItemPurgatoryResponse_Finalize_Failed_ItemsNotInPurgatory)
    k_ItemPurgatoryResponse_Finalize_Failed_ItemsNotInPurgatory = 2,
    // @@protoc_insertion_point(enum_value:EItemPurgatoryResponse_Finalize.k_ItemPurgatoryResponse_Finalize_Failed_CouldNotFindItems)
    k_ItemPurgatoryResponse_Finalize_Failed_CouldNotFindItems = 3,
    // @@protoc_insertion_point(enum_value:EItemPurgatoryResponse_Finalize.k_ItemPurgatoryResponse_Finalize_Failed_NoSOCache)
    k_ItemPurgatoryResponse_Finalize_Failed_NoSOCache = 4,
    // @@protoc_insertion_point(enum_value:EItemPurgatoryResponse_Finalize.k_ItemPurgatoryResponse_Finalize_BackpackFull)
    k_ItemPurgatoryResponse_Finalize_BackpackFull = 5,
}

impl ::protobuf::Enum for EItemPurgatoryResponse_Finalize {
    const NAME: &'static str = "EItemPurgatoryResponse_Finalize";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EItemPurgatoryResponse_Finalize> {
        match value {
            0 => ::std::option::Option::Some(EItemPurgatoryResponse_Finalize::k_ItemPurgatoryResponse_Finalize_Succeeded),
            1 => ::std::option::Option::Some(EItemPurgatoryResponse_Finalize::k_ItemPurgatoryResponse_Finalize_Failed_Incomplete),
            2 => ::std::option::Option::Some(EItemPurgatoryResponse_Finalize::k_ItemPurgatoryResponse_Finalize_Failed_ItemsNotInPurgatory),
            3 => ::std::option::Option::Some(EItemPurgatoryResponse_Finalize::k_ItemPurgatoryResponse_Finalize_Failed_CouldNotFindItems),
            4 => ::std::option::Option::Some(EItemPurgatoryResponse_Finalize::k_ItemPurgatoryResponse_Finalize_Failed_NoSOCache),
            5 => ::std::option::Option::Some(EItemPurgatoryResponse_Finalize::k_ItemPurgatoryResponse_Finalize_BackpackFull),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EItemPurgatoryResponse_Finalize] = &[
        EItemPurgatoryResponse_Finalize::k_ItemPurgatoryResponse_Finalize_Succeeded,
        EItemPurgatoryResponse_Finalize::k_ItemPurgatoryResponse_Finalize_Failed_Incomplete,
        EItemPurgatoryResponse_Finalize::k_ItemPurgatoryResponse_Finalize_Failed_ItemsNotInPurgatory,
        EItemPurgatoryResponse_Finalize::k_ItemPurgatoryResponse_Finalize_Failed_CouldNotFindItems,
        EItemPurgatoryResponse_Finalize::k_ItemPurgatoryResponse_Finalize_Failed_NoSOCache,
        EItemPurgatoryResponse_Finalize::k_ItemPurgatoryResponse_Finalize_BackpackFull,
    ];
}

impl ::protobuf::EnumFull for EItemPurgatoryResponse_Finalize {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EItemPurgatoryResponse_Finalize").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EItemPurgatoryResponse_Finalize {
    fn default() -> Self {
        EItemPurgatoryResponse_Finalize::k_ItemPurgatoryResponse_Finalize_Succeeded
    }
}

impl EItemPurgatoryResponse_Finalize {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EItemPurgatoryResponse_Finalize>("EItemPurgatoryResponse_Finalize")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EItemPurgatoryResponse_Refund)
pub enum EItemPurgatoryResponse_Refund {
    // @@protoc_insertion_point(enum_value:EItemPurgatoryResponse_Refund.k_ItemPurgatoryResponse_Refund_Succeeded)
    k_ItemPurgatoryResponse_Refund_Succeeded = 0,
    // @@protoc_insertion_point(enum_value:EItemPurgatoryResponse_Refund.k_ItemPurgatoryResponse_Refund_Failed_ItemNotInPurgatory)
    k_ItemPurgatoryResponse_Refund_Failed_ItemNotInPurgatory = 1,
    // @@protoc_insertion_point(enum_value:EItemPurgatoryResponse_Refund.k_ItemPurgatoryResponse_Refund_Failed_CouldNotFindItem)
    k_ItemPurgatoryResponse_Refund_Failed_CouldNotFindItem = 2,
    // @@protoc_insertion_point(enum_value:EItemPurgatoryResponse_Refund.k_ItemPurgatoryResponse_Refund_Failed_NoSOCache)
    k_ItemPurgatoryResponse_Refund_Failed_NoSOCache = 3,
    // @@protoc_insertion_point(enum_value:EItemPurgatoryResponse_Refund.k_ItemPurgatoryResponse_Refund_Failed_NoDetail)
    k_ItemPurgatoryResponse_Refund_Failed_NoDetail = 4,
    // @@protoc_insertion_point(enum_value:EItemPurgatoryResponse_Refund.k_ItemPurgatoryResponse_Refund_Failed_NexonWebAPI)
    k_ItemPurgatoryResponse_Refund_Failed_NexonWebAPI = 5,
}

impl ::protobuf::Enum for EItemPurgatoryResponse_Refund {
    const NAME: &'static str = "EItemPurgatoryResponse_Refund";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EItemPurgatoryResponse_Refund> {
        match value {
            0 => ::std::option::Option::Some(EItemPurgatoryResponse_Refund::k_ItemPurgatoryResponse_Refund_Succeeded),
            1 => ::std::option::Option::Some(EItemPurgatoryResponse_Refund::k_ItemPurgatoryResponse_Refund_Failed_ItemNotInPurgatory),
            2 => ::std::option::Option::Some(EItemPurgatoryResponse_Refund::k_ItemPurgatoryResponse_Refund_Failed_CouldNotFindItem),
            3 => ::std::option::Option::Some(EItemPurgatoryResponse_Refund::k_ItemPurgatoryResponse_Refund_Failed_NoSOCache),
            4 => ::std::option::Option::Some(EItemPurgatoryResponse_Refund::k_ItemPurgatoryResponse_Refund_Failed_NoDetail),
            5 => ::std::option::Option::Some(EItemPurgatoryResponse_Refund::k_ItemPurgatoryResponse_Refund_Failed_NexonWebAPI),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EItemPurgatoryResponse_Refund] = &[
        EItemPurgatoryResponse_Refund::k_ItemPurgatoryResponse_Refund_Succeeded,
        EItemPurgatoryResponse_Refund::k_ItemPurgatoryResponse_Refund_Failed_ItemNotInPurgatory,
        EItemPurgatoryResponse_Refund::k_ItemPurgatoryResponse_Refund_Failed_CouldNotFindItem,
        EItemPurgatoryResponse_Refund::k_ItemPurgatoryResponse_Refund_Failed_NoSOCache,
        EItemPurgatoryResponse_Refund::k_ItemPurgatoryResponse_Refund_Failed_NoDetail,
        EItemPurgatoryResponse_Refund::k_ItemPurgatoryResponse_Refund_Failed_NexonWebAPI,
    ];
}

impl ::protobuf::EnumFull for EItemPurgatoryResponse_Refund {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EItemPurgatoryResponse_Refund").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EItemPurgatoryResponse_Refund {
    fn default() -> Self {
        EItemPurgatoryResponse_Refund::k_ItemPurgatoryResponse_Refund_Succeeded
    }
}

impl EItemPurgatoryResponse_Refund {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EItemPurgatoryResponse_Refund>("EItemPurgatoryResponse_Refund")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x15econ_gcmessages.proto\x1a\x13steammessages.proto\"b\n\x12CMsgApply\
    Autograph\x12*\n\x11autograph_item_id\x18\x01\x20\x01(\x04R\x0fautograph\
    ItemId\x12\x20\n\x0citem_item_id\x18\x02\x20\x01(\x04R\nitemItemId\"\xb3\
    \x02\n$CMsgEconPlayerStrangeCountAdjustment\x12\x1d\n\naccount_id\x18\
    \x01\x20\x01(\rR\taccountId\x12y\n\x19strange_count_adjustments\x18\x02\
    \x20\x03(\x0b2=.CMsgEconPlayerStrangeCountAdjustment.CStrangeCountAdjust\
    mentR\x17strangeCountAdjustments\x1aq\n\x17CStrangeCountAdjustment\x12\
    \x1d\n\nevent_type\x18\x01\x20\x01(\rR\teventType\x12\x17\n\x07item_id\
    \x18\x02\x20\x01(\x04R\x06itemId\x12\x1e\n\nadjustment\x18\x03\x20\x01(\
    \rR\nadjustment\"F\n)CMsgRequestItemPurgatory_FinalizePurchase\x12\x19\n\
    \x08item_ids\x18\x01\x20\x03(\x04R\x07itemIds\"K\n1CMsgRequestItemPurgat\
    ory_FinalizePurchaseResponse\x12\x16\n\x06result\x18\x01\x20\x01(\rR\x06\
    result\"B\n'CMsgRequestItemPurgatory_RefundPurchase\x12\x17\n\x07item_id\
    \x18\x01\x20\x01(\x04R\x06itemId\"I\n/CMsgRequestItemPurgatory_RefundPur\
    chaseResponse\x12\x16\n\x06result\x18\x01\x20\x01(\rR\x06result\"1\n\x14\
    CMsgCraftingResponse\x12\x19\n\x08item_ids\x18\x01\x20\x03(\x04R\x07item\
    Ids\"S\n\x1bCMsgGCRequestStoreSalesData\x12\x18\n\x07version\x18\x01\x20\
    \x01(\rR\x07version\x12\x1a\n\x08currency\x18\x02\x20\x01(\rR\x08currenc\
    y\"\xed\x01\n#CMsgGCRequestStoreSalesDataResponse\x12I\n\nsale_price\x18\
    \x01\x20\x03(\x0b2*.CMsgGCRequestStoreSalesDataResponse.PriceR\tsalePric\
    e\x12\x18\n\x07version\x18\x02\x20\x01(\rR\x07version\x12'\n\x0fexpirati\
    on_time\x18\x03\x20\x01(\rR\x0eexpirationTime\x1a8\n\x05Price\x12\x19\n\
    \x08item_def\x18\x01\x20\x01(\rR\x07itemDef\x12\x14\n\x05price\x18\x02\
    \x20\x01(\rR\x05price\"p\n+CMsgGCRequestStoreSalesDataUpToDateResponse\
    \x12\x18\n\x07version\x18\x01\x20\x01(\rR\x07version\x12'\n\x0fexpiratio\
    n_time\x18\x02\x20\x01(\rR\x0eexpirationTime\"\x17\n\x15CMsgGCToGCPingRe\
    quest\"\x18\n\x16CMsgGCToGCPingResponse\"?\n\x1eCMsgGCToGCGetUserSession\
    Server\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\"P\n&CMsgGCT\
    oGCGetUserSessionServerResponse\x12&\n\x0fserver_steam_id\x18\x01\x20\
    \x01(\x06R\rserverSteamId\"f\n\x1eCMsgGCToGCGetUserServerMembers\x12\x1d\
    \n\naccount_id\x18\x01\x20\x01(\rR\taccountId\x12%\n\x0emax_spectators\
    \x18\x02\x20\x01(\rR\rmaxSpectators\"T\n&CMsgGCToGCGetUserServerMembersR\
    esponse\x12*\n\x11member_account_id\x18\x01\x20\x03(\rR\x0fmemberAccount\
    Id\"D\n\x1eCMsgLookupMultipleAccountNames\x12\"\n\naccountids\x18\x01\
    \x20\x03(\rR\naccountidsB\x02\x10\x01\"\xb8\x01\n&CMsgLookupMultipleAcco\
    untNamesResponse\x12K\n\x08accounts\x18\x01\x20\x03(\x0b2/.CMsgLookupMul\
    tipleAccountNamesResponse.AccountR\x08accounts\x1aA\n\x07Account\x12\x1c\
    \n\taccountid\x18\x01\x20\x01(\rR\taccountid\x12\x18\n\x07persona\x18\
    \x02\x20\x01(\tR\x07persona\"j\n$CMsgGCToGCGrantSelfMadeItemToAccount\
    \x12$\n\x0eitem_def_index\x18\x01\x20\x01(\rR\x0citemDefIndex\x12\x1c\n\
    \taccountid\x18\x02\x20\x01(\rR\taccountid\"\x80\x01\n\x1aCMsgGCToGCThan\
    kedByNewUser\x12,\n\x12new_user_accountid\x18\x01\x20\x01(\rR\x10newUser\
    Accountid\x124\n\x16thanked_user_accountid\x18\x02\x20\x01(\rR\x14thanke\
    dUserAccountid\"j\n\x1aCMsgGCShuffleCrateContents\x12\"\n\rcrate_item_id\
    \x18\x01\x20\x01(\x04R\x0bcrateItemId\x12(\n\x10user_code_string\x18\x02\
    \x20\x01(\tR\x0euserCodeString\"\xa3\x01\n\x1dCMsgGCQuestObjective_Progr\
    ess\x12\x19\n\x08quest_id\x18\x01\x20\x01(\x04R\x07questId\x12,\n\x12que\
    st_attrib_index\x18\x02\x20\x01(\rR\x10questAttribIndex\x12\x14\n\x05del\
    ta\x18\x03\x20\x01(\rR\x05delta\x12#\n\rowner_steamid\x18\x04\x20\x01(\
    \x06R\x0cownerSteamid\"\xe9\x01\n!CMsgGCQuestObjective_PointsChange\x12\
    \x19\n\x08quest_id\x18\x01\x20\x01(\x04R\x07questId\x12#\n\rowner_steami\
    d\x18\x04\x20\x01(\x06R\x0cownerSteamid\x123\n\x12update_base_points\x18\
    \x05\x20\x01(\x08:\x05falseR\x10updateBasePoints\x12\x19\n\x08points_0\
    \x18\x06\x20\x01(\rR\x07points0\x12\x19\n\x08points_1\x18\x07\x20\x01(\r\
    R\x07points1\x12\x19\n\x08points_2\x18\x08\x20\x01(\rR\x07points2\"8\n\
    \x1bCMsgGCQuestComplete_Request\x12\x19\n\x08quest_id\x18\x01\x20\x01(\
    \x04R\x07questId\"\x16\n\x14CMsgGCQuestCompleted\"D\n'CMsgGCQuestObjecti\
    ve_RequestLoanerItems\x12\x19\n\x08quest_id\x18\x01\x20\x01(\x04R\x07que\
    stId\",\n*CMsgGCQuestObjective_RequestLoanerResponse\"5\n\x1aCMsgCraftCo\
    llectionUpgrade\x12\x17\n\x07item_id\x18\x01\x20\x03(\x04R\x06itemId\"N\
    \n\x1aCMsgCraftHalloweenOffering\x12\x17\n\x07tool_id\x18\x01\x20\x01(\
    \x04R\x06toolId\x12\x17\n\x07item_id\x18\x02\x20\x03(\x04R\x06itemId\"L\
    \n\x18CMsgCraftCommonStatClock\x12\x17\n\x07tool_id\x18\x01\x20\x01(\x04\
    R\x06toolId\x12\x17\n\x07item_id\x18\x02\x20\x03(\x04R\x06itemId\"7\n\
    \x1aCMsgGCQuestDiscard_Request\x12\x19\n\x08quest_id\x18\x01\x20\x01(\
    \x04R\x07questId*\xcb/\n\nEGCItemMsg\x12\x11\n\x0ck_EMsgGCBase\x10\xe8\
    \x07\x12\"\n\x1dk_EMsgGCSetSingleItemPosition\x10\xe9\x07\x12\x12\n\rk_E\
    MsgGCCraft\x10\xea\x07\x12\x1a\n\x15k_EMsgGCCraftResponse\x10\xeb\x07\
    \x12\x13\n\x0ek_EMsgGCDelete\x10\xec\x07\x12$\n\x1fk_EMsgGCVerifyCacheSu\
    bscription\x10\xed\x07\x12\x15\n\x10k_EMsgGCNameItem\x10\xee\x07\x12\x18\
    \n\x13k_EMsgGCUnlockCrate\x10\xef\x07\x12\x20\n\x1bk_EMsgGCUnlockCrateRe\
    sponse\x10\xf0\x07\x12\x16\n\x11k_EMsgGCPaintItem\x10\xf1\x07\x12\x1e\n\
    \x19k_EMsgGCPaintItemResponse\x10\xf2\x07\x12\"\n\x1dk_EMsgGCGoldenWrenc\
    hBroadcast\x10\xf3\x07\x12\x18\n\x13k_EMsgGCMOTDRequest\x10\xf4\x07\x12\
    \x20\n\x1bk_EMsgGCMOTDRequestResponse\x10\xf5\x07\x12\x19\n\x14k_EMsgGCN\
    ameBaseItem\x10\xfb\x07\x12!\n\x1ck_EMsgGCNameBaseItemResponse\x10\xfc\
    \x07\x12(\n#k_EMsgGCRemoveSocketItem_DEPRECATED\x10\xfd\x07\x120\n+k_EMs\
    gGCRemoveSocketItemResponse_DEPRECATED\x10\xfe\x07\x12!\n\x1ck_EMsgGCCus\
    tomizeItemTexture\x10\xff\x07\x12)\n$k_EMsgGCCustomizeItemTextureRespons\
    e\x10\x80\x08\x12\x1b\n\x16k_EMsgGCUseItemRequest\x10\x81\x08\x12\x1c\n\
    \x17k_EMsgGCUseItemResponse\x10\x82\x08\x12%\n\x20k_EMsgGCRespawnPostLoa\
    doutChange\x10\x85\x08\x12\x1b\n\x16k_EMsgGCRemoveItemName\x10\x86\x08\
    \x12\x1c\n\x17k_EMsgGCRemoveItemPaint\x10\x87\x08\x12\x19\n\x14k_EMsgGCG\
    iftWrapItem\x10\x88\x08\x12!\n\x1ck_EMsgGCGiftWrapItemResponse\x10\x89\
    \x08\x12\x18\n\x13k_EMsgGCDeliverGift\x10\x8a\x08\x12(\n#k_EMsgGCDeliver\
    GiftResponseReceiver\x10\x8c\x08\x12\x1e\n\x19k_EMsgGCUnwrapGiftRequest\
    \x10\x8d\x08\x12\x1f\n\x1ak_EMsgGCUnwrapGiftResponse\x10\x8e\x08\x12\x19\
    \n\x14k_EMsgGCSetItemStyle\x10\x8f\x08\x12\x1e\n\x19k_EMsgGCUsedClaimCod\
    eItem\x10\x90\x08\x12\x16\n\x11k_EMsgGCSortItems\x10\x91\x08\x12*\n%k_EM\
    sgGC_RevolvingLootList_DEPRECATED\x10\x92\x08\x12\x1a\n\x15k_EMsgGCLooku\
    pAccount\x10\x93\x08\x12\"\n\x1dk_EMsgGCLookupAccountResponse\x10\x94\
    \x08\x12\x1e\n\x19k_EMsgGCLookupAccountName\x10\x95\x08\x12&\n!k_EMsgGCL\
    ookupAccountNameResponse\x10\x96\x08\x12\x1d\n\x18k_EMsgGCUpdateItemSche\
    ma\x10\x99\x08\x12$\n\x1fk_EMsgGCRequestInventoryRefresh\x10\x9a\x08\x12\
    \x20\n\x1bk_EMsgGCRemoveCustomTexture\x10\x9b\x08\x12(\n#k_EMsgGCRemoveC\
    ustomTextureResponse\x10\x9c\x08\x12\x1d\n\x18k_EMsgGCRemoveMakersMark\
    \x10\x9d\x08\x12%\n\x20k_EMsgGCRemoveMakersMarkResponse\x10\x9e\x08\x12#\
    \n\x1ek_EMsgGCRemoveUniqueCraftIndex\x10\x9f\x08\x12+\n&k_EMsgGCRemoveUn\
    iqueCraftIndexResponse\x10\xa0\x08\x12\x1b\n\x16k_EMsgGCSaxxyBroadcast\
    \x10\xa1\x08\x12!\n\x1ck_EMsgGCBackpackSortFinished\x10\xa2\x08\x12$\n\
    \x1fk_EMsgGCAdjustItemEquippedState\x10\xa3\x08\x12\x18\n\x13k_EMsgGCCol\
    lectItem\x10\xa5\x08\x12\x1d\n\x18k_EMsgGCItemAcknowledged\x10\xa6\x08\
    \x12)\n$k_EMsgGCPresets_SelectPresetForClass\x10\xa7\x08\x12$\n\x1fk_EMs\
    gGCPresets_SetItemPosition\x10\xa8\x08\x12\x19\n\x14k_EMsgGC_ReportAbuse\
    \x10\xa9\x08\x12!\n\x1ck_EMsgGC_ReportAbuseResponse\x10\xaa\x08\x12.\n)k\
    _EMsgGCPresets_SelectPresetForClassReply\x10\xab\x08\x12!\n\x1ck_EMsgGCN\
    ameItemNotification\x10\xac\x08\x12&\n!k_EMsgGCClientDisplayNotification\
    \x10\xad\x08\x12\x1d\n\x18k_EMsgGCApplyStrangePart\x10\xae\x08\x12)\n$k_\
    EMsgGC_IncrementKillCountAttribute\x10\xaf\x08\x12(\n#k_EMsgGC_Increment\
    KillCountResponse\x10\xb0\x08\x12\x1e\n\x19k_EMsgGCRemoveStrangePart\x10\
    \xb1\x08\x12\x1f\n\x1ak_EMsgGCResetStrangeScores\x10\xb2\x08\x12\x18\n\
    \x13k_EMsgGCGiftedItems\x10\xb3\x08\x12\x1d\n\x18k_EMsgGCApplyUpgradeCar\
    d\x10\xb5\x08\x12\x1e\n\x19k_EMsgGCRemoveUpgradeCard\x10\xb6\x08\x12$\n\
    \x1fk_EMsgGCApplyStrangeRestriction\x10\xb7\x08\x12$\n\x1fk_EMsgGCClient\
    RequestMarketData\x10\xb8\x08\x12,\n'k_EMsgGCClientRequestMarketDataResp\
    onse\x10\xb9\x08\x12\x18\n\x13k_EMsgGCApplyXifier\x10\xba\x08\x12\x20\n\
    \x1bk_EMsgGCApplyXifierResponse\x10\xbb\x08\x12(\n#k_EMsgGC_TrackUniqueP\
    layerPairEvent\x10\xbc\x08\x12*\n%k_EMsgGCFulfillDynamicRecipeComponent\
    \x10\xbd\x08\x122\n-k_EMsgGCFulfillDynamicRecipeComponentResponse\x10\
    \xbe\x08\x12(\n#k_EMsgGCSetItemEffectVerticalOffset\x10\xbf\x08\x12&\n!k\
    _EMsgGCSetHatEffectUseHeadOrigin\x10\xc0\x08\x12\x1f\n\x1ak_EMsgGCItemEa\
    terRecharger\x10\xc1\x08\x12'\n\"k_EMsgGCItemEaterRechargerResponse\x10\
    \xc2\x08\x12\x20\n\x1bk_EMsgGCApplyBaseItemXifier\x10\xc3\x08\x12%\n\x20\
    k_EMsgGCApplyClassTransmogrifier\x10\xc4\x08\x12(\n#k_EMsgGCApplyHallowe\
    enSpellbookPage\x10\xc5\x08\x12\x1d\n\x18k_EMsgGCRemoveKillStreak\x10\
    \xc6\x08\x12%\n\x20k_EMsgGCRemoveKillStreakResponse\x10\xc7\x08\x12$\n\
    \x1fk_EMsgGCTFSpecificItemBroadcast\x10\xc8\x08\x122\n-k_EMsgGC_Incremen\
    tKillCountAttribute_Multiple\x10\xc9\x08\x12%\n\x20k_EMsgGCDeliverGiftRe\
    sponseGiver\x10\xca\x08\x12\x1d\n\x18k_EMsgGCSetItemPositions\x10\xcc\
    \x08\x12'\n\"k_EMsgGCLookupMultipleAccountNames\x10\xcd\x08\x12/\n*k_EMs\
    gGCLookupMultipleAccountNamesResponse\x10\xce\x08\x12\x18\n\x13k_EMsgGCT\
    radingBase\x10\xdc\x0b\x12)\n$k_EMsgGCTrading_InitiateTradeRequest\x10\
    \xdd\x0b\x12*\n%k_EMsgGCTrading_InitiateTradeResponse\x10\xde\x0b\x12!\n\
    \x1ck_EMsgGCTrading_StartSession\x10\xdf\x0b\x12\"\n\x1dk_EMsgGCTrading_\
    SessionClosed\x10\xe5\x0b\x12\"\n\x1dk_EMsgGCTrading_CancelSession\x10\
    \xe6\x0b\x121\n,k_EMsgGCTrading_InitiateTradeRequestResponse\x10\xea\x0b\
    \x12)\n$k_EMsgGCServerBrowser_FavoriteServer\x10\xc1\x0c\x12*\n%k_EMsgGC\
    ServerBrowser_BlacklistServer\x10\xc2\x0c\x12\x1e\n\x19k_EMsgGCServerRen\
    talsBase\x10\xa4\r\x12#\n\x1ek_EMsgGCItemPreviewCheckStatus\x10\xa5\r\
    \x12&\n!k_EMsgGCItemPreviewStatusResponse\x10\xa6\r\x12\x1f\n\x1ak_EMsgG\
    CItemPreviewRequest\x10\xa7\r\x12'\n\"k_EMsgGCItemPreviewRequestResponse\
    \x10\xa8\r\x12\x1e\n\x19k_EMsgGCItemPreviewExpire\x10\xa9\r\x12*\n%k_EMs\
    gGCItemPreviewExpireNotification\x10\xaa\r\x12.\n)k_EMsgGCItemPreviewIte\
    mBoughtNotification\x10\xac\r\x12\x1f\n\x1ak_EMsgGCDev_NewItemRequest\
    \x10\xd1\x0f\x12'\n\"k_EMsgGCDev_NewItemRequestResponse\x10\xd2\x0f\x12%\
    \n\x20k_EMsgGCDev_DebugRollLootRequest\x10\xd3\x0f\x12\x1d\n\x18k_EMsgGC\
    StoreGetUserData\x10\xc4\x13\x12%\n\x20k_EMsgGCStoreGetUserDataResponse\
    \x10\xc5\x13\x12)\n$k_EMsgGCStorePurchaseInit_DEPRECATED\x10\xc6\x13\x12\
    1\n,k_EMsgGCStorePurchaseInitResponse_DEPRECATED\x10\xc7\x13\x12\"\n\x1d\
    k_EMsgGCStorePurchaseFinalize\x10\xd0\x13\x12*\n%k_EMsgGCStorePurchaseFi\
    nalizeResponse\x10\xd1\x13\x12\x20\n\x1bk_EMsgGCStorePurchaseCancel\x10\
    \xd2\x13\x12(\n#k_EMsgGCStorePurchaseCancelResponse\x10\xd3\x13\x12\"\n\
    \x1dk_EMsgGCStorePurchaseQueryTxn\x10\xcc\x13\x12*\n%k_EMsgGCStorePurcha\
    seQueryTxnResponse\x10\xcd\x13\x12\x1e\n\x19k_EMsgGCStorePurchaseInit\
    \x10\xce\x13\x12&\n!k_EMsgGCStorePurchaseInitResponse\x10\xcf\x13\x12\
    \x1e\n\x19k_EMsgGCToGCDirtySDOCache\x10\xd4\x13\x12&\n!k_EMsgGCToGCDirty\
    MultipleSDOCache\x10\xd5\x13\x12\"\n\x1dk_EMsgGCToGCUpdateSQLKeyValue\
    \x10\xd6\x13\x12(\n#k_EMsgGCToGCBroadcastConsoleCommand\x10\xd9\x13\x12!\
    \n\x1ck_EMsgGCServerVersionUpdated\x10\xda\x13\x12\x1b\n\x16k_EMsgGCAppl\
    yAutograph\x10\xdb\x13\x12%\n\x20k_EMsgGCToGCWebAPIAccountChanged\x10\
    \xdc\x13\x12!\n\x1ck_EMsgGCRequestAnnouncements\x10\xdd\x13\x12)\n$k_EMs\
    gGCRequestAnnouncementsResponse\x10\xde\x13\x12%\n\x20k_EMsgGCRequestPas\
    sportItemGrant\x10\xdf\x13\x12!\n\x1ck_EMsgGCClientVersionUpdated\x10\
    \xe0\x13\x12+\n&k_EMsgGCItemPurgatory_FinalizePurchase\x10\xe3\x13\x123\
    \n.k_EMsgGCItemPurgatory_FinalizePurchaseResponse\x10\xe4\x13\x12)\n$k_E\
    MsgGCItemPurgatory_RefundPurchase\x10\xe5\x13\x121\n,k_EMsgGCItemPurgato\
    ry_RefundPurchaseResponse\x10\xe6\x13\x12.\n)k_EMsgGCToGCPlayerStrangeCo\
    untAdjustments\x10\xe7\x13\x12\"\n\x1dk_EMsgGCRequestStoreSalesData\x10\
    \xe8\x13\x12*\n%k_EMsgGCRequestStoreSalesDataResponse\x10\xe9\x13\x122\n\
    -k_EMsgGCRequestStoreSalesDataUpToDateResponse\x10\xea\x13\x12\x1c\n\x17\
    k_EMsgGCToGCPingRequest\x10\xeb\x13\x12\x1d\n\x18k_EMsgGCToGCPingRespons\
    e\x10\xec\x13\x12%\n\x20k_EMsgGCToGCGetUserSessionServer\x10\xed\x13\x12\
    -\n(k_EMsgGCToGCGetUserSessionServerResponse\x10\xee\x13\x12%\n\x20k_EMs\
    gGCToGCGetUserServerMembers\x10\xef\x13\x12-\n(k_EMsgGCToGCGetUserServer\
    MembersResponse\x10\xf0\x13\x12+\n&k_EMsgGCToGCGrantSelfMadeItemToAccoun\
    t\x10\xfb\x13\x12!\n\x1ck_EMsgGCToGCThankedByNewUser\x10\xfc\x13\x12!\n\
    \x1ck_EMsgGCShuffleCrateContents\x10\xfd\x13\x12$\n\x1fk_EMsgGCQuestObje\
    ctive_Progress\x10\xfe\x13\x12\x1b\n\x16k_EMsgGCQuestCompleted\x10\xff\
    \x13\x12\x1b\n\x16k_EMsgGCApplyDuckToken\x10\x80\x14\x12(\n#k_EMsgGCQues\
    tObjective_PointsChange\x10\x82\x14\x12.\n)k_EMsgGCQuestObjective_Reques\
    tLoanerItems\x10\x84\x14\x121\n,k_EMsgGCQuestObjective_RequestLoanerResp\
    onse\x10\x85\x14\x12&\n!k_EMsgGCApplyStrangeCountTransfer\x10\x86\x14\
    \x12#\n\x1ek_EMsgGCCraftCollectionUpgrade\x10\x87\x14\x12#\n\x1ek_EMsgGC\
    CraftHalloweenOffering\x10\x88\x14\x12!\n\x1ck_EMsgGCQuestDiscard_Reques\
    t\x10\x89\x14\x12\x1b\n\x16k_EMsgGCRemoveGiftedBy\x10\x8a\x14\x12#\n\x1e\
    k_EMsgGCRemoveGiftedByResponse\x10\x8b\x14\x12\x1d\n\x18k_EMsgGCRemoveFe\
    stivizer\x10\x8c\x14\x12%\n\x20k_EMsgGCRemoveFestivizerResponse\x10\x8d\
    \x14\x12!\n\x1ck_EMsgGCCraftCommonStatClock\x10\x8e\x14*\x9b\x02\n\x0eEG\
    CMsgResponse\x12\x16\n\x12k_EGCMsgResponseOK\x10\0\x12\x1a\n\x16k_EGCMsg\
    ResponseDenied\x10\x01\x12\x1f\n\x1bk_EGCMsgResponseServerError\x10\x02\
    \x12\x1b\n\x17k_EGCMsgResponseTimeout\x10\x03\x12\x1b\n\x17k_EGCMsgRespo\
    nseInvalid\x10\x04\x12\x1b\n\x17k_EGCMsgResponseNoMatch\x10\x05\x12\x20\
    \n\x1ck_EGCMsgResponseUnknownError\x10\x06\x12\x1f\n\x1bk_EGCMsgResponse\
    NotLoggedOn\x10\x07\x12\x1a\n\x16k_EGCMsgFailedToCreate\x10\x08*\x91\x02\
    \n\x0cEUnlockStyle\x12\x1b\n\x17k_UnlockStyle_Succeeded\x10\0\x12\x1f\n\
    \x1bk_UnlockStyle_Failed_PreReq\x10\x01\x12#\n\x1fk_UnlockStyle_Failed_C\
    antAfford\x10\x02\x12#\n\x1fk_UnlockStyle_Failed_CantCommit\x10\x03\x12&\
    \n\"k_UnlockStyle_Failed_CantLockCache\x10\x04\x12)\n%k_UnlockStyle_Fail\
    ed_CantAffordAttrib\x10\x05\x12&\n\"k_UnlockStyle_Failed_CantAffordGem\
    \x10\x06*\xf3\x02\n\x1fEItemPurgatoryResponse_Finalize\x12.\n*k_ItemPurg\
    atoryResponse_Finalize_Succeeded\x10\0\x126\n2k_ItemPurgatoryResponse_Fi\
    nalize_Failed_Incomplete\x10\x01\x12?\n;k_ItemPurgatoryResponse_Finalize\
    _Failed_ItemsNotInPurgatory\x10\x02\x12=\n9k_ItemPurgatoryResponse_Final\
    ize_Failed_CouldNotFindItems\x10\x03\x125\n1k_ItemPurgatoryResponse_Fina\
    lize_Failed_NoSOCache\x10\x04\x121\n-k_ItemPurgatoryResponse_Finalize_Ba\
    ckpackFull\x10\x05*\xe7\x02\n\x1dEItemPurgatoryResponse_Refund\x12,\n(k_\
    ItemPurgatoryResponse_Refund_Succeeded\x10\0\x12<\n8k_ItemPurgatoryRespo\
    nse_Refund_Failed_ItemNotInPurgatory\x10\x01\x12:\n6k_ItemPurgatoryRespo\
    nse_Refund_Failed_CouldNotFindItem\x10\x02\x123\n/k_ItemPurgatoryRespons\
    e_Refund_Failed_NoSOCache\x10\x03\x122\n.k_ItemPurgatoryResponse_Refund_\
    Failed_NoDetail\x10\x04\x125\n1k_ItemPurgatoryResponse_Refund_Failed_Nex\
    onWebAPI\x10\x05B\x05H\x01\x80\x01\0J\xb1i\n\x07\x12\x05\0\0\xef\x02\x01\
    \n\t\n\x02\x03\0\x12\x03\0\x07\x1c\n\x08\n\x01\x08\x12\x03\x02\0\x1c\n\t\
    \n\x02\x08\t\x12\x03\x02\0\x1c\n\x08\n\x01\x08\x12\x03\x03\0#\n\t\n\x02\
    \x08\x10\x12\x03\x03\0#\n\x0b\n\x02\x05\0\x12\x05\x05\0\xab\x01\x01\n\n\
    \n\x03\x05\0\x01\x12\x03\x05\x05\x0f\n\x0b\n\x04\x05\0\x02\0\x12\x03\x06\
    \x08\x1c\n\x0c\n\x05\x05\0\x02\0\x01\x12\x03\x06\x08\x14\n\x0c\n\x05\x05\
    \0\x02\0\x02\x12\x03\x06\x17\x1b\n\x0b\n\x04\x05\0\x02\x01\x12\x03\x07\
    \x08-\n\x0c\n\x05\x05\0\x02\x01\x01\x12\x03\x07\x08%\n\x0c\n\x05\x05\0\
    \x02\x01\x02\x12\x03\x07(,\n\x0b\n\x04\x05\0\x02\x02\x12\x03\x08\x08\x1d\
    \n\x0c\n\x05\x05\0\x02\x02\x01\x12\x03\x08\x08\x15\n\x0c\n\x05\x05\0\x02\
    \x02\x02\x12\x03\x08\x18\x1c\n\x0b\n\x04\x05\0\x02\x03\x12\x03\t\x08%\n\
    \x0c\n\x05\x05\0\x02\x03\x01\x12\x03\t\x08\x1d\n\x0c\n\x05\x05\0\x02\x03\
    \x02\x12\x03\t\x20$\n\x0b\n\x04\x05\0\x02\x04\x12\x03\n\x08\x1e\n\x0c\n\
    \x05\x05\0\x02\x04\x01\x12\x03\n\x08\x16\n\x0c\n\x05\x05\0\x02\x04\x02\
    \x12\x03\n\x19\x1d\n\x0b\n\x04\x05\0\x02\x05\x12\x03\x0b\x08/\n\x0c\n\
    \x05\x05\0\x02\x05\x01\x12\x03\x0b\x08'\n\x0c\n\x05\x05\0\x02\x05\x02\
    \x12\x03\x0b*.\n\x0b\n\x04\x05\0\x02\x06\x12\x03\x0c\x08\x20\n\x0c\n\x05\
    \x05\0\x02\x06\x01\x12\x03\x0c\x08\x18\n\x0c\n\x05\x05\0\x02\x06\x02\x12\
    \x03\x0c\x1b\x1f\n\x0b\n\x04\x05\0\x02\x07\x12\x03\r\x08#\n\x0c\n\x05\
    \x05\0\x02\x07\x01\x12\x03\r\x08\x1b\n\x0c\n\x05\x05\0\x02\x07\x02\x12\
    \x03\r\x1e\"\n\x0b\n\x04\x05\0\x02\x08\x12\x03\x0e\x08+\n\x0c\n\x05\x05\
    \0\x02\x08\x01\x12\x03\x0e\x08#\n\x0c\n\x05\x05\0\x02\x08\x02\x12\x03\
    \x0e&*\n\x0b\n\x04\x05\0\x02\t\x12\x03\x0f\x08!\n\x0c\n\x05\x05\0\x02\t\
    \x01\x12\x03\x0f\x08\x19\n\x0c\n\x05\x05\0\x02\t\x02\x12\x03\x0f\x1c\x20\
    \n\x0b\n\x04\x05\0\x02\n\x12\x03\x10\x08)\n\x0c\n\x05\x05\0\x02\n\x01\
    \x12\x03\x10\x08!\n\x0c\n\x05\x05\0\x02\n\x02\x12\x03\x10$(\n\x0b\n\x04\
    \x05\0\x02\x0b\x12\x03\x11\x08-\n\x0c\n\x05\x05\0\x02\x0b\x01\x12\x03\
    \x11\x08%\n\x0c\n\x05\x05\0\x02\x0b\x02\x12\x03\x11(,\n\x0b\n\x04\x05\0\
    \x02\x0c\x12\x03\x12\x08#\n\x0c\n\x05\x05\0\x02\x0c\x01\x12\x03\x12\x08\
    \x1b\n\x0c\n\x05\x05\0\x02\x0c\x02\x12\x03\x12\x1e\"\n\x0b\n\x04\x05\0\
    \x02\r\x12\x03\x13\x08+\n\x0c\n\x05\x05\0\x02\r\x01\x12\x03\x13\x08#\n\
    \x0c\n\x05\x05\0\x02\r\x02\x12\x03\x13&*\n\x0b\n\x04\x05\0\x02\x0e\x12\
    \x03\x14\x08$\n\x0c\n\x05\x05\0\x02\x0e\x01\x12\x03\x14\x08\x1c\n\x0c\n\
    \x05\x05\0\x02\x0e\x02\x12\x03\x14\x1f#\n\x0b\n\x04\x05\0\x02\x0f\x12\
    \x03\x15\x08,\n\x0c\n\x05\x05\0\x02\x0f\x01\x12\x03\x15\x08$\n\x0c\n\x05\
    \x05\0\x02\x0f\x02\x12\x03\x15'+\n\x0b\n\x04\x05\0\x02\x10\x12\x03\x16\
    \x083\n\x0c\n\x05\x05\0\x02\x10\x01\x12\x03\x16\x08+\n\x0c\n\x05\x05\0\
    \x02\x10\x02\x12\x03\x16.2\n\x0b\n\x04\x05\0\x02\x11\x12\x03\x17\x08;\n\
    \x0c\n\x05\x05\0\x02\x11\x01\x12\x03\x17\x083\n\x0c\n\x05\x05\0\x02\x11\
    \x02\x12\x03\x176:\n\x0b\n\x04\x05\0\x02\x12\x12\x03\x18\x08,\n\x0c\n\
    \x05\x05\0\x02\x12\x01\x12\x03\x18\x08$\n\x0c\n\x05\x05\0\x02\x12\x02\
    \x12\x03\x18'+\n\x0b\n\x04\x05\0\x02\x13\x12\x03\x19\x084\n\x0c\n\x05\
    \x05\0\x02\x13\x01\x12\x03\x19\x08,\n\x0c\n\x05\x05\0\x02\x13\x02\x12\
    \x03\x19/3\n\x0b\n\x04\x05\0\x02\x14\x12\x03\x1a\x08&\n\x0c\n\x05\x05\0\
    \x02\x14\x01\x12\x03\x1a\x08\x1e\n\x0c\n\x05\x05\0\x02\x14\x02\x12\x03\
    \x1a!%\n\x0b\n\x04\x05\0\x02\x15\x12\x03\x1b\x08'\n\x0c\n\x05\x05\0\x02\
    \x15\x01\x12\x03\x1b\x08\x1f\n\x0c\n\x05\x05\0\x02\x15\x02\x12\x03\x1b\"\
    &\n\x0b\n\x04\x05\0\x02\x16\x12\x03\x1c\x080\n\x0c\n\x05\x05\0\x02\x16\
    \x01\x12\x03\x1c\x08(\n\x0c\n\x05\x05\0\x02\x16\x02\x12\x03\x1c+/\n\x0b\
    \n\x04\x05\0\x02\x17\x12\x03\x1d\x08&\n\x0c\n\x05\x05\0\x02\x17\x01\x12\
    \x03\x1d\x08\x1e\n\x0c\n\x05\x05\0\x02\x17\x02\x12\x03\x1d!%\n\x0b\n\x04\
    \x05\0\x02\x18\x12\x03\x1e\x08'\n\x0c\n\x05\x05\0\x02\x18\x01\x12\x03\
    \x1e\x08\x1f\n\x0c\n\x05\x05\0\x02\x18\x02\x12\x03\x1e\"&\n\x0b\n\x04\
    \x05\0\x02\x19\x12\x03\x1f\x08$\n\x0c\n\x05\x05\0\x02\x19\x01\x12\x03\
    \x1f\x08\x1c\n\x0c\n\x05\x05\0\x02\x19\x02\x12\x03\x1f\x1f#\n\x0b\n\x04\
    \x05\0\x02\x1a\x12\x03\x20\x08,\n\x0c\n\x05\x05\0\x02\x1a\x01\x12\x03\
    \x20\x08$\n\x0c\n\x05\x05\0\x02\x1a\x02\x12\x03\x20'+\n\x0b\n\x04\x05\0\
    \x02\x1b\x12\x03!\x08#\n\x0c\n\x05\x05\0\x02\x1b\x01\x12\x03!\x08\x1b\n\
    \x0c\n\x05\x05\0\x02\x1b\x02\x12\x03!\x1e\"\n\x0b\n\x04\x05\0\x02\x1c\
    \x12\x03\"\x083\n\x0c\n\x05\x05\0\x02\x1c\x01\x12\x03\"\x08+\n\x0c\n\x05\
    \x05\0\x02\x1c\x02\x12\x03\".2\n\x0b\n\x04\x05\0\x02\x1d\x12\x03#\x08)\n\
    \x0c\n\x05\x05\0\x02\x1d\x01\x12\x03#\x08!\n\x0c\n\x05\x05\0\x02\x1d\x02\
    \x12\x03#$(\n\x0b\n\x04\x05\0\x02\x1e\x12\x03$\x08*\n\x0c\n\x05\x05\0\
    \x02\x1e\x01\x12\x03$\x08\"\n\x0c\n\x05\x05\0\x02\x1e\x02\x12\x03$%)\n\
    \x0b\n\x04\x05\0\x02\x1f\x12\x03%\x08$\n\x0c\n\x05\x05\0\x02\x1f\x01\x12\
    \x03%\x08\x1c\n\x0c\n\x05\x05\0\x02\x1f\x02\x12\x03%\x1f#\n\x0b\n\x04\
    \x05\0\x02\x20\x12\x03&\x08)\n\x0c\n\x05\x05\0\x02\x20\x01\x12\x03&\x08!\
    \n\x0c\n\x05\x05\0\x02\x20\x02\x12\x03&$(\n\x0b\n\x04\x05\0\x02!\x12\x03\
    '\x08!\n\x0c\n\x05\x05\0\x02!\x01\x12\x03'\x08\x19\n\x0c\n\x05\x05\0\x02\
    !\x02\x12\x03'\x1c\x20\n\x0b\n\x04\x05\0\x02\"\x12\x03(\x085\n\x0c\n\x05\
    \x05\0\x02\"\x01\x12\x03(\x08-\n\x0c\n\x05\x05\0\x02\"\x02\x12\x03(04\n\
    \x0b\n\x04\x05\0\x02#\x12\x03)\x08%\n\x0c\n\x05\x05\0\x02#\x01\x12\x03)\
    \x08\x1d\n\x0c\n\x05\x05\0\x02#\x02\x12\x03)\x20$\n\x0b\n\x04\x05\0\x02$\
    \x12\x03*\x08-\n\x0c\n\x05\x05\0\x02$\x01\x12\x03*\x08%\n\x0c\n\x05\x05\
    \0\x02$\x02\x12\x03*(,\n\x0b\n\x04\x05\0\x02%\x12\x03+\x08)\n\x0c\n\x05\
    \x05\0\x02%\x01\x12\x03+\x08!\n\x0c\n\x05\x05\0\x02%\x02\x12\x03+$(\n\
    \x0b\n\x04\x05\0\x02&\x12\x03,\x081\n\x0c\n\x05\x05\0\x02&\x01\x12\x03,\
    \x08)\n\x0c\n\x05\x05\0\x02&\x02\x12\x03,,0\n\x0b\n\x04\x05\0\x02'\x12\
    \x03-\x08(\n\x0c\n\x05\x05\0\x02'\x01\x12\x03-\x08\x20\n\x0c\n\x05\x05\0\
    \x02'\x02\x12\x03-#'\n\x0b\n\x04\x05\0\x02(\x12\x03.\x08/\n\x0c\n\x05\
    \x05\0\x02(\x01\x12\x03.\x08'\n\x0c\n\x05\x05\0\x02(\x02\x12\x03.*.\n\
    \x0b\n\x04\x05\0\x02)\x12\x03/\x08+\n\x0c\n\x05\x05\0\x02)\x01\x12\x03/\
    \x08#\n\x0c\n\x05\x05\0\x02)\x02\x12\x03/&*\n\x0b\n\x04\x05\0\x02*\x12\
    \x030\x083\n\x0c\n\x05\x05\0\x02*\x01\x12\x030\x08+\n\x0c\n\x05\x05\0\
    \x02*\x02\x12\x030.2\n\x0b\n\x04\x05\0\x02+\x12\x031\x08(\n\x0c\n\x05\
    \x05\0\x02+\x01\x12\x031\x08\x20\n\x0c\n\x05\x05\0\x02+\x02\x12\x031#'\n\
    \x0b\n\x04\x05\0\x02,\x12\x032\x080\n\x0c\n\x05\x05\0\x02,\x01\x12\x032\
    \x08(\n\x0c\n\x05\x05\0\x02,\x02\x12\x032+/\n\x0b\n\x04\x05\0\x02-\x12\
    \x033\x08.\n\x0c\n\x05\x05\0\x02-\x01\x12\x033\x08&\n\x0c\n\x05\x05\0\
    \x02-\x02\x12\x033)-\n\x0b\n\x04\x05\0\x02.\x12\x034\x086\n\x0c\n\x05\
    \x05\0\x02.\x01\x12\x034\x08.\n\x0c\n\x05\x05\0\x02.\x02\x12\x03415\n\
    \x0b\n\x04\x05\0\x02/\x12\x035\x08&\n\x0c\n\x05\x05\0\x02/\x01\x12\x035\
    \x08\x1e\n\x0c\n\x05\x05\0\x02/\x02\x12\x035!%\n\x0b\n\x04\x05\0\x020\
    \x12\x036\x08,\n\x0c\n\x05\x05\0\x020\x01\x12\x036\x08$\n\x0c\n\x05\x05\
    \0\x020\x02\x12\x036'+\n\x0b\n\x04\x05\0\x021\x12\x037\x08/\n\x0c\n\x05\
    \x05\0\x021\x01\x12\x037\x08'\n\x0c\n\x05\x05\0\x021\x02\x12\x037*.\n\
    \x0b\n\x04\x05\0\x022\x12\x038\x08#\n\x0c\n\x05\x05\0\x022\x01\x12\x038\
    \x08\x1b\n\x0c\n\x05\x05\0\x022\x02\x12\x038\x1e\"\n\x0b\n\x04\x05\0\x02\
    3\x12\x039\x08(\n\x0c\n\x05\x05\0\x023\x01\x12\x039\x08\x20\n\x0c\n\x05\
    \x05\0\x023\x02\x12\x039#'\n\x0b\n\x04\x05\0\x024\x12\x03:\x084\n\x0c\n\
    \x05\x05\0\x024\x01\x12\x03:\x08,\n\x0c\n\x05\x05\0\x024\x02\x12\x03:/3\
    \n\x0b\n\x04\x05\0\x025\x12\x03;\x08/\n\x0c\n\x05\x05\0\x025\x01\x12\x03\
    ;\x08'\n\x0c\n\x05\x05\0\x025\x02\x12\x03;*.\n\x0b\n\x04\x05\0\x026\x12\
    \x03<\x08$\n\x0c\n\x05\x05\0\x026\x01\x12\x03<\x08\x1c\n\x0c\n\x05\x05\0\
    \x026\x02\x12\x03<\x1f#\n\x0b\n\x04\x05\0\x027\x12\x03=\x08,\n\x0c\n\x05\
    \x05\0\x027\x01\x12\x03=\x08$\n\x0c\n\x05\x05\0\x027\x02\x12\x03='+\n\
    \x0b\n\x04\x05\0\x028\x12\x03>\x089\n\x0c\n\x05\x05\0\x028\x01\x12\x03>\
    \x081\n\x0c\n\x05\x05\0\x028\x02\x12\x03>48\n\x0b\n\x04\x05\0\x029\x12\
    \x03?\x08,\n\x0c\n\x05\x05\0\x029\x01\x12\x03?\x08$\n\x0c\n\x05\x05\0\
    \x029\x02\x12\x03?'+\n\x0b\n\x04\x05\0\x02:\x12\x03@\x081\n\x0c\n\x05\
    \x05\0\x02:\x01\x12\x03@\x08)\n\x0c\n\x05\x05\0\x02:\x02\x12\x03@,0\n\
    \x0b\n\x04\x05\0\x02;\x12\x03A\x08(\n\x0c\n\x05\x05\0\x02;\x01\x12\x03A\
    \x08\x20\n\x0c\n\x05\x05\0\x02;\x02\x12\x03A#'\n\x0b\n\x04\x05\0\x02<\
    \x12\x03B\x084\n\x0c\n\x05\x05\0\x02<\x01\x12\x03B\x08,\n\x0c\n\x05\x05\
    \0\x02<\x02\x12\x03B/3\n\x0b\n\x04\x05\0\x02=\x12\x03C\x083\n\x0c\n\x05\
    \x05\0\x02=\x01\x12\x03C\x08+\n\x0c\n\x05\x05\0\x02=\x02\x12\x03C.2\n\
    \x0b\n\x04\x05\0\x02>\x12\x03D\x08)\n\x0c\n\x05\x05\0\x02>\x01\x12\x03D\
    \x08!\n\x0c\n\x05\x05\0\x02>\x02\x12\x03D$(\n\x0b\n\x04\x05\0\x02?\x12\
    \x03E\x08*\n\x0c\n\x05\x05\0\x02?\x01\x12\x03E\x08\"\n\x0c\n\x05\x05\0\
    \x02?\x02\x12\x03E%)\n\x0b\n\x04\x05\0\x02@\x12\x03F\x08#\n\x0c\n\x05\
    \x05\0\x02@\x01\x12\x03F\x08\x1b\n\x0c\n\x05\x05\0\x02@\x02\x12\x03F\x1e\
    \"\n\x0b\n\x04\x05\0\x02A\x12\x03G\x08(\n\x0c\n\x05\x05\0\x02A\x01\x12\
    \x03G\x08\x20\n\x0c\n\x05\x05\0\x02A\x02\x12\x03G#'\n\x0b\n\x04\x05\0\
    \x02B\x12\x03H\x08)\n\x0c\n\x05\x05\0\x02B\x01\x12\x03H\x08!\n\x0c\n\x05\
    \x05\0\x02B\x02\x12\x03H$(\n\x0b\n\x04\x05\0\x02C\x12\x03I\x08/\n\x0c\n\
    \x05\x05\0\x02C\x01\x12\x03I\x08'\n\x0c\n\x05\x05\0\x02C\x02\x12\x03I*.\
    \n\x0b\n\x04\x05\0\x02D\x12\x03J\x08/\n\x0c\n\x05\x05\0\x02D\x01\x12\x03\
    J\x08'\n\x0c\n\x05\x05\0\x02D\x02\x12\x03J*.\n\x0b\n\x04\x05\0\x02E\x12\
    \x03K\x087\n\x0c\n\x05\x05\0\x02E\x01\x12\x03K\x08/\n\x0c\n\x05\x05\0\
    \x02E\x02\x12\x03K26\n\x0b\n\x04\x05\0\x02F\x12\x03L\x08#\n\x0c\n\x05\
    \x05\0\x02F\x01\x12\x03L\x08\x1b\n\x0c\n\x05\x05\0\x02F\x02\x12\x03L\x1e\
    \"\n\x0b\n\x04\x05\0\x02G\x12\x03M\x08+\n\x0c\n\x05\x05\0\x02G\x01\x12\
    \x03M\x08#\n\x0c\n\x05\x05\0\x02G\x02\x12\x03M&*\n\x0b\n\x04\x05\0\x02H\
    \x12\x03N\x083\n\x0c\n\x05\x05\0\x02H\x01\x12\x03N\x08+\n\x0c\n\x05\x05\
    \0\x02H\x02\x12\x03N.2\n\x0b\n\x04\x05\0\x02I\x12\x03O\x085\n\x0c\n\x05\
    \x05\0\x02I\x01\x12\x03O\x08-\n\x0c\n\x05\x05\0\x02I\x02\x12\x03O04\n\
    \x0b\n\x04\x05\0\x02J\x12\x03P\x08=\n\x0c\n\x05\x05\0\x02J\x01\x12\x03P\
    \x085\n\x0c\n\x05\x05\0\x02J\x02\x12\x03P8<\n\x0b\n\x04\x05\0\x02K\x12\
    \x03Q\x083\n\x0c\n\x05\x05\0\x02K\x01\x12\x03Q\x08+\n\x0c\n\x05\x05\0\
    \x02K\x02\x12\x03Q.2\n\x0b\n\x04\x05\0\x02L\x12\x03R\x081\n\x0c\n\x05\
    \x05\0\x02L\x01\x12\x03R\x08)\n\x0c\n\x05\x05\0\x02L\x02\x12\x03R,0\n\
    \x0b\n\x04\x05\0\x02M\x12\x03S\x08*\n\x0c\n\x05\x05\0\x02M\x01\x12\x03S\
    \x08\"\n\x0c\n\x05\x05\0\x02M\x02\x12\x03S%)\n\x0b\n\x04\x05\0\x02N\x12\
    \x03T\x082\n\x0c\n\x05\x05\0\x02N\x01\x12\x03T\x08*\n\x0c\n\x05\x05\0\
    \x02N\x02\x12\x03T-1\n\x0b\n\x04\x05\0\x02O\x12\x03U\x08+\n\x0c\n\x05\
    \x05\0\x02O\x01\x12\x03U\x08#\n\x0c\n\x05\x05\0\x02O\x02\x12\x03U&*\n\
    \x0b\n\x04\x05\0\x02P\x12\x03V\x080\n\x0c\n\x05\x05\0\x02P\x01\x12\x03V\
    \x08(\n\x0c\n\x05\x05\0\x02P\x02\x12\x03V+/\n\x0b\n\x04\x05\0\x02Q\x12\
    \x03W\x083\n\x0c\n\x05\x05\0\x02Q\x01\x12\x03W\x08+\n\x0c\n\x05\x05\0\
    \x02Q\x02\x12\x03W.2\n\x0b\n\x04\x05\0\x02R\x12\x03X\x08(\n\x0c\n\x05\
    \x05\0\x02R\x01\x12\x03X\x08\x20\n\x0c\n\x05\x05\0\x02R\x02\x12\x03X#'\n\
    \x0b\n\x04\x05\0\x02S\x12\x03Y\x080\n\x0c\n\x05\x05\0\x02S\x01\x12\x03Y\
    \x08(\n\x0c\n\x05\x05\0\x02S\x02\x12\x03Y+/\n\x0b\n\x04\x05\0\x02T\x12\
    \x03Z\x08/\n\x0c\n\x05\x05\0\x02T\x01\x12\x03Z\x08'\n\x0c\n\x05\x05\0\
    \x02T\x02\x12\x03Z*.\n\x0b\n\x04\x05\0\x02U\x12\x03[\x08=\n\x0c\n\x05\
    \x05\0\x02U\x01\x12\x03[\x085\n\x0c\n\x05\x05\0\x02U\x02\x12\x03[8<\n\
    \x0b\n\x04\x05\0\x02V\x12\x03\\\x080\n\x0c\n\x05\x05\0\x02V\x01\x12\x03\
    \\\x08(\n\x0c\n\x05\x05\0\x02V\x02\x12\x03\\+/\n\x0b\n\x04\x05\0\x02W\
    \x12\x03]\x08(\n\x0c\n\x05\x05\0\x02W\x01\x12\x03]\x08\x20\n\x0c\n\x05\
    \x05\0\x02W\x02\x12\x03]#'\n\x0b\n\x04\x05\0\x02X\x12\x03^\x082\n\x0c\n\
    \x05\x05\0\x02X\x01\x12\x03^\x08*\n\x0c\n\x05\x05\0\x02X\x02\x12\x03^-1\
    \n\x0b\n\x04\x05\0\x02Y\x12\x03_\x08:\n\x0c\n\x05\x05\0\x02Y\x01\x12\x03\
    _\x082\n\x0c\n\x05\x05\0\x02Y\x02\x12\x03_59\n\x0b\n\x04\x05\0\x02Z\x12\
    \x03`\x08#\n\x0c\n\x05\x05\0\x02Z\x01\x12\x03`\x08\x1b\n\x0c\n\x05\x05\0\
    \x02Z\x02\x12\x03`\x1e\"\n\x0b\n\x04\x05\0\x02[\x12\x03a\x084\n\x0c\n\
    \x05\x05\0\x02[\x01\x12\x03a\x08,\n\x0c\n\x05\x05\0\x02[\x02\x12\x03a/3\
    \n\x0b\n\x04\x05\0\x02\\\x12\x03b\x085\n\x0c\n\x05\x05\0\x02\\\x01\x12\
    \x03b\x08-\n\x0c\n\x05\x05\0\x02\\\x02\x12\x03b04\n\x0b\n\x04\x05\0\x02]\
    \x12\x03c\x08,\n\x0c\n\x05\x05\0\x02]\x01\x12\x03c\x08$\n\x0c\n\x05\x05\
    \0\x02]\x02\x12\x03c'+\n\x0b\n\x04\x05\0\x02^\x12\x03d\x08-\n\x0c\n\x05\
    \x05\0\x02^\x01\x12\x03d\x08%\n\x0c\n\x05\x05\0\x02^\x02\x12\x03d(,\n\
    \x0b\n\x04\x05\0\x02_\x12\x03e\x08-\n\x0c\n\x05\x05\0\x02_\x01\x12\x03e\
    \x08%\n\x0c\n\x05\x05\0\x02_\x02\x12\x03e(,\n\x0b\n\x04\x05\0\x02`\x12\
    \x03f\x08<\n\x0c\n\x05\x05\0\x02`\x01\x12\x03f\x084\n\x0c\n\x05\x05\0\
    \x02`\x02\x12\x03f7;\n\x0b\n\x04\x05\0\x02a\x12\x03g\x084\n\x0c\n\x05\
    \x05\0\x02a\x01\x12\x03g\x08,\n\x0c\n\x05\x05\0\x02a\x02\x12\x03g/3\n\
    \x0b\n\x04\x05\0\x02b\x12\x03h\x085\n\x0c\n\x05\x05\0\x02b\x01\x12\x03h\
    \x08-\n\x0c\n\x05\x05\0\x02b\x02\x12\x03h04\n\x0b\n\x04\x05\0\x02c\x12\
    \x03i\x08)\n\x0c\n\x05\x05\0\x02c\x01\x12\x03i\x08!\n\x0c\n\x05\x05\0\
    \x02c\x02\x12\x03i$(\n\x0b\n\x04\x05\0\x02d\x12\x03j\x08.\n\x0c\n\x05\
    \x05\0\x02d\x01\x12\x03j\x08&\n\x0c\n\x05\x05\0\x02d\x02\x12\x03j)-\n\
    \x0b\n\x04\x05\0\x02e\x12\x03k\x081\n\x0c\n\x05\x05\0\x02e\x01\x12\x03k\
    \x08)\n\x0c\n\x05\x05\0\x02e\x02\x12\x03k,0\n\x0b\n\x04\x05\0\x02f\x12\
    \x03l\x08*\n\x0c\n\x05\x05\0\x02f\x01\x12\x03l\x08\"\n\x0c\n\x05\x05\0\
    \x02f\x02\x12\x03l%)\n\x0b\n\x04\x05\0\x02g\x12\x03m\x082\n\x0c\n\x05\
    \x05\0\x02g\x01\x12\x03m\x08*\n\x0c\n\x05\x05\0\x02g\x02\x12\x03m-1\n\
    \x0b\n\x04\x05\0\x02h\x12\x03n\x08)\n\x0c\n\x05\x05\0\x02h\x01\x12\x03n\
    \x08!\n\x0c\n\x05\x05\0\x02h\x02\x12\x03n$(\n\x0b\n\x04\x05\0\x02i\x12\
    \x03o\x085\n\x0c\n\x05\x05\0\x02i\x01\x12\x03o\x08-\n\x0c\n\x05\x05\0\
    \x02i\x02\x12\x03o04\n\x0b\n\x04\x05\0\x02j\x12\x03p\x089\n\x0c\n\x05\
    \x05\0\x02j\x01\x12\x03p\x081\n\x0c\n\x05\x05\0\x02j\x02\x12\x03p48\n\
    \x0b\n\x04\x05\0\x02k\x12\x03q\x08*\n\x0c\n\x05\x05\0\x02k\x01\x12\x03q\
    \x08\"\n\x0c\n\x05\x05\0\x02k\x02\x12\x03q%)\n\x0b\n\x04\x05\0\x02l\x12\
    \x03r\x082\n\x0c\n\x05\x05\0\x02l\x01\x12\x03r\x08*\n\x0c\n\x05\x05\0\
    \x02l\x02\x12\x03r-1\n\x0b\n\x04\x05\0\x02m\x12\x03s\x080\n\x0c\n\x05\
    \x05\0\x02m\x01\x12\x03s\x08(\n\x0c\n\x05\x05\0\x02m\x02\x12\x03s+/\n\
    \x0b\n\x04\x05\0\x02n\x12\x03t\x08(\n\x0c\n\x05\x05\0\x02n\x01\x12\x03t\
    \x08\x20\n\x0c\n\x05\x05\0\x02n\x02\x12\x03t#'\n\x0b\n\x04\x05\0\x02o\
    \x12\x03u\x080\n\x0c\n\x05\x05\0\x02o\x01\x12\x03u\x08(\n\x0c\n\x05\x05\
    \0\x02o\x02\x12\x03u+/\n\x0b\n\x04\x05\0\x02p\x12\x03v\x084\n\x0c\n\x05\
    \x05\0\x02p\x01\x12\x03v\x08,\n\x0c\n\x05\x05\0\x02p\x02\x12\x03v/3\n\
    \x0b\n\x04\x05\0\x02q\x12\x03w\x08<\n\x0c\n\x05\x05\0\x02q\x01\x12\x03w\
    \x084\n\x0c\n\x05\x05\0\x02q\x02\x12\x03w7;\n\x0b\n\x04\x05\0\x02r\x12\
    \x03x\x08-\n\x0c\n\x05\x05\0\x02r\x01\x12\x03x\x08%\n\x0c\n\x05\x05\0\
    \x02r\x02\x12\x03x(,\n\x0b\n\x04\x05\0\x02s\x12\x03y\x085\n\x0c\n\x05\
    \x05\0\x02s\x01\x12\x03y\x08-\n\x0c\n\x05\x05\0\x02s\x02\x12\x03y04\n\
    \x0b\n\x04\x05\0\x02t\x12\x03z\x08+\n\x0c\n\x05\x05\0\x02t\x01\x12\x03z\
    \x08#\n\x0c\n\x05\x05\0\x02t\x02\x12\x03z&*\n\x0b\n\x04\x05\0\x02u\x12\
    \x03{\x083\n\x0c\n\x05\x05\0\x02u\x01\x12\x03{\x08+\n\x0c\n\x05\x05\0\
    \x02u\x02\x12\x03{.2\n\x0b\n\x04\x05\0\x02v\x12\x03|\x08-\n\x0c\n\x05\
    \x05\0\x02v\x01\x12\x03|\x08%\n\x0c\n\x05\x05\0\x02v\x02\x12\x03|(,\n\
    \x0b\n\x04\x05\0\x02w\x12\x03}\x085\n\x0c\n\x05\x05\0\x02w\x01\x12\x03}\
    \x08-\n\x0c\n\x05\x05\0\x02w\x02\x12\x03}04\n\x0b\n\x04\x05\0\x02x\x12\
    \x03~\x08)\n\x0c\n\x05\x05\0\x02x\x01\x12\x03~\x08!\n\x0c\n\x05\x05\0\
    \x02x\x02\x12\x03~$(\n\x0b\n\x04\x05\0\x02y\x12\x03\x7f\x081\n\x0c\n\x05\
    \x05\0\x02y\x01\x12\x03\x7f\x08)\n\x0c\n\x05\x05\0\x02y\x02\x12\x03\x7f,\
    0\n\x0c\n\x04\x05\0\x02z\x12\x04\x80\x01\x08)\n\r\n\x05\x05\0\x02z\x01\
    \x12\x04\x80\x01\x08!\n\r\n\x05\x05\0\x02z\x02\x12\x04\x80\x01$(\n\x0c\n\
    \x04\x05\0\x02{\x12\x04\x81\x01\x081\n\r\n\x05\x05\0\x02{\x01\x12\x04\
    \x81\x01\x08)\n\r\n\x05\x05\0\x02{\x02\x12\x04\x81\x01,0\n\x0c\n\x04\x05\
    \0\x02|\x12\x04\x82\x01\x08-\n\r\n\x05\x05\0\x02|\x01\x12\x04\x82\x01\
    \x08%\n\r\n\x05\x05\0\x02|\x02\x12\x04\x82\x01(,\n\x0c\n\x04\x05\0\x02}\
    \x12\x04\x83\x01\x083\n\r\n\x05\x05\0\x02}\x01\x12\x04\x83\x01\x08+\n\r\
    \n\x05\x05\0\x02}\x02\x12\x04\x83\x01.2\n\x0c\n\x04\x05\0\x02~\x12\x04\
    \x84\x01\x08,\n\r\n\x05\x05\0\x02~\x01\x12\x04\x84\x01\x08$\n\r\n\x05\
    \x05\0\x02~\x02\x12\x04\x84\x01'+\n\x0c\n\x04\x05\0\x02\x7f\x12\x04\x85\
    \x01\x08&\n\r\n\x05\x05\0\x02\x7f\x01\x12\x04\x85\x01\x08\x1e\n\r\n\x05\
    \x05\0\x02\x7f\x02\x12\x04\x85\x01!%\n\r\n\x05\x05\0\x02\x80\x01\x12\x04\
    \x86\x01\x080\n\x0e\n\x06\x05\0\x02\x80\x01\x01\x12\x04\x86\x01\x08(\n\
    \x0e\n\x06\x05\0\x02\x80\x01\x02\x12\x04\x86\x01+/\n\r\n\x05\x05\0\x02\
    \x81\x01\x12\x04\x87\x01\x08,\n\x0e\n\x06\x05\0\x02\x81\x01\x01\x12\x04\
    \x87\x01\x08$\n\x0e\n\x06\x05\0\x02\x81\x01\x02\x12\x04\x87\x01'+\n\r\n\
    \x05\x05\0\x02\x82\x01\x12\x04\x88\x01\x084\n\x0e\n\x06\x05\0\x02\x82\
    \x01\x01\x12\x04\x88\x01\x08,\n\x0e\n\x06\x05\0\x02\x82\x01\x02\x12\x04\
    \x88\x01/3\n\r\n\x05\x05\0\x02\x83\x01\x12\x04\x89\x01\x080\n\x0e\n\x06\
    \x05\0\x02\x83\x01\x01\x12\x04\x89\x01\x08(\n\x0e\n\x06\x05\0\x02\x83\
    \x01\x02\x12\x04\x89\x01+/\n\r\n\x05\x05\0\x02\x84\x01\x12\x04\x8a\x01\
    \x08,\n\x0e\n\x06\x05\0\x02\x84\x01\x01\x12\x04\x8a\x01\x08$\n\x0e\n\x06\
    \x05\0\x02\x84\x01\x02\x12\x04\x8a\x01'+\n\r\n\x05\x05\0\x02\x85\x01\x12\
    \x04\x8b\x01\x086\n\x0e\n\x06\x05\0\x02\x85\x01\x01\x12\x04\x8b\x01\x08.\
    \n\x0e\n\x06\x05\0\x02\x85\x01\x02\x12\x04\x8b\x0115\n\r\n\x05\x05\0\x02\
    \x86\x01\x12\x04\x8c\x01\x08>\n\x0e\n\x06\x05\0\x02\x86\x01\x01\x12\x04\
    \x8c\x01\x086\n\x0e\n\x06\x05\0\x02\x86\x01\x02\x12\x04\x8c\x019=\n\r\n\
    \x05\x05\0\x02\x87\x01\x12\x04\x8d\x01\x084\n\x0e\n\x06\x05\0\x02\x87\
    \x01\x01\x12\x04\x8d\x01\x08,\n\x0e\n\x06\x05\0\x02\x87\x01\x02\x12\x04\
    \x8d\x01/3\n\r\n\x05\x05\0\x02\x88\x01\x12\x04\x8e\x01\x08<\n\x0e\n\x06\
    \x05\0\x02\x88\x01\x01\x12\x04\x8e\x01\x084\n\x0e\n\x06\x05\0\x02\x88\
    \x01\x02\x12\x04\x8e\x017;\n\r\n\x05\x05\0\x02\x89\x01\x12\x04\x8f\x01\
    \x089\n\x0e\n\x06\x05\0\x02\x89\x01\x01\x12\x04\x8f\x01\x081\n\x0e\n\x06\
    \x05\0\x02\x89\x01\x02\x12\x04\x8f\x0148\n\r\n\x05\x05\0\x02\x8a\x01\x12\
    \x04\x90\x01\x08-\n\x0e\n\x06\x05\0\x02\x8a\x01\x01\x12\x04\x90\x01\x08%\
    \n\x0e\n\x06\x05\0\x02\x8a\x01\x02\x12\x04\x90\x01(,\n\r\n\x05\x05\0\x02\
    \x8b\x01\x12\x04\x91\x01\x085\n\x0e\n\x06\x05\0\x02\x8b\x01\x01\x12\x04\
    \x91\x01\x08-\n\x0e\n\x06\x05\0\x02\x8b\x01\x02\x12\x04\x91\x0104\n\r\n\
    \x05\x05\0\x02\x8c\x01\x12\x04\x92\x01\x08=\n\x0e\n\x06\x05\0\x02\x8c\
    \x01\x01\x12\x04\x92\x01\x085\n\x0e\n\x06\x05\0\x02\x8c\x01\x02\x12\x04\
    \x92\x018<\n\r\n\x05\x05\0\x02\x8d\x01\x12\x04\x93\x01\x08'\n\x0e\n\x06\
    \x05\0\x02\x8d\x01\x01\x12\x04\x93\x01\x08\x1f\n\x0e\n\x06\x05\0\x02\x8d\
    \x01\x02\x12\x04\x93\x01\"&\n\r\n\x05\x05\0\x02\x8e\x01\x12\x04\x94\x01\
    \x08(\n\x0e\n\x06\x05\0\x02\x8e\x01\x01\x12\x04\x94\x01\x08\x20\n\x0e\n\
    \x06\x05\0\x02\x8e\x01\x02\x12\x04\x94\x01#'\n\r\n\x05\x05\0\x02\x8f\x01\
    \x12\x04\x95\x01\x080\n\x0e\n\x06\x05\0\x02\x8f\x01\x01\x12\x04\x95\x01\
    \x08(\n\x0e\n\x06\x05\0\x02\x8f\x01\x02\x12\x04\x95\x01+/\n\r\n\x05\x05\
    \0\x02\x90\x01\x12\x04\x96\x01\x088\n\x0e\n\x06\x05\0\x02\x90\x01\x01\
    \x12\x04\x96\x01\x080\n\x0e\n\x06\x05\0\x02\x90\x01\x02\x12\x04\x96\x013\
    7\n\r\n\x05\x05\0\x02\x91\x01\x12\x04\x97\x01\x080\n\x0e\n\x06\x05\0\x02\
    \x91\x01\x01\x12\x04\x97\x01\x08(\n\x0e\n\x06\x05\0\x02\x91\x01\x02\x12\
    \x04\x97\x01+/\n\r\n\x05\x05\0\x02\x92\x01\x12\x04\x98\x01\x088\n\x0e\n\
    \x06\x05\0\x02\x92\x01\x01\x12\x04\x98\x01\x080\n\x0e\n\x06\x05\0\x02\
    \x92\x01\x02\x12\x04\x98\x0137\n\r\n\x05\x05\0\x02\x93\x01\x12\x04\x99\
    \x01\x086\n\x0e\n\x06\x05\0\x02\x93\x01\x01\x12\x04\x99\x01\x08.\n\x0e\n\
    \x06\x05\0\x02\x93\x01\x02\x12\x04\x99\x0115\n\r\n\x05\x05\0\x02\x94\x01\
    \x12\x04\x9a\x01\x08,\n\x0e\n\x06\x05\0\x02\x94\x01\x01\x12\x04\x9a\x01\
    \x08$\n\x0e\n\x06\x05\0\x02\x94\x01\x02\x12\x04\x9a\x01'+\n\r\n\x05\x05\
    \0\x02\x95\x01\x12\x04\x9b\x01\x08,\n\x0e\n\x06\x05\0\x02\x95\x01\x01\
    \x12\x04\x9b\x01\x08$\n\x0e\n\x06\x05\0\x02\x95\x01\x02\x12\x04\x9b\x01'\
    +\n\r\n\x05\x05\0\x02\x96\x01\x12\x04\x9c\x01\x08/\n\x0e\n\x06\x05\0\x02\
    \x96\x01\x01\x12\x04\x9c\x01\x08'\n\x0e\n\x06\x05\0\x02\x96\x01\x02\x12\
    \x04\x9c\x01*.\n\r\n\x05\x05\0\x02\x97\x01\x12\x04\x9d\x01\x08&\n\x0e\n\
    \x06\x05\0\x02\x97\x01\x01\x12\x04\x9d\x01\x08\x1e\n\x0e\n\x06\x05\0\x02\
    \x97\x01\x02\x12\x04\x9d\x01!%\n\r\n\x05\x05\0\x02\x98\x01\x12\x04\x9e\
    \x01\x08&\n\x0e\n\x06\x05\0\x02\x98\x01\x01\x12\x04\x9e\x01\x08\x1e\n\
    \x0e\n\x06\x05\0\x02\x98\x01\x02\x12\x04\x9e\x01!%\n\r\n\x05\x05\0\x02\
    \x99\x01\x12\x04\x9f\x01\x083\n\x0e\n\x06\x05\0\x02\x99\x01\x01\x12\x04\
    \x9f\x01\x08+\n\x0e\n\x06\x05\0\x02\x99\x01\x02\x12\x04\x9f\x01.2\n\r\n\
    \x05\x05\0\x02\x9a\x01\x12\x04\xa0\x01\x089\n\x0e\n\x06\x05\0\x02\x9a\
    \x01\x01\x12\x04\xa0\x01\x081\n\x0e\n\x06\x05\0\x02\x9a\x01\x02\x12\x04\
    \xa0\x0148\n\r\n\x05\x05\0\x02\x9b\x01\x12\x04\xa1\x01\x08<\n\x0e\n\x06\
    \x05\0\x02\x9b\x01\x01\x12\x04\xa1\x01\x084\n\x0e\n\x06\x05\0\x02\x9b\
    \x01\x02\x12\x04\xa1\x017;\n\r\n\x05\x05\0\x02\x9c\x01\x12\x04\xa2\x01\
    \x081\n\x0e\n\x06\x05\0\x02\x9c\x01\x01\x12\x04\xa2\x01\x08)\n\x0e\n\x06\
    \x05\0\x02\x9c\x01\x02\x12\x04\xa2\x01,0\n\r\n\x05\x05\0\x02\x9d\x01\x12\
    \x04\xa3\x01\x08.\n\x0e\n\x06\x05\0\x02\x9d\x01\x01\x12\x04\xa3\x01\x08&\
    \n\x0e\n\x06\x05\0\x02\x9d\x01\x02\x12\x04\xa3\x01)-\n\r\n\x05\x05\0\x02\
    \x9e\x01\x12\x04\xa4\x01\x08.\n\x0e\n\x06\x05\0\x02\x9e\x01\x01\x12\x04\
    \xa4\x01\x08&\n\x0e\n\x06\x05\0\x02\x9e\x01\x02\x12\x04\xa4\x01)-\n\r\n\
    \x05\x05\0\x02\x9f\x01\x12\x04\xa5\x01\x08,\n\x0e\n\x06\x05\0\x02\x9f\
    \x01\x01\x12\x04\xa5\x01\x08$\n\x0e\n\x06\x05\0\x02\x9f\x01\x02\x12\x04\
    \xa5\x01'+\n\r\n\x05\x05\0\x02\xa0\x01\x12\x04\xa6\x01\x08&\n\x0e\n\x06\
    \x05\0\x02\xa0\x01\x01\x12\x04\xa6\x01\x08\x1e\n\x0e\n\x06\x05\0\x02\xa0\
    \x01\x02\x12\x04\xa6\x01!%\n\r\n\x05\x05\0\x02\xa1\x01\x12\x04\xa7\x01\
    \x08.\n\x0e\n\x06\x05\0\x02\xa1\x01\x01\x12\x04\xa7\x01\x08&\n\x0e\n\x06\
    \x05\0\x02\xa1\x01\x02\x12\x04\xa7\x01)-\n\r\n\x05\x05\0\x02\xa2\x01\x12\
    \x04\xa8\x01\x08(\n\x0e\n\x06\x05\0\x02\xa2\x01\x01\x12\x04\xa8\x01\x08\
    \x20\n\x0e\n\x06\x05\0\x02\xa2\x01\x02\x12\x04\xa8\x01#'\n\r\n\x05\x05\0\
    \x02\xa3\x01\x12\x04\xa9\x01\x080\n\x0e\n\x06\x05\0\x02\xa3\x01\x01\x12\
    \x04\xa9\x01\x08(\n\x0e\n\x06\x05\0\x02\xa3\x01\x02\x12\x04\xa9\x01+/\n\
    \r\n\x05\x05\0\x02\xa4\x01\x12\x04\xaa\x01\x08,\n\x0e\n\x06\x05\0\x02\
    \xa4\x01\x01\x12\x04\xaa\x01\x08$\n\x0e\n\x06\x05\0\x02\xa4\x01\x02\x12\
    \x04\xaa\x01'+\n\x0c\n\x02\x05\x01\x12\x06\xad\x01\0\xb7\x01\x01\n\x0b\n\
    \x03\x05\x01\x01\x12\x04\xad\x01\x05\x13\n\x0c\n\x04\x05\x01\x02\0\x12\
    \x04\xae\x01\x08\x1f\n\r\n\x05\x05\x01\x02\0\x01\x12\x04\xae\x01\x08\x1a\
    \n\r\n\x05\x05\x01\x02\0\x02\x12\x04\xae\x01\x1d\x1e\n\x0c\n\x04\x05\x01\
    \x02\x01\x12\x04\xaf\x01\x08#\n\r\n\x05\x05\x01\x02\x01\x01\x12\x04\xaf\
    \x01\x08\x1e\n\r\n\x05\x05\x01\x02\x01\x02\x12\x04\xaf\x01!\"\n\x0c\n\
    \x04\x05\x01\x02\x02\x12\x04\xb0\x01\x08(\n\r\n\x05\x05\x01\x02\x02\x01\
    \x12\x04\xb0\x01\x08#\n\r\n\x05\x05\x01\x02\x02\x02\x12\x04\xb0\x01&'\n\
    \x0c\n\x04\x05\x01\x02\x03\x12\x04\xb1\x01\x08$\n\r\n\x05\x05\x01\x02\
    \x03\x01\x12\x04\xb1\x01\x08\x1f\n\r\n\x05\x05\x01\x02\x03\x02\x12\x04\
    \xb1\x01\"#\n\x0c\n\x04\x05\x01\x02\x04\x12\x04\xb2\x01\x08$\n\r\n\x05\
    \x05\x01\x02\x04\x01\x12\x04\xb2\x01\x08\x1f\n\r\n\x05\x05\x01\x02\x04\
    \x02\x12\x04\xb2\x01\"#\n\x0c\n\x04\x05\x01\x02\x05\x12\x04\xb3\x01\x08$\
    \n\r\n\x05\x05\x01\x02\x05\x01\x12\x04\xb3\x01\x08\x1f\n\r\n\x05\x05\x01\
    \x02\x05\x02\x12\x04\xb3\x01\"#\n\x0c\n\x04\x05\x01\x02\x06\x12\x04\xb4\
    \x01\x08)\n\r\n\x05\x05\x01\x02\x06\x01\x12\x04\xb4\x01\x08$\n\r\n\x05\
    \x05\x01\x02\x06\x02\x12\x04\xb4\x01'(\n\x0c\n\x04\x05\x01\x02\x07\x12\
    \x04\xb5\x01\x08(\n\r\n\x05\x05\x01\x02\x07\x01\x12\x04\xb5\x01\x08#\n\r\
    \n\x05\x05\x01\x02\x07\x02\x12\x04\xb5\x01&'\n\x0c\n\x04\x05\x01\x02\x08\
    \x12\x04\xb6\x01\x08#\n\r\n\x05\x05\x01\x02\x08\x01\x12\x04\xb6\x01\x08\
    \x1e\n\r\n\x05\x05\x01\x02\x08\x02\x12\x04\xb6\x01!\"\n\x0c\n\x02\x05\
    \x02\x12\x06\xb9\x01\0\xc1\x01\x01\n\x0b\n\x03\x05\x02\x01\x12\x04\xb9\
    \x01\x05\x11\n\x0c\n\x04\x05\x02\x02\0\x12\x04\xba\x01\x08$\n\r\n\x05\
    \x05\x02\x02\0\x01\x12\x04\xba\x01\x08\x1f\n\r\n\x05\x05\x02\x02\0\x02\
    \x12\x04\xba\x01\"#\n\x0c\n\x04\x05\x02\x02\x01\x12\x04\xbb\x01\x08(\n\r\
    \n\x05\x05\x02\x02\x01\x01\x12\x04\xbb\x01\x08#\n\r\n\x05\x05\x02\x02\
    \x01\x02\x12\x04\xbb\x01&'\n\x0c\n\x04\x05\x02\x02\x02\x12\x04\xbc\x01\
    \x08,\n\r\n\x05\x05\x02\x02\x02\x01\x12\x04\xbc\x01\x08'\n\r\n\x05\x05\
    \x02\x02\x02\x02\x12\x04\xbc\x01*+\n\x0c\n\x04\x05\x02\x02\x03\x12\x04\
    \xbd\x01\x08,\n\r\n\x05\x05\x02\x02\x03\x01\x12\x04\xbd\x01\x08'\n\r\n\
    \x05\x05\x02\x02\x03\x02\x12\x04\xbd\x01*+\n\x0c\n\x04\x05\x02\x02\x04\
    \x12\x04\xbe\x01\x08/\n\r\n\x05\x05\x02\x02\x04\x01\x12\x04\xbe\x01\x08*\
    \n\r\n\x05\x05\x02\x02\x04\x02\x12\x04\xbe\x01-.\n\x0c\n\x04\x05\x02\x02\
    \x05\x12\x04\xbf\x01\x082\n\r\n\x05\x05\x02\x02\x05\x01\x12\x04\xbf\x01\
    \x08-\n\r\n\x05\x05\x02\x02\x05\x02\x12\x04\xbf\x0101\n\x0c\n\x04\x05\
    \x02\x02\x06\x12\x04\xc0\x01\x08/\n\r\n\x05\x05\x02\x02\x06\x01\x12\x04\
    \xc0\x01\x08*\n\r\n\x05\x05\x02\x02\x06\x02\x12\x04\xc0\x01-.\n\x0c\n\
    \x02\x05\x03\x12\x06\xc3\x01\0\xca\x01\x01\n\x0b\n\x03\x05\x03\x01\x12\
    \x04\xc3\x01\x05$\n\x0c\n\x04\x05\x03\x02\0\x12\x04\xc4\x01\x087\n\r\n\
    \x05\x05\x03\x02\0\x01\x12\x04\xc4\x01\x082\n\r\n\x05\x05\x03\x02\0\x02\
    \x12\x04\xc4\x0156\n\x0c\n\x04\x05\x03\x02\x01\x12\x04\xc5\x01\x08?\n\r\
    \n\x05\x05\x03\x02\x01\x01\x12\x04\xc5\x01\x08:\n\r\n\x05\x05\x03\x02\
    \x01\x02\x12\x04\xc5\x01=>\n\x0c\n\x04\x05\x03\x02\x02\x12\x04\xc6\x01\
    \x08H\n\r\n\x05\x05\x03\x02\x02\x01\x12\x04\xc6\x01\x08C\n\r\n\x05\x05\
    \x03\x02\x02\x02\x12\x04\xc6\x01FG\n\x0c\n\x04\x05\x03\x02\x03\x12\x04\
    \xc7\x01\x08F\n\r\n\x05\x05\x03\x02\x03\x01\x12\x04\xc7\x01\x08A\n\r\n\
    \x05\x05\x03\x02\x03\x02\x12\x04\xc7\x01DE\n\x0c\n\x04\x05\x03\x02\x04\
    \x12\x04\xc8\x01\x08>\n\r\n\x05\x05\x03\x02\x04\x01\x12\x04\xc8\x01\x089\
    \n\r\n\x05\x05\x03\x02\x04\x02\x12\x04\xc8\x01<=\n\x0c\n\x04\x05\x03\x02\
    \x05\x12\x04\xc9\x01\x08:\n\r\n\x05\x05\x03\x02\x05\x01\x12\x04\xc9\x01\
    \x085\n\r\n\x05\x05\x03\x02\x05\x02\x12\x04\xc9\x0189\n\x0c\n\x02\x05\
    \x04\x12\x06\xcc\x01\0\xd3\x01\x01\n\x0b\n\x03\x05\x04\x01\x12\x04\xcc\
    \x01\x05\"\n\x0c\n\x04\x05\x04\x02\0\x12\x04\xcd\x01\x085\n\r\n\x05\x05\
    \x04\x02\0\x01\x12\x04\xcd\x01\x080\n\r\n\x05\x05\x04\x02\0\x02\x12\x04\
    \xcd\x0134\n\x0c\n\x04\x05\x04\x02\x01\x12\x04\xce\x01\x08E\n\r\n\x05\
    \x05\x04\x02\x01\x01\x12\x04\xce\x01\x08@\n\r\n\x05\x05\x04\x02\x01\x02\
    \x12\x04\xce\x01CD\n\x0c\n\x04\x05\x04\x02\x02\x12\x04\xcf\x01\x08C\n\r\
    \n\x05\x05\x04\x02\x02\x01\x12\x04\xcf\x01\x08>\n\r\n\x05\x05\x04\x02\
    \x02\x02\x12\x04\xcf\x01AB\n\x0c\n\x04\x05\x04\x02\x03\x12\x04\xd0\x01\
    \x08<\n\r\n\x05\x05\x04\x02\x03\x01\x12\x04\xd0\x01\x087\n\r\n\x05\x05\
    \x04\x02\x03\x02\x12\x04\xd0\x01:;\n\x0c\n\x04\x05\x04\x02\x04\x12\x04\
    \xd1\x01\x08;\n\r\n\x05\x05\x04\x02\x04\x01\x12\x04\xd1\x01\x086\n\r\n\
    \x05\x05\x04\x02\x04\x02\x12\x04\xd1\x019:\n\x0c\n\x04\x05\x04\x02\x05\
    \x12\x04\xd2\x01\x08>\n\r\n\x05\x05\x04\x02\x05\x01\x12\x04\xd2\x01\x089\
    \n\r\n\x05\x05\x04\x02\x05\x02\x12\x04\xd2\x01<=\n\x0c\n\x02\x04\0\x12\
    \x06\xd5\x01\0\xd8\x01\x01\n\x0b\n\x03\x04\0\x01\x12\x04\xd5\x01\x08\x1a\
    \n\x0c\n\x04\x04\0\x02\0\x12\x04\xd6\x01\x08.\n\r\n\x05\x04\0\x02\0\x04\
    \x12\x04\xd6\x01\x08\x10\n\r\n\x05\x04\0\x02\0\x05\x12\x04\xd6\x01\x11\
    \x17\n\r\n\x05\x04\0\x02\0\x01\x12\x04\xd6\x01\x18)\n\r\n\x05\x04\0\x02\
    \0\x03\x12\x04\xd6\x01,-\n\x0c\n\x04\x04\0\x02\x01\x12\x04\xd7\x01\x08)\
    \n\r\n\x05\x04\0\x02\x01\x04\x12\x04\xd7\x01\x08\x10\n\r\n\x05\x04\0\x02\
    \x01\x05\x12\x04\xd7\x01\x11\x17\n\r\n\x05\x04\0\x02\x01\x01\x12\x04\xd7\
    \x01\x18$\n\r\n\x05\x04\0\x02\x01\x03\x12\x04\xd7\x01'(\n\x0c\n\x02\x04\
    \x01\x12\x06\xda\x01\0\xe3\x01\x01\n\x0b\n\x03\x04\x01\x01\x12\x04\xda\
    \x01\x08,\n\x0e\n\x04\x04\x01\x03\0\x12\x06\xdb\x01\x08\xdf\x01\t\n\r\n\
    \x05\x04\x01\x03\0\x01\x12\x04\xdb\x01\x10'\n\x0e\n\x06\x04\x01\x03\0\
    \x02\0\x12\x04\xdc\x01\x10/\n\x0f\n\x07\x04\x01\x03\0\x02\0\x04\x12\x04\
    \xdc\x01\x10\x18\n\x0f\n\x07\x04\x01\x03\0\x02\0\x05\x12\x04\xdc\x01\x19\
    \x1f\n\x0f\n\x07\x04\x01\x03\0\x02\0\x01\x12\x04\xdc\x01\x20*\n\x0f\n\
    \x07\x04\x01\x03\0\x02\0\x03\x12\x04\xdc\x01-.\n\x0e\n\x06\x04\x01\x03\0\
    \x02\x01\x12\x04\xdd\x01\x10,\n\x0f\n\x07\x04\x01\x03\0\x02\x01\x04\x12\
    \x04\xdd\x01\x10\x18\n\x0f\n\x07\x04\x01\x03\0\x02\x01\x05\x12\x04\xdd\
    \x01\x19\x1f\n\x0f\n\x07\x04\x01\x03\0\x02\x01\x01\x12\x04\xdd\x01\x20'\
    \n\x0f\n\x07\x04\x01\x03\0\x02\x01\x03\x12\x04\xdd\x01*+\n\x0e\n\x06\x04\
    \x01\x03\0\x02\x02\x12\x04\xde\x01\x10/\n\x0f\n\x07\x04\x01\x03\0\x02\
    \x02\x04\x12\x04\xde\x01\x10\x18\n\x0f\n\x07\x04\x01\x03\0\x02\x02\x05\
    \x12\x04\xde\x01\x19\x1f\n\x0f\n\x07\x04\x01\x03\0\x02\x02\x01\x12\x04\
    \xde\x01\x20*\n\x0f\n\x07\x04\x01\x03\0\x02\x02\x03\x12\x04\xde\x01-.\n\
    \x0c\n\x04\x04\x01\x02\0\x12\x04\xe1\x01\x08'\n\r\n\x05\x04\x01\x02\0\
    \x04\x12\x04\xe1\x01\x08\x10\n\r\n\x05\x04\x01\x02\0\x05\x12\x04\xe1\x01\
    \x11\x17\n\r\n\x05\x04\x01\x02\0\x01\x12\x04\xe1\x01\x18\"\n\r\n\x05\x04\
    \x01\x02\0\x03\x12\x04\xe1\x01%&\n\x0c\n\x04\x04\x01\x02\x01\x12\x04\xe2\
    \x01\x08m\n\r\n\x05\x04\x01\x02\x01\x04\x12\x04\xe2\x01\x08\x10\n\r\n\
    \x05\x04\x01\x02\x01\x06\x12\x04\xe2\x01\x11N\n\r\n\x05\x04\x01\x02\x01\
    \x01\x12\x04\xe2\x01Oh\n\r\n\x05\x04\x01\x02\x01\x03\x12\x04\xe2\x01kl\n\
    \x0c\n\x02\x04\x02\x12\x06\xe5\x01\0\xe7\x01\x01\n\x0b\n\x03\x04\x02\x01\
    \x12\x04\xe5\x01\x081\n\x0c\n\x04\x04\x02\x02\0\x12\x04\xe6\x01\x08%\n\r\
    \n\x05\x04\x02\x02\0\x04\x12\x04\xe6\x01\x08\x10\n\r\n\x05\x04\x02\x02\0\
    \x05\x12\x04\xe6\x01\x11\x17\n\r\n\x05\x04\x02\x02\0\x01\x12\x04\xe6\x01\
    \x18\x20\n\r\n\x05\x04\x02\x02\0\x03\x12\x04\xe6\x01#$\n\x0c\n\x02\x04\
    \x03\x12\x06\xe9\x01\0\xeb\x01\x01\n\x0b\n\x03\x04\x03\x01\x12\x04\xe9\
    \x01\x089\n\x0c\n\x04\x04\x03\x02\0\x12\x04\xea\x01\x08#\n\r\n\x05\x04\
    \x03\x02\0\x04\x12\x04\xea\x01\x08\x10\n\r\n\x05\x04\x03\x02\0\x05\x12\
    \x04\xea\x01\x11\x17\n\r\n\x05\x04\x03\x02\0\x01\x12\x04\xea\x01\x18\x1e\
    \n\r\n\x05\x04\x03\x02\0\x03\x12\x04\xea\x01!\"\n\x0c\n\x02\x04\x04\x12\
    \x06\xed\x01\0\xef\x01\x01\n\x0b\n\x03\x04\x04\x01\x12\x04\xed\x01\x08/\
    \n\x0c\n\x04\x04\x04\x02\0\x12\x04\xee\x01\x08$\n\r\n\x05\x04\x04\x02\0\
    \x04\x12\x04\xee\x01\x08\x10\n\r\n\x05\x04\x04\x02\0\x05\x12\x04\xee\x01\
    \x11\x17\n\r\n\x05\x04\x04\x02\0\x01\x12\x04\xee\x01\x18\x1f\n\r\n\x05\
    \x04\x04\x02\0\x03\x12\x04\xee\x01\"#\n\x0c\n\x02\x04\x05\x12\x06\xf1\
    \x01\0\xf3\x01\x01\n\x0b\n\x03\x04\x05\x01\x12\x04\xf1\x01\x087\n\x0c\n\
    \x04\x04\x05\x02\0\x12\x04\xf2\x01\x08#\n\r\n\x05\x04\x05\x02\0\x04\x12\
    \x04\xf2\x01\x08\x10\n\r\n\x05\x04\x05\x02\0\x05\x12\x04\xf2\x01\x11\x17\
    \n\r\n\x05\x04\x05\x02\0\x01\x12\x04\xf2\x01\x18\x1e\n\r\n\x05\x04\x05\
    \x02\0\x03\x12\x04\xf2\x01!\"\n\x0c\n\x02\x04\x06\x12\x06\xf5\x01\0\xf7\
    \x01\x01\n\x0b\n\x03\x04\x06\x01\x12\x04\xf5\x01\x08\x1c\n\x0c\n\x04\x04\
    \x06\x02\0\x12\x04\xf6\x01\x08%\n\r\n\x05\x04\x06\x02\0\x04\x12\x04\xf6\
    \x01\x08\x10\n\r\n\x05\x04\x06\x02\0\x05\x12\x04\xf6\x01\x11\x17\n\r\n\
    \x05\x04\x06\x02\0\x01\x12\x04\xf6\x01\x18\x20\n\r\n\x05\x04\x06\x02\0\
    \x03\x12\x04\xf6\x01#$\n\x0c\n\x02\x04\x07\x12\x06\xf9\x01\0\xfc\x01\x01\
    \n\x0b\n\x03\x04\x07\x01\x12\x04\xf9\x01\x08#\n\x0c\n\x04\x04\x07\x02\0\
    \x12\x04\xfa\x01\x08$\n\r\n\x05\x04\x07\x02\0\x04\x12\x04\xfa\x01\x08\
    \x10\n\r\n\x05\x04\x07\x02\0\x05\x12\x04\xfa\x01\x11\x17\n\r\n\x05\x04\
    \x07\x02\0\x01\x12\x04\xfa\x01\x18\x1f\n\r\n\x05\x04\x07\x02\0\x03\x12\
    \x04\xfa\x01\"#\n\x0c\n\x04\x04\x07\x02\x01\x12\x04\xfb\x01\x08%\n\r\n\
    \x05\x04\x07\x02\x01\x04\x12\x04\xfb\x01\x08\x10\n\r\n\x05\x04\x07\x02\
    \x01\x05\x12\x04\xfb\x01\x11\x17\n\r\n\x05\x04\x07\x02\x01\x01\x12\x04\
    \xfb\x01\x18\x20\n\r\n\x05\x04\x07\x02\x01\x03\x12\x04\xfb\x01#$\n\x0c\n\
    \x02\x04\x08\x12\x06\xfe\x01\0\x87\x02\x01\n\x0b\n\x03\x04\x08\x01\x12\
    \x04\xfe\x01\x08+\n\x0e\n\x04\x04\x08\x03\0\x12\x06\xff\x01\x08\x82\x02\
    \t\n\r\n\x05\x04\x08\x03\0\x01\x12\x04\xff\x01\x10\x15\n\x0e\n\x06\x04\
    \x08\x03\0\x02\0\x12\x04\x80\x02\x10-\n\x0f\n\x07\x04\x08\x03\0\x02\0\
    \x04\x12\x04\x80\x02\x10\x18\n\x0f\n\x07\x04\x08\x03\0\x02\0\x05\x12\x04\
    \x80\x02\x19\x1f\n\x0f\n\x07\x04\x08\x03\0\x02\0\x01\x12\x04\x80\x02\x20\
    (\n\x0f\n\x07\x04\x08\x03\0\x02\0\x03\x12\x04\x80\x02+,\n\x0e\n\x06\x04\
    \x08\x03\0\x02\x01\x12\x04\x81\x02\x10*\n\x0f\n\x07\x04\x08\x03\0\x02\
    \x01\x04\x12\x04\x81\x02\x10\x18\n\x0f\n\x07\x04\x08\x03\0\x02\x01\x05\
    \x12\x04\x81\x02\x19\x1f\n\x0f\n\x07\x04\x08\x03\0\x02\x01\x01\x12\x04\
    \x81\x02\x20%\n\x0f\n\x07\x04\x08\x03\0\x02\x01\x03\x12\x04\x81\x02()\n\
    \x0c\n\x04\x04\x08\x02\0\x12\x04\x84\x02\x08K\n\r\n\x05\x04\x08\x02\0\
    \x04\x12\x04\x84\x02\x08\x10\n\r\n\x05\x04\x08\x02\0\x06\x12\x04\x84\x02\
    \x11;\n\r\n\x05\x04\x08\x02\0\x01\x12\x04\x84\x02<F\n\r\n\x05\x04\x08\
    \x02\0\x03\x12\x04\x84\x02IJ\n\x0c\n\x04\x04\x08\x02\x01\x12\x04\x85\x02\
    \x08$\n\r\n\x05\x04\x08\x02\x01\x04\x12\x04\x85\x02\x08\x10\n\r\n\x05\
    \x04\x08\x02\x01\x05\x12\x04\x85\x02\x11\x17\n\r\n\x05\x04\x08\x02\x01\
    \x01\x12\x04\x85\x02\x18\x1f\n\r\n\x05\x04\x08\x02\x01\x03\x12\x04\x85\
    \x02\"#\n\x0c\n\x04\x04\x08\x02\x02\x12\x04\x86\x02\x08,\n\r\n\x05\x04\
    \x08\x02\x02\x04\x12\x04\x86\x02\x08\x10\n\r\n\x05\x04\x08\x02\x02\x05\
    \x12\x04\x86\x02\x11\x17\n\r\n\x05\x04\x08\x02\x02\x01\x12\x04\x86\x02\
    \x18'\n\r\n\x05\x04\x08\x02\x02\x03\x12\x04\x86\x02*+\n\x0c\n\x02\x04\t\
    \x12\x06\x89\x02\0\x8c\x02\x01\n\x0b\n\x03\x04\t\x01\x12\x04\x89\x02\x08\
    3\n\x0c\n\x04\x04\t\x02\0\x12\x04\x8a\x02\x08$\n\r\n\x05\x04\t\x02\0\x04\
    \x12\x04\x8a\x02\x08\x10\n\r\n\x05\x04\t\x02\0\x05\x12\x04\x8a\x02\x11\
    \x17\n\r\n\x05\x04\t\x02\0\x01\x12\x04\x8a\x02\x18\x1f\n\r\n\x05\x04\t\
    \x02\0\x03\x12\x04\x8a\x02\"#\n\x0c\n\x04\x04\t\x02\x01\x12\x04\x8b\x02\
    \x08,\n\r\n\x05\x04\t\x02\x01\x04\x12\x04\x8b\x02\x08\x10\n\r\n\x05\x04\
    \t\x02\x01\x05\x12\x04\x8b\x02\x11\x17\n\r\n\x05\x04\t\x02\x01\x01\x12\
    \x04\x8b\x02\x18'\n\r\n\x05\x04\t\x02\x01\x03\x12\x04\x8b\x02*+\n\x0c\n\
    \x02\x04\n\x12\x06\x8e\x02\0\x8f\x02\x01\n\x0b\n\x03\x04\n\x01\x12\x04\
    \x8e\x02\x08\x1d\n\x0c\n\x02\x04\x0b\x12\x06\x91\x02\0\x92\x02\x01\n\x0b\
    \n\x03\x04\x0b\x01\x12\x04\x91\x02\x08\x1e\n\x0c\n\x02\x04\x0c\x12\x06\
    \x94\x02\0\x96\x02\x01\n\x0b\n\x03\x04\x0c\x01\x12\x04\x94\x02\x08&\n\
    \x0c\n\x04\x04\x0c\x02\0\x12\x04\x95\x02\x08'\n\r\n\x05\x04\x0c\x02\0\
    \x04\x12\x04\x95\x02\x08\x10\n\r\n\x05\x04\x0c\x02\0\x05\x12\x04\x95\x02\
    \x11\x17\n\r\n\x05\x04\x0c\x02\0\x01\x12\x04\x95\x02\x18\"\n\r\n\x05\x04\
    \x0c\x02\0\x03\x12\x04\x95\x02%&\n\x0c\n\x02\x04\r\x12\x06\x98\x02\0\x9a\
    \x02\x01\n\x0b\n\x03\x04\r\x01\x12\x04\x98\x02\x08.\n\x0c\n\x04\x04\r\
    \x02\0\x12\x04\x99\x02\x08-\n\r\n\x05\x04\r\x02\0\x04\x12\x04\x99\x02\
    \x08\x10\n\r\n\x05\x04\r\x02\0\x05\x12\x04\x99\x02\x11\x18\n\r\n\x05\x04\
    \r\x02\0\x01\x12\x04\x99\x02\x19(\n\r\n\x05\x04\r\x02\0\x03\x12\x04\x99\
    \x02+,\n\x0c\n\x02\x04\x0e\x12\x06\x9c\x02\0\x9f\x02\x01\n\x0b\n\x03\x04\
    \x0e\x01\x12\x04\x9c\x02\x08&\n\x0c\n\x04\x04\x0e\x02\0\x12\x04\x9d\x02\
    \x08'\n\r\n\x05\x04\x0e\x02\0\x04\x12\x04\x9d\x02\x08\x10\n\r\n\x05\x04\
    \x0e\x02\0\x05\x12\x04\x9d\x02\x11\x17\n\r\n\x05\x04\x0e\x02\0\x01\x12\
    \x04\x9d\x02\x18\"\n\r\n\x05\x04\x0e\x02\0\x03\x12\x04\x9d\x02%&\n\x0c\n\
    \x04\x04\x0e\x02\x01\x12\x04\x9e\x02\x08+\n\r\n\x05\x04\x0e\x02\x01\x04\
    \x12\x04\x9e\x02\x08\x10\n\r\n\x05\x04\x0e\x02\x01\x05\x12\x04\x9e\x02\
    \x11\x17\n\r\n\x05\x04\x0e\x02\x01\x01\x12\x04\x9e\x02\x18&\n\r\n\x05\
    \x04\x0e\x02\x01\x03\x12\x04\x9e\x02)*\n\x0c\n\x02\x04\x0f\x12\x06\xa1\
    \x02\0\xa3\x02\x01\n\x0b\n\x03\x04\x0f\x01\x12\x04\xa1\x02\x08.\n\x0c\n\
    \x04\x04\x0f\x02\0\x12\x04\xa2\x02\x08.\n\r\n\x05\x04\x0f\x02\0\x04\x12\
    \x04\xa2\x02\x08\x10\n\r\n\x05\x04\x0f\x02\0\x05\x12\x04\xa2\x02\x11\x17\
    \n\r\n\x05\x04\x0f\x02\0\x01\x12\x04\xa2\x02\x18)\n\r\n\x05\x04\x0f\x02\
    \0\x03\x12\x04\xa2\x02,-\n\x0c\n\x02\x04\x10\x12\x06\xa5\x02\0\xa7\x02\
    \x01\n\x0b\n\x03\x04\x10\x01\x12\x04\xa5\x02\x08&\n\x0c\n\x04\x04\x10\
    \x02\0\x12\x04\xa6\x02\x087\n\r\n\x05\x04\x10\x02\0\x04\x12\x04\xa6\x02\
    \x08\x10\n\r\n\x05\x04\x10\x02\0\x05\x12\x04\xa6\x02\x11\x17\n\r\n\x05\
    \x04\x10\x02\0\x01\x12\x04\xa6\x02\x18\"\n\r\n\x05\x04\x10\x02\0\x03\x12\
    \x04\xa6\x02%&\n\r\n\x05\x04\x10\x02\0\x08\x12\x04\xa6\x02'6\n\x0e\n\x06\
    \x04\x10\x02\0\x08\x02\x12\x04\xa6\x02(5\n\x0c\n\x02\x04\x11\x12\x06\xa9\
    \x02\0\xb0\x02\x01\n\x0b\n\x03\x04\x11\x01\x12\x04\xa9\x02\x08.\n\x0e\n\
    \x04\x04\x11\x03\0\x12\x06\xaa\x02\x08\xad\x02\t\n\r\n\x05\x04\x11\x03\0\
    \x01\x12\x04\xaa\x02\x10\x17\n\x0e\n\x06\x04\x11\x03\0\x02\0\x12\x04\xab\
    \x02\x10.\n\x0f\n\x07\x04\x11\x03\0\x02\0\x04\x12\x04\xab\x02\x10\x18\n\
    \x0f\n\x07\x04\x11\x03\0\x02\0\x05\x12\x04\xab\x02\x19\x1f\n\x0f\n\x07\
    \x04\x11\x03\0\x02\0\x01\x12\x04\xab\x02\x20)\n\x0f\n\x07\x04\x11\x03\0\
    \x02\0\x03\x12\x04\xab\x02,-\n\x0e\n\x06\x04\x11\x03\0\x02\x01\x12\x04\
    \xac\x02\x10,\n\x0f\n\x07\x04\x11\x03\0\x02\x01\x04\x12\x04\xac\x02\x10\
    \x18\n\x0f\n\x07\x04\x11\x03\0\x02\x01\x05\x12\x04\xac\x02\x19\x1f\n\x0f\
    \n\x07\x04\x11\x03\0\x02\x01\x01\x12\x04\xac\x02\x20'\n\x0f\n\x07\x04\
    \x11\x03\0\x02\x01\x03\x12\x04\xac\x02*+\n\x0c\n\x04\x04\x11\x02\0\x12\
    \x04\xaf\x02\x08N\n\r\n\x05\x04\x11\x02\0\x04\x12\x04\xaf\x02\x08\x10\n\
    \r\n\x05\x04\x11\x02\0\x06\x12\x04\xaf\x02\x11@\n\r\n\x05\x04\x11\x02\0\
    \x01\x12\x04\xaf\x02AI\n\r\n\x05\x04\x11\x02\0\x03\x12\x04\xaf\x02LM\n\
    \x0c\n\x02\x04\x12\x12\x06\xb2\x02\0\xb5\x02\x01\n\x0b\n\x03\x04\x12\x01\
    \x12\x04\xb2\x02\x08,\n\x0c\n\x04\x04\x12\x02\0\x12\x04\xb3\x02\x08+\n\r\
    \n\x05\x04\x12\x02\0\x04\x12\x04\xb3\x02\x08\x10\n\r\n\x05\x04\x12\x02\0\
    \x05\x12\x04\xb3\x02\x11\x17\n\r\n\x05\x04\x12\x02\0\x01\x12\x04\xb3\x02\
    \x18&\n\r\n\x05\x04\x12\x02\0\x03\x12\x04\xb3\x02)*\n\x0c\n\x04\x04\x12\
    \x02\x01\x12\x04\xb4\x02\x08&\n\r\n\x05\x04\x12\x02\x01\x04\x12\x04\xb4\
    \x02\x08\x10\n\r\n\x05\x04\x12\x02\x01\x05\x12\x04\xb4\x02\x11\x17\n\r\n\
    \x05\x04\x12\x02\x01\x01\x12\x04\xb4\x02\x18!\n\r\n\x05\x04\x12\x02\x01\
    \x03\x12\x04\xb4\x02$%\n\x0c\n\x02\x04\x13\x12\x06\xb7\x02\0\xba\x02\x01\
    \n\x0b\n\x03\x04\x13\x01\x12\x04\xb7\x02\x08\"\n\x0c\n\x04\x04\x13\x02\0\
    \x12\x04\xb8\x02\x08/\n\r\n\x05\x04\x13\x02\0\x04\x12\x04\xb8\x02\x08\
    \x10\n\r\n\x05\x04\x13\x02\0\x05\x12\x04\xb8\x02\x11\x17\n\r\n\x05\x04\
    \x13\x02\0\x01\x12\x04\xb8\x02\x18*\n\r\n\x05\x04\x13\x02\0\x03\x12\x04\
    \xb8\x02-.\n\x0c\n\x04\x04\x13\x02\x01\x12\x04\xb9\x02\x083\n\r\n\x05\
    \x04\x13\x02\x01\x04\x12\x04\xb9\x02\x08\x10\n\r\n\x05\x04\x13\x02\x01\
    \x05\x12\x04\xb9\x02\x11\x17\n\r\n\x05\x04\x13\x02\x01\x01\x12\x04\xb9\
    \x02\x18.\n\r\n\x05\x04\x13\x02\x01\x03\x12\x04\xb9\x0212\n\x0c\n\x02\
    \x04\x14\x12\x06\xbc\x02\0\xbf\x02\x01\n\x0b\n\x03\x04\x14\x01\x12\x04\
    \xbc\x02\x08\"\n\x0c\n\x04\x04\x14\x02\0\x12\x04\xbd\x02\x08*\n\r\n\x05\
    \x04\x14\x02\0\x04\x12\x04\xbd\x02\x08\x10\n\r\n\x05\x04\x14\x02\0\x05\
    \x12\x04\xbd\x02\x11\x17\n\r\n\x05\x04\x14\x02\0\x01\x12\x04\xbd\x02\x18\
    %\n\r\n\x05\x04\x14\x02\0\x03\x12\x04\xbd\x02()\n\x0c\n\x04\x04\x14\x02\
    \x01\x12\x04\xbe\x02\x08-\n\r\n\x05\x04\x14\x02\x01\x04\x12\x04\xbe\x02\
    \x08\x10\n\r\n\x05\x04\x14\x02\x01\x05\x12\x04\xbe\x02\x11\x17\n\r\n\x05\
    \x04\x14\x02\x01\x01\x12\x04\xbe\x02\x18(\n\r\n\x05\x04\x14\x02\x01\x03\
    \x12\x04\xbe\x02+,\n\x0c\n\x02\x04\x15\x12\x06\xc1\x02\0\xc6\x02\x01\n\
    \x0b\n\x03\x04\x15\x01\x12\x04\xc1\x02\x08%\n\x0c\n\x04\x04\x15\x02\0\
    \x12\x04\xc2\x02\x08%\n\r\n\x05\x04\x15\x02\0\x04\x12\x04\xc2\x02\x08\
    \x10\n\r\n\x05\x04\x15\x02\0\x05\x12\x04\xc2\x02\x11\x17\n\r\n\x05\x04\
    \x15\x02\0\x01\x12\x04\xc2\x02\x18\x20\n\r\n\x05\x04\x15\x02\0\x03\x12\
    \x04\xc2\x02#$\n\x0c\n\x04\x04\x15\x02\x01\x12\x04\xc3\x02\x08/\n\r\n\
    \x05\x04\x15\x02\x01\x04\x12\x04\xc3\x02\x08\x10\n\r\n\x05\x04\x15\x02\
    \x01\x05\x12\x04\xc3\x02\x11\x17\n\r\n\x05\x04\x15\x02\x01\x01\x12\x04\
    \xc3\x02\x18*\n\r\n\x05\x04\x15\x02\x01\x03\x12\x04\xc3\x02-.\n\x0c\n\
    \x04\x04\x15\x02\x02\x12\x04\xc4\x02\x08\"\n\r\n\x05\x04\x15\x02\x02\x04\
    \x12\x04\xc4\x02\x08\x10\n\r\n\x05\x04\x15\x02\x02\x05\x12\x04\xc4\x02\
    \x11\x17\n\r\n\x05\x04\x15\x02\x02\x01\x12\x04\xc4\x02\x18\x1d\n\r\n\x05\
    \x04\x15\x02\x02\x03\x12\x04\xc4\x02\x20!\n\x0c\n\x04\x04\x15\x02\x03\
    \x12\x04\xc5\x02\x08+\n\r\n\x05\x04\x15\x02\x03\x04\x12\x04\xc5\x02\x08\
    \x10\n\r\n\x05\x04\x15\x02\x03\x05\x12\x04\xc5\x02\x11\x18\n\r\n\x05\x04\
    \x15\x02\x03\x01\x12\x04\xc5\x02\x19&\n\r\n\x05\x04\x15\x02\x03\x03\x12\
    \x04\xc5\x02)*\n\x0c\n\x02\x04\x16\x12\x06\xc8\x02\0\xcf\x02\x01\n\x0b\n\
    \x03\x04\x16\x01\x12\x04\xc8\x02\x08)\n\x0c\n\x04\x04\x16\x02\0\x12\x04\
    \xc9\x02\x08%\n\r\n\x05\x04\x16\x02\0\x04\x12\x04\xc9\x02\x08\x10\n\r\n\
    \x05\x04\x16\x02\0\x05\x12\x04\xc9\x02\x11\x17\n\r\n\x05\x04\x16\x02\0\
    \x01\x12\x04\xc9\x02\x18\x20\n\r\n\x05\x04\x16\x02\0\x03\x12\x04\xc9\x02\
    #$\n\x0c\n\x04\x04\x16\x02\x01\x12\x04\xca\x02\x08+\n\r\n\x05\x04\x16\
    \x02\x01\x04\x12\x04\xca\x02\x08\x10\n\r\n\x05\x04\x16\x02\x01\x05\x12\
    \x04\xca\x02\x11\x18\n\r\n\x05\x04\x16\x02\x01\x01\x12\x04\xca\x02\x19&\
    \n\r\n\x05\x04\x16\x02\x01\x03\x12\x04\xca\x02)*\n\x0c\n\x04\x04\x16\x02\
    \x02\x12\x04\xcb\x02\x08?\n\r\n\x05\x04\x16\x02\x02\x04\x12\x04\xcb\x02\
    \x08\x10\n\r\n\x05\x04\x16\x02\x02\x05\x12\x04\xcb\x02\x11\x15\n\r\n\x05\
    \x04\x16\x02\x02\x01\x12\x04\xcb\x02\x16(\n\r\n\x05\x04\x16\x02\x02\x03\
    \x12\x04\xcb\x02+,\n\r\n\x05\x04\x16\x02\x02\x08\x12\x04\xcb\x02->\n\r\n\
    \x05\x04\x16\x02\x02\x07\x12\x04\xcb\x028=\n\x0c\n\x04\x04\x16\x02\x03\
    \x12\x04\xcc\x02\x08%\n\r\n\x05\x04\x16\x02\x03\x04\x12\x04\xcc\x02\x08\
    \x10\n\r\n\x05\x04\x16\x02\x03\x05\x12\x04\xcc\x02\x11\x17\n\r\n\x05\x04\
    \x16\x02\x03\x01\x12\x04\xcc\x02\x18\x20\n\r\n\x05\x04\x16\x02\x03\x03\
    \x12\x04\xcc\x02#$\n\x0c\n\x04\x04\x16\x02\x04\x12\x04\xcd\x02\x08%\n\r\
    \n\x05\x04\x16\x02\x04\x04\x12\x04\xcd\x02\x08\x10\n\r\n\x05\x04\x16\x02\
    \x04\x05\x12\x04\xcd\x02\x11\x17\n\r\n\x05\x04\x16\x02\x04\x01\x12\x04\
    \xcd\x02\x18\x20\n\r\n\x05\x04\x16\x02\x04\x03\x12\x04\xcd\x02#$\n\x0c\n\
    \x04\x04\x16\x02\x05\x12\x04\xce\x02\x08%\n\r\n\x05\x04\x16\x02\x05\x04\
    \x12\x04\xce\x02\x08\x10\n\r\n\x05\x04\x16\x02\x05\x05\x12\x04\xce\x02\
    \x11\x17\n\r\n\x05\x04\x16\x02\x05\x01\x12\x04\xce\x02\x18\x20\n\r\n\x05\
    \x04\x16\x02\x05\x03\x12\x04\xce\x02#$\n\x0c\n\x02\x04\x17\x12\x06\xd1\
    \x02\0\xd3\x02\x01\n\x0b\n\x03\x04\x17\x01\x12\x04\xd1\x02\x08#\n\x0c\n\
    \x04\x04\x17\x02\0\x12\x04\xd2\x02\x08%\n\r\n\x05\x04\x17\x02\0\x04\x12\
    \x04\xd2\x02\x08\x10\n\r\n\x05\x04\x17\x02\0\x05\x12\x04\xd2\x02\x11\x17\
    \n\r\n\x05\x04\x17\x02\0\x01\x12\x04\xd2\x02\x18\x20\n\r\n\x05\x04\x17\
    \x02\0\x03\x12\x04\xd2\x02#$\n\x0c\n\x02\x04\x18\x12\x06\xd5\x02\0\xd6\
    \x02\x01\n\x0b\n\x03\x04\x18\x01\x12\x04\xd5\x02\x08\x1c\n\x0c\n\x02\x04\
    \x19\x12\x06\xd8\x02\0\xda\x02\x01\n\x0b\n\x03\x04\x19\x01\x12\x04\xd8\
    \x02\x08/\n\x0c\n\x04\x04\x19\x02\0\x12\x04\xd9\x02\x08%\n\r\n\x05\x04\
    \x19\x02\0\x04\x12\x04\xd9\x02\x08\x10\n\r\n\x05\x04\x19\x02\0\x05\x12\
    \x04\xd9\x02\x11\x17\n\r\n\x05\x04\x19\x02\0\x01\x12\x04\xd9\x02\x18\x20\
    \n\r\n\x05\x04\x19\x02\0\x03\x12\x04\xd9\x02#$\n\x0c\n\x02\x04\x1a\x12\
    \x06\xdc\x02\0\xdd\x02\x01\n\x0b\n\x03\x04\x1a\x01\x12\x04\xdc\x02\x082\
    \n\x0c\n\x02\x04\x1b\x12\x06\xdf\x02\0\xe1\x02\x01\n\x0b\n\x03\x04\x1b\
    \x01\x12\x04\xdf\x02\x08\"\n\x0c\n\x04\x04\x1b\x02\0\x12\x04\xe0\x02\x08\
    $\n\r\n\x05\x04\x1b\x02\0\x04\x12\x04\xe0\x02\x08\x10\n\r\n\x05\x04\x1b\
    \x02\0\x05\x12\x04\xe0\x02\x11\x17\n\r\n\x05\x04\x1b\x02\0\x01\x12\x04\
    \xe0\x02\x18\x1f\n\r\n\x05\x04\x1b\x02\0\x03\x12\x04\xe0\x02\"#\n\x0c\n\
    \x02\x04\x1c\x12\x06\xe3\x02\0\xe6\x02\x01\n\x0b\n\x03\x04\x1c\x01\x12\
    \x04\xe3\x02\x08\"\n\x0c\n\x04\x04\x1c\x02\0\x12\x04\xe4\x02\x08$\n\r\n\
    \x05\x04\x1c\x02\0\x04\x12\x04\xe4\x02\x08\x10\n\r\n\x05\x04\x1c\x02\0\
    \x05\x12\x04\xe4\x02\x11\x17\n\r\n\x05\x04\x1c\x02\0\x01\x12\x04\xe4\x02\
    \x18\x1f\n\r\n\x05\x04\x1c\x02\0\x03\x12\x04\xe4\x02\"#\n\x0c\n\x04\x04\
    \x1c\x02\x01\x12\x04\xe5\x02\x08$\n\r\n\x05\x04\x1c\x02\x01\x04\x12\x04\
    \xe5\x02\x08\x10\n\r\n\x05\x04\x1c\x02\x01\x05\x12\x04\xe5\x02\x11\x17\n\
    \r\n\x05\x04\x1c\x02\x01\x01\x12\x04\xe5\x02\x18\x1f\n\r\n\x05\x04\x1c\
    \x02\x01\x03\x12\x04\xe5\x02\"#\n\x0c\n\x02\x04\x1d\x12\x06\xe8\x02\0\
    \xeb\x02\x01\n\x0b\n\x03\x04\x1d\x01\x12\x04\xe8\x02\x08\x20\n\x0c\n\x04\
    \x04\x1d\x02\0\x12\x04\xe9\x02\x08$\n\r\n\x05\x04\x1d\x02\0\x04\x12\x04\
    \xe9\x02\x08\x10\n\r\n\x05\x04\x1d\x02\0\x05\x12\x04\xe9\x02\x11\x17\n\r\
    \n\x05\x04\x1d\x02\0\x01\x12\x04\xe9\x02\x18\x1f\n\r\n\x05\x04\x1d\x02\0\
    \x03\x12\x04\xe9\x02\"#\n\x0c\n\x04\x04\x1d\x02\x01\x12\x04\xea\x02\x08$\
    \n\r\n\x05\x04\x1d\x02\x01\x04\x12\x04\xea\x02\x08\x10\n\r\n\x05\x04\x1d\
    \x02\x01\x05\x12\x04\xea\x02\x11\x17\n\r\n\x05\x04\x1d\x02\x01\x01\x12\
    \x04\xea\x02\x18\x1f\n\r\n\x05\x04\x1d\x02\x01\x03\x12\x04\xea\x02\"#\n\
    \x0c\n\x02\x04\x1e\x12\x06\xed\x02\0\xef\x02\x01\n\x0b\n\x03\x04\x1e\x01\
    \x12\x04\xed\x02\x08\"\n\x0c\n\x04\x04\x1e\x02\0\x12\x04\xee\x02\x08%\n\
    \r\n\x05\x04\x1e\x02\0\x04\x12\x04\xee\x02\x08\x10\n\r\n\x05\x04\x1e\x02\
    \0\x05\x12\x04\xee\x02\x11\x17\n\r\n\x05\x04\x1e\x02\0\x01\x12\x04\xee\
    \x02\x18\x20\n\r\n\x05\x04\x1e\x02\0\x03\x12\x04\xee\x02#$\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(1);
            deps.push(super::steammessages::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(34);
            messages.push(CMsgApplyAutograph::generated_message_descriptor_data());
            messages.push(CMsgEconPlayerStrangeCountAdjustment::generated_message_descriptor_data());
            messages.push(CMsgRequestItemPurgatory_FinalizePurchase::generated_message_descriptor_data());
            messages.push(CMsgRequestItemPurgatory_FinalizePurchaseResponse::generated_message_descriptor_data());
            messages.push(CMsgRequestItemPurgatory_RefundPurchase::generated_message_descriptor_data());
            messages.push(CMsgRequestItemPurgatory_RefundPurchaseResponse::generated_message_descriptor_data());
            messages.push(CMsgCraftingResponse::generated_message_descriptor_data());
            messages.push(CMsgGCRequestStoreSalesData::generated_message_descriptor_data());
            messages.push(CMsgGCRequestStoreSalesDataResponse::generated_message_descriptor_data());
            messages.push(CMsgGCRequestStoreSalesDataUpToDateResponse::generated_message_descriptor_data());
            messages.push(CMsgGCToGCPingRequest::generated_message_descriptor_data());
            messages.push(CMsgGCToGCPingResponse::generated_message_descriptor_data());
            messages.push(CMsgGCToGCGetUserSessionServer::generated_message_descriptor_data());
            messages.push(CMsgGCToGCGetUserSessionServerResponse::generated_message_descriptor_data());
            messages.push(CMsgGCToGCGetUserServerMembers::generated_message_descriptor_data());
            messages.push(CMsgGCToGCGetUserServerMembersResponse::generated_message_descriptor_data());
            messages.push(CMsgLookupMultipleAccountNames::generated_message_descriptor_data());
            messages.push(CMsgLookupMultipleAccountNamesResponse::generated_message_descriptor_data());
            messages.push(CMsgGCToGCGrantSelfMadeItemToAccount::generated_message_descriptor_data());
            messages.push(CMsgGCToGCThankedByNewUser::generated_message_descriptor_data());
            messages.push(CMsgGCShuffleCrateContents::generated_message_descriptor_data());
            messages.push(CMsgGCQuestObjective_Progress::generated_message_descriptor_data());
            messages.push(CMsgGCQuestObjective_PointsChange::generated_message_descriptor_data());
            messages.push(CMsgGCQuestComplete_Request::generated_message_descriptor_data());
            messages.push(CMsgGCQuestCompleted::generated_message_descriptor_data());
            messages.push(CMsgGCQuestObjective_RequestLoanerItems::generated_message_descriptor_data());
            messages.push(CMsgGCQuestObjective_RequestLoanerResponse::generated_message_descriptor_data());
            messages.push(CMsgCraftCollectionUpgrade::generated_message_descriptor_data());
            messages.push(CMsgCraftHalloweenOffering::generated_message_descriptor_data());
            messages.push(CMsgCraftCommonStatClock::generated_message_descriptor_data());
            messages.push(CMsgGCQuestDiscard_Request::generated_message_descriptor_data());
            messages.push(cmsg_econ_player_strange_count_adjustment::CStrangeCountAdjustment::generated_message_descriptor_data());
            messages.push(cmsg_gcrequest_store_sales_data_response::Price::generated_message_descriptor_data());
            messages.push(cmsg_lookup_multiple_account_names_response::Account::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(5);
            enums.push(EGCItemMsg::generated_enum_descriptor_data());
            enums.push(EGCMsgResponse::generated_enum_descriptor_data());
            enums.push(EUnlockStyle::generated_enum_descriptor_data());
            enums.push(EItemPurgatoryResponse_Finalize::generated_enum_descriptor_data());
            enums.push(EItemPurgatoryResponse_Refund::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
