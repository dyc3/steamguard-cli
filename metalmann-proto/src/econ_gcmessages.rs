// This file is generated by rust-protobuf 2.24.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `econ_gcmessages.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_24_1;

#[derive(PartialEq,Clone,Default)]
pub struct CMsgApplyAutograph {
    // message fields
    autograph_item_id: ::std::option::Option<u64>,
    item_item_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgApplyAutograph {
    fn default() -> &'a CMsgApplyAutograph {
        <CMsgApplyAutograph as ::protobuf::Message>::default_instance()
    }
}

impl CMsgApplyAutograph {
    pub fn new() -> CMsgApplyAutograph {
        ::std::default::Default::default()
    }

    // optional uint64 autograph_item_id = 1;


    pub fn get_autograph_item_id(&self) -> u64 {
        self.autograph_item_id.unwrap_or(0)
    }
    pub fn clear_autograph_item_id(&mut self) {
        self.autograph_item_id = ::std::option::Option::None;
    }

    pub fn has_autograph_item_id(&self) -> bool {
        self.autograph_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_autograph_item_id(&mut self, v: u64) {
        self.autograph_item_id = ::std::option::Option::Some(v);
    }

    // optional uint64 item_item_id = 2;


    pub fn get_item_item_id(&self) -> u64 {
        self.item_item_id.unwrap_or(0)
    }
    pub fn clear_item_item_id(&mut self) {
        self.item_item_id = ::std::option::Option::None;
    }

    pub fn has_item_item_id(&self) -> bool {
        self.item_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_item_id(&mut self, v: u64) {
        self.item_item_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgApplyAutograph {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.autograph_item_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.item_item_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.autograph_item_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.item_item_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.autograph_item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.item_item_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgApplyAutograph {
        CMsgApplyAutograph::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "autograph_item_id",
                |m: &CMsgApplyAutograph| { &m.autograph_item_id },
                |m: &mut CMsgApplyAutograph| { &mut m.autograph_item_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "item_item_id",
                |m: &CMsgApplyAutograph| { &m.item_item_id },
                |m: &mut CMsgApplyAutograph| { &mut m.item_item_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgApplyAutograph>(
                "CMsgApplyAutograph",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgApplyAutograph {
        static instance: ::protobuf::rt::LazyV2<CMsgApplyAutograph> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgApplyAutograph::new)
    }
}

impl ::protobuf::Clear for CMsgApplyAutograph {
    fn clear(&mut self) {
        self.autograph_item_id = ::std::option::Option::None;
        self.item_item_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgApplyAutograph {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgApplyAutograph {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgEconPlayerStrangeCountAdjustment {
    // message fields
    account_id: ::std::option::Option<u32>,
    pub strange_count_adjustments: ::protobuf::RepeatedField<CMsgEconPlayerStrangeCountAdjustment_CStrangeCountAdjustment>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgEconPlayerStrangeCountAdjustment {
    fn default() -> &'a CMsgEconPlayerStrangeCountAdjustment {
        <CMsgEconPlayerStrangeCountAdjustment as ::protobuf::Message>::default_instance()
    }
}

impl CMsgEconPlayerStrangeCountAdjustment {
    pub fn new() -> CMsgEconPlayerStrangeCountAdjustment {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;


    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }
    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // repeated .CMsgEconPlayerStrangeCountAdjustment.CStrangeCountAdjustment strange_count_adjustments = 2;


    pub fn get_strange_count_adjustments(&self) -> &[CMsgEconPlayerStrangeCountAdjustment_CStrangeCountAdjustment] {
        &self.strange_count_adjustments
    }
    pub fn clear_strange_count_adjustments(&mut self) {
        self.strange_count_adjustments.clear();
    }

    // Param is passed by value, moved
    pub fn set_strange_count_adjustments(&mut self, v: ::protobuf::RepeatedField<CMsgEconPlayerStrangeCountAdjustment_CStrangeCountAdjustment>) {
        self.strange_count_adjustments = v;
    }

    // Mutable pointer to the field.
    pub fn mut_strange_count_adjustments(&mut self) -> &mut ::protobuf::RepeatedField<CMsgEconPlayerStrangeCountAdjustment_CStrangeCountAdjustment> {
        &mut self.strange_count_adjustments
    }

    // Take field
    pub fn take_strange_count_adjustments(&mut self) -> ::protobuf::RepeatedField<CMsgEconPlayerStrangeCountAdjustment_CStrangeCountAdjustment> {
        ::std::mem::replace(&mut self.strange_count_adjustments, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgEconPlayerStrangeCountAdjustment {
    fn is_initialized(&self) -> bool {
        for v in &self.strange_count_adjustments {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.strange_count_adjustments)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.strange_count_adjustments {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.strange_count_adjustments {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgEconPlayerStrangeCountAdjustment {
        CMsgEconPlayerStrangeCountAdjustment::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "account_id",
                |m: &CMsgEconPlayerStrangeCountAdjustment| { &m.account_id },
                |m: &mut CMsgEconPlayerStrangeCountAdjustment| { &mut m.account_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgEconPlayerStrangeCountAdjustment_CStrangeCountAdjustment>>(
                "strange_count_adjustments",
                |m: &CMsgEconPlayerStrangeCountAdjustment| { &m.strange_count_adjustments },
                |m: &mut CMsgEconPlayerStrangeCountAdjustment| { &mut m.strange_count_adjustments },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgEconPlayerStrangeCountAdjustment>(
                "CMsgEconPlayerStrangeCountAdjustment",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgEconPlayerStrangeCountAdjustment {
        static instance: ::protobuf::rt::LazyV2<CMsgEconPlayerStrangeCountAdjustment> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgEconPlayerStrangeCountAdjustment::new)
    }
}

impl ::protobuf::Clear for CMsgEconPlayerStrangeCountAdjustment {
    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.strange_count_adjustments.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgEconPlayerStrangeCountAdjustment {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgEconPlayerStrangeCountAdjustment {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgEconPlayerStrangeCountAdjustment_CStrangeCountAdjustment {
    // message fields
    event_type: ::std::option::Option<u32>,
    item_id: ::std::option::Option<u64>,
    adjustment: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgEconPlayerStrangeCountAdjustment_CStrangeCountAdjustment {
    fn default() -> &'a CMsgEconPlayerStrangeCountAdjustment_CStrangeCountAdjustment {
        <CMsgEconPlayerStrangeCountAdjustment_CStrangeCountAdjustment as ::protobuf::Message>::default_instance()
    }
}

impl CMsgEconPlayerStrangeCountAdjustment_CStrangeCountAdjustment {
    pub fn new() -> CMsgEconPlayerStrangeCountAdjustment_CStrangeCountAdjustment {
        ::std::default::Default::default()
    }

    // optional uint32 event_type = 1;


    pub fn get_event_type(&self) -> u32 {
        self.event_type.unwrap_or(0)
    }
    pub fn clear_event_type(&mut self) {
        self.event_type = ::std::option::Option::None;
    }

    pub fn has_event_type(&self) -> bool {
        self.event_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_type(&mut self, v: u32) {
        self.event_type = ::std::option::Option::Some(v);
    }

    // optional uint64 item_id = 2;


    pub fn get_item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }
    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    // optional uint32 adjustment = 3;


    pub fn get_adjustment(&self) -> u32 {
        self.adjustment.unwrap_or(0)
    }
    pub fn clear_adjustment(&mut self) {
        self.adjustment = ::std::option::Option::None;
    }

    pub fn has_adjustment(&self) -> bool {
        self.adjustment.is_some()
    }

    // Param is passed by value, moved
    pub fn set_adjustment(&mut self, v: u32) {
        self.adjustment = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgEconPlayerStrangeCountAdjustment_CStrangeCountAdjustment {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.event_type = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.item_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.adjustment = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.event_type {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.adjustment {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.event_type {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.item_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.adjustment {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgEconPlayerStrangeCountAdjustment_CStrangeCountAdjustment {
        CMsgEconPlayerStrangeCountAdjustment_CStrangeCountAdjustment::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "event_type",
                |m: &CMsgEconPlayerStrangeCountAdjustment_CStrangeCountAdjustment| { &m.event_type },
                |m: &mut CMsgEconPlayerStrangeCountAdjustment_CStrangeCountAdjustment| { &mut m.event_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "item_id",
                |m: &CMsgEconPlayerStrangeCountAdjustment_CStrangeCountAdjustment| { &m.item_id },
                |m: &mut CMsgEconPlayerStrangeCountAdjustment_CStrangeCountAdjustment| { &mut m.item_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "adjustment",
                |m: &CMsgEconPlayerStrangeCountAdjustment_CStrangeCountAdjustment| { &m.adjustment },
                |m: &mut CMsgEconPlayerStrangeCountAdjustment_CStrangeCountAdjustment| { &mut m.adjustment },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgEconPlayerStrangeCountAdjustment_CStrangeCountAdjustment>(
                "CMsgEconPlayerStrangeCountAdjustment.CStrangeCountAdjustment",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgEconPlayerStrangeCountAdjustment_CStrangeCountAdjustment {
        static instance: ::protobuf::rt::LazyV2<CMsgEconPlayerStrangeCountAdjustment_CStrangeCountAdjustment> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgEconPlayerStrangeCountAdjustment_CStrangeCountAdjustment::new)
    }
}

impl ::protobuf::Clear for CMsgEconPlayerStrangeCountAdjustment_CStrangeCountAdjustment {
    fn clear(&mut self) {
        self.event_type = ::std::option::Option::None;
        self.item_id = ::std::option::Option::None;
        self.adjustment = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgEconPlayerStrangeCountAdjustment_CStrangeCountAdjustment {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgEconPlayerStrangeCountAdjustment_CStrangeCountAdjustment {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgRequestItemPurgatory_FinalizePurchase {
    // message fields
    pub item_ids: ::std::vec::Vec<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgRequestItemPurgatory_FinalizePurchase {
    fn default() -> &'a CMsgRequestItemPurgatory_FinalizePurchase {
        <CMsgRequestItemPurgatory_FinalizePurchase as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRequestItemPurgatory_FinalizePurchase {
    pub fn new() -> CMsgRequestItemPurgatory_FinalizePurchase {
        ::std::default::Default::default()
    }

    // repeated uint64 item_ids = 1;


    pub fn get_item_ids(&self) -> &[u64] {
        &self.item_ids
    }
    pub fn clear_item_ids(&mut self) {
        self.item_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_item_ids(&mut self, v: ::std::vec::Vec<u64>) {
        self.item_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_item_ids(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.item_ids
    }

    // Take field
    pub fn take_item_ids(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.item_ids, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgRequestItemPurgatory_FinalizePurchase {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.item_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.item_ids {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.item_ids {
            os.write_uint64(1, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgRequestItemPurgatory_FinalizePurchase {
        CMsgRequestItemPurgatory_FinalizePurchase::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "item_ids",
                |m: &CMsgRequestItemPurgatory_FinalizePurchase| { &m.item_ids },
                |m: &mut CMsgRequestItemPurgatory_FinalizePurchase| { &mut m.item_ids },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgRequestItemPurgatory_FinalizePurchase>(
                "CMsgRequestItemPurgatory_FinalizePurchase",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgRequestItemPurgatory_FinalizePurchase {
        static instance: ::protobuf::rt::LazyV2<CMsgRequestItemPurgatory_FinalizePurchase> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgRequestItemPurgatory_FinalizePurchase::new)
    }
}

impl ::protobuf::Clear for CMsgRequestItemPurgatory_FinalizePurchase {
    fn clear(&mut self) {
        self.item_ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgRequestItemPurgatory_FinalizePurchase {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgRequestItemPurgatory_FinalizePurchase {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgRequestItemPurgatory_FinalizePurchaseResponse {
    // message fields
    result: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgRequestItemPurgatory_FinalizePurchaseResponse {
    fn default() -> &'a CMsgRequestItemPurgatory_FinalizePurchaseResponse {
        <CMsgRequestItemPurgatory_FinalizePurchaseResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRequestItemPurgatory_FinalizePurchaseResponse {
    pub fn new() -> CMsgRequestItemPurgatory_FinalizePurchaseResponse {
        ::std::default::Default::default()
    }

    // optional uint32 result = 1;


    pub fn get_result(&self) -> u32 {
        self.result.unwrap_or(0)
    }
    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: u32) {
        self.result = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgRequestItemPurgatory_FinalizePurchaseResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgRequestItemPurgatory_FinalizePurchaseResponse {
        CMsgRequestItemPurgatory_FinalizePurchaseResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "result",
                |m: &CMsgRequestItemPurgatory_FinalizePurchaseResponse| { &m.result },
                |m: &mut CMsgRequestItemPurgatory_FinalizePurchaseResponse| { &mut m.result },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgRequestItemPurgatory_FinalizePurchaseResponse>(
                "CMsgRequestItemPurgatory_FinalizePurchaseResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgRequestItemPurgatory_FinalizePurchaseResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgRequestItemPurgatory_FinalizePurchaseResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgRequestItemPurgatory_FinalizePurchaseResponse::new)
    }
}

impl ::protobuf::Clear for CMsgRequestItemPurgatory_FinalizePurchaseResponse {
    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgRequestItemPurgatory_FinalizePurchaseResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgRequestItemPurgatory_FinalizePurchaseResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgRequestItemPurgatory_RefundPurchase {
    // message fields
    item_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgRequestItemPurgatory_RefundPurchase {
    fn default() -> &'a CMsgRequestItemPurgatory_RefundPurchase {
        <CMsgRequestItemPurgatory_RefundPurchase as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRequestItemPurgatory_RefundPurchase {
    pub fn new() -> CMsgRequestItemPurgatory_RefundPurchase {
        ::std::default::Default::default()
    }

    // optional uint64 item_id = 1;


    pub fn get_item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }
    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgRequestItemPurgatory_RefundPurchase {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.item_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.item_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgRequestItemPurgatory_RefundPurchase {
        CMsgRequestItemPurgatory_RefundPurchase::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "item_id",
                |m: &CMsgRequestItemPurgatory_RefundPurchase| { &m.item_id },
                |m: &mut CMsgRequestItemPurgatory_RefundPurchase| { &mut m.item_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgRequestItemPurgatory_RefundPurchase>(
                "CMsgRequestItemPurgatory_RefundPurchase",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgRequestItemPurgatory_RefundPurchase {
        static instance: ::protobuf::rt::LazyV2<CMsgRequestItemPurgatory_RefundPurchase> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgRequestItemPurgatory_RefundPurchase::new)
    }
}

impl ::protobuf::Clear for CMsgRequestItemPurgatory_RefundPurchase {
    fn clear(&mut self) {
        self.item_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgRequestItemPurgatory_RefundPurchase {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgRequestItemPurgatory_RefundPurchase {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgRequestItemPurgatory_RefundPurchaseResponse {
    // message fields
    result: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgRequestItemPurgatory_RefundPurchaseResponse {
    fn default() -> &'a CMsgRequestItemPurgatory_RefundPurchaseResponse {
        <CMsgRequestItemPurgatory_RefundPurchaseResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRequestItemPurgatory_RefundPurchaseResponse {
    pub fn new() -> CMsgRequestItemPurgatory_RefundPurchaseResponse {
        ::std::default::Default::default()
    }

    // optional uint32 result = 1;


    pub fn get_result(&self) -> u32 {
        self.result.unwrap_or(0)
    }
    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: u32) {
        self.result = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgRequestItemPurgatory_RefundPurchaseResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgRequestItemPurgatory_RefundPurchaseResponse {
        CMsgRequestItemPurgatory_RefundPurchaseResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "result",
                |m: &CMsgRequestItemPurgatory_RefundPurchaseResponse| { &m.result },
                |m: &mut CMsgRequestItemPurgatory_RefundPurchaseResponse| { &mut m.result },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgRequestItemPurgatory_RefundPurchaseResponse>(
                "CMsgRequestItemPurgatory_RefundPurchaseResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgRequestItemPurgatory_RefundPurchaseResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgRequestItemPurgatory_RefundPurchaseResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgRequestItemPurgatory_RefundPurchaseResponse::new)
    }
}

impl ::protobuf::Clear for CMsgRequestItemPurgatory_RefundPurchaseResponse {
    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgRequestItemPurgatory_RefundPurchaseResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgRequestItemPurgatory_RefundPurchaseResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgCraftingResponse {
    // message fields
    pub item_ids: ::std::vec::Vec<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgCraftingResponse {
    fn default() -> &'a CMsgCraftingResponse {
        <CMsgCraftingResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgCraftingResponse {
    pub fn new() -> CMsgCraftingResponse {
        ::std::default::Default::default()
    }

    // repeated uint64 item_ids = 1;


    pub fn get_item_ids(&self) -> &[u64] {
        &self.item_ids
    }
    pub fn clear_item_ids(&mut self) {
        self.item_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_item_ids(&mut self, v: ::std::vec::Vec<u64>) {
        self.item_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_item_ids(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.item_ids
    }

    // Take field
    pub fn take_item_ids(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.item_ids, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgCraftingResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.item_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.item_ids {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.item_ids {
            os.write_uint64(1, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgCraftingResponse {
        CMsgCraftingResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "item_ids",
                |m: &CMsgCraftingResponse| { &m.item_ids },
                |m: &mut CMsgCraftingResponse| { &mut m.item_ids },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgCraftingResponse>(
                "CMsgCraftingResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgCraftingResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgCraftingResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgCraftingResponse::new)
    }
}

impl ::protobuf::Clear for CMsgCraftingResponse {
    fn clear(&mut self) {
        self.item_ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgCraftingResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgCraftingResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCRequestStoreSalesData {
    // message fields
    version: ::std::option::Option<u32>,
    currency: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCRequestStoreSalesData {
    fn default() -> &'a CMsgGCRequestStoreSalesData {
        <CMsgGCRequestStoreSalesData as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCRequestStoreSalesData {
    pub fn new() -> CMsgGCRequestStoreSalesData {
        ::std::default::Default::default()
    }

    // optional uint32 version = 1;


    pub fn get_version(&self) -> u32 {
        self.version.unwrap_or(0)
    }
    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u32) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional uint32 currency = 2;


    pub fn get_currency(&self) -> u32 {
        self.currency.unwrap_or(0)
    }
    pub fn clear_currency(&mut self) {
        self.currency = ::std::option::Option::None;
    }

    pub fn has_currency(&self) -> bool {
        self.currency.is_some()
    }

    // Param is passed by value, moved
    pub fn set_currency(&mut self, v: u32) {
        self.currency = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCRequestStoreSalesData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.version = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.currency = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.currency {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.version {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.currency {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCRequestStoreSalesData {
        CMsgGCRequestStoreSalesData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "version",
                |m: &CMsgGCRequestStoreSalesData| { &m.version },
                |m: &mut CMsgGCRequestStoreSalesData| { &mut m.version },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "currency",
                |m: &CMsgGCRequestStoreSalesData| { &m.currency },
                |m: &mut CMsgGCRequestStoreSalesData| { &mut m.currency },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCRequestStoreSalesData>(
                "CMsgGCRequestStoreSalesData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCRequestStoreSalesData {
        static instance: ::protobuf::rt::LazyV2<CMsgGCRequestStoreSalesData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCRequestStoreSalesData::new)
    }
}

impl ::protobuf::Clear for CMsgGCRequestStoreSalesData {
    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.currency = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCRequestStoreSalesData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCRequestStoreSalesData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCRequestStoreSalesDataResponse {
    // message fields
    pub sale_price: ::protobuf::RepeatedField<CMsgGCRequestStoreSalesDataResponse_Price>,
    version: ::std::option::Option<u32>,
    expiration_time: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCRequestStoreSalesDataResponse {
    fn default() -> &'a CMsgGCRequestStoreSalesDataResponse {
        <CMsgGCRequestStoreSalesDataResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCRequestStoreSalesDataResponse {
    pub fn new() -> CMsgGCRequestStoreSalesDataResponse {
        ::std::default::Default::default()
    }

    // repeated .CMsgGCRequestStoreSalesDataResponse.Price sale_price = 1;


    pub fn get_sale_price(&self) -> &[CMsgGCRequestStoreSalesDataResponse_Price] {
        &self.sale_price
    }
    pub fn clear_sale_price(&mut self) {
        self.sale_price.clear();
    }

    // Param is passed by value, moved
    pub fn set_sale_price(&mut self, v: ::protobuf::RepeatedField<CMsgGCRequestStoreSalesDataResponse_Price>) {
        self.sale_price = v;
    }

    // Mutable pointer to the field.
    pub fn mut_sale_price(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGCRequestStoreSalesDataResponse_Price> {
        &mut self.sale_price
    }

    // Take field
    pub fn take_sale_price(&mut self) -> ::protobuf::RepeatedField<CMsgGCRequestStoreSalesDataResponse_Price> {
        ::std::mem::replace(&mut self.sale_price, ::protobuf::RepeatedField::new())
    }

    // optional uint32 version = 2;


    pub fn get_version(&self) -> u32 {
        self.version.unwrap_or(0)
    }
    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u32) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional uint32 expiration_time = 3;


    pub fn get_expiration_time(&self) -> u32 {
        self.expiration_time.unwrap_or(0)
    }
    pub fn clear_expiration_time(&mut self) {
        self.expiration_time = ::std::option::Option::None;
    }

    pub fn has_expiration_time(&self) -> bool {
        self.expiration_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expiration_time(&mut self, v: u32) {
        self.expiration_time = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCRequestStoreSalesDataResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.sale_price {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.sale_price)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.version = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.expiration_time = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.sale_price {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.expiration_time {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.sale_price {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.version {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.expiration_time {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCRequestStoreSalesDataResponse {
        CMsgGCRequestStoreSalesDataResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCRequestStoreSalesDataResponse_Price>>(
                "sale_price",
                |m: &CMsgGCRequestStoreSalesDataResponse| { &m.sale_price },
                |m: &mut CMsgGCRequestStoreSalesDataResponse| { &mut m.sale_price },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "version",
                |m: &CMsgGCRequestStoreSalesDataResponse| { &m.version },
                |m: &mut CMsgGCRequestStoreSalesDataResponse| { &mut m.version },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "expiration_time",
                |m: &CMsgGCRequestStoreSalesDataResponse| { &m.expiration_time },
                |m: &mut CMsgGCRequestStoreSalesDataResponse| { &mut m.expiration_time },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCRequestStoreSalesDataResponse>(
                "CMsgGCRequestStoreSalesDataResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCRequestStoreSalesDataResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgGCRequestStoreSalesDataResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCRequestStoreSalesDataResponse::new)
    }
}

impl ::protobuf::Clear for CMsgGCRequestStoreSalesDataResponse {
    fn clear(&mut self) {
        self.sale_price.clear();
        self.version = ::std::option::Option::None;
        self.expiration_time = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCRequestStoreSalesDataResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCRequestStoreSalesDataResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCRequestStoreSalesDataResponse_Price {
    // message fields
    item_def: ::std::option::Option<u32>,
    price: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCRequestStoreSalesDataResponse_Price {
    fn default() -> &'a CMsgGCRequestStoreSalesDataResponse_Price {
        <CMsgGCRequestStoreSalesDataResponse_Price as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCRequestStoreSalesDataResponse_Price {
    pub fn new() -> CMsgGCRequestStoreSalesDataResponse_Price {
        ::std::default::Default::default()
    }

    // optional uint32 item_def = 1;


    pub fn get_item_def(&self) -> u32 {
        self.item_def.unwrap_or(0)
    }
    pub fn clear_item_def(&mut self) {
        self.item_def = ::std::option::Option::None;
    }

    pub fn has_item_def(&self) -> bool {
        self.item_def.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_def(&mut self, v: u32) {
        self.item_def = ::std::option::Option::Some(v);
    }

    // optional uint32 price = 2;


    pub fn get_price(&self) -> u32 {
        self.price.unwrap_or(0)
    }
    pub fn clear_price(&mut self) {
        self.price = ::std::option::Option::None;
    }

    pub fn has_price(&self) -> bool {
        self.price.is_some()
    }

    // Param is passed by value, moved
    pub fn set_price(&mut self, v: u32) {
        self.price = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCRequestStoreSalesDataResponse_Price {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.item_def = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.price = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.item_def {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.price {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.item_def {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.price {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCRequestStoreSalesDataResponse_Price {
        CMsgGCRequestStoreSalesDataResponse_Price::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "item_def",
                |m: &CMsgGCRequestStoreSalesDataResponse_Price| { &m.item_def },
                |m: &mut CMsgGCRequestStoreSalesDataResponse_Price| { &mut m.item_def },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "price",
                |m: &CMsgGCRequestStoreSalesDataResponse_Price| { &m.price },
                |m: &mut CMsgGCRequestStoreSalesDataResponse_Price| { &mut m.price },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCRequestStoreSalesDataResponse_Price>(
                "CMsgGCRequestStoreSalesDataResponse.Price",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCRequestStoreSalesDataResponse_Price {
        static instance: ::protobuf::rt::LazyV2<CMsgGCRequestStoreSalesDataResponse_Price> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCRequestStoreSalesDataResponse_Price::new)
    }
}

impl ::protobuf::Clear for CMsgGCRequestStoreSalesDataResponse_Price {
    fn clear(&mut self) {
        self.item_def = ::std::option::Option::None;
        self.price = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCRequestStoreSalesDataResponse_Price {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCRequestStoreSalesDataResponse_Price {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCRequestStoreSalesDataUpToDateResponse {
    // message fields
    version: ::std::option::Option<u32>,
    expiration_time: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCRequestStoreSalesDataUpToDateResponse {
    fn default() -> &'a CMsgGCRequestStoreSalesDataUpToDateResponse {
        <CMsgGCRequestStoreSalesDataUpToDateResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCRequestStoreSalesDataUpToDateResponse {
    pub fn new() -> CMsgGCRequestStoreSalesDataUpToDateResponse {
        ::std::default::Default::default()
    }

    // optional uint32 version = 1;


    pub fn get_version(&self) -> u32 {
        self.version.unwrap_or(0)
    }
    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u32) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional uint32 expiration_time = 2;


    pub fn get_expiration_time(&self) -> u32 {
        self.expiration_time.unwrap_or(0)
    }
    pub fn clear_expiration_time(&mut self) {
        self.expiration_time = ::std::option::Option::None;
    }

    pub fn has_expiration_time(&self) -> bool {
        self.expiration_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expiration_time(&mut self, v: u32) {
        self.expiration_time = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCRequestStoreSalesDataUpToDateResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.version = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.expiration_time = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.expiration_time {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.version {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.expiration_time {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCRequestStoreSalesDataUpToDateResponse {
        CMsgGCRequestStoreSalesDataUpToDateResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "version",
                |m: &CMsgGCRequestStoreSalesDataUpToDateResponse| { &m.version },
                |m: &mut CMsgGCRequestStoreSalesDataUpToDateResponse| { &mut m.version },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "expiration_time",
                |m: &CMsgGCRequestStoreSalesDataUpToDateResponse| { &m.expiration_time },
                |m: &mut CMsgGCRequestStoreSalesDataUpToDateResponse| { &mut m.expiration_time },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCRequestStoreSalesDataUpToDateResponse>(
                "CMsgGCRequestStoreSalesDataUpToDateResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCRequestStoreSalesDataUpToDateResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgGCRequestStoreSalesDataUpToDateResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCRequestStoreSalesDataUpToDateResponse::new)
    }
}

impl ::protobuf::Clear for CMsgGCRequestStoreSalesDataUpToDateResponse {
    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.expiration_time = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCRequestStoreSalesDataUpToDateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCRequestStoreSalesDataUpToDateResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToGCPingRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCPingRequest {
    fn default() -> &'a CMsgGCToGCPingRequest {
        <CMsgGCToGCPingRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCPingRequest {
    pub fn new() -> CMsgGCToGCPingRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgGCToGCPingRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCToGCPingRequest {
        CMsgGCToGCPingRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCToGCPingRequest>(
                "CMsgGCToGCPingRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCToGCPingRequest {
        static instance: ::protobuf::rt::LazyV2<CMsgGCToGCPingRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCToGCPingRequest::new)
    }
}

impl ::protobuf::Clear for CMsgGCToGCPingRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToGCPingRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCPingRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToGCPingResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCPingResponse {
    fn default() -> &'a CMsgGCToGCPingResponse {
        <CMsgGCToGCPingResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCPingResponse {
    pub fn new() -> CMsgGCToGCPingResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgGCToGCPingResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCToGCPingResponse {
        CMsgGCToGCPingResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCToGCPingResponse>(
                "CMsgGCToGCPingResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCToGCPingResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgGCToGCPingResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCToGCPingResponse::new)
    }
}

impl ::protobuf::Clear for CMsgGCToGCPingResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToGCPingResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCPingResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToGCGetUserSessionServer {
    // message fields
    account_id: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCGetUserSessionServer {
    fn default() -> &'a CMsgGCToGCGetUserSessionServer {
        <CMsgGCToGCGetUserSessionServer as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCGetUserSessionServer {
    pub fn new() -> CMsgGCToGCGetUserSessionServer {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;


    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }
    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCToGCGetUserSessionServer {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCToGCGetUserSessionServer {
        CMsgGCToGCGetUserSessionServer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "account_id",
                |m: &CMsgGCToGCGetUserSessionServer| { &m.account_id },
                |m: &mut CMsgGCToGCGetUserSessionServer| { &mut m.account_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCToGCGetUserSessionServer>(
                "CMsgGCToGCGetUserSessionServer",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCToGCGetUserSessionServer {
        static instance: ::protobuf::rt::LazyV2<CMsgGCToGCGetUserSessionServer> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCToGCGetUserSessionServer::new)
    }
}

impl ::protobuf::Clear for CMsgGCToGCGetUserSessionServer {
    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToGCGetUserSessionServer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCGetUserSessionServer {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToGCGetUserSessionServerResponse {
    // message fields
    server_steam_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCGetUserSessionServerResponse {
    fn default() -> &'a CMsgGCToGCGetUserSessionServerResponse {
        <CMsgGCToGCGetUserSessionServerResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCGetUserSessionServerResponse {
    pub fn new() -> CMsgGCToGCGetUserSessionServerResponse {
        ::std::default::Default::default()
    }

    // optional fixed64 server_steam_id = 1;


    pub fn get_server_steam_id(&self) -> u64 {
        self.server_steam_id.unwrap_or(0)
    }
    pub fn clear_server_steam_id(&mut self) {
        self.server_steam_id = ::std::option::Option::None;
    }

    pub fn has_server_steam_id(&self) -> bool {
        self.server_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_steam_id(&mut self, v: u64) {
        self.server_steam_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCToGCGetUserSessionServerResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.server_steam_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.server_steam_id {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.server_steam_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCToGCGetUserSessionServerResponse {
        CMsgGCToGCGetUserSessionServerResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "server_steam_id",
                |m: &CMsgGCToGCGetUserSessionServerResponse| { &m.server_steam_id },
                |m: &mut CMsgGCToGCGetUserSessionServerResponse| { &mut m.server_steam_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCToGCGetUserSessionServerResponse>(
                "CMsgGCToGCGetUserSessionServerResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCToGCGetUserSessionServerResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgGCToGCGetUserSessionServerResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCToGCGetUserSessionServerResponse::new)
    }
}

impl ::protobuf::Clear for CMsgGCToGCGetUserSessionServerResponse {
    fn clear(&mut self) {
        self.server_steam_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToGCGetUserSessionServerResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCGetUserSessionServerResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToGCGetUserServerMembers {
    // message fields
    account_id: ::std::option::Option<u32>,
    max_spectators: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCGetUserServerMembers {
    fn default() -> &'a CMsgGCToGCGetUserServerMembers {
        <CMsgGCToGCGetUserServerMembers as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCGetUserServerMembers {
    pub fn new() -> CMsgGCToGCGetUserServerMembers {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;


    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }
    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 max_spectators = 2;


    pub fn get_max_spectators(&self) -> u32 {
        self.max_spectators.unwrap_or(0)
    }
    pub fn clear_max_spectators(&mut self) {
        self.max_spectators = ::std::option::Option::None;
    }

    pub fn has_max_spectators(&self) -> bool {
        self.max_spectators.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_spectators(&mut self, v: u32) {
        self.max_spectators = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCToGCGetUserServerMembers {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.max_spectators = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.max_spectators {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.max_spectators {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCToGCGetUserServerMembers {
        CMsgGCToGCGetUserServerMembers::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "account_id",
                |m: &CMsgGCToGCGetUserServerMembers| { &m.account_id },
                |m: &mut CMsgGCToGCGetUserServerMembers| { &mut m.account_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "max_spectators",
                |m: &CMsgGCToGCGetUserServerMembers| { &m.max_spectators },
                |m: &mut CMsgGCToGCGetUserServerMembers| { &mut m.max_spectators },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCToGCGetUserServerMembers>(
                "CMsgGCToGCGetUserServerMembers",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCToGCGetUserServerMembers {
        static instance: ::protobuf::rt::LazyV2<CMsgGCToGCGetUserServerMembers> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCToGCGetUserServerMembers::new)
    }
}

impl ::protobuf::Clear for CMsgGCToGCGetUserServerMembers {
    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.max_spectators = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToGCGetUserServerMembers {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCGetUserServerMembers {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToGCGetUserServerMembersResponse {
    // message fields
    pub member_account_id: ::std::vec::Vec<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCGetUserServerMembersResponse {
    fn default() -> &'a CMsgGCToGCGetUserServerMembersResponse {
        <CMsgGCToGCGetUserServerMembersResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCGetUserServerMembersResponse {
    pub fn new() -> CMsgGCToGCGetUserServerMembersResponse {
        ::std::default::Default::default()
    }

    // repeated uint32 member_account_id = 1;


    pub fn get_member_account_id(&self) -> &[u32] {
        &self.member_account_id
    }
    pub fn clear_member_account_id(&mut self) {
        self.member_account_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_member_account_id(&mut self, v: ::std::vec::Vec<u32>) {
        self.member_account_id = v;
    }

    // Mutable pointer to the field.
    pub fn mut_member_account_id(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.member_account_id
    }

    // Take field
    pub fn take_member_account_id(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.member_account_id, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgGCToGCGetUserServerMembersResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.member_account_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.member_account_id {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.member_account_id {
            os.write_uint32(1, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCToGCGetUserServerMembersResponse {
        CMsgGCToGCGetUserServerMembersResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "member_account_id",
                |m: &CMsgGCToGCGetUserServerMembersResponse| { &m.member_account_id },
                |m: &mut CMsgGCToGCGetUserServerMembersResponse| { &mut m.member_account_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCToGCGetUserServerMembersResponse>(
                "CMsgGCToGCGetUserServerMembersResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCToGCGetUserServerMembersResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgGCToGCGetUserServerMembersResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCToGCGetUserServerMembersResponse::new)
    }
}

impl ::protobuf::Clear for CMsgGCToGCGetUserServerMembersResponse {
    fn clear(&mut self) {
        self.member_account_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToGCGetUserServerMembersResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCGetUserServerMembersResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgLookupMultipleAccountNames {
    // message fields
    pub accountids: ::std::vec::Vec<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgLookupMultipleAccountNames {
    fn default() -> &'a CMsgLookupMultipleAccountNames {
        <CMsgLookupMultipleAccountNames as ::protobuf::Message>::default_instance()
    }
}

impl CMsgLookupMultipleAccountNames {
    pub fn new() -> CMsgLookupMultipleAccountNames {
        ::std::default::Default::default()
    }

    // repeated uint32 accountids = 1;


    pub fn get_accountids(&self) -> &[u32] {
        &self.accountids
    }
    pub fn clear_accountids(&mut self) {
        self.accountids.clear();
    }

    // Param is passed by value, moved
    pub fn set_accountids(&mut self, v: ::std::vec::Vec<u32>) {
        self.accountids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_accountids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.accountids
    }

    // Take field
    pub fn take_accountids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.accountids, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgLookupMultipleAccountNames {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.accountids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.accountids.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_size(1, &self.accountids);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.accountids.is_empty() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_data_size(&self.accountids))?;
            for v in &self.accountids {
                os.write_uint32_no_tag(*v)?;
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgLookupMultipleAccountNames {
        CMsgLookupMultipleAccountNames::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "accountids",
                |m: &CMsgLookupMultipleAccountNames| { &m.accountids },
                |m: &mut CMsgLookupMultipleAccountNames| { &mut m.accountids },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgLookupMultipleAccountNames>(
                "CMsgLookupMultipleAccountNames",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgLookupMultipleAccountNames {
        static instance: ::protobuf::rt::LazyV2<CMsgLookupMultipleAccountNames> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgLookupMultipleAccountNames::new)
    }
}

impl ::protobuf::Clear for CMsgLookupMultipleAccountNames {
    fn clear(&mut self) {
        self.accountids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgLookupMultipleAccountNames {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgLookupMultipleAccountNames {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgLookupMultipleAccountNamesResponse {
    // message fields
    pub accounts: ::protobuf::RepeatedField<CMsgLookupMultipleAccountNamesResponse_Account>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgLookupMultipleAccountNamesResponse {
    fn default() -> &'a CMsgLookupMultipleAccountNamesResponse {
        <CMsgLookupMultipleAccountNamesResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgLookupMultipleAccountNamesResponse {
    pub fn new() -> CMsgLookupMultipleAccountNamesResponse {
        ::std::default::Default::default()
    }

    // repeated .CMsgLookupMultipleAccountNamesResponse.Account accounts = 1;


    pub fn get_accounts(&self) -> &[CMsgLookupMultipleAccountNamesResponse_Account] {
        &self.accounts
    }
    pub fn clear_accounts(&mut self) {
        self.accounts.clear();
    }

    // Param is passed by value, moved
    pub fn set_accounts(&mut self, v: ::protobuf::RepeatedField<CMsgLookupMultipleAccountNamesResponse_Account>) {
        self.accounts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_accounts(&mut self) -> &mut ::protobuf::RepeatedField<CMsgLookupMultipleAccountNamesResponse_Account> {
        &mut self.accounts
    }

    // Take field
    pub fn take_accounts(&mut self) -> ::protobuf::RepeatedField<CMsgLookupMultipleAccountNamesResponse_Account> {
        ::std::mem::replace(&mut self.accounts, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgLookupMultipleAccountNamesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.accounts {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.accounts)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.accounts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.accounts {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgLookupMultipleAccountNamesResponse {
        CMsgLookupMultipleAccountNamesResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgLookupMultipleAccountNamesResponse_Account>>(
                "accounts",
                |m: &CMsgLookupMultipleAccountNamesResponse| { &m.accounts },
                |m: &mut CMsgLookupMultipleAccountNamesResponse| { &mut m.accounts },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgLookupMultipleAccountNamesResponse>(
                "CMsgLookupMultipleAccountNamesResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgLookupMultipleAccountNamesResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgLookupMultipleAccountNamesResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgLookupMultipleAccountNamesResponse::new)
    }
}

impl ::protobuf::Clear for CMsgLookupMultipleAccountNamesResponse {
    fn clear(&mut self) {
        self.accounts.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgLookupMultipleAccountNamesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgLookupMultipleAccountNamesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgLookupMultipleAccountNamesResponse_Account {
    // message fields
    accountid: ::std::option::Option<u32>,
    persona: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgLookupMultipleAccountNamesResponse_Account {
    fn default() -> &'a CMsgLookupMultipleAccountNamesResponse_Account {
        <CMsgLookupMultipleAccountNamesResponse_Account as ::protobuf::Message>::default_instance()
    }
}

impl CMsgLookupMultipleAccountNamesResponse_Account {
    pub fn new() -> CMsgLookupMultipleAccountNamesResponse_Account {
        ::std::default::Default::default()
    }

    // optional uint32 accountid = 1;


    pub fn get_accountid(&self) -> u32 {
        self.accountid.unwrap_or(0)
    }
    pub fn clear_accountid(&mut self) {
        self.accountid = ::std::option::Option::None;
    }

    pub fn has_accountid(&self) -> bool {
        self.accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid(&mut self, v: u32) {
        self.accountid = ::std::option::Option::Some(v);
    }

    // optional string persona = 2;


    pub fn get_persona(&self) -> &str {
        match self.persona.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_persona(&mut self) {
        self.persona.clear();
    }

    pub fn has_persona(&self) -> bool {
        self.persona.is_some()
    }

    // Param is passed by value, moved
    pub fn set_persona(&mut self, v: ::std::string::String) {
        self.persona = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_persona(&mut self) -> &mut ::std::string::String {
        if self.persona.is_none() {
            self.persona.set_default();
        }
        self.persona.as_mut().unwrap()
    }

    // Take field
    pub fn take_persona(&mut self) -> ::std::string::String {
        self.persona.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgLookupMultipleAccountNamesResponse_Account {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.accountid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.persona)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.accountid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.persona.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.accountid {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.persona.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgLookupMultipleAccountNamesResponse_Account {
        CMsgLookupMultipleAccountNamesResponse_Account::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "accountid",
                |m: &CMsgLookupMultipleAccountNamesResponse_Account| { &m.accountid },
                |m: &mut CMsgLookupMultipleAccountNamesResponse_Account| { &mut m.accountid },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "persona",
                |m: &CMsgLookupMultipleAccountNamesResponse_Account| { &m.persona },
                |m: &mut CMsgLookupMultipleAccountNamesResponse_Account| { &mut m.persona },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgLookupMultipleAccountNamesResponse_Account>(
                "CMsgLookupMultipleAccountNamesResponse.Account",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgLookupMultipleAccountNamesResponse_Account {
        static instance: ::protobuf::rt::LazyV2<CMsgLookupMultipleAccountNamesResponse_Account> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgLookupMultipleAccountNamesResponse_Account::new)
    }
}

impl ::protobuf::Clear for CMsgLookupMultipleAccountNamesResponse_Account {
    fn clear(&mut self) {
        self.accountid = ::std::option::Option::None;
        self.persona.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgLookupMultipleAccountNamesResponse_Account {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgLookupMultipleAccountNamesResponse_Account {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToGCGrantSelfMadeItemToAccount {
    // message fields
    item_def_index: ::std::option::Option<u32>,
    accountid: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCGrantSelfMadeItemToAccount {
    fn default() -> &'a CMsgGCToGCGrantSelfMadeItemToAccount {
        <CMsgGCToGCGrantSelfMadeItemToAccount as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCGrantSelfMadeItemToAccount {
    pub fn new() -> CMsgGCToGCGrantSelfMadeItemToAccount {
        ::std::default::Default::default()
    }

    // optional uint32 item_def_index = 1;


    pub fn get_item_def_index(&self) -> u32 {
        self.item_def_index.unwrap_or(0)
    }
    pub fn clear_item_def_index(&mut self) {
        self.item_def_index = ::std::option::Option::None;
    }

    pub fn has_item_def_index(&self) -> bool {
        self.item_def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_def_index(&mut self, v: u32) {
        self.item_def_index = ::std::option::Option::Some(v);
    }

    // optional uint32 accountid = 2;


    pub fn get_accountid(&self) -> u32 {
        self.accountid.unwrap_or(0)
    }
    pub fn clear_accountid(&mut self) {
        self.accountid = ::std::option::Option::None;
    }

    pub fn has_accountid(&self) -> bool {
        self.accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid(&mut self, v: u32) {
        self.accountid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCToGCGrantSelfMadeItemToAccount {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.item_def_index = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.accountid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.item_def_index {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.accountid {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.item_def_index {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.accountid {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCToGCGrantSelfMadeItemToAccount {
        CMsgGCToGCGrantSelfMadeItemToAccount::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "item_def_index",
                |m: &CMsgGCToGCGrantSelfMadeItemToAccount| { &m.item_def_index },
                |m: &mut CMsgGCToGCGrantSelfMadeItemToAccount| { &mut m.item_def_index },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "accountid",
                |m: &CMsgGCToGCGrantSelfMadeItemToAccount| { &m.accountid },
                |m: &mut CMsgGCToGCGrantSelfMadeItemToAccount| { &mut m.accountid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCToGCGrantSelfMadeItemToAccount>(
                "CMsgGCToGCGrantSelfMadeItemToAccount",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCToGCGrantSelfMadeItemToAccount {
        static instance: ::protobuf::rt::LazyV2<CMsgGCToGCGrantSelfMadeItemToAccount> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCToGCGrantSelfMadeItemToAccount::new)
    }
}

impl ::protobuf::Clear for CMsgGCToGCGrantSelfMadeItemToAccount {
    fn clear(&mut self) {
        self.item_def_index = ::std::option::Option::None;
        self.accountid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToGCGrantSelfMadeItemToAccount {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCGrantSelfMadeItemToAccount {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToGCThankedByNewUser {
    // message fields
    new_user_accountid: ::std::option::Option<u32>,
    thanked_user_accountid: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCThankedByNewUser {
    fn default() -> &'a CMsgGCToGCThankedByNewUser {
        <CMsgGCToGCThankedByNewUser as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCThankedByNewUser {
    pub fn new() -> CMsgGCToGCThankedByNewUser {
        ::std::default::Default::default()
    }

    // optional uint32 new_user_accountid = 1;


    pub fn get_new_user_accountid(&self) -> u32 {
        self.new_user_accountid.unwrap_or(0)
    }
    pub fn clear_new_user_accountid(&mut self) {
        self.new_user_accountid = ::std::option::Option::None;
    }

    pub fn has_new_user_accountid(&self) -> bool {
        self.new_user_accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_new_user_accountid(&mut self, v: u32) {
        self.new_user_accountid = ::std::option::Option::Some(v);
    }

    // optional uint32 thanked_user_accountid = 2;


    pub fn get_thanked_user_accountid(&self) -> u32 {
        self.thanked_user_accountid.unwrap_or(0)
    }
    pub fn clear_thanked_user_accountid(&mut self) {
        self.thanked_user_accountid = ::std::option::Option::None;
    }

    pub fn has_thanked_user_accountid(&self) -> bool {
        self.thanked_user_accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_thanked_user_accountid(&mut self, v: u32) {
        self.thanked_user_accountid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCToGCThankedByNewUser {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.new_user_accountid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.thanked_user_accountid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.new_user_accountid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.thanked_user_accountid {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.new_user_accountid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.thanked_user_accountid {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCToGCThankedByNewUser {
        CMsgGCToGCThankedByNewUser::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "new_user_accountid",
                |m: &CMsgGCToGCThankedByNewUser| { &m.new_user_accountid },
                |m: &mut CMsgGCToGCThankedByNewUser| { &mut m.new_user_accountid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "thanked_user_accountid",
                |m: &CMsgGCToGCThankedByNewUser| { &m.thanked_user_accountid },
                |m: &mut CMsgGCToGCThankedByNewUser| { &mut m.thanked_user_accountid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCToGCThankedByNewUser>(
                "CMsgGCToGCThankedByNewUser",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCToGCThankedByNewUser {
        static instance: ::protobuf::rt::LazyV2<CMsgGCToGCThankedByNewUser> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCToGCThankedByNewUser::new)
    }
}

impl ::protobuf::Clear for CMsgGCToGCThankedByNewUser {
    fn clear(&mut self) {
        self.new_user_accountid = ::std::option::Option::None;
        self.thanked_user_accountid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToGCThankedByNewUser {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCThankedByNewUser {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCShuffleCrateContents {
    // message fields
    crate_item_id: ::std::option::Option<u64>,
    user_code_string: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCShuffleCrateContents {
    fn default() -> &'a CMsgGCShuffleCrateContents {
        <CMsgGCShuffleCrateContents as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCShuffleCrateContents {
    pub fn new() -> CMsgGCShuffleCrateContents {
        ::std::default::Default::default()
    }

    // optional uint64 crate_item_id = 1;


    pub fn get_crate_item_id(&self) -> u64 {
        self.crate_item_id.unwrap_or(0)
    }
    pub fn clear_crate_item_id(&mut self) {
        self.crate_item_id = ::std::option::Option::None;
    }

    pub fn has_crate_item_id(&self) -> bool {
        self.crate_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_crate_item_id(&mut self, v: u64) {
        self.crate_item_id = ::std::option::Option::Some(v);
    }

    // optional string user_code_string = 2;


    pub fn get_user_code_string(&self) -> &str {
        match self.user_code_string.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_user_code_string(&mut self) {
        self.user_code_string.clear();
    }

    pub fn has_user_code_string(&self) -> bool {
        self.user_code_string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_code_string(&mut self, v: ::std::string::String) {
        self.user_code_string = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_code_string(&mut self) -> &mut ::std::string::String {
        if self.user_code_string.is_none() {
            self.user_code_string.set_default();
        }
        self.user_code_string.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_code_string(&mut self) -> ::std::string::String {
        self.user_code_string.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgGCShuffleCrateContents {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.crate_item_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.user_code_string)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.crate_item_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.user_code_string.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.crate_item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(ref v) = self.user_code_string.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCShuffleCrateContents {
        CMsgGCShuffleCrateContents::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "crate_item_id",
                |m: &CMsgGCShuffleCrateContents| { &m.crate_item_id },
                |m: &mut CMsgGCShuffleCrateContents| { &mut m.crate_item_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "user_code_string",
                |m: &CMsgGCShuffleCrateContents| { &m.user_code_string },
                |m: &mut CMsgGCShuffleCrateContents| { &mut m.user_code_string },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCShuffleCrateContents>(
                "CMsgGCShuffleCrateContents",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCShuffleCrateContents {
        static instance: ::protobuf::rt::LazyV2<CMsgGCShuffleCrateContents> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCShuffleCrateContents::new)
    }
}

impl ::protobuf::Clear for CMsgGCShuffleCrateContents {
    fn clear(&mut self) {
        self.crate_item_id = ::std::option::Option::None;
        self.user_code_string.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCShuffleCrateContents {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCShuffleCrateContents {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCQuestObjective_Progress {
    // message fields
    quest_id: ::std::option::Option<u64>,
    quest_attrib_index: ::std::option::Option<u32>,
    delta: ::std::option::Option<u32>,
    owner_steamid: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCQuestObjective_Progress {
    fn default() -> &'a CMsgGCQuestObjective_Progress {
        <CMsgGCQuestObjective_Progress as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCQuestObjective_Progress {
    pub fn new() -> CMsgGCQuestObjective_Progress {
        ::std::default::Default::default()
    }

    // optional uint64 quest_id = 1;


    pub fn get_quest_id(&self) -> u64 {
        self.quest_id.unwrap_or(0)
    }
    pub fn clear_quest_id(&mut self) {
        self.quest_id = ::std::option::Option::None;
    }

    pub fn has_quest_id(&self) -> bool {
        self.quest_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quest_id(&mut self, v: u64) {
        self.quest_id = ::std::option::Option::Some(v);
    }

    // optional uint32 quest_attrib_index = 2;


    pub fn get_quest_attrib_index(&self) -> u32 {
        self.quest_attrib_index.unwrap_or(0)
    }
    pub fn clear_quest_attrib_index(&mut self) {
        self.quest_attrib_index = ::std::option::Option::None;
    }

    pub fn has_quest_attrib_index(&self) -> bool {
        self.quest_attrib_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quest_attrib_index(&mut self, v: u32) {
        self.quest_attrib_index = ::std::option::Option::Some(v);
    }

    // optional uint32 delta = 3;


    pub fn get_delta(&self) -> u32 {
        self.delta.unwrap_or(0)
    }
    pub fn clear_delta(&mut self) {
        self.delta = ::std::option::Option::None;
    }

    pub fn has_delta(&self) -> bool {
        self.delta.is_some()
    }

    // Param is passed by value, moved
    pub fn set_delta(&mut self, v: u32) {
        self.delta = ::std::option::Option::Some(v);
    }

    // optional fixed64 owner_steamid = 4;


    pub fn get_owner_steamid(&self) -> u64 {
        self.owner_steamid.unwrap_or(0)
    }
    pub fn clear_owner_steamid(&mut self) {
        self.owner_steamid = ::std::option::Option::None;
    }

    pub fn has_owner_steamid(&self) -> bool {
        self.owner_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner_steamid(&mut self, v: u64) {
        self.owner_steamid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCQuestObjective_Progress {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.quest_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.quest_attrib_index = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.delta = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.owner_steamid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.quest_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.quest_attrib_index {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.delta {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.owner_steamid {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.quest_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.quest_attrib_index {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.delta {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.owner_steamid {
            os.write_fixed64(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCQuestObjective_Progress {
        CMsgGCQuestObjective_Progress::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "quest_id",
                |m: &CMsgGCQuestObjective_Progress| { &m.quest_id },
                |m: &mut CMsgGCQuestObjective_Progress| { &mut m.quest_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "quest_attrib_index",
                |m: &CMsgGCQuestObjective_Progress| { &m.quest_attrib_index },
                |m: &mut CMsgGCQuestObjective_Progress| { &mut m.quest_attrib_index },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "delta",
                |m: &CMsgGCQuestObjective_Progress| { &m.delta },
                |m: &mut CMsgGCQuestObjective_Progress| { &mut m.delta },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "owner_steamid",
                |m: &CMsgGCQuestObjective_Progress| { &m.owner_steamid },
                |m: &mut CMsgGCQuestObjective_Progress| { &mut m.owner_steamid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCQuestObjective_Progress>(
                "CMsgGCQuestObjective_Progress",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCQuestObjective_Progress {
        static instance: ::protobuf::rt::LazyV2<CMsgGCQuestObjective_Progress> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCQuestObjective_Progress::new)
    }
}

impl ::protobuf::Clear for CMsgGCQuestObjective_Progress {
    fn clear(&mut self) {
        self.quest_id = ::std::option::Option::None;
        self.quest_attrib_index = ::std::option::Option::None;
        self.delta = ::std::option::Option::None;
        self.owner_steamid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCQuestObjective_Progress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCQuestObjective_Progress {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCQuestObjective_PointsChange {
    // message fields
    quest_id: ::std::option::Option<u64>,
    owner_steamid: ::std::option::Option<u64>,
    update_base_points: ::std::option::Option<bool>,
    points_0: ::std::option::Option<u32>,
    points_1: ::std::option::Option<u32>,
    points_2: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCQuestObjective_PointsChange {
    fn default() -> &'a CMsgGCQuestObjective_PointsChange {
        <CMsgGCQuestObjective_PointsChange as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCQuestObjective_PointsChange {
    pub fn new() -> CMsgGCQuestObjective_PointsChange {
        ::std::default::Default::default()
    }

    // optional uint64 quest_id = 1;


    pub fn get_quest_id(&self) -> u64 {
        self.quest_id.unwrap_or(0)
    }
    pub fn clear_quest_id(&mut self) {
        self.quest_id = ::std::option::Option::None;
    }

    pub fn has_quest_id(&self) -> bool {
        self.quest_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quest_id(&mut self, v: u64) {
        self.quest_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 owner_steamid = 4;


    pub fn get_owner_steamid(&self) -> u64 {
        self.owner_steamid.unwrap_or(0)
    }
    pub fn clear_owner_steamid(&mut self) {
        self.owner_steamid = ::std::option::Option::None;
    }

    pub fn has_owner_steamid(&self) -> bool {
        self.owner_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner_steamid(&mut self, v: u64) {
        self.owner_steamid = ::std::option::Option::Some(v);
    }

    // optional bool update_base_points = 5;


    pub fn get_update_base_points(&self) -> bool {
        self.update_base_points.unwrap_or(false)
    }
    pub fn clear_update_base_points(&mut self) {
        self.update_base_points = ::std::option::Option::None;
    }

    pub fn has_update_base_points(&self) -> bool {
        self.update_base_points.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_base_points(&mut self, v: bool) {
        self.update_base_points = ::std::option::Option::Some(v);
    }

    // optional uint32 points_0 = 6;


    pub fn get_points_0(&self) -> u32 {
        self.points_0.unwrap_or(0)
    }
    pub fn clear_points_0(&mut self) {
        self.points_0 = ::std::option::Option::None;
    }

    pub fn has_points_0(&self) -> bool {
        self.points_0.is_some()
    }

    // Param is passed by value, moved
    pub fn set_points_0(&mut self, v: u32) {
        self.points_0 = ::std::option::Option::Some(v);
    }

    // optional uint32 points_1 = 7;


    pub fn get_points_1(&self) -> u32 {
        self.points_1.unwrap_or(0)
    }
    pub fn clear_points_1(&mut self) {
        self.points_1 = ::std::option::Option::None;
    }

    pub fn has_points_1(&self) -> bool {
        self.points_1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_points_1(&mut self, v: u32) {
        self.points_1 = ::std::option::Option::Some(v);
    }

    // optional uint32 points_2 = 8;


    pub fn get_points_2(&self) -> u32 {
        self.points_2.unwrap_or(0)
    }
    pub fn clear_points_2(&mut self) {
        self.points_2 = ::std::option::Option::None;
    }

    pub fn has_points_2(&self) -> bool {
        self.points_2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_points_2(&mut self, v: u32) {
        self.points_2 = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCQuestObjective_PointsChange {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.quest_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.owner_steamid = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.update_base_points = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.points_0 = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.points_1 = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.points_2 = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.quest_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.owner_steamid {
            my_size += 9;
        }
        if let Some(v) = self.update_base_points {
            my_size += 2;
        }
        if let Some(v) = self.points_0 {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.points_1 {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.points_2 {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.quest_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.owner_steamid {
            os.write_fixed64(4, v)?;
        }
        if let Some(v) = self.update_base_points {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.points_0 {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.points_1 {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.points_2 {
            os.write_uint32(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCQuestObjective_PointsChange {
        CMsgGCQuestObjective_PointsChange::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "quest_id",
                |m: &CMsgGCQuestObjective_PointsChange| { &m.quest_id },
                |m: &mut CMsgGCQuestObjective_PointsChange| { &mut m.quest_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "owner_steamid",
                |m: &CMsgGCQuestObjective_PointsChange| { &m.owner_steamid },
                |m: &mut CMsgGCQuestObjective_PointsChange| { &mut m.owner_steamid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "update_base_points",
                |m: &CMsgGCQuestObjective_PointsChange| { &m.update_base_points },
                |m: &mut CMsgGCQuestObjective_PointsChange| { &mut m.update_base_points },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "points_0",
                |m: &CMsgGCQuestObjective_PointsChange| { &m.points_0 },
                |m: &mut CMsgGCQuestObjective_PointsChange| { &mut m.points_0 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "points_1",
                |m: &CMsgGCQuestObjective_PointsChange| { &m.points_1 },
                |m: &mut CMsgGCQuestObjective_PointsChange| { &mut m.points_1 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "points_2",
                |m: &CMsgGCQuestObjective_PointsChange| { &m.points_2 },
                |m: &mut CMsgGCQuestObjective_PointsChange| { &mut m.points_2 },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCQuestObjective_PointsChange>(
                "CMsgGCQuestObjective_PointsChange",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCQuestObjective_PointsChange {
        static instance: ::protobuf::rt::LazyV2<CMsgGCQuestObjective_PointsChange> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCQuestObjective_PointsChange::new)
    }
}

impl ::protobuf::Clear for CMsgGCQuestObjective_PointsChange {
    fn clear(&mut self) {
        self.quest_id = ::std::option::Option::None;
        self.owner_steamid = ::std::option::Option::None;
        self.update_base_points = ::std::option::Option::None;
        self.points_0 = ::std::option::Option::None;
        self.points_1 = ::std::option::Option::None;
        self.points_2 = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCQuestObjective_PointsChange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCQuestObjective_PointsChange {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCQuestComplete_Request {
    // message fields
    quest_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCQuestComplete_Request {
    fn default() -> &'a CMsgGCQuestComplete_Request {
        <CMsgGCQuestComplete_Request as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCQuestComplete_Request {
    pub fn new() -> CMsgGCQuestComplete_Request {
        ::std::default::Default::default()
    }

    // optional uint64 quest_id = 1;


    pub fn get_quest_id(&self) -> u64 {
        self.quest_id.unwrap_or(0)
    }
    pub fn clear_quest_id(&mut self) {
        self.quest_id = ::std::option::Option::None;
    }

    pub fn has_quest_id(&self) -> bool {
        self.quest_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quest_id(&mut self, v: u64) {
        self.quest_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCQuestComplete_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.quest_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.quest_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.quest_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCQuestComplete_Request {
        CMsgGCQuestComplete_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "quest_id",
                |m: &CMsgGCQuestComplete_Request| { &m.quest_id },
                |m: &mut CMsgGCQuestComplete_Request| { &mut m.quest_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCQuestComplete_Request>(
                "CMsgGCQuestComplete_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCQuestComplete_Request {
        static instance: ::protobuf::rt::LazyV2<CMsgGCQuestComplete_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCQuestComplete_Request::new)
    }
}

impl ::protobuf::Clear for CMsgGCQuestComplete_Request {
    fn clear(&mut self) {
        self.quest_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCQuestComplete_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCQuestComplete_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCQuestCompleted {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCQuestCompleted {
    fn default() -> &'a CMsgGCQuestCompleted {
        <CMsgGCQuestCompleted as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCQuestCompleted {
    pub fn new() -> CMsgGCQuestCompleted {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgGCQuestCompleted {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCQuestCompleted {
        CMsgGCQuestCompleted::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCQuestCompleted>(
                "CMsgGCQuestCompleted",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCQuestCompleted {
        static instance: ::protobuf::rt::LazyV2<CMsgGCQuestCompleted> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCQuestCompleted::new)
    }
}

impl ::protobuf::Clear for CMsgGCQuestCompleted {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCQuestCompleted {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCQuestCompleted {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCQuestObjective_RequestLoanerItems {
    // message fields
    quest_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCQuestObjective_RequestLoanerItems {
    fn default() -> &'a CMsgGCQuestObjective_RequestLoanerItems {
        <CMsgGCQuestObjective_RequestLoanerItems as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCQuestObjective_RequestLoanerItems {
    pub fn new() -> CMsgGCQuestObjective_RequestLoanerItems {
        ::std::default::Default::default()
    }

    // optional uint64 quest_id = 1;


    pub fn get_quest_id(&self) -> u64 {
        self.quest_id.unwrap_or(0)
    }
    pub fn clear_quest_id(&mut self) {
        self.quest_id = ::std::option::Option::None;
    }

    pub fn has_quest_id(&self) -> bool {
        self.quest_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quest_id(&mut self, v: u64) {
        self.quest_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCQuestObjective_RequestLoanerItems {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.quest_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.quest_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.quest_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCQuestObjective_RequestLoanerItems {
        CMsgGCQuestObjective_RequestLoanerItems::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "quest_id",
                |m: &CMsgGCQuestObjective_RequestLoanerItems| { &m.quest_id },
                |m: &mut CMsgGCQuestObjective_RequestLoanerItems| { &mut m.quest_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCQuestObjective_RequestLoanerItems>(
                "CMsgGCQuestObjective_RequestLoanerItems",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCQuestObjective_RequestLoanerItems {
        static instance: ::protobuf::rt::LazyV2<CMsgGCQuestObjective_RequestLoanerItems> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCQuestObjective_RequestLoanerItems::new)
    }
}

impl ::protobuf::Clear for CMsgGCQuestObjective_RequestLoanerItems {
    fn clear(&mut self) {
        self.quest_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCQuestObjective_RequestLoanerItems {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCQuestObjective_RequestLoanerItems {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCQuestObjective_RequestLoanerResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCQuestObjective_RequestLoanerResponse {
    fn default() -> &'a CMsgGCQuestObjective_RequestLoanerResponse {
        <CMsgGCQuestObjective_RequestLoanerResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCQuestObjective_RequestLoanerResponse {
    pub fn new() -> CMsgGCQuestObjective_RequestLoanerResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgGCQuestObjective_RequestLoanerResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCQuestObjective_RequestLoanerResponse {
        CMsgGCQuestObjective_RequestLoanerResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCQuestObjective_RequestLoanerResponse>(
                "CMsgGCQuestObjective_RequestLoanerResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCQuestObjective_RequestLoanerResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgGCQuestObjective_RequestLoanerResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCQuestObjective_RequestLoanerResponse::new)
    }
}

impl ::protobuf::Clear for CMsgGCQuestObjective_RequestLoanerResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCQuestObjective_RequestLoanerResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCQuestObjective_RequestLoanerResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgCraftCollectionUpgrade {
    // message fields
    pub item_id: ::std::vec::Vec<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgCraftCollectionUpgrade {
    fn default() -> &'a CMsgCraftCollectionUpgrade {
        <CMsgCraftCollectionUpgrade as ::protobuf::Message>::default_instance()
    }
}

impl CMsgCraftCollectionUpgrade {
    pub fn new() -> CMsgCraftCollectionUpgrade {
        ::std::default::Default::default()
    }

    // repeated uint64 item_id = 1;


    pub fn get_item_id(&self) -> &[u64] {
        &self.item_id
    }
    pub fn clear_item_id(&mut self) {
        self.item_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: ::std::vec::Vec<u64>) {
        self.item_id = v;
    }

    // Mutable pointer to the field.
    pub fn mut_item_id(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.item_id
    }

    // Take field
    pub fn take_item_id(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.item_id, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgCraftCollectionUpgrade {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.item_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.item_id {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.item_id {
            os.write_uint64(1, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgCraftCollectionUpgrade {
        CMsgCraftCollectionUpgrade::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "item_id",
                |m: &CMsgCraftCollectionUpgrade| { &m.item_id },
                |m: &mut CMsgCraftCollectionUpgrade| { &mut m.item_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgCraftCollectionUpgrade>(
                "CMsgCraftCollectionUpgrade",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgCraftCollectionUpgrade {
        static instance: ::protobuf::rt::LazyV2<CMsgCraftCollectionUpgrade> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgCraftCollectionUpgrade::new)
    }
}

impl ::protobuf::Clear for CMsgCraftCollectionUpgrade {
    fn clear(&mut self) {
        self.item_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgCraftCollectionUpgrade {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgCraftCollectionUpgrade {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgCraftHalloweenOffering {
    // message fields
    tool_id: ::std::option::Option<u64>,
    pub item_id: ::std::vec::Vec<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgCraftHalloweenOffering {
    fn default() -> &'a CMsgCraftHalloweenOffering {
        <CMsgCraftHalloweenOffering as ::protobuf::Message>::default_instance()
    }
}

impl CMsgCraftHalloweenOffering {
    pub fn new() -> CMsgCraftHalloweenOffering {
        ::std::default::Default::default()
    }

    // optional uint64 tool_id = 1;


    pub fn get_tool_id(&self) -> u64 {
        self.tool_id.unwrap_or(0)
    }
    pub fn clear_tool_id(&mut self) {
        self.tool_id = ::std::option::Option::None;
    }

    pub fn has_tool_id(&self) -> bool {
        self.tool_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tool_id(&mut self, v: u64) {
        self.tool_id = ::std::option::Option::Some(v);
    }

    // repeated uint64 item_id = 2;


    pub fn get_item_id(&self) -> &[u64] {
        &self.item_id
    }
    pub fn clear_item_id(&mut self) {
        self.item_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: ::std::vec::Vec<u64>) {
        self.item_id = v;
    }

    // Mutable pointer to the field.
    pub fn mut_item_id(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.item_id
    }

    // Take field
    pub fn take_item_id(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.item_id, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgCraftHalloweenOffering {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.tool_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.item_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.tool_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.item_id {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.tool_id {
            os.write_uint64(1, v)?;
        }
        for v in &self.item_id {
            os.write_uint64(2, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgCraftHalloweenOffering {
        CMsgCraftHalloweenOffering::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "tool_id",
                |m: &CMsgCraftHalloweenOffering| { &m.tool_id },
                |m: &mut CMsgCraftHalloweenOffering| { &mut m.tool_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "item_id",
                |m: &CMsgCraftHalloweenOffering| { &m.item_id },
                |m: &mut CMsgCraftHalloweenOffering| { &mut m.item_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgCraftHalloweenOffering>(
                "CMsgCraftHalloweenOffering",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgCraftHalloweenOffering {
        static instance: ::protobuf::rt::LazyV2<CMsgCraftHalloweenOffering> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgCraftHalloweenOffering::new)
    }
}

impl ::protobuf::Clear for CMsgCraftHalloweenOffering {
    fn clear(&mut self) {
        self.tool_id = ::std::option::Option::None;
        self.item_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgCraftHalloweenOffering {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgCraftHalloweenOffering {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgCraftCommonStatClock {
    // message fields
    tool_id: ::std::option::Option<u64>,
    pub item_id: ::std::vec::Vec<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgCraftCommonStatClock {
    fn default() -> &'a CMsgCraftCommonStatClock {
        <CMsgCraftCommonStatClock as ::protobuf::Message>::default_instance()
    }
}

impl CMsgCraftCommonStatClock {
    pub fn new() -> CMsgCraftCommonStatClock {
        ::std::default::Default::default()
    }

    // optional uint64 tool_id = 1;


    pub fn get_tool_id(&self) -> u64 {
        self.tool_id.unwrap_or(0)
    }
    pub fn clear_tool_id(&mut self) {
        self.tool_id = ::std::option::Option::None;
    }

    pub fn has_tool_id(&self) -> bool {
        self.tool_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tool_id(&mut self, v: u64) {
        self.tool_id = ::std::option::Option::Some(v);
    }

    // repeated uint64 item_id = 2;


    pub fn get_item_id(&self) -> &[u64] {
        &self.item_id
    }
    pub fn clear_item_id(&mut self) {
        self.item_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: ::std::vec::Vec<u64>) {
        self.item_id = v;
    }

    // Mutable pointer to the field.
    pub fn mut_item_id(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.item_id
    }

    // Take field
    pub fn take_item_id(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.item_id, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgCraftCommonStatClock {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.tool_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.item_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.tool_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.item_id {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.tool_id {
            os.write_uint64(1, v)?;
        }
        for v in &self.item_id {
            os.write_uint64(2, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgCraftCommonStatClock {
        CMsgCraftCommonStatClock::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "tool_id",
                |m: &CMsgCraftCommonStatClock| { &m.tool_id },
                |m: &mut CMsgCraftCommonStatClock| { &mut m.tool_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "item_id",
                |m: &CMsgCraftCommonStatClock| { &m.item_id },
                |m: &mut CMsgCraftCommonStatClock| { &mut m.item_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgCraftCommonStatClock>(
                "CMsgCraftCommonStatClock",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgCraftCommonStatClock {
        static instance: ::protobuf::rt::LazyV2<CMsgCraftCommonStatClock> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgCraftCommonStatClock::new)
    }
}

impl ::protobuf::Clear for CMsgCraftCommonStatClock {
    fn clear(&mut self) {
        self.tool_id = ::std::option::Option::None;
        self.item_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgCraftCommonStatClock {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgCraftCommonStatClock {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCQuestDiscard_Request {
    // message fields
    quest_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCQuestDiscard_Request {
    fn default() -> &'a CMsgGCQuestDiscard_Request {
        <CMsgGCQuestDiscard_Request as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCQuestDiscard_Request {
    pub fn new() -> CMsgGCQuestDiscard_Request {
        ::std::default::Default::default()
    }

    // optional uint64 quest_id = 1;


    pub fn get_quest_id(&self) -> u64 {
        self.quest_id.unwrap_or(0)
    }
    pub fn clear_quest_id(&mut self) {
        self.quest_id = ::std::option::Option::None;
    }

    pub fn has_quest_id(&self) -> bool {
        self.quest_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quest_id(&mut self, v: u64) {
        self.quest_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCQuestDiscard_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.quest_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.quest_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.quest_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCQuestDiscard_Request {
        CMsgGCQuestDiscard_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "quest_id",
                |m: &CMsgGCQuestDiscard_Request| { &m.quest_id },
                |m: &mut CMsgGCQuestDiscard_Request| { &mut m.quest_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCQuestDiscard_Request>(
                "CMsgGCQuestDiscard_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCQuestDiscard_Request {
        static instance: ::protobuf::rt::LazyV2<CMsgGCQuestDiscard_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCQuestDiscard_Request::new)
    }
}

impl ::protobuf::Clear for CMsgGCQuestDiscard_Request {
    fn clear(&mut self) {
        self.quest_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCQuestDiscard_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCQuestDiscard_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EGCItemMsg {
    k_EMsgGCBase = 1000,
    k_EMsgGCSetSingleItemPosition = 1001,
    k_EMsgGCCraft = 1002,
    k_EMsgGCCraftResponse = 1003,
    k_EMsgGCDelete = 1004,
    k_EMsgGCVerifyCacheSubscription = 1005,
    k_EMsgGCNameItem = 1006,
    k_EMsgGCUnlockCrate = 1007,
    k_EMsgGCUnlockCrateResponse = 1008,
    k_EMsgGCPaintItem = 1009,
    k_EMsgGCPaintItemResponse = 1010,
    k_EMsgGCGoldenWrenchBroadcast = 1011,
    k_EMsgGCMOTDRequest = 1012,
    k_EMsgGCMOTDRequestResponse = 1013,
    k_EMsgGCNameBaseItem = 1019,
    k_EMsgGCNameBaseItemResponse = 1020,
    k_EMsgGCRemoveSocketItem_DEPRECATED = 1021,
    k_EMsgGCRemoveSocketItemResponse_DEPRECATED = 1022,
    k_EMsgGCCustomizeItemTexture = 1023,
    k_EMsgGCCustomizeItemTextureResponse = 1024,
    k_EMsgGCUseItemRequest = 1025,
    k_EMsgGCUseItemResponse = 1026,
    k_EMsgGCRespawnPostLoadoutChange = 1029,
    k_EMsgGCRemoveItemName = 1030,
    k_EMsgGCRemoveItemPaint = 1031,
    k_EMsgGCGiftWrapItem = 1032,
    k_EMsgGCGiftWrapItemResponse = 1033,
    k_EMsgGCDeliverGift = 1034,
    k_EMsgGCDeliverGiftResponseReceiver = 1036,
    k_EMsgGCUnwrapGiftRequest = 1037,
    k_EMsgGCUnwrapGiftResponse = 1038,
    k_EMsgGCSetItemStyle = 1039,
    k_EMsgGCUsedClaimCodeItem = 1040,
    k_EMsgGCSortItems = 1041,
    k_EMsgGC_RevolvingLootList_DEPRECATED = 1042,
    k_EMsgGCLookupAccount = 1043,
    k_EMsgGCLookupAccountResponse = 1044,
    k_EMsgGCLookupAccountName = 1045,
    k_EMsgGCLookupAccountNameResponse = 1046,
    k_EMsgGCUpdateItemSchema = 1049,
    k_EMsgGCRequestInventoryRefresh = 1050,
    k_EMsgGCRemoveCustomTexture = 1051,
    k_EMsgGCRemoveCustomTextureResponse = 1052,
    k_EMsgGCRemoveMakersMark = 1053,
    k_EMsgGCRemoveMakersMarkResponse = 1054,
    k_EMsgGCRemoveUniqueCraftIndex = 1055,
    k_EMsgGCRemoveUniqueCraftIndexResponse = 1056,
    k_EMsgGCSaxxyBroadcast = 1057,
    k_EMsgGCBackpackSortFinished = 1058,
    k_EMsgGCAdjustItemEquippedState = 1059,
    k_EMsgGCCollectItem = 1061,
    k_EMsgGCItemAcknowledged = 1062,
    k_EMsgGCPresets_SelectPresetForClass = 1063,
    k_EMsgGCPresets_SetItemPosition = 1064,
    k_EMsgGC_ReportAbuse = 1065,
    k_EMsgGC_ReportAbuseResponse = 1066,
    k_EMsgGCPresets_SelectPresetForClassReply = 1067,
    k_EMsgGCNameItemNotification = 1068,
    k_EMsgGCClientDisplayNotification = 1069,
    k_EMsgGCApplyStrangePart = 1070,
    k_EMsgGC_IncrementKillCountAttribute = 1071,
    k_EMsgGC_IncrementKillCountResponse = 1072,
    k_EMsgGCRemoveStrangePart = 1073,
    k_EMsgGCResetStrangeScores = 1074,
    k_EMsgGCGiftedItems = 1075,
    k_EMsgGCApplyUpgradeCard = 1077,
    k_EMsgGCRemoveUpgradeCard = 1078,
    k_EMsgGCApplyStrangeRestriction = 1079,
    k_EMsgGCClientRequestMarketData = 1080,
    k_EMsgGCClientRequestMarketDataResponse = 1081,
    k_EMsgGCApplyXifier = 1082,
    k_EMsgGCApplyXifierResponse = 1083,
    k_EMsgGC_TrackUniquePlayerPairEvent = 1084,
    k_EMsgGCFulfillDynamicRecipeComponent = 1085,
    k_EMsgGCFulfillDynamicRecipeComponentResponse = 1086,
    k_EMsgGCSetItemEffectVerticalOffset = 1087,
    k_EMsgGCSetHatEffectUseHeadOrigin = 1088,
    k_EMsgGCItemEaterRecharger = 1089,
    k_EMsgGCItemEaterRechargerResponse = 1090,
    k_EMsgGCApplyBaseItemXifier = 1091,
    k_EMsgGCApplyClassTransmogrifier = 1092,
    k_EMsgGCApplyHalloweenSpellbookPage = 1093,
    k_EMsgGCRemoveKillStreak = 1094,
    k_EMsgGCRemoveKillStreakResponse = 1095,
    k_EMsgGCTFSpecificItemBroadcast = 1096,
    k_EMsgGC_IncrementKillCountAttribute_Multiple = 1097,
    k_EMsgGCDeliverGiftResponseGiver = 1098,
    k_EMsgGCSetItemPositions = 1100,
    k_EMsgGCLookupMultipleAccountNames = 1101,
    k_EMsgGCLookupMultipleAccountNamesResponse = 1102,
    k_EMsgGCTradingBase = 1500,
    k_EMsgGCTrading_InitiateTradeRequest = 1501,
    k_EMsgGCTrading_InitiateTradeResponse = 1502,
    k_EMsgGCTrading_StartSession = 1503,
    k_EMsgGCTrading_SessionClosed = 1509,
    k_EMsgGCTrading_CancelSession = 1510,
    k_EMsgGCTrading_InitiateTradeRequestResponse = 1514,
    k_EMsgGCServerBrowser_FavoriteServer = 1601,
    k_EMsgGCServerBrowser_BlacklistServer = 1602,
    k_EMsgGCServerRentalsBase = 1700,
    k_EMsgGCItemPreviewCheckStatus = 1701,
    k_EMsgGCItemPreviewStatusResponse = 1702,
    k_EMsgGCItemPreviewRequest = 1703,
    k_EMsgGCItemPreviewRequestResponse = 1704,
    k_EMsgGCItemPreviewExpire = 1705,
    k_EMsgGCItemPreviewExpireNotification = 1706,
    k_EMsgGCItemPreviewItemBoughtNotification = 1708,
    k_EMsgGCDev_NewItemRequest = 2001,
    k_EMsgGCDev_NewItemRequestResponse = 2002,
    k_EMsgGCDev_DebugRollLootRequest = 2003,
    k_EMsgGCStoreGetUserData = 2500,
    k_EMsgGCStoreGetUserDataResponse = 2501,
    k_EMsgGCStorePurchaseInit_DEPRECATED = 2502,
    k_EMsgGCStorePurchaseInitResponse_DEPRECATED = 2503,
    k_EMsgGCStorePurchaseFinalize = 2512,
    k_EMsgGCStorePurchaseFinalizeResponse = 2513,
    k_EMsgGCStorePurchaseCancel = 2514,
    k_EMsgGCStorePurchaseCancelResponse = 2515,
    k_EMsgGCStorePurchaseQueryTxn = 2508,
    k_EMsgGCStorePurchaseQueryTxnResponse = 2509,
    k_EMsgGCStorePurchaseInit = 2510,
    k_EMsgGCStorePurchaseInitResponse = 2511,
    k_EMsgGCToGCDirtySDOCache = 2516,
    k_EMsgGCToGCDirtyMultipleSDOCache = 2517,
    k_EMsgGCToGCUpdateSQLKeyValue = 2518,
    k_EMsgGCToGCBroadcastConsoleCommand = 2521,
    k_EMsgGCServerVersionUpdated = 2522,
    k_EMsgGCApplyAutograph = 2523,
    k_EMsgGCToGCWebAPIAccountChanged = 2524,
    k_EMsgGCRequestAnnouncements = 2525,
    k_EMsgGCRequestAnnouncementsResponse = 2526,
    k_EMsgGCRequestPassportItemGrant = 2527,
    k_EMsgGCClientVersionUpdated = 2528,
    k_EMsgGCItemPurgatory_FinalizePurchase = 2531,
    k_EMsgGCItemPurgatory_FinalizePurchaseResponse = 2532,
    k_EMsgGCItemPurgatory_RefundPurchase = 2533,
    k_EMsgGCItemPurgatory_RefundPurchaseResponse = 2534,
    k_EMsgGCToGCPlayerStrangeCountAdjustments = 2535,
    k_EMsgGCRequestStoreSalesData = 2536,
    k_EMsgGCRequestStoreSalesDataResponse = 2537,
    k_EMsgGCRequestStoreSalesDataUpToDateResponse = 2538,
    k_EMsgGCToGCPingRequest = 2539,
    k_EMsgGCToGCPingResponse = 2540,
    k_EMsgGCToGCGetUserSessionServer = 2541,
    k_EMsgGCToGCGetUserSessionServerResponse = 2542,
    k_EMsgGCToGCGetUserServerMembers = 2543,
    k_EMsgGCToGCGetUserServerMembersResponse = 2544,
    k_EMsgGCToGCGrantSelfMadeItemToAccount = 2555,
    k_EMsgGCToGCThankedByNewUser = 2556,
    k_EMsgGCShuffleCrateContents = 2557,
    k_EMsgGCQuestObjective_Progress = 2558,
    k_EMsgGCQuestCompleted = 2559,
    k_EMsgGCApplyDuckToken = 2560,
    k_EMsgGCQuestObjective_PointsChange = 2562,
    k_EMsgGCQuestObjective_RequestLoanerItems = 2564,
    k_EMsgGCQuestObjective_RequestLoanerResponse = 2565,
    k_EMsgGCApplyStrangeCountTransfer = 2566,
    k_EMsgGCCraftCollectionUpgrade = 2567,
    k_EMsgGCCraftHalloweenOffering = 2568,
    k_EMsgGCQuestDiscard_Request = 2569,
    k_EMsgGCRemoveGiftedBy = 2570,
    k_EMsgGCRemoveGiftedByResponse = 2571,
    k_EMsgGCRemoveFestivizer = 2572,
    k_EMsgGCRemoveFestivizerResponse = 2573,
    k_EMsgGCCraftCommonStatClock = 2574,
}

impl ::protobuf::ProtobufEnum for EGCItemMsg {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EGCItemMsg> {
        match value {
            1000 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCBase),
            1001 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCSetSingleItemPosition),
            1002 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCCraft),
            1003 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCCraftResponse),
            1004 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCDelete),
            1005 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCVerifyCacheSubscription),
            1006 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCNameItem),
            1007 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCUnlockCrate),
            1008 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCUnlockCrateResponse),
            1009 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCPaintItem),
            1010 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCPaintItemResponse),
            1011 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCGoldenWrenchBroadcast),
            1012 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCMOTDRequest),
            1013 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCMOTDRequestResponse),
            1019 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCNameBaseItem),
            1020 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCNameBaseItemResponse),
            1021 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRemoveSocketItem_DEPRECATED),
            1022 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRemoveSocketItemResponse_DEPRECATED),
            1023 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCCustomizeItemTexture),
            1024 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCCustomizeItemTextureResponse),
            1025 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCUseItemRequest),
            1026 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCUseItemResponse),
            1029 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRespawnPostLoadoutChange),
            1030 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRemoveItemName),
            1031 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRemoveItemPaint),
            1032 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCGiftWrapItem),
            1033 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCGiftWrapItemResponse),
            1034 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCDeliverGift),
            1036 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCDeliverGiftResponseReceiver),
            1037 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCUnwrapGiftRequest),
            1038 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCUnwrapGiftResponse),
            1039 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCSetItemStyle),
            1040 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCUsedClaimCodeItem),
            1041 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCSortItems),
            1042 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGC_RevolvingLootList_DEPRECATED),
            1043 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCLookupAccount),
            1044 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCLookupAccountResponse),
            1045 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCLookupAccountName),
            1046 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCLookupAccountNameResponse),
            1049 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCUpdateItemSchema),
            1050 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRequestInventoryRefresh),
            1051 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRemoveCustomTexture),
            1052 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRemoveCustomTextureResponse),
            1053 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRemoveMakersMark),
            1054 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRemoveMakersMarkResponse),
            1055 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRemoveUniqueCraftIndex),
            1056 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRemoveUniqueCraftIndexResponse),
            1057 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCSaxxyBroadcast),
            1058 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCBackpackSortFinished),
            1059 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCAdjustItemEquippedState),
            1061 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCCollectItem),
            1062 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCItemAcknowledged),
            1063 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCPresets_SelectPresetForClass),
            1064 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCPresets_SetItemPosition),
            1065 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGC_ReportAbuse),
            1066 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGC_ReportAbuseResponse),
            1067 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCPresets_SelectPresetForClassReply),
            1068 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCNameItemNotification),
            1069 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCClientDisplayNotification),
            1070 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCApplyStrangePart),
            1071 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGC_IncrementKillCountAttribute),
            1072 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGC_IncrementKillCountResponse),
            1073 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRemoveStrangePart),
            1074 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCResetStrangeScores),
            1075 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCGiftedItems),
            1077 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCApplyUpgradeCard),
            1078 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRemoveUpgradeCard),
            1079 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCApplyStrangeRestriction),
            1080 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCClientRequestMarketData),
            1081 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCClientRequestMarketDataResponse),
            1082 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCApplyXifier),
            1083 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCApplyXifierResponse),
            1084 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGC_TrackUniquePlayerPairEvent),
            1085 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCFulfillDynamicRecipeComponent),
            1086 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCFulfillDynamicRecipeComponentResponse),
            1087 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCSetItemEffectVerticalOffset),
            1088 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCSetHatEffectUseHeadOrigin),
            1089 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCItemEaterRecharger),
            1090 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCItemEaterRechargerResponse),
            1091 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCApplyBaseItemXifier),
            1092 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCApplyClassTransmogrifier),
            1093 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCApplyHalloweenSpellbookPage),
            1094 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRemoveKillStreak),
            1095 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRemoveKillStreakResponse),
            1096 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCTFSpecificItemBroadcast),
            1097 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGC_IncrementKillCountAttribute_Multiple),
            1098 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCDeliverGiftResponseGiver),
            1100 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCSetItemPositions),
            1101 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCLookupMultipleAccountNames),
            1102 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCLookupMultipleAccountNamesResponse),
            1500 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCTradingBase),
            1501 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCTrading_InitiateTradeRequest),
            1502 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCTrading_InitiateTradeResponse),
            1503 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCTrading_StartSession),
            1509 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCTrading_SessionClosed),
            1510 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCTrading_CancelSession),
            1514 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCTrading_InitiateTradeRequestResponse),
            1601 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCServerBrowser_FavoriteServer),
            1602 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCServerBrowser_BlacklistServer),
            1700 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCServerRentalsBase),
            1701 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCItemPreviewCheckStatus),
            1702 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCItemPreviewStatusResponse),
            1703 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCItemPreviewRequest),
            1704 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCItemPreviewRequestResponse),
            1705 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCItemPreviewExpire),
            1706 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCItemPreviewExpireNotification),
            1708 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCItemPreviewItemBoughtNotification),
            2001 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCDev_NewItemRequest),
            2002 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCDev_NewItemRequestResponse),
            2003 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCDev_DebugRollLootRequest),
            2500 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCStoreGetUserData),
            2501 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCStoreGetUserDataResponse),
            2502 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCStorePurchaseInit_DEPRECATED),
            2503 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCStorePurchaseInitResponse_DEPRECATED),
            2512 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCStorePurchaseFinalize),
            2513 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCStorePurchaseFinalizeResponse),
            2514 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCStorePurchaseCancel),
            2515 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCStorePurchaseCancelResponse),
            2508 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCStorePurchaseQueryTxn),
            2509 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCStorePurchaseQueryTxnResponse),
            2510 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCStorePurchaseInit),
            2511 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCStorePurchaseInitResponse),
            2516 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCDirtySDOCache),
            2517 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCDirtyMultipleSDOCache),
            2518 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCUpdateSQLKeyValue),
            2521 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCBroadcastConsoleCommand),
            2522 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCServerVersionUpdated),
            2523 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCApplyAutograph),
            2524 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCWebAPIAccountChanged),
            2525 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRequestAnnouncements),
            2526 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRequestAnnouncementsResponse),
            2527 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRequestPassportItemGrant),
            2528 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCClientVersionUpdated),
            2531 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCItemPurgatory_FinalizePurchase),
            2532 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCItemPurgatory_FinalizePurchaseResponse),
            2533 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCItemPurgatory_RefundPurchase),
            2534 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCItemPurgatory_RefundPurchaseResponse),
            2535 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCPlayerStrangeCountAdjustments),
            2536 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRequestStoreSalesData),
            2537 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRequestStoreSalesDataResponse),
            2538 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRequestStoreSalesDataUpToDateResponse),
            2539 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCPingRequest),
            2540 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCPingResponse),
            2541 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCGetUserSessionServer),
            2542 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCGetUserSessionServerResponse),
            2543 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCGetUserServerMembers),
            2544 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCGetUserServerMembersResponse),
            2555 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCGrantSelfMadeItemToAccount),
            2556 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCToGCThankedByNewUser),
            2557 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCShuffleCrateContents),
            2558 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCQuestObjective_Progress),
            2559 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCQuestCompleted),
            2560 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCApplyDuckToken),
            2562 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCQuestObjective_PointsChange),
            2564 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCQuestObjective_RequestLoanerItems),
            2565 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCQuestObjective_RequestLoanerResponse),
            2566 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCApplyStrangeCountTransfer),
            2567 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCCraftCollectionUpgrade),
            2568 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCCraftHalloweenOffering),
            2569 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCQuestDiscard_Request),
            2570 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRemoveGiftedBy),
            2571 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRemoveGiftedByResponse),
            2572 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRemoveFestivizer),
            2573 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCRemoveFestivizerResponse),
            2574 => ::std::option::Option::Some(EGCItemMsg::k_EMsgGCCraftCommonStatClock),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EGCItemMsg] = &[
            EGCItemMsg::k_EMsgGCBase,
            EGCItemMsg::k_EMsgGCSetSingleItemPosition,
            EGCItemMsg::k_EMsgGCCraft,
            EGCItemMsg::k_EMsgGCCraftResponse,
            EGCItemMsg::k_EMsgGCDelete,
            EGCItemMsg::k_EMsgGCVerifyCacheSubscription,
            EGCItemMsg::k_EMsgGCNameItem,
            EGCItemMsg::k_EMsgGCUnlockCrate,
            EGCItemMsg::k_EMsgGCUnlockCrateResponse,
            EGCItemMsg::k_EMsgGCPaintItem,
            EGCItemMsg::k_EMsgGCPaintItemResponse,
            EGCItemMsg::k_EMsgGCGoldenWrenchBroadcast,
            EGCItemMsg::k_EMsgGCMOTDRequest,
            EGCItemMsg::k_EMsgGCMOTDRequestResponse,
            EGCItemMsg::k_EMsgGCNameBaseItem,
            EGCItemMsg::k_EMsgGCNameBaseItemResponse,
            EGCItemMsg::k_EMsgGCRemoveSocketItem_DEPRECATED,
            EGCItemMsg::k_EMsgGCRemoveSocketItemResponse_DEPRECATED,
            EGCItemMsg::k_EMsgGCCustomizeItemTexture,
            EGCItemMsg::k_EMsgGCCustomizeItemTextureResponse,
            EGCItemMsg::k_EMsgGCUseItemRequest,
            EGCItemMsg::k_EMsgGCUseItemResponse,
            EGCItemMsg::k_EMsgGCRespawnPostLoadoutChange,
            EGCItemMsg::k_EMsgGCRemoveItemName,
            EGCItemMsg::k_EMsgGCRemoveItemPaint,
            EGCItemMsg::k_EMsgGCGiftWrapItem,
            EGCItemMsg::k_EMsgGCGiftWrapItemResponse,
            EGCItemMsg::k_EMsgGCDeliverGift,
            EGCItemMsg::k_EMsgGCDeliverGiftResponseReceiver,
            EGCItemMsg::k_EMsgGCUnwrapGiftRequest,
            EGCItemMsg::k_EMsgGCUnwrapGiftResponse,
            EGCItemMsg::k_EMsgGCSetItemStyle,
            EGCItemMsg::k_EMsgGCUsedClaimCodeItem,
            EGCItemMsg::k_EMsgGCSortItems,
            EGCItemMsg::k_EMsgGC_RevolvingLootList_DEPRECATED,
            EGCItemMsg::k_EMsgGCLookupAccount,
            EGCItemMsg::k_EMsgGCLookupAccountResponse,
            EGCItemMsg::k_EMsgGCLookupAccountName,
            EGCItemMsg::k_EMsgGCLookupAccountNameResponse,
            EGCItemMsg::k_EMsgGCUpdateItemSchema,
            EGCItemMsg::k_EMsgGCRequestInventoryRefresh,
            EGCItemMsg::k_EMsgGCRemoveCustomTexture,
            EGCItemMsg::k_EMsgGCRemoveCustomTextureResponse,
            EGCItemMsg::k_EMsgGCRemoveMakersMark,
            EGCItemMsg::k_EMsgGCRemoveMakersMarkResponse,
            EGCItemMsg::k_EMsgGCRemoveUniqueCraftIndex,
            EGCItemMsg::k_EMsgGCRemoveUniqueCraftIndexResponse,
            EGCItemMsg::k_EMsgGCSaxxyBroadcast,
            EGCItemMsg::k_EMsgGCBackpackSortFinished,
            EGCItemMsg::k_EMsgGCAdjustItemEquippedState,
            EGCItemMsg::k_EMsgGCCollectItem,
            EGCItemMsg::k_EMsgGCItemAcknowledged,
            EGCItemMsg::k_EMsgGCPresets_SelectPresetForClass,
            EGCItemMsg::k_EMsgGCPresets_SetItemPosition,
            EGCItemMsg::k_EMsgGC_ReportAbuse,
            EGCItemMsg::k_EMsgGC_ReportAbuseResponse,
            EGCItemMsg::k_EMsgGCPresets_SelectPresetForClassReply,
            EGCItemMsg::k_EMsgGCNameItemNotification,
            EGCItemMsg::k_EMsgGCClientDisplayNotification,
            EGCItemMsg::k_EMsgGCApplyStrangePart,
            EGCItemMsg::k_EMsgGC_IncrementKillCountAttribute,
            EGCItemMsg::k_EMsgGC_IncrementKillCountResponse,
            EGCItemMsg::k_EMsgGCRemoveStrangePart,
            EGCItemMsg::k_EMsgGCResetStrangeScores,
            EGCItemMsg::k_EMsgGCGiftedItems,
            EGCItemMsg::k_EMsgGCApplyUpgradeCard,
            EGCItemMsg::k_EMsgGCRemoveUpgradeCard,
            EGCItemMsg::k_EMsgGCApplyStrangeRestriction,
            EGCItemMsg::k_EMsgGCClientRequestMarketData,
            EGCItemMsg::k_EMsgGCClientRequestMarketDataResponse,
            EGCItemMsg::k_EMsgGCApplyXifier,
            EGCItemMsg::k_EMsgGCApplyXifierResponse,
            EGCItemMsg::k_EMsgGC_TrackUniquePlayerPairEvent,
            EGCItemMsg::k_EMsgGCFulfillDynamicRecipeComponent,
            EGCItemMsg::k_EMsgGCFulfillDynamicRecipeComponentResponse,
            EGCItemMsg::k_EMsgGCSetItemEffectVerticalOffset,
            EGCItemMsg::k_EMsgGCSetHatEffectUseHeadOrigin,
            EGCItemMsg::k_EMsgGCItemEaterRecharger,
            EGCItemMsg::k_EMsgGCItemEaterRechargerResponse,
            EGCItemMsg::k_EMsgGCApplyBaseItemXifier,
            EGCItemMsg::k_EMsgGCApplyClassTransmogrifier,
            EGCItemMsg::k_EMsgGCApplyHalloweenSpellbookPage,
            EGCItemMsg::k_EMsgGCRemoveKillStreak,
            EGCItemMsg::k_EMsgGCRemoveKillStreakResponse,
            EGCItemMsg::k_EMsgGCTFSpecificItemBroadcast,
            EGCItemMsg::k_EMsgGC_IncrementKillCountAttribute_Multiple,
            EGCItemMsg::k_EMsgGCDeliverGiftResponseGiver,
            EGCItemMsg::k_EMsgGCSetItemPositions,
            EGCItemMsg::k_EMsgGCLookupMultipleAccountNames,
            EGCItemMsg::k_EMsgGCLookupMultipleAccountNamesResponse,
            EGCItemMsg::k_EMsgGCTradingBase,
            EGCItemMsg::k_EMsgGCTrading_InitiateTradeRequest,
            EGCItemMsg::k_EMsgGCTrading_InitiateTradeResponse,
            EGCItemMsg::k_EMsgGCTrading_StartSession,
            EGCItemMsg::k_EMsgGCTrading_SessionClosed,
            EGCItemMsg::k_EMsgGCTrading_CancelSession,
            EGCItemMsg::k_EMsgGCTrading_InitiateTradeRequestResponse,
            EGCItemMsg::k_EMsgGCServerBrowser_FavoriteServer,
            EGCItemMsg::k_EMsgGCServerBrowser_BlacklistServer,
            EGCItemMsg::k_EMsgGCServerRentalsBase,
            EGCItemMsg::k_EMsgGCItemPreviewCheckStatus,
            EGCItemMsg::k_EMsgGCItemPreviewStatusResponse,
            EGCItemMsg::k_EMsgGCItemPreviewRequest,
            EGCItemMsg::k_EMsgGCItemPreviewRequestResponse,
            EGCItemMsg::k_EMsgGCItemPreviewExpire,
            EGCItemMsg::k_EMsgGCItemPreviewExpireNotification,
            EGCItemMsg::k_EMsgGCItemPreviewItemBoughtNotification,
            EGCItemMsg::k_EMsgGCDev_NewItemRequest,
            EGCItemMsg::k_EMsgGCDev_NewItemRequestResponse,
            EGCItemMsg::k_EMsgGCDev_DebugRollLootRequest,
            EGCItemMsg::k_EMsgGCStoreGetUserData,
            EGCItemMsg::k_EMsgGCStoreGetUserDataResponse,
            EGCItemMsg::k_EMsgGCStorePurchaseInit_DEPRECATED,
            EGCItemMsg::k_EMsgGCStorePurchaseInitResponse_DEPRECATED,
            EGCItemMsg::k_EMsgGCStorePurchaseFinalize,
            EGCItemMsg::k_EMsgGCStorePurchaseFinalizeResponse,
            EGCItemMsg::k_EMsgGCStorePurchaseCancel,
            EGCItemMsg::k_EMsgGCStorePurchaseCancelResponse,
            EGCItemMsg::k_EMsgGCStorePurchaseQueryTxn,
            EGCItemMsg::k_EMsgGCStorePurchaseQueryTxnResponse,
            EGCItemMsg::k_EMsgGCStorePurchaseInit,
            EGCItemMsg::k_EMsgGCStorePurchaseInitResponse,
            EGCItemMsg::k_EMsgGCToGCDirtySDOCache,
            EGCItemMsg::k_EMsgGCToGCDirtyMultipleSDOCache,
            EGCItemMsg::k_EMsgGCToGCUpdateSQLKeyValue,
            EGCItemMsg::k_EMsgGCToGCBroadcastConsoleCommand,
            EGCItemMsg::k_EMsgGCServerVersionUpdated,
            EGCItemMsg::k_EMsgGCApplyAutograph,
            EGCItemMsg::k_EMsgGCToGCWebAPIAccountChanged,
            EGCItemMsg::k_EMsgGCRequestAnnouncements,
            EGCItemMsg::k_EMsgGCRequestAnnouncementsResponse,
            EGCItemMsg::k_EMsgGCRequestPassportItemGrant,
            EGCItemMsg::k_EMsgGCClientVersionUpdated,
            EGCItemMsg::k_EMsgGCItemPurgatory_FinalizePurchase,
            EGCItemMsg::k_EMsgGCItemPurgatory_FinalizePurchaseResponse,
            EGCItemMsg::k_EMsgGCItemPurgatory_RefundPurchase,
            EGCItemMsg::k_EMsgGCItemPurgatory_RefundPurchaseResponse,
            EGCItemMsg::k_EMsgGCToGCPlayerStrangeCountAdjustments,
            EGCItemMsg::k_EMsgGCRequestStoreSalesData,
            EGCItemMsg::k_EMsgGCRequestStoreSalesDataResponse,
            EGCItemMsg::k_EMsgGCRequestStoreSalesDataUpToDateResponse,
            EGCItemMsg::k_EMsgGCToGCPingRequest,
            EGCItemMsg::k_EMsgGCToGCPingResponse,
            EGCItemMsg::k_EMsgGCToGCGetUserSessionServer,
            EGCItemMsg::k_EMsgGCToGCGetUserSessionServerResponse,
            EGCItemMsg::k_EMsgGCToGCGetUserServerMembers,
            EGCItemMsg::k_EMsgGCToGCGetUserServerMembersResponse,
            EGCItemMsg::k_EMsgGCToGCGrantSelfMadeItemToAccount,
            EGCItemMsg::k_EMsgGCToGCThankedByNewUser,
            EGCItemMsg::k_EMsgGCShuffleCrateContents,
            EGCItemMsg::k_EMsgGCQuestObjective_Progress,
            EGCItemMsg::k_EMsgGCQuestCompleted,
            EGCItemMsg::k_EMsgGCApplyDuckToken,
            EGCItemMsg::k_EMsgGCQuestObjective_PointsChange,
            EGCItemMsg::k_EMsgGCQuestObjective_RequestLoanerItems,
            EGCItemMsg::k_EMsgGCQuestObjective_RequestLoanerResponse,
            EGCItemMsg::k_EMsgGCApplyStrangeCountTransfer,
            EGCItemMsg::k_EMsgGCCraftCollectionUpgrade,
            EGCItemMsg::k_EMsgGCCraftHalloweenOffering,
            EGCItemMsg::k_EMsgGCQuestDiscard_Request,
            EGCItemMsg::k_EMsgGCRemoveGiftedBy,
            EGCItemMsg::k_EMsgGCRemoveGiftedByResponse,
            EGCItemMsg::k_EMsgGCRemoveFestivizer,
            EGCItemMsg::k_EMsgGCRemoveFestivizerResponse,
            EGCItemMsg::k_EMsgGCCraftCommonStatClock,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<EGCItemMsg>("EGCItemMsg", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for EGCItemMsg {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EGCItemMsg {
    fn default() -> Self {
        EGCItemMsg::k_EMsgGCBase
    }
}

impl ::protobuf::reflect::ProtobufValue for EGCItemMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EGCMsgResponse {
    k_EGCMsgResponseOK = 0,
    k_EGCMsgResponseDenied = 1,
    k_EGCMsgResponseServerError = 2,
    k_EGCMsgResponseTimeout = 3,
    k_EGCMsgResponseInvalid = 4,
    k_EGCMsgResponseNoMatch = 5,
    k_EGCMsgResponseUnknownError = 6,
    k_EGCMsgResponseNotLoggedOn = 7,
    k_EGCMsgFailedToCreate = 8,
}

impl ::protobuf::ProtobufEnum for EGCMsgResponse {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EGCMsgResponse> {
        match value {
            0 => ::std::option::Option::Some(EGCMsgResponse::k_EGCMsgResponseOK),
            1 => ::std::option::Option::Some(EGCMsgResponse::k_EGCMsgResponseDenied),
            2 => ::std::option::Option::Some(EGCMsgResponse::k_EGCMsgResponseServerError),
            3 => ::std::option::Option::Some(EGCMsgResponse::k_EGCMsgResponseTimeout),
            4 => ::std::option::Option::Some(EGCMsgResponse::k_EGCMsgResponseInvalid),
            5 => ::std::option::Option::Some(EGCMsgResponse::k_EGCMsgResponseNoMatch),
            6 => ::std::option::Option::Some(EGCMsgResponse::k_EGCMsgResponseUnknownError),
            7 => ::std::option::Option::Some(EGCMsgResponse::k_EGCMsgResponseNotLoggedOn),
            8 => ::std::option::Option::Some(EGCMsgResponse::k_EGCMsgFailedToCreate),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EGCMsgResponse] = &[
            EGCMsgResponse::k_EGCMsgResponseOK,
            EGCMsgResponse::k_EGCMsgResponseDenied,
            EGCMsgResponse::k_EGCMsgResponseServerError,
            EGCMsgResponse::k_EGCMsgResponseTimeout,
            EGCMsgResponse::k_EGCMsgResponseInvalid,
            EGCMsgResponse::k_EGCMsgResponseNoMatch,
            EGCMsgResponse::k_EGCMsgResponseUnknownError,
            EGCMsgResponse::k_EGCMsgResponseNotLoggedOn,
            EGCMsgResponse::k_EGCMsgFailedToCreate,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<EGCMsgResponse>("EGCMsgResponse", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for EGCMsgResponse {
}

impl ::std::default::Default for EGCMsgResponse {
    fn default() -> Self {
        EGCMsgResponse::k_EGCMsgResponseOK
    }
}

impl ::protobuf::reflect::ProtobufValue for EGCMsgResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EUnlockStyle {
    k_UnlockStyle_Succeeded = 0,
    k_UnlockStyle_Failed_PreReq = 1,
    k_UnlockStyle_Failed_CantAfford = 2,
    k_UnlockStyle_Failed_CantCommit = 3,
    k_UnlockStyle_Failed_CantLockCache = 4,
    k_UnlockStyle_Failed_CantAffordAttrib = 5,
    k_UnlockStyle_Failed_CantAffordGem = 6,
}

impl ::protobuf::ProtobufEnum for EUnlockStyle {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EUnlockStyle> {
        match value {
            0 => ::std::option::Option::Some(EUnlockStyle::k_UnlockStyle_Succeeded),
            1 => ::std::option::Option::Some(EUnlockStyle::k_UnlockStyle_Failed_PreReq),
            2 => ::std::option::Option::Some(EUnlockStyle::k_UnlockStyle_Failed_CantAfford),
            3 => ::std::option::Option::Some(EUnlockStyle::k_UnlockStyle_Failed_CantCommit),
            4 => ::std::option::Option::Some(EUnlockStyle::k_UnlockStyle_Failed_CantLockCache),
            5 => ::std::option::Option::Some(EUnlockStyle::k_UnlockStyle_Failed_CantAffordAttrib),
            6 => ::std::option::Option::Some(EUnlockStyle::k_UnlockStyle_Failed_CantAffordGem),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EUnlockStyle] = &[
            EUnlockStyle::k_UnlockStyle_Succeeded,
            EUnlockStyle::k_UnlockStyle_Failed_PreReq,
            EUnlockStyle::k_UnlockStyle_Failed_CantAfford,
            EUnlockStyle::k_UnlockStyle_Failed_CantCommit,
            EUnlockStyle::k_UnlockStyle_Failed_CantLockCache,
            EUnlockStyle::k_UnlockStyle_Failed_CantAffordAttrib,
            EUnlockStyle::k_UnlockStyle_Failed_CantAffordGem,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<EUnlockStyle>("EUnlockStyle", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for EUnlockStyle {
}

impl ::std::default::Default for EUnlockStyle {
    fn default() -> Self {
        EUnlockStyle::k_UnlockStyle_Succeeded
    }
}

impl ::protobuf::reflect::ProtobufValue for EUnlockStyle {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EItemPurgatoryResponse_Finalize {
    k_ItemPurgatoryResponse_Finalize_Succeeded = 0,
    k_ItemPurgatoryResponse_Finalize_Failed_Incomplete = 1,
    k_ItemPurgatoryResponse_Finalize_Failed_ItemsNotInPurgatory = 2,
    k_ItemPurgatoryResponse_Finalize_Failed_CouldNotFindItems = 3,
    k_ItemPurgatoryResponse_Finalize_Failed_NoSOCache = 4,
    k_ItemPurgatoryResponse_Finalize_BackpackFull = 5,
}

impl ::protobuf::ProtobufEnum for EItemPurgatoryResponse_Finalize {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EItemPurgatoryResponse_Finalize> {
        match value {
            0 => ::std::option::Option::Some(EItemPurgatoryResponse_Finalize::k_ItemPurgatoryResponse_Finalize_Succeeded),
            1 => ::std::option::Option::Some(EItemPurgatoryResponse_Finalize::k_ItemPurgatoryResponse_Finalize_Failed_Incomplete),
            2 => ::std::option::Option::Some(EItemPurgatoryResponse_Finalize::k_ItemPurgatoryResponse_Finalize_Failed_ItemsNotInPurgatory),
            3 => ::std::option::Option::Some(EItemPurgatoryResponse_Finalize::k_ItemPurgatoryResponse_Finalize_Failed_CouldNotFindItems),
            4 => ::std::option::Option::Some(EItemPurgatoryResponse_Finalize::k_ItemPurgatoryResponse_Finalize_Failed_NoSOCache),
            5 => ::std::option::Option::Some(EItemPurgatoryResponse_Finalize::k_ItemPurgatoryResponse_Finalize_BackpackFull),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EItemPurgatoryResponse_Finalize] = &[
            EItemPurgatoryResponse_Finalize::k_ItemPurgatoryResponse_Finalize_Succeeded,
            EItemPurgatoryResponse_Finalize::k_ItemPurgatoryResponse_Finalize_Failed_Incomplete,
            EItemPurgatoryResponse_Finalize::k_ItemPurgatoryResponse_Finalize_Failed_ItemsNotInPurgatory,
            EItemPurgatoryResponse_Finalize::k_ItemPurgatoryResponse_Finalize_Failed_CouldNotFindItems,
            EItemPurgatoryResponse_Finalize::k_ItemPurgatoryResponse_Finalize_Failed_NoSOCache,
            EItemPurgatoryResponse_Finalize::k_ItemPurgatoryResponse_Finalize_BackpackFull,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<EItemPurgatoryResponse_Finalize>("EItemPurgatoryResponse_Finalize", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for EItemPurgatoryResponse_Finalize {
}

impl ::std::default::Default for EItemPurgatoryResponse_Finalize {
    fn default() -> Self {
        EItemPurgatoryResponse_Finalize::k_ItemPurgatoryResponse_Finalize_Succeeded
    }
}

impl ::protobuf::reflect::ProtobufValue for EItemPurgatoryResponse_Finalize {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EItemPurgatoryResponse_Refund {
    k_ItemPurgatoryResponse_Refund_Succeeded = 0,
    k_ItemPurgatoryResponse_Refund_Failed_ItemNotInPurgatory = 1,
    k_ItemPurgatoryResponse_Refund_Failed_CouldNotFindItem = 2,
    k_ItemPurgatoryResponse_Refund_Failed_NoSOCache = 3,
    k_ItemPurgatoryResponse_Refund_Failed_NoDetail = 4,
    k_ItemPurgatoryResponse_Refund_Failed_NexonWebAPI = 5,
}

impl ::protobuf::ProtobufEnum for EItemPurgatoryResponse_Refund {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EItemPurgatoryResponse_Refund> {
        match value {
            0 => ::std::option::Option::Some(EItemPurgatoryResponse_Refund::k_ItemPurgatoryResponse_Refund_Succeeded),
            1 => ::std::option::Option::Some(EItemPurgatoryResponse_Refund::k_ItemPurgatoryResponse_Refund_Failed_ItemNotInPurgatory),
            2 => ::std::option::Option::Some(EItemPurgatoryResponse_Refund::k_ItemPurgatoryResponse_Refund_Failed_CouldNotFindItem),
            3 => ::std::option::Option::Some(EItemPurgatoryResponse_Refund::k_ItemPurgatoryResponse_Refund_Failed_NoSOCache),
            4 => ::std::option::Option::Some(EItemPurgatoryResponse_Refund::k_ItemPurgatoryResponse_Refund_Failed_NoDetail),
            5 => ::std::option::Option::Some(EItemPurgatoryResponse_Refund::k_ItemPurgatoryResponse_Refund_Failed_NexonWebAPI),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EItemPurgatoryResponse_Refund] = &[
            EItemPurgatoryResponse_Refund::k_ItemPurgatoryResponse_Refund_Succeeded,
            EItemPurgatoryResponse_Refund::k_ItemPurgatoryResponse_Refund_Failed_ItemNotInPurgatory,
            EItemPurgatoryResponse_Refund::k_ItemPurgatoryResponse_Refund_Failed_CouldNotFindItem,
            EItemPurgatoryResponse_Refund::k_ItemPurgatoryResponse_Refund_Failed_NoSOCache,
            EItemPurgatoryResponse_Refund::k_ItemPurgatoryResponse_Refund_Failed_NoDetail,
            EItemPurgatoryResponse_Refund::k_ItemPurgatoryResponse_Refund_Failed_NexonWebAPI,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<EItemPurgatoryResponse_Refund>("EItemPurgatoryResponse_Refund", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for EItemPurgatoryResponse_Refund {
}

impl ::std::default::Default for EItemPurgatoryResponse_Refund {
    fn default() -> Self {
        EItemPurgatoryResponse_Refund::k_ItemPurgatoryResponse_Refund_Succeeded
    }
}

impl ::protobuf::reflect::ProtobufValue for EItemPurgatoryResponse_Refund {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x15econ_gcmessages.proto\x1a\x13steammessages.proto\"b\n\x12CMsgApply\
    Autograph\x12*\n\x11autograph_item_id\x18\x01\x20\x01(\x04R\x0fautograph\
    ItemId\x12\x20\n\x0citem_item_id\x18\x02\x20\x01(\x04R\nitemItemId\"\xb3\
    \x02\n$CMsgEconPlayerStrangeCountAdjustment\x12\x1d\n\naccount_id\x18\
    \x01\x20\x01(\rR\taccountId\x12y\n\x19strange_count_adjustments\x18\x02\
    \x20\x03(\x0b2=.CMsgEconPlayerStrangeCountAdjustment.CStrangeCountAdjust\
    mentR\x17strangeCountAdjustments\x1aq\n\x17CStrangeCountAdjustment\x12\
    \x1d\n\nevent_type\x18\x01\x20\x01(\rR\teventType\x12\x17\n\x07item_id\
    \x18\x02\x20\x01(\x04R\x06itemId\x12\x1e\n\nadjustment\x18\x03\x20\x01(\
    \rR\nadjustment\"F\n)CMsgRequestItemPurgatory_FinalizePurchase\x12\x19\n\
    \x08item_ids\x18\x01\x20\x03(\x04R\x07itemIds\"K\n1CMsgRequestItemPurgat\
    ory_FinalizePurchaseResponse\x12\x16\n\x06result\x18\x01\x20\x01(\rR\x06\
    result\"B\n'CMsgRequestItemPurgatory_RefundPurchase\x12\x17\n\x07item_id\
    \x18\x01\x20\x01(\x04R\x06itemId\"I\n/CMsgRequestItemPurgatory_RefundPur\
    chaseResponse\x12\x16\n\x06result\x18\x01\x20\x01(\rR\x06result\"1\n\x14\
    CMsgCraftingResponse\x12\x19\n\x08item_ids\x18\x01\x20\x03(\x04R\x07item\
    Ids\"S\n\x1bCMsgGCRequestStoreSalesData\x12\x18\n\x07version\x18\x01\x20\
    \x01(\rR\x07version\x12\x1a\n\x08currency\x18\x02\x20\x01(\rR\x08currenc\
    y\"\xed\x01\n#CMsgGCRequestStoreSalesDataResponse\x12I\n\nsale_price\x18\
    \x01\x20\x03(\x0b2*.CMsgGCRequestStoreSalesDataResponse.PriceR\tsalePric\
    e\x12\x18\n\x07version\x18\x02\x20\x01(\rR\x07version\x12'\n\x0fexpirati\
    on_time\x18\x03\x20\x01(\rR\x0eexpirationTime\x1a8\n\x05Price\x12\x19\n\
    \x08item_def\x18\x01\x20\x01(\rR\x07itemDef\x12\x14\n\x05price\x18\x02\
    \x20\x01(\rR\x05price\"p\n+CMsgGCRequestStoreSalesDataUpToDateResponse\
    \x12\x18\n\x07version\x18\x01\x20\x01(\rR\x07version\x12'\n\x0fexpiratio\
    n_time\x18\x02\x20\x01(\rR\x0eexpirationTime\"\x17\n\x15CMsgGCToGCPingRe\
    quest\"\x18\n\x16CMsgGCToGCPingResponse\"?\n\x1eCMsgGCToGCGetUserSession\
    Server\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\"P\n&CMsgGCT\
    oGCGetUserSessionServerResponse\x12&\n\x0fserver_steam_id\x18\x01\x20\
    \x01(\x06R\rserverSteamId\"f\n\x1eCMsgGCToGCGetUserServerMembers\x12\x1d\
    \n\naccount_id\x18\x01\x20\x01(\rR\taccountId\x12%\n\x0emax_spectators\
    \x18\x02\x20\x01(\rR\rmaxSpectators\"T\n&CMsgGCToGCGetUserServerMembersR\
    esponse\x12*\n\x11member_account_id\x18\x01\x20\x03(\rR\x0fmemberAccount\
    Id\"D\n\x1eCMsgLookupMultipleAccountNames\x12\"\n\naccountids\x18\x01\
    \x20\x03(\rR\naccountidsB\x02\x10\x01\"\xb8\x01\n&CMsgLookupMultipleAcco\
    untNamesResponse\x12K\n\x08accounts\x18\x01\x20\x03(\x0b2/.CMsgLookupMul\
    tipleAccountNamesResponse.AccountR\x08accounts\x1aA\n\x07Account\x12\x1c\
    \n\taccountid\x18\x01\x20\x01(\rR\taccountid\x12\x18\n\x07persona\x18\
    \x02\x20\x01(\tR\x07persona\"j\n$CMsgGCToGCGrantSelfMadeItemToAccount\
    \x12$\n\x0eitem_def_index\x18\x01\x20\x01(\rR\x0citemDefIndex\x12\x1c\n\
    \taccountid\x18\x02\x20\x01(\rR\taccountid\"\x80\x01\n\x1aCMsgGCToGCThan\
    kedByNewUser\x12,\n\x12new_user_accountid\x18\x01\x20\x01(\rR\x10newUser\
    Accountid\x124\n\x16thanked_user_accountid\x18\x02\x20\x01(\rR\x14thanke\
    dUserAccountid\"j\n\x1aCMsgGCShuffleCrateContents\x12\"\n\rcrate_item_id\
    \x18\x01\x20\x01(\x04R\x0bcrateItemId\x12(\n\x10user_code_string\x18\x02\
    \x20\x01(\tR\x0euserCodeString\"\xa3\x01\n\x1dCMsgGCQuestObjective_Progr\
    ess\x12\x19\n\x08quest_id\x18\x01\x20\x01(\x04R\x07questId\x12,\n\x12que\
    st_attrib_index\x18\x02\x20\x01(\rR\x10questAttribIndex\x12\x14\n\x05del\
    ta\x18\x03\x20\x01(\rR\x05delta\x12#\n\rowner_steamid\x18\x04\x20\x01(\
    \x06R\x0cownerSteamid\"\xe9\x01\n!CMsgGCQuestObjective_PointsChange\x12\
    \x19\n\x08quest_id\x18\x01\x20\x01(\x04R\x07questId\x12#\n\rowner_steami\
    d\x18\x04\x20\x01(\x06R\x0cownerSteamid\x123\n\x12update_base_points\x18\
    \x05\x20\x01(\x08:\x05falseR\x10updateBasePoints\x12\x19\n\x08points_0\
    \x18\x06\x20\x01(\rR\x07points0\x12\x19\n\x08points_1\x18\x07\x20\x01(\r\
    R\x07points1\x12\x19\n\x08points_2\x18\x08\x20\x01(\rR\x07points2\"8\n\
    \x1bCMsgGCQuestComplete_Request\x12\x19\n\x08quest_id\x18\x01\x20\x01(\
    \x04R\x07questId\"\x16\n\x14CMsgGCQuestCompleted\"D\n'CMsgGCQuestObjecti\
    ve_RequestLoanerItems\x12\x19\n\x08quest_id\x18\x01\x20\x01(\x04R\x07que\
    stId\",\n*CMsgGCQuestObjective_RequestLoanerResponse\"5\n\x1aCMsgCraftCo\
    llectionUpgrade\x12\x17\n\x07item_id\x18\x01\x20\x03(\x04R\x06itemId\"N\
    \n\x1aCMsgCraftHalloweenOffering\x12\x17\n\x07tool_id\x18\x01\x20\x01(\
    \x04R\x06toolId\x12\x17\n\x07item_id\x18\x02\x20\x03(\x04R\x06itemId\"L\
    \n\x18CMsgCraftCommonStatClock\x12\x17\n\x07tool_id\x18\x01\x20\x01(\x04\
    R\x06toolId\x12\x17\n\x07item_id\x18\x02\x20\x03(\x04R\x06itemId\"7\n\
    \x1aCMsgGCQuestDiscard_Request\x12\x19\n\x08quest_id\x18\x01\x20\x01(\
    \x04R\x07questId*\xcb/\n\nEGCItemMsg\x12\x11\n\x0ck_EMsgGCBase\x10\xe8\
    \x07\x12\"\n\x1dk_EMsgGCSetSingleItemPosition\x10\xe9\x07\x12\x12\n\rk_E\
    MsgGCCraft\x10\xea\x07\x12\x1a\n\x15k_EMsgGCCraftResponse\x10\xeb\x07\
    \x12\x13\n\x0ek_EMsgGCDelete\x10\xec\x07\x12$\n\x1fk_EMsgGCVerifyCacheSu\
    bscription\x10\xed\x07\x12\x15\n\x10k_EMsgGCNameItem\x10\xee\x07\x12\x18\
    \n\x13k_EMsgGCUnlockCrate\x10\xef\x07\x12\x20\n\x1bk_EMsgGCUnlockCrateRe\
    sponse\x10\xf0\x07\x12\x16\n\x11k_EMsgGCPaintItem\x10\xf1\x07\x12\x1e\n\
    \x19k_EMsgGCPaintItemResponse\x10\xf2\x07\x12\"\n\x1dk_EMsgGCGoldenWrenc\
    hBroadcast\x10\xf3\x07\x12\x18\n\x13k_EMsgGCMOTDRequest\x10\xf4\x07\x12\
    \x20\n\x1bk_EMsgGCMOTDRequestResponse\x10\xf5\x07\x12\x19\n\x14k_EMsgGCN\
    ameBaseItem\x10\xfb\x07\x12!\n\x1ck_EMsgGCNameBaseItemResponse\x10\xfc\
    \x07\x12(\n#k_EMsgGCRemoveSocketItem_DEPRECATED\x10\xfd\x07\x120\n+k_EMs\
    gGCRemoveSocketItemResponse_DEPRECATED\x10\xfe\x07\x12!\n\x1ck_EMsgGCCus\
    tomizeItemTexture\x10\xff\x07\x12)\n$k_EMsgGCCustomizeItemTextureRespons\
    e\x10\x80\x08\x12\x1b\n\x16k_EMsgGCUseItemRequest\x10\x81\x08\x12\x1c\n\
    \x17k_EMsgGCUseItemResponse\x10\x82\x08\x12%\n\x20k_EMsgGCRespawnPostLoa\
    doutChange\x10\x85\x08\x12\x1b\n\x16k_EMsgGCRemoveItemName\x10\x86\x08\
    \x12\x1c\n\x17k_EMsgGCRemoveItemPaint\x10\x87\x08\x12\x19\n\x14k_EMsgGCG\
    iftWrapItem\x10\x88\x08\x12!\n\x1ck_EMsgGCGiftWrapItemResponse\x10\x89\
    \x08\x12\x18\n\x13k_EMsgGCDeliverGift\x10\x8a\x08\x12(\n#k_EMsgGCDeliver\
    GiftResponseReceiver\x10\x8c\x08\x12\x1e\n\x19k_EMsgGCUnwrapGiftRequest\
    \x10\x8d\x08\x12\x1f\n\x1ak_EMsgGCUnwrapGiftResponse\x10\x8e\x08\x12\x19\
    \n\x14k_EMsgGCSetItemStyle\x10\x8f\x08\x12\x1e\n\x19k_EMsgGCUsedClaimCod\
    eItem\x10\x90\x08\x12\x16\n\x11k_EMsgGCSortItems\x10\x91\x08\x12*\n%k_EM\
    sgGC_RevolvingLootList_DEPRECATED\x10\x92\x08\x12\x1a\n\x15k_EMsgGCLooku\
    pAccount\x10\x93\x08\x12\"\n\x1dk_EMsgGCLookupAccountResponse\x10\x94\
    \x08\x12\x1e\n\x19k_EMsgGCLookupAccountName\x10\x95\x08\x12&\n!k_EMsgGCL\
    ookupAccountNameResponse\x10\x96\x08\x12\x1d\n\x18k_EMsgGCUpdateItemSche\
    ma\x10\x99\x08\x12$\n\x1fk_EMsgGCRequestInventoryRefresh\x10\x9a\x08\x12\
    \x20\n\x1bk_EMsgGCRemoveCustomTexture\x10\x9b\x08\x12(\n#k_EMsgGCRemoveC\
    ustomTextureResponse\x10\x9c\x08\x12\x1d\n\x18k_EMsgGCRemoveMakersMark\
    \x10\x9d\x08\x12%\n\x20k_EMsgGCRemoveMakersMarkResponse\x10\x9e\x08\x12#\
    \n\x1ek_EMsgGCRemoveUniqueCraftIndex\x10\x9f\x08\x12+\n&k_EMsgGCRemoveUn\
    iqueCraftIndexResponse\x10\xa0\x08\x12\x1b\n\x16k_EMsgGCSaxxyBroadcast\
    \x10\xa1\x08\x12!\n\x1ck_EMsgGCBackpackSortFinished\x10\xa2\x08\x12$\n\
    \x1fk_EMsgGCAdjustItemEquippedState\x10\xa3\x08\x12\x18\n\x13k_EMsgGCCol\
    lectItem\x10\xa5\x08\x12\x1d\n\x18k_EMsgGCItemAcknowledged\x10\xa6\x08\
    \x12)\n$k_EMsgGCPresets_SelectPresetForClass\x10\xa7\x08\x12$\n\x1fk_EMs\
    gGCPresets_SetItemPosition\x10\xa8\x08\x12\x19\n\x14k_EMsgGC_ReportAbuse\
    \x10\xa9\x08\x12!\n\x1ck_EMsgGC_ReportAbuseResponse\x10\xaa\x08\x12.\n)k\
    _EMsgGCPresets_SelectPresetForClassReply\x10\xab\x08\x12!\n\x1ck_EMsgGCN\
    ameItemNotification\x10\xac\x08\x12&\n!k_EMsgGCClientDisplayNotification\
    \x10\xad\x08\x12\x1d\n\x18k_EMsgGCApplyStrangePart\x10\xae\x08\x12)\n$k_\
    EMsgGC_IncrementKillCountAttribute\x10\xaf\x08\x12(\n#k_EMsgGC_Increment\
    KillCountResponse\x10\xb0\x08\x12\x1e\n\x19k_EMsgGCRemoveStrangePart\x10\
    \xb1\x08\x12\x1f\n\x1ak_EMsgGCResetStrangeScores\x10\xb2\x08\x12\x18\n\
    \x13k_EMsgGCGiftedItems\x10\xb3\x08\x12\x1d\n\x18k_EMsgGCApplyUpgradeCar\
    d\x10\xb5\x08\x12\x1e\n\x19k_EMsgGCRemoveUpgradeCard\x10\xb6\x08\x12$\n\
    \x1fk_EMsgGCApplyStrangeRestriction\x10\xb7\x08\x12$\n\x1fk_EMsgGCClient\
    RequestMarketData\x10\xb8\x08\x12,\n'k_EMsgGCClientRequestMarketDataResp\
    onse\x10\xb9\x08\x12\x18\n\x13k_EMsgGCApplyXifier\x10\xba\x08\x12\x20\n\
    \x1bk_EMsgGCApplyXifierResponse\x10\xbb\x08\x12(\n#k_EMsgGC_TrackUniqueP\
    layerPairEvent\x10\xbc\x08\x12*\n%k_EMsgGCFulfillDynamicRecipeComponent\
    \x10\xbd\x08\x122\n-k_EMsgGCFulfillDynamicRecipeComponentResponse\x10\
    \xbe\x08\x12(\n#k_EMsgGCSetItemEffectVerticalOffset\x10\xbf\x08\x12&\n!k\
    _EMsgGCSetHatEffectUseHeadOrigin\x10\xc0\x08\x12\x1f\n\x1ak_EMsgGCItemEa\
    terRecharger\x10\xc1\x08\x12'\n\"k_EMsgGCItemEaterRechargerResponse\x10\
    \xc2\x08\x12\x20\n\x1bk_EMsgGCApplyBaseItemXifier\x10\xc3\x08\x12%\n\x20\
    k_EMsgGCApplyClassTransmogrifier\x10\xc4\x08\x12(\n#k_EMsgGCApplyHallowe\
    enSpellbookPage\x10\xc5\x08\x12\x1d\n\x18k_EMsgGCRemoveKillStreak\x10\
    \xc6\x08\x12%\n\x20k_EMsgGCRemoveKillStreakResponse\x10\xc7\x08\x12$\n\
    \x1fk_EMsgGCTFSpecificItemBroadcast\x10\xc8\x08\x122\n-k_EMsgGC_Incremen\
    tKillCountAttribute_Multiple\x10\xc9\x08\x12%\n\x20k_EMsgGCDeliverGiftRe\
    sponseGiver\x10\xca\x08\x12\x1d\n\x18k_EMsgGCSetItemPositions\x10\xcc\
    \x08\x12'\n\"k_EMsgGCLookupMultipleAccountNames\x10\xcd\x08\x12/\n*k_EMs\
    gGCLookupMultipleAccountNamesResponse\x10\xce\x08\x12\x18\n\x13k_EMsgGCT\
    radingBase\x10\xdc\x0b\x12)\n$k_EMsgGCTrading_InitiateTradeRequest\x10\
    \xdd\x0b\x12*\n%k_EMsgGCTrading_InitiateTradeResponse\x10\xde\x0b\x12!\n\
    \x1ck_EMsgGCTrading_StartSession\x10\xdf\x0b\x12\"\n\x1dk_EMsgGCTrading_\
    SessionClosed\x10\xe5\x0b\x12\"\n\x1dk_EMsgGCTrading_CancelSession\x10\
    \xe6\x0b\x121\n,k_EMsgGCTrading_InitiateTradeRequestResponse\x10\xea\x0b\
    \x12)\n$k_EMsgGCServerBrowser_FavoriteServer\x10\xc1\x0c\x12*\n%k_EMsgGC\
    ServerBrowser_BlacklistServer\x10\xc2\x0c\x12\x1e\n\x19k_EMsgGCServerRen\
    talsBase\x10\xa4\r\x12#\n\x1ek_EMsgGCItemPreviewCheckStatus\x10\xa5\r\
    \x12&\n!k_EMsgGCItemPreviewStatusResponse\x10\xa6\r\x12\x1f\n\x1ak_EMsgG\
    CItemPreviewRequest\x10\xa7\r\x12'\n\"k_EMsgGCItemPreviewRequestResponse\
    \x10\xa8\r\x12\x1e\n\x19k_EMsgGCItemPreviewExpire\x10\xa9\r\x12*\n%k_EMs\
    gGCItemPreviewExpireNotification\x10\xaa\r\x12.\n)k_EMsgGCItemPreviewIte\
    mBoughtNotification\x10\xac\r\x12\x1f\n\x1ak_EMsgGCDev_NewItemRequest\
    \x10\xd1\x0f\x12'\n\"k_EMsgGCDev_NewItemRequestResponse\x10\xd2\x0f\x12%\
    \n\x20k_EMsgGCDev_DebugRollLootRequest\x10\xd3\x0f\x12\x1d\n\x18k_EMsgGC\
    StoreGetUserData\x10\xc4\x13\x12%\n\x20k_EMsgGCStoreGetUserDataResponse\
    \x10\xc5\x13\x12)\n$k_EMsgGCStorePurchaseInit_DEPRECATED\x10\xc6\x13\x12\
    1\n,k_EMsgGCStorePurchaseInitResponse_DEPRECATED\x10\xc7\x13\x12\"\n\x1d\
    k_EMsgGCStorePurchaseFinalize\x10\xd0\x13\x12*\n%k_EMsgGCStorePurchaseFi\
    nalizeResponse\x10\xd1\x13\x12\x20\n\x1bk_EMsgGCStorePurchaseCancel\x10\
    \xd2\x13\x12(\n#k_EMsgGCStorePurchaseCancelResponse\x10\xd3\x13\x12\"\n\
    \x1dk_EMsgGCStorePurchaseQueryTxn\x10\xcc\x13\x12*\n%k_EMsgGCStorePurcha\
    seQueryTxnResponse\x10\xcd\x13\x12\x1e\n\x19k_EMsgGCStorePurchaseInit\
    \x10\xce\x13\x12&\n!k_EMsgGCStorePurchaseInitResponse\x10\xcf\x13\x12\
    \x1e\n\x19k_EMsgGCToGCDirtySDOCache\x10\xd4\x13\x12&\n!k_EMsgGCToGCDirty\
    MultipleSDOCache\x10\xd5\x13\x12\"\n\x1dk_EMsgGCToGCUpdateSQLKeyValue\
    \x10\xd6\x13\x12(\n#k_EMsgGCToGCBroadcastConsoleCommand\x10\xd9\x13\x12!\
    \n\x1ck_EMsgGCServerVersionUpdated\x10\xda\x13\x12\x1b\n\x16k_EMsgGCAppl\
    yAutograph\x10\xdb\x13\x12%\n\x20k_EMsgGCToGCWebAPIAccountChanged\x10\
    \xdc\x13\x12!\n\x1ck_EMsgGCRequestAnnouncements\x10\xdd\x13\x12)\n$k_EMs\
    gGCRequestAnnouncementsResponse\x10\xde\x13\x12%\n\x20k_EMsgGCRequestPas\
    sportItemGrant\x10\xdf\x13\x12!\n\x1ck_EMsgGCClientVersionUpdated\x10\
    \xe0\x13\x12+\n&k_EMsgGCItemPurgatory_FinalizePurchase\x10\xe3\x13\x123\
    \n.k_EMsgGCItemPurgatory_FinalizePurchaseResponse\x10\xe4\x13\x12)\n$k_E\
    MsgGCItemPurgatory_RefundPurchase\x10\xe5\x13\x121\n,k_EMsgGCItemPurgato\
    ry_RefundPurchaseResponse\x10\xe6\x13\x12.\n)k_EMsgGCToGCPlayerStrangeCo\
    untAdjustments\x10\xe7\x13\x12\"\n\x1dk_EMsgGCRequestStoreSalesData\x10\
    \xe8\x13\x12*\n%k_EMsgGCRequestStoreSalesDataResponse\x10\xe9\x13\x122\n\
    -k_EMsgGCRequestStoreSalesDataUpToDateResponse\x10\xea\x13\x12\x1c\n\x17\
    k_EMsgGCToGCPingRequest\x10\xeb\x13\x12\x1d\n\x18k_EMsgGCToGCPingRespons\
    e\x10\xec\x13\x12%\n\x20k_EMsgGCToGCGetUserSessionServer\x10\xed\x13\x12\
    -\n(k_EMsgGCToGCGetUserSessionServerResponse\x10\xee\x13\x12%\n\x20k_EMs\
    gGCToGCGetUserServerMembers\x10\xef\x13\x12-\n(k_EMsgGCToGCGetUserServer\
    MembersResponse\x10\xf0\x13\x12+\n&k_EMsgGCToGCGrantSelfMadeItemToAccoun\
    t\x10\xfb\x13\x12!\n\x1ck_EMsgGCToGCThankedByNewUser\x10\xfc\x13\x12!\n\
    \x1ck_EMsgGCShuffleCrateContents\x10\xfd\x13\x12$\n\x1fk_EMsgGCQuestObje\
    ctive_Progress\x10\xfe\x13\x12\x1b\n\x16k_EMsgGCQuestCompleted\x10\xff\
    \x13\x12\x1b\n\x16k_EMsgGCApplyDuckToken\x10\x80\x14\x12(\n#k_EMsgGCQues\
    tObjective_PointsChange\x10\x82\x14\x12.\n)k_EMsgGCQuestObjective_Reques\
    tLoanerItems\x10\x84\x14\x121\n,k_EMsgGCQuestObjective_RequestLoanerResp\
    onse\x10\x85\x14\x12&\n!k_EMsgGCApplyStrangeCountTransfer\x10\x86\x14\
    \x12#\n\x1ek_EMsgGCCraftCollectionUpgrade\x10\x87\x14\x12#\n\x1ek_EMsgGC\
    CraftHalloweenOffering\x10\x88\x14\x12!\n\x1ck_EMsgGCQuestDiscard_Reques\
    t\x10\x89\x14\x12\x1b\n\x16k_EMsgGCRemoveGiftedBy\x10\x8a\x14\x12#\n\x1e\
    k_EMsgGCRemoveGiftedByResponse\x10\x8b\x14\x12\x1d\n\x18k_EMsgGCRemoveFe\
    stivizer\x10\x8c\x14\x12%\n\x20k_EMsgGCRemoveFestivizerResponse\x10\x8d\
    \x14\x12!\n\x1ck_EMsgGCCraftCommonStatClock\x10\x8e\x14*\x9b\x02\n\x0eEG\
    CMsgResponse\x12\x16\n\x12k_EGCMsgResponseOK\x10\0\x12\x1a\n\x16k_EGCMsg\
    ResponseDenied\x10\x01\x12\x1f\n\x1bk_EGCMsgResponseServerError\x10\x02\
    \x12\x1b\n\x17k_EGCMsgResponseTimeout\x10\x03\x12\x1b\n\x17k_EGCMsgRespo\
    nseInvalid\x10\x04\x12\x1b\n\x17k_EGCMsgResponseNoMatch\x10\x05\x12\x20\
    \n\x1ck_EGCMsgResponseUnknownError\x10\x06\x12\x1f\n\x1bk_EGCMsgResponse\
    NotLoggedOn\x10\x07\x12\x1a\n\x16k_EGCMsgFailedToCreate\x10\x08*\x91\x02\
    \n\x0cEUnlockStyle\x12\x1b\n\x17k_UnlockStyle_Succeeded\x10\0\x12\x1f\n\
    \x1bk_UnlockStyle_Failed_PreReq\x10\x01\x12#\n\x1fk_UnlockStyle_Failed_C\
    antAfford\x10\x02\x12#\n\x1fk_UnlockStyle_Failed_CantCommit\x10\x03\x12&\
    \n\"k_UnlockStyle_Failed_CantLockCache\x10\x04\x12)\n%k_UnlockStyle_Fail\
    ed_CantAffordAttrib\x10\x05\x12&\n\"k_UnlockStyle_Failed_CantAffordGem\
    \x10\x06*\xf3\x02\n\x1fEItemPurgatoryResponse_Finalize\x12.\n*k_ItemPurg\
    atoryResponse_Finalize_Succeeded\x10\0\x126\n2k_ItemPurgatoryResponse_Fi\
    nalize_Failed_Incomplete\x10\x01\x12?\n;k_ItemPurgatoryResponse_Finalize\
    _Failed_ItemsNotInPurgatory\x10\x02\x12=\n9k_ItemPurgatoryResponse_Final\
    ize_Failed_CouldNotFindItems\x10\x03\x125\n1k_ItemPurgatoryResponse_Fina\
    lize_Failed_NoSOCache\x10\x04\x121\n-k_ItemPurgatoryResponse_Finalize_Ba\
    ckpackFull\x10\x05*\xe7\x02\n\x1dEItemPurgatoryResponse_Refund\x12,\n(k_\
    ItemPurgatoryResponse_Refund_Succeeded\x10\0\x12<\n8k_ItemPurgatoryRespo\
    nse_Refund_Failed_ItemNotInPurgatory\x10\x01\x12:\n6k_ItemPurgatoryRespo\
    nse_Refund_Failed_CouldNotFindItem\x10\x02\x123\n/k_ItemPurgatoryRespons\
    e_Refund_Failed_NoSOCache\x10\x03\x122\n.k_ItemPurgatoryResponse_Refund_\
    Failed_NoDetail\x10\x04\x125\n1k_ItemPurgatoryResponse_Refund_Failed_Nex\
    onWebAPI\x10\x05B\x05H\x01\x80\x01\0J\xb1i\n\x07\x12\x05\0\0\xef\x02\x01\
    \n\t\n\x02\x03\0\x12\x03\0\x07\x1c\n\x08\n\x01\x08\x12\x03\x02\0\x1c\n\t\
    \n\x02\x08\t\x12\x03\x02\0\x1c\n\x08\n\x01\x08\x12\x03\x03\0#\n\t\n\x02\
    \x08\x10\x12\x03\x03\0#\n\x0b\n\x02\x05\0\x12\x05\x05\0\xab\x01\x01\n\n\
    \n\x03\x05\0\x01\x12\x03\x05\x05\x0f\n\x0b\n\x04\x05\0\x02\0\x12\x03\x06\
    \x08\x1c\n\x0c\n\x05\x05\0\x02\0\x01\x12\x03\x06\x08\x14\n\x0c\n\x05\x05\
    \0\x02\0\x02\x12\x03\x06\x17\x1b\n\x0b\n\x04\x05\0\x02\x01\x12\x03\x07\
    \x08-\n\x0c\n\x05\x05\0\x02\x01\x01\x12\x03\x07\x08%\n\x0c\n\x05\x05\0\
    \x02\x01\x02\x12\x03\x07(,\n\x0b\n\x04\x05\0\x02\x02\x12\x03\x08\x08\x1d\
    \n\x0c\n\x05\x05\0\x02\x02\x01\x12\x03\x08\x08\x15\n\x0c\n\x05\x05\0\x02\
    \x02\x02\x12\x03\x08\x18\x1c\n\x0b\n\x04\x05\0\x02\x03\x12\x03\t\x08%\n\
    \x0c\n\x05\x05\0\x02\x03\x01\x12\x03\t\x08\x1d\n\x0c\n\x05\x05\0\x02\x03\
    \x02\x12\x03\t\x20$\n\x0b\n\x04\x05\0\x02\x04\x12\x03\n\x08\x1e\n\x0c\n\
    \x05\x05\0\x02\x04\x01\x12\x03\n\x08\x16\n\x0c\n\x05\x05\0\x02\x04\x02\
    \x12\x03\n\x19\x1d\n\x0b\n\x04\x05\0\x02\x05\x12\x03\x0b\x08/\n\x0c\n\
    \x05\x05\0\x02\x05\x01\x12\x03\x0b\x08'\n\x0c\n\x05\x05\0\x02\x05\x02\
    \x12\x03\x0b*.\n\x0b\n\x04\x05\0\x02\x06\x12\x03\x0c\x08\x20\n\x0c\n\x05\
    \x05\0\x02\x06\x01\x12\x03\x0c\x08\x18\n\x0c\n\x05\x05\0\x02\x06\x02\x12\
    \x03\x0c\x1b\x1f\n\x0b\n\x04\x05\0\x02\x07\x12\x03\r\x08#\n\x0c\n\x05\
    \x05\0\x02\x07\x01\x12\x03\r\x08\x1b\n\x0c\n\x05\x05\0\x02\x07\x02\x12\
    \x03\r\x1e\"\n\x0b\n\x04\x05\0\x02\x08\x12\x03\x0e\x08+\n\x0c\n\x05\x05\
    \0\x02\x08\x01\x12\x03\x0e\x08#\n\x0c\n\x05\x05\0\x02\x08\x02\x12\x03\
    \x0e&*\n\x0b\n\x04\x05\0\x02\t\x12\x03\x0f\x08!\n\x0c\n\x05\x05\0\x02\t\
    \x01\x12\x03\x0f\x08\x19\n\x0c\n\x05\x05\0\x02\t\x02\x12\x03\x0f\x1c\x20\
    \n\x0b\n\x04\x05\0\x02\n\x12\x03\x10\x08)\n\x0c\n\x05\x05\0\x02\n\x01\
    \x12\x03\x10\x08!\n\x0c\n\x05\x05\0\x02\n\x02\x12\x03\x10$(\n\x0b\n\x04\
    \x05\0\x02\x0b\x12\x03\x11\x08-\n\x0c\n\x05\x05\0\x02\x0b\x01\x12\x03\
    \x11\x08%\n\x0c\n\x05\x05\0\x02\x0b\x02\x12\x03\x11(,\n\x0b\n\x04\x05\0\
    \x02\x0c\x12\x03\x12\x08#\n\x0c\n\x05\x05\0\x02\x0c\x01\x12\x03\x12\x08\
    \x1b\n\x0c\n\x05\x05\0\x02\x0c\x02\x12\x03\x12\x1e\"\n\x0b\n\x04\x05\0\
    \x02\r\x12\x03\x13\x08+\n\x0c\n\x05\x05\0\x02\r\x01\x12\x03\x13\x08#\n\
    \x0c\n\x05\x05\0\x02\r\x02\x12\x03\x13&*\n\x0b\n\x04\x05\0\x02\x0e\x12\
    \x03\x14\x08$\n\x0c\n\x05\x05\0\x02\x0e\x01\x12\x03\x14\x08\x1c\n\x0c\n\
    \x05\x05\0\x02\x0e\x02\x12\x03\x14\x1f#\n\x0b\n\x04\x05\0\x02\x0f\x12\
    \x03\x15\x08,\n\x0c\n\x05\x05\0\x02\x0f\x01\x12\x03\x15\x08$\n\x0c\n\x05\
    \x05\0\x02\x0f\x02\x12\x03\x15'+\n\x0b\n\x04\x05\0\x02\x10\x12\x03\x16\
    \x083\n\x0c\n\x05\x05\0\x02\x10\x01\x12\x03\x16\x08+\n\x0c\n\x05\x05\0\
    \x02\x10\x02\x12\x03\x16.2\n\x0b\n\x04\x05\0\x02\x11\x12\x03\x17\x08;\n\
    \x0c\n\x05\x05\0\x02\x11\x01\x12\x03\x17\x083\n\x0c\n\x05\x05\0\x02\x11\
    \x02\x12\x03\x176:\n\x0b\n\x04\x05\0\x02\x12\x12\x03\x18\x08,\n\x0c\n\
    \x05\x05\0\x02\x12\x01\x12\x03\x18\x08$\n\x0c\n\x05\x05\0\x02\x12\x02\
    \x12\x03\x18'+\n\x0b\n\x04\x05\0\x02\x13\x12\x03\x19\x084\n\x0c\n\x05\
    \x05\0\x02\x13\x01\x12\x03\x19\x08,\n\x0c\n\x05\x05\0\x02\x13\x02\x12\
    \x03\x19/3\n\x0b\n\x04\x05\0\x02\x14\x12\x03\x1a\x08&\n\x0c\n\x05\x05\0\
    \x02\x14\x01\x12\x03\x1a\x08\x1e\n\x0c\n\x05\x05\0\x02\x14\x02\x12\x03\
    \x1a!%\n\x0b\n\x04\x05\0\x02\x15\x12\x03\x1b\x08'\n\x0c\n\x05\x05\0\x02\
    \x15\x01\x12\x03\x1b\x08\x1f\n\x0c\n\x05\x05\0\x02\x15\x02\x12\x03\x1b\"\
    &\n\x0b\n\x04\x05\0\x02\x16\x12\x03\x1c\x080\n\x0c\n\x05\x05\0\x02\x16\
    \x01\x12\x03\x1c\x08(\n\x0c\n\x05\x05\0\x02\x16\x02\x12\x03\x1c+/\n\x0b\
    \n\x04\x05\0\x02\x17\x12\x03\x1d\x08&\n\x0c\n\x05\x05\0\x02\x17\x01\x12\
    \x03\x1d\x08\x1e\n\x0c\n\x05\x05\0\x02\x17\x02\x12\x03\x1d!%\n\x0b\n\x04\
    \x05\0\x02\x18\x12\x03\x1e\x08'\n\x0c\n\x05\x05\0\x02\x18\x01\x12\x03\
    \x1e\x08\x1f\n\x0c\n\x05\x05\0\x02\x18\x02\x12\x03\x1e\"&\n\x0b\n\x04\
    \x05\0\x02\x19\x12\x03\x1f\x08$\n\x0c\n\x05\x05\0\x02\x19\x01\x12\x03\
    \x1f\x08\x1c\n\x0c\n\x05\x05\0\x02\x19\x02\x12\x03\x1f\x1f#\n\x0b\n\x04\
    \x05\0\x02\x1a\x12\x03\x20\x08,\n\x0c\n\x05\x05\0\x02\x1a\x01\x12\x03\
    \x20\x08$\n\x0c\n\x05\x05\0\x02\x1a\x02\x12\x03\x20'+\n\x0b\n\x04\x05\0\
    \x02\x1b\x12\x03!\x08#\n\x0c\n\x05\x05\0\x02\x1b\x01\x12\x03!\x08\x1b\n\
    \x0c\n\x05\x05\0\x02\x1b\x02\x12\x03!\x1e\"\n\x0b\n\x04\x05\0\x02\x1c\
    \x12\x03\"\x083\n\x0c\n\x05\x05\0\x02\x1c\x01\x12\x03\"\x08+\n\x0c\n\x05\
    \x05\0\x02\x1c\x02\x12\x03\".2\n\x0b\n\x04\x05\0\x02\x1d\x12\x03#\x08)\n\
    \x0c\n\x05\x05\0\x02\x1d\x01\x12\x03#\x08!\n\x0c\n\x05\x05\0\x02\x1d\x02\
    \x12\x03#$(\n\x0b\n\x04\x05\0\x02\x1e\x12\x03$\x08*\n\x0c\n\x05\x05\0\
    \x02\x1e\x01\x12\x03$\x08\"\n\x0c\n\x05\x05\0\x02\x1e\x02\x12\x03$%)\n\
    \x0b\n\x04\x05\0\x02\x1f\x12\x03%\x08$\n\x0c\n\x05\x05\0\x02\x1f\x01\x12\
    \x03%\x08\x1c\n\x0c\n\x05\x05\0\x02\x1f\x02\x12\x03%\x1f#\n\x0b\n\x04\
    \x05\0\x02\x20\x12\x03&\x08)\n\x0c\n\x05\x05\0\x02\x20\x01\x12\x03&\x08!\
    \n\x0c\n\x05\x05\0\x02\x20\x02\x12\x03&$(\n\x0b\n\x04\x05\0\x02!\x12\x03\
    '\x08!\n\x0c\n\x05\x05\0\x02!\x01\x12\x03'\x08\x19\n\x0c\n\x05\x05\0\x02\
    !\x02\x12\x03'\x1c\x20\n\x0b\n\x04\x05\0\x02\"\x12\x03(\x085\n\x0c\n\x05\
    \x05\0\x02\"\x01\x12\x03(\x08-\n\x0c\n\x05\x05\0\x02\"\x02\x12\x03(04\n\
    \x0b\n\x04\x05\0\x02#\x12\x03)\x08%\n\x0c\n\x05\x05\0\x02#\x01\x12\x03)\
    \x08\x1d\n\x0c\n\x05\x05\0\x02#\x02\x12\x03)\x20$\n\x0b\n\x04\x05\0\x02$\
    \x12\x03*\x08-\n\x0c\n\x05\x05\0\x02$\x01\x12\x03*\x08%\n\x0c\n\x05\x05\
    \0\x02$\x02\x12\x03*(,\n\x0b\n\x04\x05\0\x02%\x12\x03+\x08)\n\x0c\n\x05\
    \x05\0\x02%\x01\x12\x03+\x08!\n\x0c\n\x05\x05\0\x02%\x02\x12\x03+$(\n\
    \x0b\n\x04\x05\0\x02&\x12\x03,\x081\n\x0c\n\x05\x05\0\x02&\x01\x12\x03,\
    \x08)\n\x0c\n\x05\x05\0\x02&\x02\x12\x03,,0\n\x0b\n\x04\x05\0\x02'\x12\
    \x03-\x08(\n\x0c\n\x05\x05\0\x02'\x01\x12\x03-\x08\x20\n\x0c\n\x05\x05\0\
    \x02'\x02\x12\x03-#'\n\x0b\n\x04\x05\0\x02(\x12\x03.\x08/\n\x0c\n\x05\
    \x05\0\x02(\x01\x12\x03.\x08'\n\x0c\n\x05\x05\0\x02(\x02\x12\x03.*.\n\
    \x0b\n\x04\x05\0\x02)\x12\x03/\x08+\n\x0c\n\x05\x05\0\x02)\x01\x12\x03/\
    \x08#\n\x0c\n\x05\x05\0\x02)\x02\x12\x03/&*\n\x0b\n\x04\x05\0\x02*\x12\
    \x030\x083\n\x0c\n\x05\x05\0\x02*\x01\x12\x030\x08+\n\x0c\n\x05\x05\0\
    \x02*\x02\x12\x030.2\n\x0b\n\x04\x05\0\x02+\x12\x031\x08(\n\x0c\n\x05\
    \x05\0\x02+\x01\x12\x031\x08\x20\n\x0c\n\x05\x05\0\x02+\x02\x12\x031#'\n\
    \x0b\n\x04\x05\0\x02,\x12\x032\x080\n\x0c\n\x05\x05\0\x02,\x01\x12\x032\
    \x08(\n\x0c\n\x05\x05\0\x02,\x02\x12\x032+/\n\x0b\n\x04\x05\0\x02-\x12\
    \x033\x08.\n\x0c\n\x05\x05\0\x02-\x01\x12\x033\x08&\n\x0c\n\x05\x05\0\
    \x02-\x02\x12\x033)-\n\x0b\n\x04\x05\0\x02.\x12\x034\x086\n\x0c\n\x05\
    \x05\0\x02.\x01\x12\x034\x08.\n\x0c\n\x05\x05\0\x02.\x02\x12\x03415\n\
    \x0b\n\x04\x05\0\x02/\x12\x035\x08&\n\x0c\n\x05\x05\0\x02/\x01\x12\x035\
    \x08\x1e\n\x0c\n\x05\x05\0\x02/\x02\x12\x035!%\n\x0b\n\x04\x05\0\x020\
    \x12\x036\x08,\n\x0c\n\x05\x05\0\x020\x01\x12\x036\x08$\n\x0c\n\x05\x05\
    \0\x020\x02\x12\x036'+\n\x0b\n\x04\x05\0\x021\x12\x037\x08/\n\x0c\n\x05\
    \x05\0\x021\x01\x12\x037\x08'\n\x0c\n\x05\x05\0\x021\x02\x12\x037*.\n\
    \x0b\n\x04\x05\0\x022\x12\x038\x08#\n\x0c\n\x05\x05\0\x022\x01\x12\x038\
    \x08\x1b\n\x0c\n\x05\x05\0\x022\x02\x12\x038\x1e\"\n\x0b\n\x04\x05\0\x02\
    3\x12\x039\x08(\n\x0c\n\x05\x05\0\x023\x01\x12\x039\x08\x20\n\x0c\n\x05\
    \x05\0\x023\x02\x12\x039#'\n\x0b\n\x04\x05\0\x024\x12\x03:\x084\n\x0c\n\
    \x05\x05\0\x024\x01\x12\x03:\x08,\n\x0c\n\x05\x05\0\x024\x02\x12\x03:/3\
    \n\x0b\n\x04\x05\0\x025\x12\x03;\x08/\n\x0c\n\x05\x05\0\x025\x01\x12\x03\
    ;\x08'\n\x0c\n\x05\x05\0\x025\x02\x12\x03;*.\n\x0b\n\x04\x05\0\x026\x12\
    \x03<\x08$\n\x0c\n\x05\x05\0\x026\x01\x12\x03<\x08\x1c\n\x0c\n\x05\x05\0\
    \x026\x02\x12\x03<\x1f#\n\x0b\n\x04\x05\0\x027\x12\x03=\x08,\n\x0c\n\x05\
    \x05\0\x027\x01\x12\x03=\x08$\n\x0c\n\x05\x05\0\x027\x02\x12\x03='+\n\
    \x0b\n\x04\x05\0\x028\x12\x03>\x089\n\x0c\n\x05\x05\0\x028\x01\x12\x03>\
    \x081\n\x0c\n\x05\x05\0\x028\x02\x12\x03>48\n\x0b\n\x04\x05\0\x029\x12\
    \x03?\x08,\n\x0c\n\x05\x05\0\x029\x01\x12\x03?\x08$\n\x0c\n\x05\x05\0\
    \x029\x02\x12\x03?'+\n\x0b\n\x04\x05\0\x02:\x12\x03@\x081\n\x0c\n\x05\
    \x05\0\x02:\x01\x12\x03@\x08)\n\x0c\n\x05\x05\0\x02:\x02\x12\x03@,0\n\
    \x0b\n\x04\x05\0\x02;\x12\x03A\x08(\n\x0c\n\x05\x05\0\x02;\x01\x12\x03A\
    \x08\x20\n\x0c\n\x05\x05\0\x02;\x02\x12\x03A#'\n\x0b\n\x04\x05\0\x02<\
    \x12\x03B\x084\n\x0c\n\x05\x05\0\x02<\x01\x12\x03B\x08,\n\x0c\n\x05\x05\
    \0\x02<\x02\x12\x03B/3\n\x0b\n\x04\x05\0\x02=\x12\x03C\x083\n\x0c\n\x05\
    \x05\0\x02=\x01\x12\x03C\x08+\n\x0c\n\x05\x05\0\x02=\x02\x12\x03C.2\n\
    \x0b\n\x04\x05\0\x02>\x12\x03D\x08)\n\x0c\n\x05\x05\0\x02>\x01\x12\x03D\
    \x08!\n\x0c\n\x05\x05\0\x02>\x02\x12\x03D$(\n\x0b\n\x04\x05\0\x02?\x12\
    \x03E\x08*\n\x0c\n\x05\x05\0\x02?\x01\x12\x03E\x08\"\n\x0c\n\x05\x05\0\
    \x02?\x02\x12\x03E%)\n\x0b\n\x04\x05\0\x02@\x12\x03F\x08#\n\x0c\n\x05\
    \x05\0\x02@\x01\x12\x03F\x08\x1b\n\x0c\n\x05\x05\0\x02@\x02\x12\x03F\x1e\
    \"\n\x0b\n\x04\x05\0\x02A\x12\x03G\x08(\n\x0c\n\x05\x05\0\x02A\x01\x12\
    \x03G\x08\x20\n\x0c\n\x05\x05\0\x02A\x02\x12\x03G#'\n\x0b\n\x04\x05\0\
    \x02B\x12\x03H\x08)\n\x0c\n\x05\x05\0\x02B\x01\x12\x03H\x08!\n\x0c\n\x05\
    \x05\0\x02B\x02\x12\x03H$(\n\x0b\n\x04\x05\0\x02C\x12\x03I\x08/\n\x0c\n\
    \x05\x05\0\x02C\x01\x12\x03I\x08'\n\x0c\n\x05\x05\0\x02C\x02\x12\x03I*.\
    \n\x0b\n\x04\x05\0\x02D\x12\x03J\x08/\n\x0c\n\x05\x05\0\x02D\x01\x12\x03\
    J\x08'\n\x0c\n\x05\x05\0\x02D\x02\x12\x03J*.\n\x0b\n\x04\x05\0\x02E\x12\
    \x03K\x087\n\x0c\n\x05\x05\0\x02E\x01\x12\x03K\x08/\n\x0c\n\x05\x05\0\
    \x02E\x02\x12\x03K26\n\x0b\n\x04\x05\0\x02F\x12\x03L\x08#\n\x0c\n\x05\
    \x05\0\x02F\x01\x12\x03L\x08\x1b\n\x0c\n\x05\x05\0\x02F\x02\x12\x03L\x1e\
    \"\n\x0b\n\x04\x05\0\x02G\x12\x03M\x08+\n\x0c\n\x05\x05\0\x02G\x01\x12\
    \x03M\x08#\n\x0c\n\x05\x05\0\x02G\x02\x12\x03M&*\n\x0b\n\x04\x05\0\x02H\
    \x12\x03N\x083\n\x0c\n\x05\x05\0\x02H\x01\x12\x03N\x08+\n\x0c\n\x05\x05\
    \0\x02H\x02\x12\x03N.2\n\x0b\n\x04\x05\0\x02I\x12\x03O\x085\n\x0c\n\x05\
    \x05\0\x02I\x01\x12\x03O\x08-\n\x0c\n\x05\x05\0\x02I\x02\x12\x03O04\n\
    \x0b\n\x04\x05\0\x02J\x12\x03P\x08=\n\x0c\n\x05\x05\0\x02J\x01\x12\x03P\
    \x085\n\x0c\n\x05\x05\0\x02J\x02\x12\x03P8<\n\x0b\n\x04\x05\0\x02K\x12\
    \x03Q\x083\n\x0c\n\x05\x05\0\x02K\x01\x12\x03Q\x08+\n\x0c\n\x05\x05\0\
    \x02K\x02\x12\x03Q.2\n\x0b\n\x04\x05\0\x02L\x12\x03R\x081\n\x0c\n\x05\
    \x05\0\x02L\x01\x12\x03R\x08)\n\x0c\n\x05\x05\0\x02L\x02\x12\x03R,0\n\
    \x0b\n\x04\x05\0\x02M\x12\x03S\x08*\n\x0c\n\x05\x05\0\x02M\x01\x12\x03S\
    \x08\"\n\x0c\n\x05\x05\0\x02M\x02\x12\x03S%)\n\x0b\n\x04\x05\0\x02N\x12\
    \x03T\x082\n\x0c\n\x05\x05\0\x02N\x01\x12\x03T\x08*\n\x0c\n\x05\x05\0\
    \x02N\x02\x12\x03T-1\n\x0b\n\x04\x05\0\x02O\x12\x03U\x08+\n\x0c\n\x05\
    \x05\0\x02O\x01\x12\x03U\x08#\n\x0c\n\x05\x05\0\x02O\x02\x12\x03U&*\n\
    \x0b\n\x04\x05\0\x02P\x12\x03V\x080\n\x0c\n\x05\x05\0\x02P\x01\x12\x03V\
    \x08(\n\x0c\n\x05\x05\0\x02P\x02\x12\x03V+/\n\x0b\n\x04\x05\0\x02Q\x12\
    \x03W\x083\n\x0c\n\x05\x05\0\x02Q\x01\x12\x03W\x08+\n\x0c\n\x05\x05\0\
    \x02Q\x02\x12\x03W.2\n\x0b\n\x04\x05\0\x02R\x12\x03X\x08(\n\x0c\n\x05\
    \x05\0\x02R\x01\x12\x03X\x08\x20\n\x0c\n\x05\x05\0\x02R\x02\x12\x03X#'\n\
    \x0b\n\x04\x05\0\x02S\x12\x03Y\x080\n\x0c\n\x05\x05\0\x02S\x01\x12\x03Y\
    \x08(\n\x0c\n\x05\x05\0\x02S\x02\x12\x03Y+/\n\x0b\n\x04\x05\0\x02T\x12\
    \x03Z\x08/\n\x0c\n\x05\x05\0\x02T\x01\x12\x03Z\x08'\n\x0c\n\x05\x05\0\
    \x02T\x02\x12\x03Z*.\n\x0b\n\x04\x05\0\x02U\x12\x03[\x08=\n\x0c\n\x05\
    \x05\0\x02U\x01\x12\x03[\x085\n\x0c\n\x05\x05\0\x02U\x02\x12\x03[8<\n\
    \x0b\n\x04\x05\0\x02V\x12\x03\\\x080\n\x0c\n\x05\x05\0\x02V\x01\x12\x03\
    \\\x08(\n\x0c\n\x05\x05\0\x02V\x02\x12\x03\\+/\n\x0b\n\x04\x05\0\x02W\
    \x12\x03]\x08(\n\x0c\n\x05\x05\0\x02W\x01\x12\x03]\x08\x20\n\x0c\n\x05\
    \x05\0\x02W\x02\x12\x03]#'\n\x0b\n\x04\x05\0\x02X\x12\x03^\x082\n\x0c\n\
    \x05\x05\0\x02X\x01\x12\x03^\x08*\n\x0c\n\x05\x05\0\x02X\x02\x12\x03^-1\
    \n\x0b\n\x04\x05\0\x02Y\x12\x03_\x08:\n\x0c\n\x05\x05\0\x02Y\x01\x12\x03\
    _\x082\n\x0c\n\x05\x05\0\x02Y\x02\x12\x03_59\n\x0b\n\x04\x05\0\x02Z\x12\
    \x03`\x08#\n\x0c\n\x05\x05\0\x02Z\x01\x12\x03`\x08\x1b\n\x0c\n\x05\x05\0\
    \x02Z\x02\x12\x03`\x1e\"\n\x0b\n\x04\x05\0\x02[\x12\x03a\x084\n\x0c\n\
    \x05\x05\0\x02[\x01\x12\x03a\x08,\n\x0c\n\x05\x05\0\x02[\x02\x12\x03a/3\
    \n\x0b\n\x04\x05\0\x02\\\x12\x03b\x085\n\x0c\n\x05\x05\0\x02\\\x01\x12\
    \x03b\x08-\n\x0c\n\x05\x05\0\x02\\\x02\x12\x03b04\n\x0b\n\x04\x05\0\x02]\
    \x12\x03c\x08,\n\x0c\n\x05\x05\0\x02]\x01\x12\x03c\x08$\n\x0c\n\x05\x05\
    \0\x02]\x02\x12\x03c'+\n\x0b\n\x04\x05\0\x02^\x12\x03d\x08-\n\x0c\n\x05\
    \x05\0\x02^\x01\x12\x03d\x08%\n\x0c\n\x05\x05\0\x02^\x02\x12\x03d(,\n\
    \x0b\n\x04\x05\0\x02_\x12\x03e\x08-\n\x0c\n\x05\x05\0\x02_\x01\x12\x03e\
    \x08%\n\x0c\n\x05\x05\0\x02_\x02\x12\x03e(,\n\x0b\n\x04\x05\0\x02`\x12\
    \x03f\x08<\n\x0c\n\x05\x05\0\x02`\x01\x12\x03f\x084\n\x0c\n\x05\x05\0\
    \x02`\x02\x12\x03f7;\n\x0b\n\x04\x05\0\x02a\x12\x03g\x084\n\x0c\n\x05\
    \x05\0\x02a\x01\x12\x03g\x08,\n\x0c\n\x05\x05\0\x02a\x02\x12\x03g/3\n\
    \x0b\n\x04\x05\0\x02b\x12\x03h\x085\n\x0c\n\x05\x05\0\x02b\x01\x12\x03h\
    \x08-\n\x0c\n\x05\x05\0\x02b\x02\x12\x03h04\n\x0b\n\x04\x05\0\x02c\x12\
    \x03i\x08)\n\x0c\n\x05\x05\0\x02c\x01\x12\x03i\x08!\n\x0c\n\x05\x05\0\
    \x02c\x02\x12\x03i$(\n\x0b\n\x04\x05\0\x02d\x12\x03j\x08.\n\x0c\n\x05\
    \x05\0\x02d\x01\x12\x03j\x08&\n\x0c\n\x05\x05\0\x02d\x02\x12\x03j)-\n\
    \x0b\n\x04\x05\0\x02e\x12\x03k\x081\n\x0c\n\x05\x05\0\x02e\x01\x12\x03k\
    \x08)\n\x0c\n\x05\x05\0\x02e\x02\x12\x03k,0\n\x0b\n\x04\x05\0\x02f\x12\
    \x03l\x08*\n\x0c\n\x05\x05\0\x02f\x01\x12\x03l\x08\"\n\x0c\n\x05\x05\0\
    \x02f\x02\x12\x03l%)\n\x0b\n\x04\x05\0\x02g\x12\x03m\x082\n\x0c\n\x05\
    \x05\0\x02g\x01\x12\x03m\x08*\n\x0c\n\x05\x05\0\x02g\x02\x12\x03m-1\n\
    \x0b\n\x04\x05\0\x02h\x12\x03n\x08)\n\x0c\n\x05\x05\0\x02h\x01\x12\x03n\
    \x08!\n\x0c\n\x05\x05\0\x02h\x02\x12\x03n$(\n\x0b\n\x04\x05\0\x02i\x12\
    \x03o\x085\n\x0c\n\x05\x05\0\x02i\x01\x12\x03o\x08-\n\x0c\n\x05\x05\0\
    \x02i\x02\x12\x03o04\n\x0b\n\x04\x05\0\x02j\x12\x03p\x089\n\x0c\n\x05\
    \x05\0\x02j\x01\x12\x03p\x081\n\x0c\n\x05\x05\0\x02j\x02\x12\x03p48\n\
    \x0b\n\x04\x05\0\x02k\x12\x03q\x08*\n\x0c\n\x05\x05\0\x02k\x01\x12\x03q\
    \x08\"\n\x0c\n\x05\x05\0\x02k\x02\x12\x03q%)\n\x0b\n\x04\x05\0\x02l\x12\
    \x03r\x082\n\x0c\n\x05\x05\0\x02l\x01\x12\x03r\x08*\n\x0c\n\x05\x05\0\
    \x02l\x02\x12\x03r-1\n\x0b\n\x04\x05\0\x02m\x12\x03s\x080\n\x0c\n\x05\
    \x05\0\x02m\x01\x12\x03s\x08(\n\x0c\n\x05\x05\0\x02m\x02\x12\x03s+/\n\
    \x0b\n\x04\x05\0\x02n\x12\x03t\x08(\n\x0c\n\x05\x05\0\x02n\x01\x12\x03t\
    \x08\x20\n\x0c\n\x05\x05\0\x02n\x02\x12\x03t#'\n\x0b\n\x04\x05\0\x02o\
    \x12\x03u\x080\n\x0c\n\x05\x05\0\x02o\x01\x12\x03u\x08(\n\x0c\n\x05\x05\
    \0\x02o\x02\x12\x03u+/\n\x0b\n\x04\x05\0\x02p\x12\x03v\x084\n\x0c\n\x05\
    \x05\0\x02p\x01\x12\x03v\x08,\n\x0c\n\x05\x05\0\x02p\x02\x12\x03v/3\n\
    \x0b\n\x04\x05\0\x02q\x12\x03w\x08<\n\x0c\n\x05\x05\0\x02q\x01\x12\x03w\
    \x084\n\x0c\n\x05\x05\0\x02q\x02\x12\x03w7;\n\x0b\n\x04\x05\0\x02r\x12\
    \x03x\x08-\n\x0c\n\x05\x05\0\x02r\x01\x12\x03x\x08%\n\x0c\n\x05\x05\0\
    \x02r\x02\x12\x03x(,\n\x0b\n\x04\x05\0\x02s\x12\x03y\x085\n\x0c\n\x05\
    \x05\0\x02s\x01\x12\x03y\x08-\n\x0c\n\x05\x05\0\x02s\x02\x12\x03y04\n\
    \x0b\n\x04\x05\0\x02t\x12\x03z\x08+\n\x0c\n\x05\x05\0\x02t\x01\x12\x03z\
    \x08#\n\x0c\n\x05\x05\0\x02t\x02\x12\x03z&*\n\x0b\n\x04\x05\0\x02u\x12\
    \x03{\x083\n\x0c\n\x05\x05\0\x02u\x01\x12\x03{\x08+\n\x0c\n\x05\x05\0\
    \x02u\x02\x12\x03{.2\n\x0b\n\x04\x05\0\x02v\x12\x03|\x08-\n\x0c\n\x05\
    \x05\0\x02v\x01\x12\x03|\x08%\n\x0c\n\x05\x05\0\x02v\x02\x12\x03|(,\n\
    \x0b\n\x04\x05\0\x02w\x12\x03}\x085\n\x0c\n\x05\x05\0\x02w\x01\x12\x03}\
    \x08-\n\x0c\n\x05\x05\0\x02w\x02\x12\x03}04\n\x0b\n\x04\x05\0\x02x\x12\
    \x03~\x08)\n\x0c\n\x05\x05\0\x02x\x01\x12\x03~\x08!\n\x0c\n\x05\x05\0\
    \x02x\x02\x12\x03~$(\n\x0b\n\x04\x05\0\x02y\x12\x03\x7f\x081\n\x0c\n\x05\
    \x05\0\x02y\x01\x12\x03\x7f\x08)\n\x0c\n\x05\x05\0\x02y\x02\x12\x03\x7f,\
    0\n\x0c\n\x04\x05\0\x02z\x12\x04\x80\x01\x08)\n\r\n\x05\x05\0\x02z\x01\
    \x12\x04\x80\x01\x08!\n\r\n\x05\x05\0\x02z\x02\x12\x04\x80\x01$(\n\x0c\n\
    \x04\x05\0\x02{\x12\x04\x81\x01\x081\n\r\n\x05\x05\0\x02{\x01\x12\x04\
    \x81\x01\x08)\n\r\n\x05\x05\0\x02{\x02\x12\x04\x81\x01,0\n\x0c\n\x04\x05\
    \0\x02|\x12\x04\x82\x01\x08-\n\r\n\x05\x05\0\x02|\x01\x12\x04\x82\x01\
    \x08%\n\r\n\x05\x05\0\x02|\x02\x12\x04\x82\x01(,\n\x0c\n\x04\x05\0\x02}\
    \x12\x04\x83\x01\x083\n\r\n\x05\x05\0\x02}\x01\x12\x04\x83\x01\x08+\n\r\
    \n\x05\x05\0\x02}\x02\x12\x04\x83\x01.2\n\x0c\n\x04\x05\0\x02~\x12\x04\
    \x84\x01\x08,\n\r\n\x05\x05\0\x02~\x01\x12\x04\x84\x01\x08$\n\r\n\x05\
    \x05\0\x02~\x02\x12\x04\x84\x01'+\n\x0c\n\x04\x05\0\x02\x7f\x12\x04\x85\
    \x01\x08&\n\r\n\x05\x05\0\x02\x7f\x01\x12\x04\x85\x01\x08\x1e\n\r\n\x05\
    \x05\0\x02\x7f\x02\x12\x04\x85\x01!%\n\r\n\x05\x05\0\x02\x80\x01\x12\x04\
    \x86\x01\x080\n\x0e\n\x06\x05\0\x02\x80\x01\x01\x12\x04\x86\x01\x08(\n\
    \x0e\n\x06\x05\0\x02\x80\x01\x02\x12\x04\x86\x01+/\n\r\n\x05\x05\0\x02\
    \x81\x01\x12\x04\x87\x01\x08,\n\x0e\n\x06\x05\0\x02\x81\x01\x01\x12\x04\
    \x87\x01\x08$\n\x0e\n\x06\x05\0\x02\x81\x01\x02\x12\x04\x87\x01'+\n\r\n\
    \x05\x05\0\x02\x82\x01\x12\x04\x88\x01\x084\n\x0e\n\x06\x05\0\x02\x82\
    \x01\x01\x12\x04\x88\x01\x08,\n\x0e\n\x06\x05\0\x02\x82\x01\x02\x12\x04\
    \x88\x01/3\n\r\n\x05\x05\0\x02\x83\x01\x12\x04\x89\x01\x080\n\x0e\n\x06\
    \x05\0\x02\x83\x01\x01\x12\x04\x89\x01\x08(\n\x0e\n\x06\x05\0\x02\x83\
    \x01\x02\x12\x04\x89\x01+/\n\r\n\x05\x05\0\x02\x84\x01\x12\x04\x8a\x01\
    \x08,\n\x0e\n\x06\x05\0\x02\x84\x01\x01\x12\x04\x8a\x01\x08$\n\x0e\n\x06\
    \x05\0\x02\x84\x01\x02\x12\x04\x8a\x01'+\n\r\n\x05\x05\0\x02\x85\x01\x12\
    \x04\x8b\x01\x086\n\x0e\n\x06\x05\0\x02\x85\x01\x01\x12\x04\x8b\x01\x08.\
    \n\x0e\n\x06\x05\0\x02\x85\x01\x02\x12\x04\x8b\x0115\n\r\n\x05\x05\0\x02\
    \x86\x01\x12\x04\x8c\x01\x08>\n\x0e\n\x06\x05\0\x02\x86\x01\x01\x12\x04\
    \x8c\x01\x086\n\x0e\n\x06\x05\0\x02\x86\x01\x02\x12\x04\x8c\x019=\n\r\n\
    \x05\x05\0\x02\x87\x01\x12\x04\x8d\x01\x084\n\x0e\n\x06\x05\0\x02\x87\
    \x01\x01\x12\x04\x8d\x01\x08,\n\x0e\n\x06\x05\0\x02\x87\x01\x02\x12\x04\
    \x8d\x01/3\n\r\n\x05\x05\0\x02\x88\x01\x12\x04\x8e\x01\x08<\n\x0e\n\x06\
    \x05\0\x02\x88\x01\x01\x12\x04\x8e\x01\x084\n\x0e\n\x06\x05\0\x02\x88\
    \x01\x02\x12\x04\x8e\x017;\n\r\n\x05\x05\0\x02\x89\x01\x12\x04\x8f\x01\
    \x089\n\x0e\n\x06\x05\0\x02\x89\x01\x01\x12\x04\x8f\x01\x081\n\x0e\n\x06\
    \x05\0\x02\x89\x01\x02\x12\x04\x8f\x0148\n\r\n\x05\x05\0\x02\x8a\x01\x12\
    \x04\x90\x01\x08-\n\x0e\n\x06\x05\0\x02\x8a\x01\x01\x12\x04\x90\x01\x08%\
    \n\x0e\n\x06\x05\0\x02\x8a\x01\x02\x12\x04\x90\x01(,\n\r\n\x05\x05\0\x02\
    \x8b\x01\x12\x04\x91\x01\x085\n\x0e\n\x06\x05\0\x02\x8b\x01\x01\x12\x04\
    \x91\x01\x08-\n\x0e\n\x06\x05\0\x02\x8b\x01\x02\x12\x04\x91\x0104\n\r\n\
    \x05\x05\0\x02\x8c\x01\x12\x04\x92\x01\x08=\n\x0e\n\x06\x05\0\x02\x8c\
    \x01\x01\x12\x04\x92\x01\x085\n\x0e\n\x06\x05\0\x02\x8c\x01\x02\x12\x04\
    \x92\x018<\n\r\n\x05\x05\0\x02\x8d\x01\x12\x04\x93\x01\x08'\n\x0e\n\x06\
    \x05\0\x02\x8d\x01\x01\x12\x04\x93\x01\x08\x1f\n\x0e\n\x06\x05\0\x02\x8d\
    \x01\x02\x12\x04\x93\x01\"&\n\r\n\x05\x05\0\x02\x8e\x01\x12\x04\x94\x01\
    \x08(\n\x0e\n\x06\x05\0\x02\x8e\x01\x01\x12\x04\x94\x01\x08\x20\n\x0e\n\
    \x06\x05\0\x02\x8e\x01\x02\x12\x04\x94\x01#'\n\r\n\x05\x05\0\x02\x8f\x01\
    \x12\x04\x95\x01\x080\n\x0e\n\x06\x05\0\x02\x8f\x01\x01\x12\x04\x95\x01\
    \x08(\n\x0e\n\x06\x05\0\x02\x8f\x01\x02\x12\x04\x95\x01+/\n\r\n\x05\x05\
    \0\x02\x90\x01\x12\x04\x96\x01\x088\n\x0e\n\x06\x05\0\x02\x90\x01\x01\
    \x12\x04\x96\x01\x080\n\x0e\n\x06\x05\0\x02\x90\x01\x02\x12\x04\x96\x013\
    7\n\r\n\x05\x05\0\x02\x91\x01\x12\x04\x97\x01\x080\n\x0e\n\x06\x05\0\x02\
    \x91\x01\x01\x12\x04\x97\x01\x08(\n\x0e\n\x06\x05\0\x02\x91\x01\x02\x12\
    \x04\x97\x01+/\n\r\n\x05\x05\0\x02\x92\x01\x12\x04\x98\x01\x088\n\x0e\n\
    \x06\x05\0\x02\x92\x01\x01\x12\x04\x98\x01\x080\n\x0e\n\x06\x05\0\x02\
    \x92\x01\x02\x12\x04\x98\x0137\n\r\n\x05\x05\0\x02\x93\x01\x12\x04\x99\
    \x01\x086\n\x0e\n\x06\x05\0\x02\x93\x01\x01\x12\x04\x99\x01\x08.\n\x0e\n\
    \x06\x05\0\x02\x93\x01\x02\x12\x04\x99\x0115\n\r\n\x05\x05\0\x02\x94\x01\
    \x12\x04\x9a\x01\x08,\n\x0e\n\x06\x05\0\x02\x94\x01\x01\x12\x04\x9a\x01\
    \x08$\n\x0e\n\x06\x05\0\x02\x94\x01\x02\x12\x04\x9a\x01'+\n\r\n\x05\x05\
    \0\x02\x95\x01\x12\x04\x9b\x01\x08,\n\x0e\n\x06\x05\0\x02\x95\x01\x01\
    \x12\x04\x9b\x01\x08$\n\x0e\n\x06\x05\0\x02\x95\x01\x02\x12\x04\x9b\x01'\
    +\n\r\n\x05\x05\0\x02\x96\x01\x12\x04\x9c\x01\x08/\n\x0e\n\x06\x05\0\x02\
    \x96\x01\x01\x12\x04\x9c\x01\x08'\n\x0e\n\x06\x05\0\x02\x96\x01\x02\x12\
    \x04\x9c\x01*.\n\r\n\x05\x05\0\x02\x97\x01\x12\x04\x9d\x01\x08&\n\x0e\n\
    \x06\x05\0\x02\x97\x01\x01\x12\x04\x9d\x01\x08\x1e\n\x0e\n\x06\x05\0\x02\
    \x97\x01\x02\x12\x04\x9d\x01!%\n\r\n\x05\x05\0\x02\x98\x01\x12\x04\x9e\
    \x01\x08&\n\x0e\n\x06\x05\0\x02\x98\x01\x01\x12\x04\x9e\x01\x08\x1e\n\
    \x0e\n\x06\x05\0\x02\x98\x01\x02\x12\x04\x9e\x01!%\n\r\n\x05\x05\0\x02\
    \x99\x01\x12\x04\x9f\x01\x083\n\x0e\n\x06\x05\0\x02\x99\x01\x01\x12\x04\
    \x9f\x01\x08+\n\x0e\n\x06\x05\0\x02\x99\x01\x02\x12\x04\x9f\x01.2\n\r\n\
    \x05\x05\0\x02\x9a\x01\x12\x04\xa0\x01\x089\n\x0e\n\x06\x05\0\x02\x9a\
    \x01\x01\x12\x04\xa0\x01\x081\n\x0e\n\x06\x05\0\x02\x9a\x01\x02\x12\x04\
    \xa0\x0148\n\r\n\x05\x05\0\x02\x9b\x01\x12\x04\xa1\x01\x08<\n\x0e\n\x06\
    \x05\0\x02\x9b\x01\x01\x12\x04\xa1\x01\x084\n\x0e\n\x06\x05\0\x02\x9b\
    \x01\x02\x12\x04\xa1\x017;\n\r\n\x05\x05\0\x02\x9c\x01\x12\x04\xa2\x01\
    \x081\n\x0e\n\x06\x05\0\x02\x9c\x01\x01\x12\x04\xa2\x01\x08)\n\x0e\n\x06\
    \x05\0\x02\x9c\x01\x02\x12\x04\xa2\x01,0\n\r\n\x05\x05\0\x02\x9d\x01\x12\
    \x04\xa3\x01\x08.\n\x0e\n\x06\x05\0\x02\x9d\x01\x01\x12\x04\xa3\x01\x08&\
    \n\x0e\n\x06\x05\0\x02\x9d\x01\x02\x12\x04\xa3\x01)-\n\r\n\x05\x05\0\x02\
    \x9e\x01\x12\x04\xa4\x01\x08.\n\x0e\n\x06\x05\0\x02\x9e\x01\x01\x12\x04\
    \xa4\x01\x08&\n\x0e\n\x06\x05\0\x02\x9e\x01\x02\x12\x04\xa4\x01)-\n\r\n\
    \x05\x05\0\x02\x9f\x01\x12\x04\xa5\x01\x08,\n\x0e\n\x06\x05\0\x02\x9f\
    \x01\x01\x12\x04\xa5\x01\x08$\n\x0e\n\x06\x05\0\x02\x9f\x01\x02\x12\x04\
    \xa5\x01'+\n\r\n\x05\x05\0\x02\xa0\x01\x12\x04\xa6\x01\x08&\n\x0e\n\x06\
    \x05\0\x02\xa0\x01\x01\x12\x04\xa6\x01\x08\x1e\n\x0e\n\x06\x05\0\x02\xa0\
    \x01\x02\x12\x04\xa6\x01!%\n\r\n\x05\x05\0\x02\xa1\x01\x12\x04\xa7\x01\
    \x08.\n\x0e\n\x06\x05\0\x02\xa1\x01\x01\x12\x04\xa7\x01\x08&\n\x0e\n\x06\
    \x05\0\x02\xa1\x01\x02\x12\x04\xa7\x01)-\n\r\n\x05\x05\0\x02\xa2\x01\x12\
    \x04\xa8\x01\x08(\n\x0e\n\x06\x05\0\x02\xa2\x01\x01\x12\x04\xa8\x01\x08\
    \x20\n\x0e\n\x06\x05\0\x02\xa2\x01\x02\x12\x04\xa8\x01#'\n\r\n\x05\x05\0\
    \x02\xa3\x01\x12\x04\xa9\x01\x080\n\x0e\n\x06\x05\0\x02\xa3\x01\x01\x12\
    \x04\xa9\x01\x08(\n\x0e\n\x06\x05\0\x02\xa3\x01\x02\x12\x04\xa9\x01+/\n\
    \r\n\x05\x05\0\x02\xa4\x01\x12\x04\xaa\x01\x08,\n\x0e\n\x06\x05\0\x02\
    \xa4\x01\x01\x12\x04\xaa\x01\x08$\n\x0e\n\x06\x05\0\x02\xa4\x01\x02\x12\
    \x04\xaa\x01'+\n\x0c\n\x02\x05\x01\x12\x06\xad\x01\0\xb7\x01\x01\n\x0b\n\
    \x03\x05\x01\x01\x12\x04\xad\x01\x05\x13\n\x0c\n\x04\x05\x01\x02\0\x12\
    \x04\xae\x01\x08\x1f\n\r\n\x05\x05\x01\x02\0\x01\x12\x04\xae\x01\x08\x1a\
    \n\r\n\x05\x05\x01\x02\0\x02\x12\x04\xae\x01\x1d\x1e\n\x0c\n\x04\x05\x01\
    \x02\x01\x12\x04\xaf\x01\x08#\n\r\n\x05\x05\x01\x02\x01\x01\x12\x04\xaf\
    \x01\x08\x1e\n\r\n\x05\x05\x01\x02\x01\x02\x12\x04\xaf\x01!\"\n\x0c\n\
    \x04\x05\x01\x02\x02\x12\x04\xb0\x01\x08(\n\r\n\x05\x05\x01\x02\x02\x01\
    \x12\x04\xb0\x01\x08#\n\r\n\x05\x05\x01\x02\x02\x02\x12\x04\xb0\x01&'\n\
    \x0c\n\x04\x05\x01\x02\x03\x12\x04\xb1\x01\x08$\n\r\n\x05\x05\x01\x02\
    \x03\x01\x12\x04\xb1\x01\x08\x1f\n\r\n\x05\x05\x01\x02\x03\x02\x12\x04\
    \xb1\x01\"#\n\x0c\n\x04\x05\x01\x02\x04\x12\x04\xb2\x01\x08$\n\r\n\x05\
    \x05\x01\x02\x04\x01\x12\x04\xb2\x01\x08\x1f\n\r\n\x05\x05\x01\x02\x04\
    \x02\x12\x04\xb2\x01\"#\n\x0c\n\x04\x05\x01\x02\x05\x12\x04\xb3\x01\x08$\
    \n\r\n\x05\x05\x01\x02\x05\x01\x12\x04\xb3\x01\x08\x1f\n\r\n\x05\x05\x01\
    \x02\x05\x02\x12\x04\xb3\x01\"#\n\x0c\n\x04\x05\x01\x02\x06\x12\x04\xb4\
    \x01\x08)\n\r\n\x05\x05\x01\x02\x06\x01\x12\x04\xb4\x01\x08$\n\r\n\x05\
    \x05\x01\x02\x06\x02\x12\x04\xb4\x01'(\n\x0c\n\x04\x05\x01\x02\x07\x12\
    \x04\xb5\x01\x08(\n\r\n\x05\x05\x01\x02\x07\x01\x12\x04\xb5\x01\x08#\n\r\
    \n\x05\x05\x01\x02\x07\x02\x12\x04\xb5\x01&'\n\x0c\n\x04\x05\x01\x02\x08\
    \x12\x04\xb6\x01\x08#\n\r\n\x05\x05\x01\x02\x08\x01\x12\x04\xb6\x01\x08\
    \x1e\n\r\n\x05\x05\x01\x02\x08\x02\x12\x04\xb6\x01!\"\n\x0c\n\x02\x05\
    \x02\x12\x06\xb9\x01\0\xc1\x01\x01\n\x0b\n\x03\x05\x02\x01\x12\x04\xb9\
    \x01\x05\x11\n\x0c\n\x04\x05\x02\x02\0\x12\x04\xba\x01\x08$\n\r\n\x05\
    \x05\x02\x02\0\x01\x12\x04\xba\x01\x08\x1f\n\r\n\x05\x05\x02\x02\0\x02\
    \x12\x04\xba\x01\"#\n\x0c\n\x04\x05\x02\x02\x01\x12\x04\xbb\x01\x08(\n\r\
    \n\x05\x05\x02\x02\x01\x01\x12\x04\xbb\x01\x08#\n\r\n\x05\x05\x02\x02\
    \x01\x02\x12\x04\xbb\x01&'\n\x0c\n\x04\x05\x02\x02\x02\x12\x04\xbc\x01\
    \x08,\n\r\n\x05\x05\x02\x02\x02\x01\x12\x04\xbc\x01\x08'\n\r\n\x05\x05\
    \x02\x02\x02\x02\x12\x04\xbc\x01*+\n\x0c\n\x04\x05\x02\x02\x03\x12\x04\
    \xbd\x01\x08,\n\r\n\x05\x05\x02\x02\x03\x01\x12\x04\xbd\x01\x08'\n\r\n\
    \x05\x05\x02\x02\x03\x02\x12\x04\xbd\x01*+\n\x0c\n\x04\x05\x02\x02\x04\
    \x12\x04\xbe\x01\x08/\n\r\n\x05\x05\x02\x02\x04\x01\x12\x04\xbe\x01\x08*\
    \n\r\n\x05\x05\x02\x02\x04\x02\x12\x04\xbe\x01-.\n\x0c\n\x04\x05\x02\x02\
    \x05\x12\x04\xbf\x01\x082\n\r\n\x05\x05\x02\x02\x05\x01\x12\x04\xbf\x01\
    \x08-\n\r\n\x05\x05\x02\x02\x05\x02\x12\x04\xbf\x0101\n\x0c\n\x04\x05\
    \x02\x02\x06\x12\x04\xc0\x01\x08/\n\r\n\x05\x05\x02\x02\x06\x01\x12\x04\
    \xc0\x01\x08*\n\r\n\x05\x05\x02\x02\x06\x02\x12\x04\xc0\x01-.\n\x0c\n\
    \x02\x05\x03\x12\x06\xc3\x01\0\xca\x01\x01\n\x0b\n\x03\x05\x03\x01\x12\
    \x04\xc3\x01\x05$\n\x0c\n\x04\x05\x03\x02\0\x12\x04\xc4\x01\x087\n\r\n\
    \x05\x05\x03\x02\0\x01\x12\x04\xc4\x01\x082\n\r\n\x05\x05\x03\x02\0\x02\
    \x12\x04\xc4\x0156\n\x0c\n\x04\x05\x03\x02\x01\x12\x04\xc5\x01\x08?\n\r\
    \n\x05\x05\x03\x02\x01\x01\x12\x04\xc5\x01\x08:\n\r\n\x05\x05\x03\x02\
    \x01\x02\x12\x04\xc5\x01=>\n\x0c\n\x04\x05\x03\x02\x02\x12\x04\xc6\x01\
    \x08H\n\r\n\x05\x05\x03\x02\x02\x01\x12\x04\xc6\x01\x08C\n\r\n\x05\x05\
    \x03\x02\x02\x02\x12\x04\xc6\x01FG\n\x0c\n\x04\x05\x03\x02\x03\x12\x04\
    \xc7\x01\x08F\n\r\n\x05\x05\x03\x02\x03\x01\x12\x04\xc7\x01\x08A\n\r\n\
    \x05\x05\x03\x02\x03\x02\x12\x04\xc7\x01DE\n\x0c\n\x04\x05\x03\x02\x04\
    \x12\x04\xc8\x01\x08>\n\r\n\x05\x05\x03\x02\x04\x01\x12\x04\xc8\x01\x089\
    \n\r\n\x05\x05\x03\x02\x04\x02\x12\x04\xc8\x01<=\n\x0c\n\x04\x05\x03\x02\
    \x05\x12\x04\xc9\x01\x08:\n\r\n\x05\x05\x03\x02\x05\x01\x12\x04\xc9\x01\
    \x085\n\r\n\x05\x05\x03\x02\x05\x02\x12\x04\xc9\x0189\n\x0c\n\x02\x05\
    \x04\x12\x06\xcc\x01\0\xd3\x01\x01\n\x0b\n\x03\x05\x04\x01\x12\x04\xcc\
    \x01\x05\"\n\x0c\n\x04\x05\x04\x02\0\x12\x04\xcd\x01\x085\n\r\n\x05\x05\
    \x04\x02\0\x01\x12\x04\xcd\x01\x080\n\r\n\x05\x05\x04\x02\0\x02\x12\x04\
    \xcd\x0134\n\x0c\n\x04\x05\x04\x02\x01\x12\x04\xce\x01\x08E\n\r\n\x05\
    \x05\x04\x02\x01\x01\x12\x04\xce\x01\x08@\n\r\n\x05\x05\x04\x02\x01\x02\
    \x12\x04\xce\x01CD\n\x0c\n\x04\x05\x04\x02\x02\x12\x04\xcf\x01\x08C\n\r\
    \n\x05\x05\x04\x02\x02\x01\x12\x04\xcf\x01\x08>\n\r\n\x05\x05\x04\x02\
    \x02\x02\x12\x04\xcf\x01AB\n\x0c\n\x04\x05\x04\x02\x03\x12\x04\xd0\x01\
    \x08<\n\r\n\x05\x05\x04\x02\x03\x01\x12\x04\xd0\x01\x087\n\r\n\x05\x05\
    \x04\x02\x03\x02\x12\x04\xd0\x01:;\n\x0c\n\x04\x05\x04\x02\x04\x12\x04\
    \xd1\x01\x08;\n\r\n\x05\x05\x04\x02\x04\x01\x12\x04\xd1\x01\x086\n\r\n\
    \x05\x05\x04\x02\x04\x02\x12\x04\xd1\x019:\n\x0c\n\x04\x05\x04\x02\x05\
    \x12\x04\xd2\x01\x08>\n\r\n\x05\x05\x04\x02\x05\x01\x12\x04\xd2\x01\x089\
    \n\r\n\x05\x05\x04\x02\x05\x02\x12\x04\xd2\x01<=\n\x0c\n\x02\x04\0\x12\
    \x06\xd5\x01\0\xd8\x01\x01\n\x0b\n\x03\x04\0\x01\x12\x04\xd5\x01\x08\x1a\
    \n\x0c\n\x04\x04\0\x02\0\x12\x04\xd6\x01\x08.\n\r\n\x05\x04\0\x02\0\x04\
    \x12\x04\xd6\x01\x08\x10\n\r\n\x05\x04\0\x02\0\x05\x12\x04\xd6\x01\x11\
    \x17\n\r\n\x05\x04\0\x02\0\x01\x12\x04\xd6\x01\x18)\n\r\n\x05\x04\0\x02\
    \0\x03\x12\x04\xd6\x01,-\n\x0c\n\x04\x04\0\x02\x01\x12\x04\xd7\x01\x08)\
    \n\r\n\x05\x04\0\x02\x01\x04\x12\x04\xd7\x01\x08\x10\n\r\n\x05\x04\0\x02\
    \x01\x05\x12\x04\xd7\x01\x11\x17\n\r\n\x05\x04\0\x02\x01\x01\x12\x04\xd7\
    \x01\x18$\n\r\n\x05\x04\0\x02\x01\x03\x12\x04\xd7\x01'(\n\x0c\n\x02\x04\
    \x01\x12\x06\xda\x01\0\xe3\x01\x01\n\x0b\n\x03\x04\x01\x01\x12\x04\xda\
    \x01\x08,\n\x0e\n\x04\x04\x01\x03\0\x12\x06\xdb\x01\x08\xdf\x01\t\n\r\n\
    \x05\x04\x01\x03\0\x01\x12\x04\xdb\x01\x10'\n\x0e\n\x06\x04\x01\x03\0\
    \x02\0\x12\x04\xdc\x01\x10/\n\x0f\n\x07\x04\x01\x03\0\x02\0\x04\x12\x04\
    \xdc\x01\x10\x18\n\x0f\n\x07\x04\x01\x03\0\x02\0\x05\x12\x04\xdc\x01\x19\
    \x1f\n\x0f\n\x07\x04\x01\x03\0\x02\0\x01\x12\x04\xdc\x01\x20*\n\x0f\n\
    \x07\x04\x01\x03\0\x02\0\x03\x12\x04\xdc\x01-.\n\x0e\n\x06\x04\x01\x03\0\
    \x02\x01\x12\x04\xdd\x01\x10,\n\x0f\n\x07\x04\x01\x03\0\x02\x01\x04\x12\
    \x04\xdd\x01\x10\x18\n\x0f\n\x07\x04\x01\x03\0\x02\x01\x05\x12\x04\xdd\
    \x01\x19\x1f\n\x0f\n\x07\x04\x01\x03\0\x02\x01\x01\x12\x04\xdd\x01\x20'\
    \n\x0f\n\x07\x04\x01\x03\0\x02\x01\x03\x12\x04\xdd\x01*+\n\x0e\n\x06\x04\
    \x01\x03\0\x02\x02\x12\x04\xde\x01\x10/\n\x0f\n\x07\x04\x01\x03\0\x02\
    \x02\x04\x12\x04\xde\x01\x10\x18\n\x0f\n\x07\x04\x01\x03\0\x02\x02\x05\
    \x12\x04\xde\x01\x19\x1f\n\x0f\n\x07\x04\x01\x03\0\x02\x02\x01\x12\x04\
    \xde\x01\x20*\n\x0f\n\x07\x04\x01\x03\0\x02\x02\x03\x12\x04\xde\x01-.\n\
    \x0c\n\x04\x04\x01\x02\0\x12\x04\xe1\x01\x08'\n\r\n\x05\x04\x01\x02\0\
    \x04\x12\x04\xe1\x01\x08\x10\n\r\n\x05\x04\x01\x02\0\x05\x12\x04\xe1\x01\
    \x11\x17\n\r\n\x05\x04\x01\x02\0\x01\x12\x04\xe1\x01\x18\"\n\r\n\x05\x04\
    \x01\x02\0\x03\x12\x04\xe1\x01%&\n\x0c\n\x04\x04\x01\x02\x01\x12\x04\xe2\
    \x01\x08m\n\r\n\x05\x04\x01\x02\x01\x04\x12\x04\xe2\x01\x08\x10\n\r\n\
    \x05\x04\x01\x02\x01\x06\x12\x04\xe2\x01\x11N\n\r\n\x05\x04\x01\x02\x01\
    \x01\x12\x04\xe2\x01Oh\n\r\n\x05\x04\x01\x02\x01\x03\x12\x04\xe2\x01kl\n\
    \x0c\n\x02\x04\x02\x12\x06\xe5\x01\0\xe7\x01\x01\n\x0b\n\x03\x04\x02\x01\
    \x12\x04\xe5\x01\x081\n\x0c\n\x04\x04\x02\x02\0\x12\x04\xe6\x01\x08%\n\r\
    \n\x05\x04\x02\x02\0\x04\x12\x04\xe6\x01\x08\x10\n\r\n\x05\x04\x02\x02\0\
    \x05\x12\x04\xe6\x01\x11\x17\n\r\n\x05\x04\x02\x02\0\x01\x12\x04\xe6\x01\
    \x18\x20\n\r\n\x05\x04\x02\x02\0\x03\x12\x04\xe6\x01#$\n\x0c\n\x02\x04\
    \x03\x12\x06\xe9\x01\0\xeb\x01\x01\n\x0b\n\x03\x04\x03\x01\x12\x04\xe9\
    \x01\x089\n\x0c\n\x04\x04\x03\x02\0\x12\x04\xea\x01\x08#\n\r\n\x05\x04\
    \x03\x02\0\x04\x12\x04\xea\x01\x08\x10\n\r\n\x05\x04\x03\x02\0\x05\x12\
    \x04\xea\x01\x11\x17\n\r\n\x05\x04\x03\x02\0\x01\x12\x04\xea\x01\x18\x1e\
    \n\r\n\x05\x04\x03\x02\0\x03\x12\x04\xea\x01!\"\n\x0c\n\x02\x04\x04\x12\
    \x06\xed\x01\0\xef\x01\x01\n\x0b\n\x03\x04\x04\x01\x12\x04\xed\x01\x08/\
    \n\x0c\n\x04\x04\x04\x02\0\x12\x04\xee\x01\x08$\n\r\n\x05\x04\x04\x02\0\
    \x04\x12\x04\xee\x01\x08\x10\n\r\n\x05\x04\x04\x02\0\x05\x12\x04\xee\x01\
    \x11\x17\n\r\n\x05\x04\x04\x02\0\x01\x12\x04\xee\x01\x18\x1f\n\r\n\x05\
    \x04\x04\x02\0\x03\x12\x04\xee\x01\"#\n\x0c\n\x02\x04\x05\x12\x06\xf1\
    \x01\0\xf3\x01\x01\n\x0b\n\x03\x04\x05\x01\x12\x04\xf1\x01\x087\n\x0c\n\
    \x04\x04\x05\x02\0\x12\x04\xf2\x01\x08#\n\r\n\x05\x04\x05\x02\0\x04\x12\
    \x04\xf2\x01\x08\x10\n\r\n\x05\x04\x05\x02\0\x05\x12\x04\xf2\x01\x11\x17\
    \n\r\n\x05\x04\x05\x02\0\x01\x12\x04\xf2\x01\x18\x1e\n\r\n\x05\x04\x05\
    \x02\0\x03\x12\x04\xf2\x01!\"\n\x0c\n\x02\x04\x06\x12\x06\xf5\x01\0\xf7\
    \x01\x01\n\x0b\n\x03\x04\x06\x01\x12\x04\xf5\x01\x08\x1c\n\x0c\n\x04\x04\
    \x06\x02\0\x12\x04\xf6\x01\x08%\n\r\n\x05\x04\x06\x02\0\x04\x12\x04\xf6\
    \x01\x08\x10\n\r\n\x05\x04\x06\x02\0\x05\x12\x04\xf6\x01\x11\x17\n\r\n\
    \x05\x04\x06\x02\0\x01\x12\x04\xf6\x01\x18\x20\n\r\n\x05\x04\x06\x02\0\
    \x03\x12\x04\xf6\x01#$\n\x0c\n\x02\x04\x07\x12\x06\xf9\x01\0\xfc\x01\x01\
    \n\x0b\n\x03\x04\x07\x01\x12\x04\xf9\x01\x08#\n\x0c\n\x04\x04\x07\x02\0\
    \x12\x04\xfa\x01\x08$\n\r\n\x05\x04\x07\x02\0\x04\x12\x04\xfa\x01\x08\
    \x10\n\r\n\x05\x04\x07\x02\0\x05\x12\x04\xfa\x01\x11\x17\n\r\n\x05\x04\
    \x07\x02\0\x01\x12\x04\xfa\x01\x18\x1f\n\r\n\x05\x04\x07\x02\0\x03\x12\
    \x04\xfa\x01\"#\n\x0c\n\x04\x04\x07\x02\x01\x12\x04\xfb\x01\x08%\n\r\n\
    \x05\x04\x07\x02\x01\x04\x12\x04\xfb\x01\x08\x10\n\r\n\x05\x04\x07\x02\
    \x01\x05\x12\x04\xfb\x01\x11\x17\n\r\n\x05\x04\x07\x02\x01\x01\x12\x04\
    \xfb\x01\x18\x20\n\r\n\x05\x04\x07\x02\x01\x03\x12\x04\xfb\x01#$\n\x0c\n\
    \x02\x04\x08\x12\x06\xfe\x01\0\x87\x02\x01\n\x0b\n\x03\x04\x08\x01\x12\
    \x04\xfe\x01\x08+\n\x0e\n\x04\x04\x08\x03\0\x12\x06\xff\x01\x08\x82\x02\
    \t\n\r\n\x05\x04\x08\x03\0\x01\x12\x04\xff\x01\x10\x15\n\x0e\n\x06\x04\
    \x08\x03\0\x02\0\x12\x04\x80\x02\x10-\n\x0f\n\x07\x04\x08\x03\0\x02\0\
    \x04\x12\x04\x80\x02\x10\x18\n\x0f\n\x07\x04\x08\x03\0\x02\0\x05\x12\x04\
    \x80\x02\x19\x1f\n\x0f\n\x07\x04\x08\x03\0\x02\0\x01\x12\x04\x80\x02\x20\
    (\n\x0f\n\x07\x04\x08\x03\0\x02\0\x03\x12\x04\x80\x02+,\n\x0e\n\x06\x04\
    \x08\x03\0\x02\x01\x12\x04\x81\x02\x10*\n\x0f\n\x07\x04\x08\x03\0\x02\
    \x01\x04\x12\x04\x81\x02\x10\x18\n\x0f\n\x07\x04\x08\x03\0\x02\x01\x05\
    \x12\x04\x81\x02\x19\x1f\n\x0f\n\x07\x04\x08\x03\0\x02\x01\x01\x12\x04\
    \x81\x02\x20%\n\x0f\n\x07\x04\x08\x03\0\x02\x01\x03\x12\x04\x81\x02()\n\
    \x0c\n\x04\x04\x08\x02\0\x12\x04\x84\x02\x08K\n\r\n\x05\x04\x08\x02\0\
    \x04\x12\x04\x84\x02\x08\x10\n\r\n\x05\x04\x08\x02\0\x06\x12\x04\x84\x02\
    \x11;\n\r\n\x05\x04\x08\x02\0\x01\x12\x04\x84\x02<F\n\r\n\x05\x04\x08\
    \x02\0\x03\x12\x04\x84\x02IJ\n\x0c\n\x04\x04\x08\x02\x01\x12\x04\x85\x02\
    \x08$\n\r\n\x05\x04\x08\x02\x01\x04\x12\x04\x85\x02\x08\x10\n\r\n\x05\
    \x04\x08\x02\x01\x05\x12\x04\x85\x02\x11\x17\n\r\n\x05\x04\x08\x02\x01\
    \x01\x12\x04\x85\x02\x18\x1f\n\r\n\x05\x04\x08\x02\x01\x03\x12\x04\x85\
    \x02\"#\n\x0c\n\x04\x04\x08\x02\x02\x12\x04\x86\x02\x08,\n\r\n\x05\x04\
    \x08\x02\x02\x04\x12\x04\x86\x02\x08\x10\n\r\n\x05\x04\x08\x02\x02\x05\
    \x12\x04\x86\x02\x11\x17\n\r\n\x05\x04\x08\x02\x02\x01\x12\x04\x86\x02\
    \x18'\n\r\n\x05\x04\x08\x02\x02\x03\x12\x04\x86\x02*+\n\x0c\n\x02\x04\t\
    \x12\x06\x89\x02\0\x8c\x02\x01\n\x0b\n\x03\x04\t\x01\x12\x04\x89\x02\x08\
    3\n\x0c\n\x04\x04\t\x02\0\x12\x04\x8a\x02\x08$\n\r\n\x05\x04\t\x02\0\x04\
    \x12\x04\x8a\x02\x08\x10\n\r\n\x05\x04\t\x02\0\x05\x12\x04\x8a\x02\x11\
    \x17\n\r\n\x05\x04\t\x02\0\x01\x12\x04\x8a\x02\x18\x1f\n\r\n\x05\x04\t\
    \x02\0\x03\x12\x04\x8a\x02\"#\n\x0c\n\x04\x04\t\x02\x01\x12\x04\x8b\x02\
    \x08,\n\r\n\x05\x04\t\x02\x01\x04\x12\x04\x8b\x02\x08\x10\n\r\n\x05\x04\
    \t\x02\x01\x05\x12\x04\x8b\x02\x11\x17\n\r\n\x05\x04\t\x02\x01\x01\x12\
    \x04\x8b\x02\x18'\n\r\n\x05\x04\t\x02\x01\x03\x12\x04\x8b\x02*+\n\x0c\n\
    \x02\x04\n\x12\x06\x8e\x02\0\x8f\x02\x01\n\x0b\n\x03\x04\n\x01\x12\x04\
    \x8e\x02\x08\x1d\n\x0c\n\x02\x04\x0b\x12\x06\x91\x02\0\x92\x02\x01\n\x0b\
    \n\x03\x04\x0b\x01\x12\x04\x91\x02\x08\x1e\n\x0c\n\x02\x04\x0c\x12\x06\
    \x94\x02\0\x96\x02\x01\n\x0b\n\x03\x04\x0c\x01\x12\x04\x94\x02\x08&\n\
    \x0c\n\x04\x04\x0c\x02\0\x12\x04\x95\x02\x08'\n\r\n\x05\x04\x0c\x02\0\
    \x04\x12\x04\x95\x02\x08\x10\n\r\n\x05\x04\x0c\x02\0\x05\x12\x04\x95\x02\
    \x11\x17\n\r\n\x05\x04\x0c\x02\0\x01\x12\x04\x95\x02\x18\"\n\r\n\x05\x04\
    \x0c\x02\0\x03\x12\x04\x95\x02%&\n\x0c\n\x02\x04\r\x12\x06\x98\x02\0\x9a\
    \x02\x01\n\x0b\n\x03\x04\r\x01\x12\x04\x98\x02\x08.\n\x0c\n\x04\x04\r\
    \x02\0\x12\x04\x99\x02\x08-\n\r\n\x05\x04\r\x02\0\x04\x12\x04\x99\x02\
    \x08\x10\n\r\n\x05\x04\r\x02\0\x05\x12\x04\x99\x02\x11\x18\n\r\n\x05\x04\
    \r\x02\0\x01\x12\x04\x99\x02\x19(\n\r\n\x05\x04\r\x02\0\x03\x12\x04\x99\
    \x02+,\n\x0c\n\x02\x04\x0e\x12\x06\x9c\x02\0\x9f\x02\x01\n\x0b\n\x03\x04\
    \x0e\x01\x12\x04\x9c\x02\x08&\n\x0c\n\x04\x04\x0e\x02\0\x12\x04\x9d\x02\
    \x08'\n\r\n\x05\x04\x0e\x02\0\x04\x12\x04\x9d\x02\x08\x10\n\r\n\x05\x04\
    \x0e\x02\0\x05\x12\x04\x9d\x02\x11\x17\n\r\n\x05\x04\x0e\x02\0\x01\x12\
    \x04\x9d\x02\x18\"\n\r\n\x05\x04\x0e\x02\0\x03\x12\x04\x9d\x02%&\n\x0c\n\
    \x04\x04\x0e\x02\x01\x12\x04\x9e\x02\x08+\n\r\n\x05\x04\x0e\x02\x01\x04\
    \x12\x04\x9e\x02\x08\x10\n\r\n\x05\x04\x0e\x02\x01\x05\x12\x04\x9e\x02\
    \x11\x17\n\r\n\x05\x04\x0e\x02\x01\x01\x12\x04\x9e\x02\x18&\n\r\n\x05\
    \x04\x0e\x02\x01\x03\x12\x04\x9e\x02)*\n\x0c\n\x02\x04\x0f\x12\x06\xa1\
    \x02\0\xa3\x02\x01\n\x0b\n\x03\x04\x0f\x01\x12\x04\xa1\x02\x08.\n\x0c\n\
    \x04\x04\x0f\x02\0\x12\x04\xa2\x02\x08.\n\r\n\x05\x04\x0f\x02\0\x04\x12\
    \x04\xa2\x02\x08\x10\n\r\n\x05\x04\x0f\x02\0\x05\x12\x04\xa2\x02\x11\x17\
    \n\r\n\x05\x04\x0f\x02\0\x01\x12\x04\xa2\x02\x18)\n\r\n\x05\x04\x0f\x02\
    \0\x03\x12\x04\xa2\x02,-\n\x0c\n\x02\x04\x10\x12\x06\xa5\x02\0\xa7\x02\
    \x01\n\x0b\n\x03\x04\x10\x01\x12\x04\xa5\x02\x08&\n\x0c\n\x04\x04\x10\
    \x02\0\x12\x04\xa6\x02\x087\n\r\n\x05\x04\x10\x02\0\x04\x12\x04\xa6\x02\
    \x08\x10\n\r\n\x05\x04\x10\x02\0\x05\x12\x04\xa6\x02\x11\x17\n\r\n\x05\
    \x04\x10\x02\0\x01\x12\x04\xa6\x02\x18\"\n\r\n\x05\x04\x10\x02\0\x03\x12\
    \x04\xa6\x02%&\n\r\n\x05\x04\x10\x02\0\x08\x12\x04\xa6\x02'6\n\x0e\n\x06\
    \x04\x10\x02\0\x08\x02\x12\x04\xa6\x02(5\n\x0c\n\x02\x04\x11\x12\x06\xa9\
    \x02\0\xb0\x02\x01\n\x0b\n\x03\x04\x11\x01\x12\x04\xa9\x02\x08.\n\x0e\n\
    \x04\x04\x11\x03\0\x12\x06\xaa\x02\x08\xad\x02\t\n\r\n\x05\x04\x11\x03\0\
    \x01\x12\x04\xaa\x02\x10\x17\n\x0e\n\x06\x04\x11\x03\0\x02\0\x12\x04\xab\
    \x02\x10.\n\x0f\n\x07\x04\x11\x03\0\x02\0\x04\x12\x04\xab\x02\x10\x18\n\
    \x0f\n\x07\x04\x11\x03\0\x02\0\x05\x12\x04\xab\x02\x19\x1f\n\x0f\n\x07\
    \x04\x11\x03\0\x02\0\x01\x12\x04\xab\x02\x20)\n\x0f\n\x07\x04\x11\x03\0\
    \x02\0\x03\x12\x04\xab\x02,-\n\x0e\n\x06\x04\x11\x03\0\x02\x01\x12\x04\
    \xac\x02\x10,\n\x0f\n\x07\x04\x11\x03\0\x02\x01\x04\x12\x04\xac\x02\x10\
    \x18\n\x0f\n\x07\x04\x11\x03\0\x02\x01\x05\x12\x04\xac\x02\x19\x1f\n\x0f\
    \n\x07\x04\x11\x03\0\x02\x01\x01\x12\x04\xac\x02\x20'\n\x0f\n\x07\x04\
    \x11\x03\0\x02\x01\x03\x12\x04\xac\x02*+\n\x0c\n\x04\x04\x11\x02\0\x12\
    \x04\xaf\x02\x08N\n\r\n\x05\x04\x11\x02\0\x04\x12\x04\xaf\x02\x08\x10\n\
    \r\n\x05\x04\x11\x02\0\x06\x12\x04\xaf\x02\x11@\n\r\n\x05\x04\x11\x02\0\
    \x01\x12\x04\xaf\x02AI\n\r\n\x05\x04\x11\x02\0\x03\x12\x04\xaf\x02LM\n\
    \x0c\n\x02\x04\x12\x12\x06\xb2\x02\0\xb5\x02\x01\n\x0b\n\x03\x04\x12\x01\
    \x12\x04\xb2\x02\x08,\n\x0c\n\x04\x04\x12\x02\0\x12\x04\xb3\x02\x08+\n\r\
    \n\x05\x04\x12\x02\0\x04\x12\x04\xb3\x02\x08\x10\n\r\n\x05\x04\x12\x02\0\
    \x05\x12\x04\xb3\x02\x11\x17\n\r\n\x05\x04\x12\x02\0\x01\x12\x04\xb3\x02\
    \x18&\n\r\n\x05\x04\x12\x02\0\x03\x12\x04\xb3\x02)*\n\x0c\n\x04\x04\x12\
    \x02\x01\x12\x04\xb4\x02\x08&\n\r\n\x05\x04\x12\x02\x01\x04\x12\x04\xb4\
    \x02\x08\x10\n\r\n\x05\x04\x12\x02\x01\x05\x12\x04\xb4\x02\x11\x17\n\r\n\
    \x05\x04\x12\x02\x01\x01\x12\x04\xb4\x02\x18!\n\r\n\x05\x04\x12\x02\x01\
    \x03\x12\x04\xb4\x02$%\n\x0c\n\x02\x04\x13\x12\x06\xb7\x02\0\xba\x02\x01\
    \n\x0b\n\x03\x04\x13\x01\x12\x04\xb7\x02\x08\"\n\x0c\n\x04\x04\x13\x02\0\
    \x12\x04\xb8\x02\x08/\n\r\n\x05\x04\x13\x02\0\x04\x12\x04\xb8\x02\x08\
    \x10\n\r\n\x05\x04\x13\x02\0\x05\x12\x04\xb8\x02\x11\x17\n\r\n\x05\x04\
    \x13\x02\0\x01\x12\x04\xb8\x02\x18*\n\r\n\x05\x04\x13\x02\0\x03\x12\x04\
    \xb8\x02-.\n\x0c\n\x04\x04\x13\x02\x01\x12\x04\xb9\x02\x083\n\r\n\x05\
    \x04\x13\x02\x01\x04\x12\x04\xb9\x02\x08\x10\n\r\n\x05\x04\x13\x02\x01\
    \x05\x12\x04\xb9\x02\x11\x17\n\r\n\x05\x04\x13\x02\x01\x01\x12\x04\xb9\
    \x02\x18.\n\r\n\x05\x04\x13\x02\x01\x03\x12\x04\xb9\x0212\n\x0c\n\x02\
    \x04\x14\x12\x06\xbc\x02\0\xbf\x02\x01\n\x0b\n\x03\x04\x14\x01\x12\x04\
    \xbc\x02\x08\"\n\x0c\n\x04\x04\x14\x02\0\x12\x04\xbd\x02\x08*\n\r\n\x05\
    \x04\x14\x02\0\x04\x12\x04\xbd\x02\x08\x10\n\r\n\x05\x04\x14\x02\0\x05\
    \x12\x04\xbd\x02\x11\x17\n\r\n\x05\x04\x14\x02\0\x01\x12\x04\xbd\x02\x18\
    %\n\r\n\x05\x04\x14\x02\0\x03\x12\x04\xbd\x02()\n\x0c\n\x04\x04\x14\x02\
    \x01\x12\x04\xbe\x02\x08-\n\r\n\x05\x04\x14\x02\x01\x04\x12\x04\xbe\x02\
    \x08\x10\n\r\n\x05\x04\x14\x02\x01\x05\x12\x04\xbe\x02\x11\x17\n\r\n\x05\
    \x04\x14\x02\x01\x01\x12\x04\xbe\x02\x18(\n\r\n\x05\x04\x14\x02\x01\x03\
    \x12\x04\xbe\x02+,\n\x0c\n\x02\x04\x15\x12\x06\xc1\x02\0\xc6\x02\x01\n\
    \x0b\n\x03\x04\x15\x01\x12\x04\xc1\x02\x08%\n\x0c\n\x04\x04\x15\x02\0\
    \x12\x04\xc2\x02\x08%\n\r\n\x05\x04\x15\x02\0\x04\x12\x04\xc2\x02\x08\
    \x10\n\r\n\x05\x04\x15\x02\0\x05\x12\x04\xc2\x02\x11\x17\n\r\n\x05\x04\
    \x15\x02\0\x01\x12\x04\xc2\x02\x18\x20\n\r\n\x05\x04\x15\x02\0\x03\x12\
    \x04\xc2\x02#$\n\x0c\n\x04\x04\x15\x02\x01\x12\x04\xc3\x02\x08/\n\r\n\
    \x05\x04\x15\x02\x01\x04\x12\x04\xc3\x02\x08\x10\n\r\n\x05\x04\x15\x02\
    \x01\x05\x12\x04\xc3\x02\x11\x17\n\r\n\x05\x04\x15\x02\x01\x01\x12\x04\
    \xc3\x02\x18*\n\r\n\x05\x04\x15\x02\x01\x03\x12\x04\xc3\x02-.\n\x0c\n\
    \x04\x04\x15\x02\x02\x12\x04\xc4\x02\x08\"\n\r\n\x05\x04\x15\x02\x02\x04\
    \x12\x04\xc4\x02\x08\x10\n\r\n\x05\x04\x15\x02\x02\x05\x12\x04\xc4\x02\
    \x11\x17\n\r\n\x05\x04\x15\x02\x02\x01\x12\x04\xc4\x02\x18\x1d\n\r\n\x05\
    \x04\x15\x02\x02\x03\x12\x04\xc4\x02\x20!\n\x0c\n\x04\x04\x15\x02\x03\
    \x12\x04\xc5\x02\x08+\n\r\n\x05\x04\x15\x02\x03\x04\x12\x04\xc5\x02\x08\
    \x10\n\r\n\x05\x04\x15\x02\x03\x05\x12\x04\xc5\x02\x11\x18\n\r\n\x05\x04\
    \x15\x02\x03\x01\x12\x04\xc5\x02\x19&\n\r\n\x05\x04\x15\x02\x03\x03\x12\
    \x04\xc5\x02)*\n\x0c\n\x02\x04\x16\x12\x06\xc8\x02\0\xcf\x02\x01\n\x0b\n\
    \x03\x04\x16\x01\x12\x04\xc8\x02\x08)\n\x0c\n\x04\x04\x16\x02\0\x12\x04\
    \xc9\x02\x08%\n\r\n\x05\x04\x16\x02\0\x04\x12\x04\xc9\x02\x08\x10\n\r\n\
    \x05\x04\x16\x02\0\x05\x12\x04\xc9\x02\x11\x17\n\r\n\x05\x04\x16\x02\0\
    \x01\x12\x04\xc9\x02\x18\x20\n\r\n\x05\x04\x16\x02\0\x03\x12\x04\xc9\x02\
    #$\n\x0c\n\x04\x04\x16\x02\x01\x12\x04\xca\x02\x08+\n\r\n\x05\x04\x16\
    \x02\x01\x04\x12\x04\xca\x02\x08\x10\n\r\n\x05\x04\x16\x02\x01\x05\x12\
    \x04\xca\x02\x11\x18\n\r\n\x05\x04\x16\x02\x01\x01\x12\x04\xca\x02\x19&\
    \n\r\n\x05\x04\x16\x02\x01\x03\x12\x04\xca\x02)*\n\x0c\n\x04\x04\x16\x02\
    \x02\x12\x04\xcb\x02\x08?\n\r\n\x05\x04\x16\x02\x02\x04\x12\x04\xcb\x02\
    \x08\x10\n\r\n\x05\x04\x16\x02\x02\x05\x12\x04\xcb\x02\x11\x15\n\r\n\x05\
    \x04\x16\x02\x02\x01\x12\x04\xcb\x02\x16(\n\r\n\x05\x04\x16\x02\x02\x03\
    \x12\x04\xcb\x02+,\n\r\n\x05\x04\x16\x02\x02\x08\x12\x04\xcb\x02->\n\r\n\
    \x05\x04\x16\x02\x02\x07\x12\x04\xcb\x028=\n\x0c\n\x04\x04\x16\x02\x03\
    \x12\x04\xcc\x02\x08%\n\r\n\x05\x04\x16\x02\x03\x04\x12\x04\xcc\x02\x08\
    \x10\n\r\n\x05\x04\x16\x02\x03\x05\x12\x04\xcc\x02\x11\x17\n\r\n\x05\x04\
    \x16\x02\x03\x01\x12\x04\xcc\x02\x18\x20\n\r\n\x05\x04\x16\x02\x03\x03\
    \x12\x04\xcc\x02#$\n\x0c\n\x04\x04\x16\x02\x04\x12\x04\xcd\x02\x08%\n\r\
    \n\x05\x04\x16\x02\x04\x04\x12\x04\xcd\x02\x08\x10\n\r\n\x05\x04\x16\x02\
    \x04\x05\x12\x04\xcd\x02\x11\x17\n\r\n\x05\x04\x16\x02\x04\x01\x12\x04\
    \xcd\x02\x18\x20\n\r\n\x05\x04\x16\x02\x04\x03\x12\x04\xcd\x02#$\n\x0c\n\
    \x04\x04\x16\x02\x05\x12\x04\xce\x02\x08%\n\r\n\x05\x04\x16\x02\x05\x04\
    \x12\x04\xce\x02\x08\x10\n\r\n\x05\x04\x16\x02\x05\x05\x12\x04\xce\x02\
    \x11\x17\n\r\n\x05\x04\x16\x02\x05\x01\x12\x04\xce\x02\x18\x20\n\r\n\x05\
    \x04\x16\x02\x05\x03\x12\x04\xce\x02#$\n\x0c\n\x02\x04\x17\x12\x06\xd1\
    \x02\0\xd3\x02\x01\n\x0b\n\x03\x04\x17\x01\x12\x04\xd1\x02\x08#\n\x0c\n\
    \x04\x04\x17\x02\0\x12\x04\xd2\x02\x08%\n\r\n\x05\x04\x17\x02\0\x04\x12\
    \x04\xd2\x02\x08\x10\n\r\n\x05\x04\x17\x02\0\x05\x12\x04\xd2\x02\x11\x17\
    \n\r\n\x05\x04\x17\x02\0\x01\x12\x04\xd2\x02\x18\x20\n\r\n\x05\x04\x17\
    \x02\0\x03\x12\x04\xd2\x02#$\n\x0c\n\x02\x04\x18\x12\x06\xd5\x02\0\xd6\
    \x02\x01\n\x0b\n\x03\x04\x18\x01\x12\x04\xd5\x02\x08\x1c\n\x0c\n\x02\x04\
    \x19\x12\x06\xd8\x02\0\xda\x02\x01\n\x0b\n\x03\x04\x19\x01\x12\x04\xd8\
    \x02\x08/\n\x0c\n\x04\x04\x19\x02\0\x12\x04\xd9\x02\x08%\n\r\n\x05\x04\
    \x19\x02\0\x04\x12\x04\xd9\x02\x08\x10\n\r\n\x05\x04\x19\x02\0\x05\x12\
    \x04\xd9\x02\x11\x17\n\r\n\x05\x04\x19\x02\0\x01\x12\x04\xd9\x02\x18\x20\
    \n\r\n\x05\x04\x19\x02\0\x03\x12\x04\xd9\x02#$\n\x0c\n\x02\x04\x1a\x12\
    \x06\xdc\x02\0\xdd\x02\x01\n\x0b\n\x03\x04\x1a\x01\x12\x04\xdc\x02\x082\
    \n\x0c\n\x02\x04\x1b\x12\x06\xdf\x02\0\xe1\x02\x01\n\x0b\n\x03\x04\x1b\
    \x01\x12\x04\xdf\x02\x08\"\n\x0c\n\x04\x04\x1b\x02\0\x12\x04\xe0\x02\x08\
    $\n\r\n\x05\x04\x1b\x02\0\x04\x12\x04\xe0\x02\x08\x10\n\r\n\x05\x04\x1b\
    \x02\0\x05\x12\x04\xe0\x02\x11\x17\n\r\n\x05\x04\x1b\x02\0\x01\x12\x04\
    \xe0\x02\x18\x1f\n\r\n\x05\x04\x1b\x02\0\x03\x12\x04\xe0\x02\"#\n\x0c\n\
    \x02\x04\x1c\x12\x06\xe3\x02\0\xe6\x02\x01\n\x0b\n\x03\x04\x1c\x01\x12\
    \x04\xe3\x02\x08\"\n\x0c\n\x04\x04\x1c\x02\0\x12\x04\xe4\x02\x08$\n\r\n\
    \x05\x04\x1c\x02\0\x04\x12\x04\xe4\x02\x08\x10\n\r\n\x05\x04\x1c\x02\0\
    \x05\x12\x04\xe4\x02\x11\x17\n\r\n\x05\x04\x1c\x02\0\x01\x12\x04\xe4\x02\
    \x18\x1f\n\r\n\x05\x04\x1c\x02\0\x03\x12\x04\xe4\x02\"#\n\x0c\n\x04\x04\
    \x1c\x02\x01\x12\x04\xe5\x02\x08$\n\r\n\x05\x04\x1c\x02\x01\x04\x12\x04\
    \xe5\x02\x08\x10\n\r\n\x05\x04\x1c\x02\x01\x05\x12\x04\xe5\x02\x11\x17\n\
    \r\n\x05\x04\x1c\x02\x01\x01\x12\x04\xe5\x02\x18\x1f\n\r\n\x05\x04\x1c\
    \x02\x01\x03\x12\x04\xe5\x02\"#\n\x0c\n\x02\x04\x1d\x12\x06\xe8\x02\0\
    \xeb\x02\x01\n\x0b\n\x03\x04\x1d\x01\x12\x04\xe8\x02\x08\x20\n\x0c\n\x04\
    \x04\x1d\x02\0\x12\x04\xe9\x02\x08$\n\r\n\x05\x04\x1d\x02\0\x04\x12\x04\
    \xe9\x02\x08\x10\n\r\n\x05\x04\x1d\x02\0\x05\x12\x04\xe9\x02\x11\x17\n\r\
    \n\x05\x04\x1d\x02\0\x01\x12\x04\xe9\x02\x18\x1f\n\r\n\x05\x04\x1d\x02\0\
    \x03\x12\x04\xe9\x02\"#\n\x0c\n\x04\x04\x1d\x02\x01\x12\x04\xea\x02\x08$\
    \n\r\n\x05\x04\x1d\x02\x01\x04\x12\x04\xea\x02\x08\x10\n\r\n\x05\x04\x1d\
    \x02\x01\x05\x12\x04\xea\x02\x11\x17\n\r\n\x05\x04\x1d\x02\x01\x01\x12\
    \x04\xea\x02\x18\x1f\n\r\n\x05\x04\x1d\x02\x01\x03\x12\x04\xea\x02\"#\n\
    \x0c\n\x02\x04\x1e\x12\x06\xed\x02\0\xef\x02\x01\n\x0b\n\x03\x04\x1e\x01\
    \x12\x04\xed\x02\x08\"\n\x0c\n\x04\x04\x1e\x02\0\x12\x04\xee\x02\x08%\n\
    \r\n\x05\x04\x1e\x02\0\x04\x12\x04\xee\x02\x08\x10\n\r\n\x05\x04\x1e\x02\
    \0\x05\x12\x04\xee\x02\x11\x17\n\r\n\x05\x04\x1e\x02\0\x01\x12\x04\xee\
    \x02\x18\x20\n\r\n\x05\x04\x1e\x02\0\x03\x12\x04\xee\x02#$\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
