// This file is generated by rust-protobuf 2.24.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `tf_gcmessages.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_24_1;

#[derive(PartialEq,Clone,Default)]
pub struct CMsgTFGoldenWrenchBroadcast {
    // message fields
    wrench_number: ::std::option::Option<i32>,
    deleted: ::std::option::Option<bool>,
    user_name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgTFGoldenWrenchBroadcast {
    fn default() -> &'a CMsgTFGoldenWrenchBroadcast {
        <CMsgTFGoldenWrenchBroadcast as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTFGoldenWrenchBroadcast {
    pub fn new() -> CMsgTFGoldenWrenchBroadcast {
        ::std::default::Default::default()
    }

    // optional int32 wrench_number = 1;


    pub fn get_wrench_number(&self) -> i32 {
        self.wrench_number.unwrap_or(0)
    }
    pub fn clear_wrench_number(&mut self) {
        self.wrench_number = ::std::option::Option::None;
    }

    pub fn has_wrench_number(&self) -> bool {
        self.wrench_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wrench_number(&mut self, v: i32) {
        self.wrench_number = ::std::option::Option::Some(v);
    }

    // optional bool deleted = 2;


    pub fn get_deleted(&self) -> bool {
        self.deleted.unwrap_or(false)
    }
    pub fn clear_deleted(&mut self) {
        self.deleted = ::std::option::Option::None;
    }

    pub fn has_deleted(&self) -> bool {
        self.deleted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deleted(&mut self, v: bool) {
        self.deleted = ::std::option::Option::Some(v);
    }

    // optional string user_name = 3;


    pub fn get_user_name(&self) -> &str {
        match self.user_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_user_name(&mut self) {
        self.user_name.clear();
    }

    pub fn has_user_name(&self) -> bool {
        self.user_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_name(&mut self, v: ::std::string::String) {
        self.user_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_name(&mut self) -> &mut ::std::string::String {
        if self.user_name.is_none() {
            self.user_name.set_default();
        }
        self.user_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_name(&mut self) -> ::std::string::String {
        self.user_name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgTFGoldenWrenchBroadcast {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.wrench_number = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.deleted = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.user_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.wrench_number {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.deleted {
            my_size += 2;
        }
        if let Some(ref v) = self.user_name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.wrench_number {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.deleted {
            os.write_bool(2, v)?;
        }
        if let Some(ref v) = self.user_name.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgTFGoldenWrenchBroadcast {
        CMsgTFGoldenWrenchBroadcast::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "wrench_number",
                |m: &CMsgTFGoldenWrenchBroadcast| { &m.wrench_number },
                |m: &mut CMsgTFGoldenWrenchBroadcast| { &mut m.wrench_number },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "deleted",
                |m: &CMsgTFGoldenWrenchBroadcast| { &m.deleted },
                |m: &mut CMsgTFGoldenWrenchBroadcast| { &mut m.deleted },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "user_name",
                |m: &CMsgTFGoldenWrenchBroadcast| { &m.user_name },
                |m: &mut CMsgTFGoldenWrenchBroadcast| { &mut m.user_name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgTFGoldenWrenchBroadcast>(
                "CMsgTFGoldenWrenchBroadcast",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgTFGoldenWrenchBroadcast {
        static instance: ::protobuf::rt::LazyV2<CMsgTFGoldenWrenchBroadcast> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgTFGoldenWrenchBroadcast::new)
    }
}

impl ::protobuf::Clear for CMsgTFGoldenWrenchBroadcast {
    fn clear(&mut self) {
        self.wrench_number = ::std::option::Option::None;
        self.deleted = ::std::option::Option::None;
        self.user_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgTFGoldenWrenchBroadcast {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTFGoldenWrenchBroadcast {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgTFSaxxyBroadcast {
    // message fields
    category_number: ::std::option::Option<i32>,
    user_name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgTFSaxxyBroadcast {
    fn default() -> &'a CMsgTFSaxxyBroadcast {
        <CMsgTFSaxxyBroadcast as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTFSaxxyBroadcast {
    pub fn new() -> CMsgTFSaxxyBroadcast {
        ::std::default::Default::default()
    }

    // optional int32 category_number = 1;


    pub fn get_category_number(&self) -> i32 {
        self.category_number.unwrap_or(0)
    }
    pub fn clear_category_number(&mut self) {
        self.category_number = ::std::option::Option::None;
    }

    pub fn has_category_number(&self) -> bool {
        self.category_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_category_number(&mut self, v: i32) {
        self.category_number = ::std::option::Option::Some(v);
    }

    // optional string user_name = 2;


    pub fn get_user_name(&self) -> &str {
        match self.user_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_user_name(&mut self) {
        self.user_name.clear();
    }

    pub fn has_user_name(&self) -> bool {
        self.user_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_name(&mut self, v: ::std::string::String) {
        self.user_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_name(&mut self) -> &mut ::std::string::String {
        if self.user_name.is_none() {
            self.user_name.set_default();
        }
        self.user_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_name(&mut self) -> ::std::string::String {
        self.user_name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgTFSaxxyBroadcast {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.category_number = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.user_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.category_number {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.user_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.category_number {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.user_name.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgTFSaxxyBroadcast {
        CMsgTFSaxxyBroadcast::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "category_number",
                |m: &CMsgTFSaxxyBroadcast| { &m.category_number },
                |m: &mut CMsgTFSaxxyBroadcast| { &mut m.category_number },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "user_name",
                |m: &CMsgTFSaxxyBroadcast| { &m.user_name },
                |m: &mut CMsgTFSaxxyBroadcast| { &mut m.user_name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgTFSaxxyBroadcast>(
                "CMsgTFSaxxyBroadcast",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgTFSaxxyBroadcast {
        static instance: ::protobuf::rt::LazyV2<CMsgTFSaxxyBroadcast> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgTFSaxxyBroadcast::new)
    }
}

impl ::protobuf::Clear for CMsgTFSaxxyBroadcast {
    fn clear(&mut self) {
        self.category_number = ::std::option::Option::None;
        self.user_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgTFSaxxyBroadcast {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTFSaxxyBroadcast {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCTFSpecificItemBroadcast {
    // message fields
    item_def_index: ::std::option::Option<u32>,
    was_destruction: ::std::option::Option<bool>,
    user_name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCTFSpecificItemBroadcast {
    fn default() -> &'a CMsgGCTFSpecificItemBroadcast {
        <CMsgGCTFSpecificItemBroadcast as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCTFSpecificItemBroadcast {
    pub fn new() -> CMsgGCTFSpecificItemBroadcast {
        ::std::default::Default::default()
    }

    // optional uint32 item_def_index = 1;


    pub fn get_item_def_index(&self) -> u32 {
        self.item_def_index.unwrap_or(0)
    }
    pub fn clear_item_def_index(&mut self) {
        self.item_def_index = ::std::option::Option::None;
    }

    pub fn has_item_def_index(&self) -> bool {
        self.item_def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_def_index(&mut self, v: u32) {
        self.item_def_index = ::std::option::Option::Some(v);
    }

    // optional bool was_destruction = 2;


    pub fn get_was_destruction(&self) -> bool {
        self.was_destruction.unwrap_or(false)
    }
    pub fn clear_was_destruction(&mut self) {
        self.was_destruction = ::std::option::Option::None;
    }

    pub fn has_was_destruction(&self) -> bool {
        self.was_destruction.is_some()
    }

    // Param is passed by value, moved
    pub fn set_was_destruction(&mut self, v: bool) {
        self.was_destruction = ::std::option::Option::Some(v);
    }

    // optional string user_name = 3;


    pub fn get_user_name(&self) -> &str {
        match self.user_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_user_name(&mut self) {
        self.user_name.clear();
    }

    pub fn has_user_name(&self) -> bool {
        self.user_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_name(&mut self, v: ::std::string::String) {
        self.user_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_name(&mut self) -> &mut ::std::string::String {
        if self.user_name.is_none() {
            self.user_name.set_default();
        }
        self.user_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_name(&mut self) -> ::std::string::String {
        self.user_name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgGCTFSpecificItemBroadcast {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.item_def_index = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.was_destruction = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.user_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.item_def_index {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.was_destruction {
            my_size += 2;
        }
        if let Some(ref v) = self.user_name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.item_def_index {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.was_destruction {
            os.write_bool(2, v)?;
        }
        if let Some(ref v) = self.user_name.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCTFSpecificItemBroadcast {
        CMsgGCTFSpecificItemBroadcast::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "item_def_index",
                |m: &CMsgGCTFSpecificItemBroadcast| { &m.item_def_index },
                |m: &mut CMsgGCTFSpecificItemBroadcast| { &mut m.item_def_index },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "was_destruction",
                |m: &CMsgGCTFSpecificItemBroadcast| { &m.was_destruction },
                |m: &mut CMsgGCTFSpecificItemBroadcast| { &mut m.was_destruction },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "user_name",
                |m: &CMsgGCTFSpecificItemBroadcast| { &m.user_name },
                |m: &mut CMsgGCTFSpecificItemBroadcast| { &mut m.user_name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCTFSpecificItemBroadcast>(
                "CMsgGCTFSpecificItemBroadcast",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCTFSpecificItemBroadcast {
        static instance: ::protobuf::rt::LazyV2<CMsgGCTFSpecificItemBroadcast> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCTFSpecificItemBroadcast::new)
    }
}

impl ::protobuf::Clear for CMsgGCTFSpecificItemBroadcast {
    fn clear(&mut self) {
        self.item_def_index = ::std::option::Option::None;
        self.was_destruction = ::std::option::Option::None;
        self.user_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCTFSpecificItemBroadcast {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCTFSpecificItemBroadcast {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgTFWorldStatus {
    // message fields
    beta_stress_test_event_active: ::std::option::Option<bool>,
    event_match_group: ::std::option::Option<ETFMatchGroup>,
    event_expire_time: ::std::option::Option<u32>,
    active_client_version: ::std::option::Option<u32>,
    pub disabled_match_groups: ::std::vec::Vec<ETFMatchGroup>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgTFWorldStatus {
    fn default() -> &'a CMsgTFWorldStatus {
        <CMsgTFWorldStatus as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTFWorldStatus {
    pub fn new() -> CMsgTFWorldStatus {
        ::std::default::Default::default()
    }

    // optional bool beta_stress_test_event_active = 1;


    pub fn get_beta_stress_test_event_active(&self) -> bool {
        self.beta_stress_test_event_active.unwrap_or(false)
    }
    pub fn clear_beta_stress_test_event_active(&mut self) {
        self.beta_stress_test_event_active = ::std::option::Option::None;
    }

    pub fn has_beta_stress_test_event_active(&self) -> bool {
        self.beta_stress_test_event_active.is_some()
    }

    // Param is passed by value, moved
    pub fn set_beta_stress_test_event_active(&mut self, v: bool) {
        self.beta_stress_test_event_active = ::std::option::Option::Some(v);
    }

    // optional .ETFMatchGroup event_match_group = 2;


    pub fn get_event_match_group(&self) -> ETFMatchGroup {
        self.event_match_group.unwrap_or(ETFMatchGroup::k_eTFMatchGroup_Invalid)
    }
    pub fn clear_event_match_group(&mut self) {
        self.event_match_group = ::std::option::Option::None;
    }

    pub fn has_event_match_group(&self) -> bool {
        self.event_match_group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_match_group(&mut self, v: ETFMatchGroup) {
        self.event_match_group = ::std::option::Option::Some(v);
    }

    // optional fixed32 event_expire_time = 3;


    pub fn get_event_expire_time(&self) -> u32 {
        self.event_expire_time.unwrap_or(0u32)
    }
    pub fn clear_event_expire_time(&mut self) {
        self.event_expire_time = ::std::option::Option::None;
    }

    pub fn has_event_expire_time(&self) -> bool {
        self.event_expire_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_expire_time(&mut self, v: u32) {
        self.event_expire_time = ::std::option::Option::Some(v);
    }

    // optional uint32 active_client_version = 4;


    pub fn get_active_client_version(&self) -> u32 {
        self.active_client_version.unwrap_or(0)
    }
    pub fn clear_active_client_version(&mut self) {
        self.active_client_version = ::std::option::Option::None;
    }

    pub fn has_active_client_version(&self) -> bool {
        self.active_client_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_active_client_version(&mut self, v: u32) {
        self.active_client_version = ::std::option::Option::Some(v);
    }

    // repeated .ETFMatchGroup disabled_match_groups = 5;


    pub fn get_disabled_match_groups(&self) -> &[ETFMatchGroup] {
        &self.disabled_match_groups
    }
    pub fn clear_disabled_match_groups(&mut self) {
        self.disabled_match_groups.clear();
    }

    // Param is passed by value, moved
    pub fn set_disabled_match_groups(&mut self, v: ::std::vec::Vec<ETFMatchGroup>) {
        self.disabled_match_groups = v;
    }

    // Mutable pointer to the field.
    pub fn mut_disabled_match_groups(&mut self) -> &mut ::std::vec::Vec<ETFMatchGroup> {
        &mut self.disabled_match_groups
    }

    // Take field
    pub fn take_disabled_match_groups(&mut self) -> ::std::vec::Vec<ETFMatchGroup> {
        ::std::mem::replace(&mut self.disabled_match_groups, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgTFWorldStatus {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.beta_stress_test_event_active = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.event_match_group, 2, &mut self.unknown_fields)?
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.event_expire_time = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.active_client_version = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.disabled_match_groups, 5, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.beta_stress_test_event_active {
            my_size += 2;
        }
        if let Some(v) = self.event_match_group {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        if let Some(v) = self.event_expire_time {
            my_size += 5;
        }
        if let Some(v) = self.active_client_version {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.disabled_match_groups {
            my_size += ::protobuf::rt::enum_size(5, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.beta_stress_test_event_active {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.event_match_group {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.event_expire_time {
            os.write_fixed32(3, v)?;
        }
        if let Some(v) = self.active_client_version {
            os.write_uint32(4, v)?;
        }
        for v in &self.disabled_match_groups {
            os.write_enum(5, ::protobuf::ProtobufEnum::value(v))?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgTFWorldStatus {
        CMsgTFWorldStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "beta_stress_test_event_active",
                |m: &CMsgTFWorldStatus| { &m.beta_stress_test_event_active },
                |m: &mut CMsgTFWorldStatus| { &mut m.beta_stress_test_event_active },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ETFMatchGroup>>(
                "event_match_group",
                |m: &CMsgTFWorldStatus| { &m.event_match_group },
                |m: &mut CMsgTFWorldStatus| { &mut m.event_match_group },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "event_expire_time",
                |m: &CMsgTFWorldStatus| { &m.event_expire_time },
                |m: &mut CMsgTFWorldStatus| { &mut m.event_expire_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "active_client_version",
                |m: &CMsgTFWorldStatus| { &m.active_client_version },
                |m: &mut CMsgTFWorldStatus| { &mut m.active_client_version },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ETFMatchGroup>>(
                "disabled_match_groups",
                |m: &CMsgTFWorldStatus| { &m.disabled_match_groups },
                |m: &mut CMsgTFWorldStatus| { &mut m.disabled_match_groups },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgTFWorldStatus>(
                "CMsgTFWorldStatus",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgTFWorldStatus {
        static instance: ::protobuf::rt::LazyV2<CMsgTFWorldStatus> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgTFWorldStatus::new)
    }
}

impl ::protobuf::Clear for CMsgTFWorldStatus {
    fn clear(&mut self) {
        self.beta_stress_test_event_active = ::std::option::Option::None;
        self.event_match_group = ::std::option::Option::None;
        self.event_expire_time = ::std::option::Option::None;
        self.active_client_version = ::std::option::Option::None;
        self.disabled_match_groups.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgTFWorldStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTFWorldStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CSOTFDuelSummary {
    // message fields
    account_id: ::std::option::Option<u32>,
    duel_wins: ::std::option::Option<u32>,
    duel_losses: ::std::option::Option<u32>,
    last_duel_account_id: ::std::option::Option<u32>,
    last_duel_timestamp: ::std::option::Option<u32>,
    last_duel_status: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CSOTFDuelSummary {
    fn default() -> &'a CSOTFDuelSummary {
        <CSOTFDuelSummary as ::protobuf::Message>::default_instance()
    }
}

impl CSOTFDuelSummary {
    pub fn new() -> CSOTFDuelSummary {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;


    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }
    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 duel_wins = 2;


    pub fn get_duel_wins(&self) -> u32 {
        self.duel_wins.unwrap_or(0)
    }
    pub fn clear_duel_wins(&mut self) {
        self.duel_wins = ::std::option::Option::None;
    }

    pub fn has_duel_wins(&self) -> bool {
        self.duel_wins.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duel_wins(&mut self, v: u32) {
        self.duel_wins = ::std::option::Option::Some(v);
    }

    // optional uint32 duel_losses = 3;


    pub fn get_duel_losses(&self) -> u32 {
        self.duel_losses.unwrap_or(0)
    }
    pub fn clear_duel_losses(&mut self) {
        self.duel_losses = ::std::option::Option::None;
    }

    pub fn has_duel_losses(&self) -> bool {
        self.duel_losses.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duel_losses(&mut self, v: u32) {
        self.duel_losses = ::std::option::Option::Some(v);
    }

    // optional uint32 last_duel_account_id = 4;


    pub fn get_last_duel_account_id(&self) -> u32 {
        self.last_duel_account_id.unwrap_or(0)
    }
    pub fn clear_last_duel_account_id(&mut self) {
        self.last_duel_account_id = ::std::option::Option::None;
    }

    pub fn has_last_duel_account_id(&self) -> bool {
        self.last_duel_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_duel_account_id(&mut self, v: u32) {
        self.last_duel_account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 last_duel_timestamp = 5;


    pub fn get_last_duel_timestamp(&self) -> u32 {
        self.last_duel_timestamp.unwrap_or(0)
    }
    pub fn clear_last_duel_timestamp(&mut self) {
        self.last_duel_timestamp = ::std::option::Option::None;
    }

    pub fn has_last_duel_timestamp(&self) -> bool {
        self.last_duel_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_duel_timestamp(&mut self, v: u32) {
        self.last_duel_timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 last_duel_status = 6;


    pub fn get_last_duel_status(&self) -> u32 {
        self.last_duel_status.unwrap_or(0)
    }
    pub fn clear_last_duel_status(&mut self) {
        self.last_duel_status = ::std::option::Option::None;
    }

    pub fn has_last_duel_status(&self) -> bool {
        self.last_duel_status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_duel_status(&mut self, v: u32) {
        self.last_duel_status = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CSOTFDuelSummary {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.duel_wins = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.duel_losses = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.last_duel_account_id = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.last_duel_timestamp = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.last_duel_status = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.duel_wins {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.duel_losses {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.last_duel_account_id {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.last_duel_timestamp {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.last_duel_status {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.duel_wins {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.duel_losses {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.last_duel_account_id {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.last_duel_timestamp {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.last_duel_status {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CSOTFDuelSummary {
        CSOTFDuelSummary::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "account_id",
                |m: &CSOTFDuelSummary| { &m.account_id },
                |m: &mut CSOTFDuelSummary| { &mut m.account_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "duel_wins",
                |m: &CSOTFDuelSummary| { &m.duel_wins },
                |m: &mut CSOTFDuelSummary| { &mut m.duel_wins },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "duel_losses",
                |m: &CSOTFDuelSummary| { &m.duel_losses },
                |m: &mut CSOTFDuelSummary| { &mut m.duel_losses },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "last_duel_account_id",
                |m: &CSOTFDuelSummary| { &m.last_duel_account_id },
                |m: &mut CSOTFDuelSummary| { &mut m.last_duel_account_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "last_duel_timestamp",
                |m: &CSOTFDuelSummary| { &m.last_duel_timestamp },
                |m: &mut CSOTFDuelSummary| { &mut m.last_duel_timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "last_duel_status",
                |m: &CSOTFDuelSummary| { &m.last_duel_status },
                |m: &mut CSOTFDuelSummary| { &mut m.last_duel_status },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CSOTFDuelSummary>(
                "CSOTFDuelSummary",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CSOTFDuelSummary {
        static instance: ::protobuf::rt::LazyV2<CSOTFDuelSummary> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CSOTFDuelSummary::new)
    }
}

impl ::protobuf::Clear for CSOTFDuelSummary {
    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.duel_wins = ::std::option::Option::None;
        self.duel_losses = ::std::option::Option::None;
        self.last_duel_account_id = ::std::option::Option::None;
        self.last_duel_timestamp = ::std::option::Option::None;
        self.last_duel_status = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSOTFDuelSummary {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOTFDuelSummary {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CSOTFMapContribution {
    // message fields
    account_id: ::std::option::Option<u32>,
    def_index: ::std::option::Option<u32>,
    contribution_level: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CSOTFMapContribution {
    fn default() -> &'a CSOTFMapContribution {
        <CSOTFMapContribution as ::protobuf::Message>::default_instance()
    }
}

impl CSOTFMapContribution {
    pub fn new() -> CSOTFMapContribution {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;


    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }
    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 def_index = 2;


    pub fn get_def_index(&self) -> u32 {
        self.def_index.unwrap_or(0)
    }
    pub fn clear_def_index(&mut self) {
        self.def_index = ::std::option::Option::None;
    }

    pub fn has_def_index(&self) -> bool {
        self.def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_def_index(&mut self, v: u32) {
        self.def_index = ::std::option::Option::Some(v);
    }

    // optional uint32 contribution_level = 3;


    pub fn get_contribution_level(&self) -> u32 {
        self.contribution_level.unwrap_or(0)
    }
    pub fn clear_contribution_level(&mut self) {
        self.contribution_level = ::std::option::Option::None;
    }

    pub fn has_contribution_level(&self) -> bool {
        self.contribution_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_contribution_level(&mut self, v: u32) {
        self.contribution_level = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CSOTFMapContribution {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.def_index = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.contribution_level = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.def_index {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.contribution_level {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.def_index {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.contribution_level {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CSOTFMapContribution {
        CSOTFMapContribution::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "account_id",
                |m: &CSOTFMapContribution| { &m.account_id },
                |m: &mut CSOTFMapContribution| { &mut m.account_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "def_index",
                |m: &CSOTFMapContribution| { &m.def_index },
                |m: &mut CSOTFMapContribution| { &mut m.def_index },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "contribution_level",
                |m: &CSOTFMapContribution| { &m.contribution_level },
                |m: &mut CSOTFMapContribution| { &mut m.contribution_level },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CSOTFMapContribution>(
                "CSOTFMapContribution",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CSOTFMapContribution {
        static instance: ::protobuf::rt::LazyV2<CSOTFMapContribution> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CSOTFMapContribution::new)
    }
}

impl ::protobuf::Clear for CSOTFMapContribution {
    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.def_index = ::std::option::Option::None;
        self.contribution_level = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSOTFMapContribution {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOTFMapContribution {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgTFFreeTrialChooseMostHelpfulFriend {
    // message fields
    account_id_friend: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgTFFreeTrialChooseMostHelpfulFriend {
    fn default() -> &'a CMsgTFFreeTrialChooseMostHelpfulFriend {
        <CMsgTFFreeTrialChooseMostHelpfulFriend as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTFFreeTrialChooseMostHelpfulFriend {
    pub fn new() -> CMsgTFFreeTrialChooseMostHelpfulFriend {
        ::std::default::Default::default()
    }

    // optional uint32 account_id_friend = 1;


    pub fn get_account_id_friend(&self) -> u32 {
        self.account_id_friend.unwrap_or(0)
    }
    pub fn clear_account_id_friend(&mut self) {
        self.account_id_friend = ::std::option::Option::None;
    }

    pub fn has_account_id_friend(&self) -> bool {
        self.account_id_friend.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id_friend(&mut self, v: u32) {
        self.account_id_friend = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgTFFreeTrialChooseMostHelpfulFriend {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id_friend = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id_friend {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id_friend {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgTFFreeTrialChooseMostHelpfulFriend {
        CMsgTFFreeTrialChooseMostHelpfulFriend::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "account_id_friend",
                |m: &CMsgTFFreeTrialChooseMostHelpfulFriend| { &m.account_id_friend },
                |m: &mut CMsgTFFreeTrialChooseMostHelpfulFriend| { &mut m.account_id_friend },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgTFFreeTrialChooseMostHelpfulFriend>(
                "CMsgTFFreeTrialChooseMostHelpfulFriend",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgTFFreeTrialChooseMostHelpfulFriend {
        static instance: ::protobuf::rt::LazyV2<CMsgTFFreeTrialChooseMostHelpfulFriend> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgTFFreeTrialChooseMostHelpfulFriend::new)
    }
}

impl ::protobuf::Clear for CMsgTFFreeTrialChooseMostHelpfulFriend {
    fn clear(&mut self) {
        self.account_id_friend = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgTFFreeTrialChooseMostHelpfulFriend {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTFFreeTrialChooseMostHelpfulFriend {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgTFRequestTF2Friends {
    // message fields
    pub account_ids: ::std::vec::Vec<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgTFRequestTF2Friends {
    fn default() -> &'a CMsgTFRequestTF2Friends {
        <CMsgTFRequestTF2Friends as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTFRequestTF2Friends {
    pub fn new() -> CMsgTFRequestTF2Friends {
        ::std::default::Default::default()
    }

    // repeated uint32 account_ids = 1;


    pub fn get_account_ids(&self) -> &[u32] {
        &self.account_ids
    }
    pub fn clear_account_ids(&mut self) {
        self.account_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_account_ids(&mut self, v: ::std::vec::Vec<u32>) {
        self.account_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_account_ids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.account_ids
    }

    // Take field
    pub fn take_account_ids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.account_ids, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgTFRequestTF2Friends {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.account_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.account_ids {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.account_ids {
            os.write_uint32(1, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgTFRequestTF2Friends {
        CMsgTFRequestTF2Friends::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "account_ids",
                |m: &CMsgTFRequestTF2Friends| { &m.account_ids },
                |m: &mut CMsgTFRequestTF2Friends| { &mut m.account_ids },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgTFRequestTF2Friends>(
                "CMsgTFRequestTF2Friends",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgTFRequestTF2Friends {
        static instance: ::protobuf::rt::LazyV2<CMsgTFRequestTF2Friends> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgTFRequestTF2Friends::new)
    }
}

impl ::protobuf::Clear for CMsgTFRequestTF2Friends {
    fn clear(&mut self) {
        self.account_ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgTFRequestTF2Friends {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTFRequestTF2Friends {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgTFRequestTF2FriendsResponse {
    // message fields
    pub account_ids: ::std::vec::Vec<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgTFRequestTF2FriendsResponse {
    fn default() -> &'a CMsgTFRequestTF2FriendsResponse {
        <CMsgTFRequestTF2FriendsResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTFRequestTF2FriendsResponse {
    pub fn new() -> CMsgTFRequestTF2FriendsResponse {
        ::std::default::Default::default()
    }

    // repeated uint32 account_ids = 1;


    pub fn get_account_ids(&self) -> &[u32] {
        &self.account_ids
    }
    pub fn clear_account_ids(&mut self) {
        self.account_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_account_ids(&mut self, v: ::std::vec::Vec<u32>) {
        self.account_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_account_ids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.account_ids
    }

    // Take field
    pub fn take_account_ids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.account_ids, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgTFRequestTF2FriendsResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.account_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.account_ids {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.account_ids {
            os.write_uint32(1, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgTFRequestTF2FriendsResponse {
        CMsgTFRequestTF2FriendsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "account_ids",
                |m: &CMsgTFRequestTF2FriendsResponse| { &m.account_ids },
                |m: &mut CMsgTFRequestTF2FriendsResponse| { &mut m.account_ids },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgTFRequestTF2FriendsResponse>(
                "CMsgTFRequestTF2FriendsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgTFRequestTF2FriendsResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgTFRequestTF2FriendsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgTFRequestTF2FriendsResponse::new)
    }
}

impl ::protobuf::Clear for CMsgTFRequestTF2FriendsResponse {
    fn clear(&mut self) {
        self.account_ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgTFRequestTF2FriendsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTFRequestTF2FriendsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CSOTFPlayerInfo {
    // message fields
    num_new_users_helped: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CSOTFPlayerInfo {
    fn default() -> &'a CSOTFPlayerInfo {
        <CSOTFPlayerInfo as ::protobuf::Message>::default_instance()
    }
}

impl CSOTFPlayerInfo {
    pub fn new() -> CSOTFPlayerInfo {
        ::std::default::Default::default()
    }

    // optional uint32 num_new_users_helped = 1;


    pub fn get_num_new_users_helped(&self) -> u32 {
        self.num_new_users_helped.unwrap_or(0)
    }
    pub fn clear_num_new_users_helped(&mut self) {
        self.num_new_users_helped = ::std::option::Option::None;
    }

    pub fn has_num_new_users_helped(&self) -> bool {
        self.num_new_users_helped.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_new_users_helped(&mut self, v: u32) {
        self.num_new_users_helped = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CSOTFPlayerInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.num_new_users_helped = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.num_new_users_helped {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.num_new_users_helped {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CSOTFPlayerInfo {
        CSOTFPlayerInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "num_new_users_helped",
                |m: &CSOTFPlayerInfo| { &m.num_new_users_helped },
                |m: &mut CSOTFPlayerInfo| { &mut m.num_new_users_helped },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CSOTFPlayerInfo>(
                "CSOTFPlayerInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CSOTFPlayerInfo {
        static instance: ::protobuf::rt::LazyV2<CSOTFPlayerInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CSOTFPlayerInfo::new)
    }
}

impl ::protobuf::Clear for CSOTFPlayerInfo {
    fn clear(&mut self) {
        self.num_new_users_helped = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSOTFPlayerInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOTFPlayerInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgTFThankedBySomeone {
    // message fields
    thanker_steam_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgTFThankedBySomeone {
    fn default() -> &'a CMsgTFThankedBySomeone {
        <CMsgTFThankedBySomeone as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTFThankedBySomeone {
    pub fn new() -> CMsgTFThankedBySomeone {
        ::std::default::Default::default()
    }

    // optional uint64 thanker_steam_id = 1;


    pub fn get_thanker_steam_id(&self) -> u64 {
        self.thanker_steam_id.unwrap_or(0)
    }
    pub fn clear_thanker_steam_id(&mut self) {
        self.thanker_steam_id = ::std::option::Option::None;
    }

    pub fn has_thanker_steam_id(&self) -> bool {
        self.thanker_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_thanker_steam_id(&mut self, v: u64) {
        self.thanker_steam_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgTFThankedBySomeone {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.thanker_steam_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.thanker_steam_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.thanker_steam_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgTFThankedBySomeone {
        CMsgTFThankedBySomeone::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "thanker_steam_id",
                |m: &CMsgTFThankedBySomeone| { &m.thanker_steam_id },
                |m: &mut CMsgTFThankedBySomeone| { &mut m.thanker_steam_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgTFThankedBySomeone>(
                "CMsgTFThankedBySomeone",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgTFThankedBySomeone {
        static instance: ::protobuf::rt::LazyV2<CMsgTFThankedBySomeone> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgTFThankedBySomeone::new)
    }
}

impl ::protobuf::Clear for CMsgTFThankedBySomeone {
    fn clear(&mut self) {
        self.thanker_steam_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgTFThankedBySomeone {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTFThankedBySomeone {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgTFThankedSomeone {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgTFThankedSomeone {
    fn default() -> &'a CMsgTFThankedSomeone {
        <CMsgTFThankedSomeone as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTFThankedSomeone {
    pub fn new() -> CMsgTFThankedSomeone {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgTFThankedSomeone {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgTFThankedSomeone {
        CMsgTFThankedSomeone::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgTFThankedSomeone>(
                "CMsgTFThankedSomeone",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgTFThankedSomeone {
        static instance: ::protobuf::rt::LazyV2<CMsgTFThankedSomeone> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgTFThankedSomeone::new)
    }
}

impl ::protobuf::Clear for CMsgTFThankedSomeone {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgTFThankedSomeone {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTFThankedSomeone {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgTFFreeTrialConvertedToPremium {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgTFFreeTrialConvertedToPremium {
    fn default() -> &'a CMsgTFFreeTrialConvertedToPremium {
        <CMsgTFFreeTrialConvertedToPremium as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTFFreeTrialConvertedToPremium {
    pub fn new() -> CMsgTFFreeTrialConvertedToPremium {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgTFFreeTrialConvertedToPremium {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgTFFreeTrialConvertedToPremium {
        CMsgTFFreeTrialConvertedToPremium::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgTFFreeTrialConvertedToPremium>(
                "CMsgTFFreeTrialConvertedToPremium",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgTFFreeTrialConvertedToPremium {
        static instance: ::protobuf::rt::LazyV2<CMsgTFFreeTrialConvertedToPremium> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgTFFreeTrialConvertedToPremium::new)
    }
}

impl ::protobuf::Clear for CMsgTFFreeTrialConvertedToPremium {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgTFFreeTrialConvertedToPremium {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTFFreeTrialConvertedToPremium {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSaxxyAwarded {
    // message fields
    category: ::std::option::Option<u32>,
    pub winner_names: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSaxxyAwarded {
    fn default() -> &'a CMsgSaxxyAwarded {
        <CMsgSaxxyAwarded as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSaxxyAwarded {
    pub fn new() -> CMsgSaxxyAwarded {
        ::std::default::Default::default()
    }

    // optional uint32 category = 1;


    pub fn get_category(&self) -> u32 {
        self.category.unwrap_or(0)
    }
    pub fn clear_category(&mut self) {
        self.category = ::std::option::Option::None;
    }

    pub fn has_category(&self) -> bool {
        self.category.is_some()
    }

    // Param is passed by value, moved
    pub fn set_category(&mut self, v: u32) {
        self.category = ::std::option::Option::Some(v);
    }

    // repeated string winner_names = 2;


    pub fn get_winner_names(&self) -> &[::std::string::String] {
        &self.winner_names
    }
    pub fn clear_winner_names(&mut self) {
        self.winner_names.clear();
    }

    // Param is passed by value, moved
    pub fn set_winner_names(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.winner_names = v;
    }

    // Mutable pointer to the field.
    pub fn mut_winner_names(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.winner_names
    }

    // Take field
    pub fn take_winner_names(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.winner_names, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgSaxxyAwarded {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.category = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.winner_names)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.category {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.winner_names {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.category {
            os.write_uint32(1, v)?;
        }
        for v in &self.winner_names {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSaxxyAwarded {
        CMsgSaxxyAwarded::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "category",
                |m: &CMsgSaxxyAwarded| { &m.category },
                |m: &mut CMsgSaxxyAwarded| { &mut m.category },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "winner_names",
                |m: &CMsgSaxxyAwarded| { &m.winner_names },
                |m: &mut CMsgSaxxyAwarded| { &mut m.winner_names },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSaxxyAwarded>(
                "CMsgSaxxyAwarded",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSaxxyAwarded {
        static instance: ::protobuf::rt::LazyV2<CMsgSaxxyAwarded> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSaxxyAwarded::new)
    }
}

impl ::protobuf::Clear for CMsgSaxxyAwarded {
    fn clear(&mut self) {
        self.category = ::std::option::Option::None;
        self.winner_names.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSaxxyAwarded {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSaxxyAwarded {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgReplaySubmitContestEntry {
    // message fields
    youtube_url: ::protobuf::SingularField<::std::string::String>,
    category: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgReplaySubmitContestEntry {
    fn default() -> &'a CMsgReplaySubmitContestEntry {
        <CMsgReplaySubmitContestEntry as ::protobuf::Message>::default_instance()
    }
}

impl CMsgReplaySubmitContestEntry {
    pub fn new() -> CMsgReplaySubmitContestEntry {
        ::std::default::Default::default()
    }

    // optional string youtube_url = 1;


    pub fn get_youtube_url(&self) -> &str {
        match self.youtube_url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_youtube_url(&mut self) {
        self.youtube_url.clear();
    }

    pub fn has_youtube_url(&self) -> bool {
        self.youtube_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_youtube_url(&mut self, v: ::std::string::String) {
        self.youtube_url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_youtube_url(&mut self) -> &mut ::std::string::String {
        if self.youtube_url.is_none() {
            self.youtube_url.set_default();
        }
        self.youtube_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_youtube_url(&mut self) -> ::std::string::String {
        self.youtube_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 category = 2;


    pub fn get_category(&self) -> u32 {
        self.category.unwrap_or(0)
    }
    pub fn clear_category(&mut self) {
        self.category = ::std::option::Option::None;
    }

    pub fn has_category(&self) -> bool {
        self.category.is_some()
    }

    // Param is passed by value, moved
    pub fn set_category(&mut self, v: u32) {
        self.category = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgReplaySubmitContestEntry {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.youtube_url)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.category = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.youtube_url.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.category {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.youtube_url.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.category {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgReplaySubmitContestEntry {
        CMsgReplaySubmitContestEntry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "youtube_url",
                |m: &CMsgReplaySubmitContestEntry| { &m.youtube_url },
                |m: &mut CMsgReplaySubmitContestEntry| { &mut m.youtube_url },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "category",
                |m: &CMsgReplaySubmitContestEntry| { &m.category },
                |m: &mut CMsgReplaySubmitContestEntry| { &mut m.category },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgReplaySubmitContestEntry>(
                "CMsgReplaySubmitContestEntry",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgReplaySubmitContestEntry {
        static instance: ::protobuf::rt::LazyV2<CMsgReplaySubmitContestEntry> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgReplaySubmitContestEntry::new)
    }
}

impl ::protobuf::Clear for CMsgReplaySubmitContestEntry {
    fn clear(&mut self) {
        self.youtube_url.clear();
        self.category = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgReplaySubmitContestEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgReplaySubmitContestEntry {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgReplaySubmitContestEntryResponse {
    // message fields
    success: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgReplaySubmitContestEntryResponse {
    fn default() -> &'a CMsgReplaySubmitContestEntryResponse {
        <CMsgReplaySubmitContestEntryResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgReplaySubmitContestEntryResponse {
    pub fn new() -> CMsgReplaySubmitContestEntryResponse {
        ::std::default::Default::default()
    }

    // optional bool success = 1;


    pub fn get_success(&self) -> bool {
        self.success.unwrap_or(false)
    }
    pub fn clear_success(&mut self) {
        self.success = ::std::option::Option::None;
    }

    pub fn has_success(&self) -> bool {
        self.success.is_some()
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgReplaySubmitContestEntryResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.success = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.success {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.success {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgReplaySubmitContestEntryResponse {
        CMsgReplaySubmitContestEntryResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "success",
                |m: &CMsgReplaySubmitContestEntryResponse| { &m.success },
                |m: &mut CMsgReplaySubmitContestEntryResponse| { &mut m.success },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgReplaySubmitContestEntryResponse>(
                "CMsgReplaySubmitContestEntryResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgReplaySubmitContestEntryResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgReplaySubmitContestEntryResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgReplaySubmitContestEntryResponse::new)
    }
}

impl ::protobuf::Clear for CMsgReplaySubmitContestEntryResponse {
    fn clear(&mut self) {
        self.success = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgReplaySubmitContestEntryResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgReplaySubmitContestEntryResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CReplayCachedContestData {
    // message fields
    timestamp: ::std::option::Option<u32>,
    num_votes_last_day: ::std::option::Option<u32>,
    pub video_entry_ids: ::std::vec::Vec<u32>,
    num_flags_last_day: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CReplayCachedContestData {
    fn default() -> &'a CReplayCachedContestData {
        <CReplayCachedContestData as ::protobuf::Message>::default_instance()
    }
}

impl CReplayCachedContestData {
    pub fn new() -> CReplayCachedContestData {
        ::std::default::Default::default()
    }

    // optional fixed32 timestamp = 1;


    pub fn get_timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 num_votes_last_day = 2;


    pub fn get_num_votes_last_day(&self) -> u32 {
        self.num_votes_last_day.unwrap_or(0)
    }
    pub fn clear_num_votes_last_day(&mut self) {
        self.num_votes_last_day = ::std::option::Option::None;
    }

    pub fn has_num_votes_last_day(&self) -> bool {
        self.num_votes_last_day.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_votes_last_day(&mut self, v: u32) {
        self.num_votes_last_day = ::std::option::Option::Some(v);
    }

    // repeated uint32 video_entry_ids = 3;


    pub fn get_video_entry_ids(&self) -> &[u32] {
        &self.video_entry_ids
    }
    pub fn clear_video_entry_ids(&mut self) {
        self.video_entry_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_video_entry_ids(&mut self, v: ::std::vec::Vec<u32>) {
        self.video_entry_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_video_entry_ids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.video_entry_ids
    }

    // Take field
    pub fn take_video_entry_ids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.video_entry_ids, ::std::vec::Vec::new())
    }

    // optional uint32 num_flags_last_day = 4;


    pub fn get_num_flags_last_day(&self) -> u32 {
        self.num_flags_last_day.unwrap_or(0)
    }
    pub fn clear_num_flags_last_day(&mut self) {
        self.num_flags_last_day = ::std::option::Option::None;
    }

    pub fn has_num_flags_last_day(&self) -> bool {
        self.num_flags_last_day.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_flags_last_day(&mut self, v: u32) {
        self.num_flags_last_day = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CReplayCachedContestData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.timestamp = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.num_votes_last_day = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.video_entry_ids)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.num_flags_last_day = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.timestamp {
            my_size += 5;
        }
        if let Some(v) = self.num_votes_last_day {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.video_entry_ids {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.num_flags_last_day {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.timestamp {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.num_votes_last_day {
            os.write_uint32(2, v)?;
        }
        for v in &self.video_entry_ids {
            os.write_uint32(3, *v)?;
        };
        if let Some(v) = self.num_flags_last_day {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CReplayCachedContestData {
        CReplayCachedContestData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "timestamp",
                |m: &CReplayCachedContestData| { &m.timestamp },
                |m: &mut CReplayCachedContestData| { &mut m.timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "num_votes_last_day",
                |m: &CReplayCachedContestData| { &m.num_votes_last_day },
                |m: &mut CReplayCachedContestData| { &mut m.num_votes_last_day },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "video_entry_ids",
                |m: &CReplayCachedContestData| { &m.video_entry_ids },
                |m: &mut CReplayCachedContestData| { &mut m.video_entry_ids },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "num_flags_last_day",
                |m: &CReplayCachedContestData| { &m.num_flags_last_day },
                |m: &mut CReplayCachedContestData| { &mut m.num_flags_last_day },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CReplayCachedContestData>(
                "CReplayCachedContestData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CReplayCachedContestData {
        static instance: ::protobuf::rt::LazyV2<CReplayCachedContestData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CReplayCachedContestData::new)
    }
}

impl ::protobuf::Clear for CReplayCachedContestData {
    fn clear(&mut self) {
        self.timestamp = ::std::option::Option::None;
        self.num_votes_last_day = ::std::option::Option::None;
        self.video_entry_ids.clear();
        self.num_flags_last_day = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CReplayCachedContestData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CReplayCachedContestData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgTFCoaching_AddToCoaches {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgTFCoaching_AddToCoaches {
    fn default() -> &'a CMsgTFCoaching_AddToCoaches {
        <CMsgTFCoaching_AddToCoaches as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTFCoaching_AddToCoaches {
    pub fn new() -> CMsgTFCoaching_AddToCoaches {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgTFCoaching_AddToCoaches {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgTFCoaching_AddToCoaches {
        CMsgTFCoaching_AddToCoaches::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgTFCoaching_AddToCoaches>(
                "CMsgTFCoaching_AddToCoaches",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgTFCoaching_AddToCoaches {
        static instance: ::protobuf::rt::LazyV2<CMsgTFCoaching_AddToCoaches> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgTFCoaching_AddToCoaches::new)
    }
}

impl ::protobuf::Clear for CMsgTFCoaching_AddToCoaches {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgTFCoaching_AddToCoaches {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTFCoaching_AddToCoaches {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgTFCoaching_RemoveFromCoaches {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgTFCoaching_RemoveFromCoaches {
    fn default() -> &'a CMsgTFCoaching_RemoveFromCoaches {
        <CMsgTFCoaching_RemoveFromCoaches as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTFCoaching_RemoveFromCoaches {
    pub fn new() -> CMsgTFCoaching_RemoveFromCoaches {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgTFCoaching_RemoveFromCoaches {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgTFCoaching_RemoveFromCoaches {
        CMsgTFCoaching_RemoveFromCoaches::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgTFCoaching_RemoveFromCoaches>(
                "CMsgTFCoaching_RemoveFromCoaches",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgTFCoaching_RemoveFromCoaches {
        static instance: ::protobuf::rt::LazyV2<CMsgTFCoaching_RemoveFromCoaches> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgTFCoaching_RemoveFromCoaches::new)
    }
}

impl ::protobuf::Clear for CMsgTFCoaching_RemoveFromCoaches {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgTFCoaching_RemoveFromCoaches {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTFCoaching_RemoveFromCoaches {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgTFCoaching_FindCoach {
    // message fields
    account_id_friend_as_coach: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgTFCoaching_FindCoach {
    fn default() -> &'a CMsgTFCoaching_FindCoach {
        <CMsgTFCoaching_FindCoach as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTFCoaching_FindCoach {
    pub fn new() -> CMsgTFCoaching_FindCoach {
        ::std::default::Default::default()
    }

    // optional uint32 account_id_friend_as_coach = 1;


    pub fn get_account_id_friend_as_coach(&self) -> u32 {
        self.account_id_friend_as_coach.unwrap_or(0)
    }
    pub fn clear_account_id_friend_as_coach(&mut self) {
        self.account_id_friend_as_coach = ::std::option::Option::None;
    }

    pub fn has_account_id_friend_as_coach(&self) -> bool {
        self.account_id_friend_as_coach.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id_friend_as_coach(&mut self, v: u32) {
        self.account_id_friend_as_coach = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgTFCoaching_FindCoach {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id_friend_as_coach = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id_friend_as_coach {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id_friend_as_coach {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgTFCoaching_FindCoach {
        CMsgTFCoaching_FindCoach::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "account_id_friend_as_coach",
                |m: &CMsgTFCoaching_FindCoach| { &m.account_id_friend_as_coach },
                |m: &mut CMsgTFCoaching_FindCoach| { &mut m.account_id_friend_as_coach },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgTFCoaching_FindCoach>(
                "CMsgTFCoaching_FindCoach",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgTFCoaching_FindCoach {
        static instance: ::protobuf::rt::LazyV2<CMsgTFCoaching_FindCoach> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgTFCoaching_FindCoach::new)
    }
}

impl ::protobuf::Clear for CMsgTFCoaching_FindCoach {
    fn clear(&mut self) {
        self.account_id_friend_as_coach = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgTFCoaching_FindCoach {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTFCoaching_FindCoach {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgTFCoaching_FindCoachResponse {
    // message fields
    found_coach: ::std::option::Option<bool>,
    num_likes: ::std::option::Option<u32>,
    coach_name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgTFCoaching_FindCoachResponse {
    fn default() -> &'a CMsgTFCoaching_FindCoachResponse {
        <CMsgTFCoaching_FindCoachResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTFCoaching_FindCoachResponse {
    pub fn new() -> CMsgTFCoaching_FindCoachResponse {
        ::std::default::Default::default()
    }

    // optional bool found_coach = 1;


    pub fn get_found_coach(&self) -> bool {
        self.found_coach.unwrap_or(false)
    }
    pub fn clear_found_coach(&mut self) {
        self.found_coach = ::std::option::Option::None;
    }

    pub fn has_found_coach(&self) -> bool {
        self.found_coach.is_some()
    }

    // Param is passed by value, moved
    pub fn set_found_coach(&mut self, v: bool) {
        self.found_coach = ::std::option::Option::Some(v);
    }

    // optional uint32 num_likes = 2;


    pub fn get_num_likes(&self) -> u32 {
        self.num_likes.unwrap_or(0)
    }
    pub fn clear_num_likes(&mut self) {
        self.num_likes = ::std::option::Option::None;
    }

    pub fn has_num_likes(&self) -> bool {
        self.num_likes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_likes(&mut self, v: u32) {
        self.num_likes = ::std::option::Option::Some(v);
    }

    // optional string coach_name = 3;


    pub fn get_coach_name(&self) -> &str {
        match self.coach_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_coach_name(&mut self) {
        self.coach_name.clear();
    }

    pub fn has_coach_name(&self) -> bool {
        self.coach_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_coach_name(&mut self, v: ::std::string::String) {
        self.coach_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_coach_name(&mut self) -> &mut ::std::string::String {
        if self.coach_name.is_none() {
            self.coach_name.set_default();
        }
        self.coach_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_coach_name(&mut self) -> ::std::string::String {
        self.coach_name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgTFCoaching_FindCoachResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.found_coach = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.num_likes = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.coach_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.found_coach {
            my_size += 2;
        }
        if let Some(v) = self.num_likes {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.coach_name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.found_coach {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.num_likes {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.coach_name.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgTFCoaching_FindCoachResponse {
        CMsgTFCoaching_FindCoachResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "found_coach",
                |m: &CMsgTFCoaching_FindCoachResponse| { &m.found_coach },
                |m: &mut CMsgTFCoaching_FindCoachResponse| { &mut m.found_coach },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "num_likes",
                |m: &CMsgTFCoaching_FindCoachResponse| { &m.num_likes },
                |m: &mut CMsgTFCoaching_FindCoachResponse| { &mut m.num_likes },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "coach_name",
                |m: &CMsgTFCoaching_FindCoachResponse| { &m.coach_name },
                |m: &mut CMsgTFCoaching_FindCoachResponse| { &mut m.coach_name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgTFCoaching_FindCoachResponse>(
                "CMsgTFCoaching_FindCoachResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgTFCoaching_FindCoachResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgTFCoaching_FindCoachResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgTFCoaching_FindCoachResponse::new)
    }
}

impl ::protobuf::Clear for CMsgTFCoaching_FindCoachResponse {
    fn clear(&mut self) {
        self.found_coach = ::std::option::Option::None;
        self.num_likes = ::std::option::Option::None;
        self.coach_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgTFCoaching_FindCoachResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTFCoaching_FindCoachResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgTFCoaching_AskCoach {
    // message fields
    account_id_student: ::std::option::Option<u32>,
    student_is_friend: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgTFCoaching_AskCoach {
    fn default() -> &'a CMsgTFCoaching_AskCoach {
        <CMsgTFCoaching_AskCoach as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTFCoaching_AskCoach {
    pub fn new() -> CMsgTFCoaching_AskCoach {
        ::std::default::Default::default()
    }

    // optional uint32 account_id_student = 1;


    pub fn get_account_id_student(&self) -> u32 {
        self.account_id_student.unwrap_or(0)
    }
    pub fn clear_account_id_student(&mut self) {
        self.account_id_student = ::std::option::Option::None;
    }

    pub fn has_account_id_student(&self) -> bool {
        self.account_id_student.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id_student(&mut self, v: u32) {
        self.account_id_student = ::std::option::Option::Some(v);
    }

    // optional bool student_is_friend = 2;


    pub fn get_student_is_friend(&self) -> bool {
        self.student_is_friend.unwrap_or(false)
    }
    pub fn clear_student_is_friend(&mut self) {
        self.student_is_friend = ::std::option::Option::None;
    }

    pub fn has_student_is_friend(&self) -> bool {
        self.student_is_friend.is_some()
    }

    // Param is passed by value, moved
    pub fn set_student_is_friend(&mut self, v: bool) {
        self.student_is_friend = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgTFCoaching_AskCoach {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id_student = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.student_is_friend = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id_student {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.student_is_friend {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id_student {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.student_is_friend {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgTFCoaching_AskCoach {
        CMsgTFCoaching_AskCoach::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "account_id_student",
                |m: &CMsgTFCoaching_AskCoach| { &m.account_id_student },
                |m: &mut CMsgTFCoaching_AskCoach| { &mut m.account_id_student },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "student_is_friend",
                |m: &CMsgTFCoaching_AskCoach| { &m.student_is_friend },
                |m: &mut CMsgTFCoaching_AskCoach| { &mut m.student_is_friend },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgTFCoaching_AskCoach>(
                "CMsgTFCoaching_AskCoach",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgTFCoaching_AskCoach {
        static instance: ::protobuf::rt::LazyV2<CMsgTFCoaching_AskCoach> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgTFCoaching_AskCoach::new)
    }
}

impl ::protobuf::Clear for CMsgTFCoaching_AskCoach {
    fn clear(&mut self) {
        self.account_id_student = ::std::option::Option::None;
        self.student_is_friend = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgTFCoaching_AskCoach {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTFCoaching_AskCoach {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgTFCoaching_AskCoachResponse {
    // message fields
    accept_coaching_assignment: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgTFCoaching_AskCoachResponse {
    fn default() -> &'a CMsgTFCoaching_AskCoachResponse {
        <CMsgTFCoaching_AskCoachResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTFCoaching_AskCoachResponse {
    pub fn new() -> CMsgTFCoaching_AskCoachResponse {
        ::std::default::Default::default()
    }

    // optional bool accept_coaching_assignment = 1;


    pub fn get_accept_coaching_assignment(&self) -> bool {
        self.accept_coaching_assignment.unwrap_or(false)
    }
    pub fn clear_accept_coaching_assignment(&mut self) {
        self.accept_coaching_assignment = ::std::option::Option::None;
    }

    pub fn has_accept_coaching_assignment(&self) -> bool {
        self.accept_coaching_assignment.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accept_coaching_assignment(&mut self, v: bool) {
        self.accept_coaching_assignment = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgTFCoaching_AskCoachResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.accept_coaching_assignment = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.accept_coaching_assignment {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.accept_coaching_assignment {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgTFCoaching_AskCoachResponse {
        CMsgTFCoaching_AskCoachResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "accept_coaching_assignment",
                |m: &CMsgTFCoaching_AskCoachResponse| { &m.accept_coaching_assignment },
                |m: &mut CMsgTFCoaching_AskCoachResponse| { &mut m.accept_coaching_assignment },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgTFCoaching_AskCoachResponse>(
                "CMsgTFCoaching_AskCoachResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgTFCoaching_AskCoachResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgTFCoaching_AskCoachResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgTFCoaching_AskCoachResponse::new)
    }
}

impl ::protobuf::Clear for CMsgTFCoaching_AskCoachResponse {
    fn clear(&mut self) {
        self.accept_coaching_assignment = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgTFCoaching_AskCoachResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTFCoaching_AskCoachResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgTFCoaching_CoachJoinGame {
    // message fields
    join_game: ::std::option::Option<bool>,
    server_address: ::std::option::Option<u32>,
    server_port: ::std::option::Option<u32>,
    account_id_student: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgTFCoaching_CoachJoinGame {
    fn default() -> &'a CMsgTFCoaching_CoachJoinGame {
        <CMsgTFCoaching_CoachJoinGame as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTFCoaching_CoachJoinGame {
    pub fn new() -> CMsgTFCoaching_CoachJoinGame {
        ::std::default::Default::default()
    }

    // optional bool join_game = 1;


    pub fn get_join_game(&self) -> bool {
        self.join_game.unwrap_or(false)
    }
    pub fn clear_join_game(&mut self) {
        self.join_game = ::std::option::Option::None;
    }

    pub fn has_join_game(&self) -> bool {
        self.join_game.is_some()
    }

    // Param is passed by value, moved
    pub fn set_join_game(&mut self, v: bool) {
        self.join_game = ::std::option::Option::Some(v);
    }

    // optional uint32 server_address = 2;


    pub fn get_server_address(&self) -> u32 {
        self.server_address.unwrap_or(0)
    }
    pub fn clear_server_address(&mut self) {
        self.server_address = ::std::option::Option::None;
    }

    pub fn has_server_address(&self) -> bool {
        self.server_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_address(&mut self, v: u32) {
        self.server_address = ::std::option::Option::Some(v);
    }

    // optional uint32 server_port = 3;


    pub fn get_server_port(&self) -> u32 {
        self.server_port.unwrap_or(0)
    }
    pub fn clear_server_port(&mut self) {
        self.server_port = ::std::option::Option::None;
    }

    pub fn has_server_port(&self) -> bool {
        self.server_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_port(&mut self, v: u32) {
        self.server_port = ::std::option::Option::Some(v);
    }

    // optional uint32 account_id_student = 4;


    pub fn get_account_id_student(&self) -> u32 {
        self.account_id_student.unwrap_or(0)
    }
    pub fn clear_account_id_student(&mut self) {
        self.account_id_student = ::std::option::Option::None;
    }

    pub fn has_account_id_student(&self) -> bool {
        self.account_id_student.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id_student(&mut self, v: u32) {
        self.account_id_student = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgTFCoaching_CoachJoinGame {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.join_game = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.server_address = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.server_port = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id_student = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.join_game {
            my_size += 2;
        }
        if let Some(v) = self.server_address {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.server_port {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.account_id_student {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.join_game {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.server_address {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.server_port {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.account_id_student {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgTFCoaching_CoachJoinGame {
        CMsgTFCoaching_CoachJoinGame::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "join_game",
                |m: &CMsgTFCoaching_CoachJoinGame| { &m.join_game },
                |m: &mut CMsgTFCoaching_CoachJoinGame| { &mut m.join_game },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "server_address",
                |m: &CMsgTFCoaching_CoachJoinGame| { &m.server_address },
                |m: &mut CMsgTFCoaching_CoachJoinGame| { &mut m.server_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "server_port",
                |m: &CMsgTFCoaching_CoachJoinGame| { &m.server_port },
                |m: &mut CMsgTFCoaching_CoachJoinGame| { &mut m.server_port },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "account_id_student",
                |m: &CMsgTFCoaching_CoachJoinGame| { &m.account_id_student },
                |m: &mut CMsgTFCoaching_CoachJoinGame| { &mut m.account_id_student },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgTFCoaching_CoachJoinGame>(
                "CMsgTFCoaching_CoachJoinGame",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgTFCoaching_CoachJoinGame {
        static instance: ::protobuf::rt::LazyV2<CMsgTFCoaching_CoachJoinGame> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgTFCoaching_CoachJoinGame::new)
    }
}

impl ::protobuf::Clear for CMsgTFCoaching_CoachJoinGame {
    fn clear(&mut self) {
        self.join_game = ::std::option::Option::None;
        self.server_address = ::std::option::Option::None;
        self.server_port = ::std::option::Option::None;
        self.account_id_student = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgTFCoaching_CoachJoinGame {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTFCoaching_CoachJoinGame {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgTFCoaching_CoachJoining {
    // message fields
    account_id_coach: ::std::option::Option<u32>,
    account_id_student: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgTFCoaching_CoachJoining {
    fn default() -> &'a CMsgTFCoaching_CoachJoining {
        <CMsgTFCoaching_CoachJoining as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTFCoaching_CoachJoining {
    pub fn new() -> CMsgTFCoaching_CoachJoining {
        ::std::default::Default::default()
    }

    // optional uint32 account_id_coach = 1;


    pub fn get_account_id_coach(&self) -> u32 {
        self.account_id_coach.unwrap_or(0)
    }
    pub fn clear_account_id_coach(&mut self) {
        self.account_id_coach = ::std::option::Option::None;
    }

    pub fn has_account_id_coach(&self) -> bool {
        self.account_id_coach.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id_coach(&mut self, v: u32) {
        self.account_id_coach = ::std::option::Option::Some(v);
    }

    // optional uint32 account_id_student = 2;


    pub fn get_account_id_student(&self) -> u32 {
        self.account_id_student.unwrap_or(0)
    }
    pub fn clear_account_id_student(&mut self) {
        self.account_id_student = ::std::option::Option::None;
    }

    pub fn has_account_id_student(&self) -> bool {
        self.account_id_student.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id_student(&mut self, v: u32) {
        self.account_id_student = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgTFCoaching_CoachJoining {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id_coach = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id_student = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id_coach {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.account_id_student {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id_coach {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.account_id_student {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgTFCoaching_CoachJoining {
        CMsgTFCoaching_CoachJoining::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "account_id_coach",
                |m: &CMsgTFCoaching_CoachJoining| { &m.account_id_coach },
                |m: &mut CMsgTFCoaching_CoachJoining| { &mut m.account_id_coach },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "account_id_student",
                |m: &CMsgTFCoaching_CoachJoining| { &m.account_id_student },
                |m: &mut CMsgTFCoaching_CoachJoining| { &mut m.account_id_student },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgTFCoaching_CoachJoining>(
                "CMsgTFCoaching_CoachJoining",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgTFCoaching_CoachJoining {
        static instance: ::protobuf::rt::LazyV2<CMsgTFCoaching_CoachJoining> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgTFCoaching_CoachJoining::new)
    }
}

impl ::protobuf::Clear for CMsgTFCoaching_CoachJoining {
    fn clear(&mut self) {
        self.account_id_coach = ::std::option::Option::None;
        self.account_id_student = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgTFCoaching_CoachJoining {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTFCoaching_CoachJoining {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgTFCoaching_CoachJoined {
    // message fields
    account_id_coach: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgTFCoaching_CoachJoined {
    fn default() -> &'a CMsgTFCoaching_CoachJoined {
        <CMsgTFCoaching_CoachJoined as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTFCoaching_CoachJoined {
    pub fn new() -> CMsgTFCoaching_CoachJoined {
        ::std::default::Default::default()
    }

    // optional uint32 account_id_coach = 1;


    pub fn get_account_id_coach(&self) -> u32 {
        self.account_id_coach.unwrap_or(0)
    }
    pub fn clear_account_id_coach(&mut self) {
        self.account_id_coach = ::std::option::Option::None;
    }

    pub fn has_account_id_coach(&self) -> bool {
        self.account_id_coach.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id_coach(&mut self, v: u32) {
        self.account_id_coach = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgTFCoaching_CoachJoined {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id_coach = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id_coach {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id_coach {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgTFCoaching_CoachJoined {
        CMsgTFCoaching_CoachJoined::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "account_id_coach",
                |m: &CMsgTFCoaching_CoachJoined| { &m.account_id_coach },
                |m: &mut CMsgTFCoaching_CoachJoined| { &mut m.account_id_coach },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgTFCoaching_CoachJoined>(
                "CMsgTFCoaching_CoachJoined",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgTFCoaching_CoachJoined {
        static instance: ::protobuf::rt::LazyV2<CMsgTFCoaching_CoachJoined> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgTFCoaching_CoachJoined::new)
    }
}

impl ::protobuf::Clear for CMsgTFCoaching_CoachJoined {
    fn clear(&mut self) {
        self.account_id_coach = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgTFCoaching_CoachJoined {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTFCoaching_CoachJoined {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgTFCoaching_LikeCurrentCoach {
    // message fields
    like_coach: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgTFCoaching_LikeCurrentCoach {
    fn default() -> &'a CMsgTFCoaching_LikeCurrentCoach {
        <CMsgTFCoaching_LikeCurrentCoach as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTFCoaching_LikeCurrentCoach {
    pub fn new() -> CMsgTFCoaching_LikeCurrentCoach {
        ::std::default::Default::default()
    }

    // optional bool like_coach = 1;


    pub fn get_like_coach(&self) -> bool {
        self.like_coach.unwrap_or(false)
    }
    pub fn clear_like_coach(&mut self) {
        self.like_coach = ::std::option::Option::None;
    }

    pub fn has_like_coach(&self) -> bool {
        self.like_coach.is_some()
    }

    // Param is passed by value, moved
    pub fn set_like_coach(&mut self, v: bool) {
        self.like_coach = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgTFCoaching_LikeCurrentCoach {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.like_coach = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.like_coach {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.like_coach {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgTFCoaching_LikeCurrentCoach {
        CMsgTFCoaching_LikeCurrentCoach::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "like_coach",
                |m: &CMsgTFCoaching_LikeCurrentCoach| { &m.like_coach },
                |m: &mut CMsgTFCoaching_LikeCurrentCoach| { &mut m.like_coach },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgTFCoaching_LikeCurrentCoach>(
                "CMsgTFCoaching_LikeCurrentCoach",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgTFCoaching_LikeCurrentCoach {
        static instance: ::protobuf::rt::LazyV2<CMsgTFCoaching_LikeCurrentCoach> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgTFCoaching_LikeCurrentCoach::new)
    }
}

impl ::protobuf::Clear for CMsgTFCoaching_LikeCurrentCoach {
    fn clear(&mut self) {
        self.like_coach = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgTFCoaching_LikeCurrentCoach {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTFCoaching_LikeCurrentCoach {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgTFCoaching_RemoveCurrentCoach {
    // message fields
    account_id_coach: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgTFCoaching_RemoveCurrentCoach {
    fn default() -> &'a CMsgTFCoaching_RemoveCurrentCoach {
        <CMsgTFCoaching_RemoveCurrentCoach as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTFCoaching_RemoveCurrentCoach {
    pub fn new() -> CMsgTFCoaching_RemoveCurrentCoach {
        ::std::default::Default::default()
    }

    // optional uint32 account_id_coach = 1;


    pub fn get_account_id_coach(&self) -> u32 {
        self.account_id_coach.unwrap_or(0)
    }
    pub fn clear_account_id_coach(&mut self) {
        self.account_id_coach = ::std::option::Option::None;
    }

    pub fn has_account_id_coach(&self) -> bool {
        self.account_id_coach.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id_coach(&mut self, v: u32) {
        self.account_id_coach = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgTFCoaching_RemoveCurrentCoach {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id_coach = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id_coach {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id_coach {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgTFCoaching_RemoveCurrentCoach {
        CMsgTFCoaching_RemoveCurrentCoach::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "account_id_coach",
                |m: &CMsgTFCoaching_RemoveCurrentCoach| { &m.account_id_coach },
                |m: &mut CMsgTFCoaching_RemoveCurrentCoach| { &mut m.account_id_coach },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgTFCoaching_RemoveCurrentCoach>(
                "CMsgTFCoaching_RemoveCurrentCoach",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgTFCoaching_RemoveCurrentCoach {
        static instance: ::protobuf::rt::LazyV2<CMsgTFCoaching_RemoveCurrentCoach> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgTFCoaching_RemoveCurrentCoach::new)
    }
}

impl ::protobuf::Clear for CMsgTFCoaching_RemoveCurrentCoach {
    fn clear(&mut self) {
        self.account_id_coach = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgTFCoaching_RemoveCurrentCoach {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTFCoaching_RemoveCurrentCoach {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgTFQuickplay_ScoreServers {
    // message fields
    pub servers: ::protobuf::RepeatedField<CMsgTFQuickplay_ScoreServers_ServerInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgTFQuickplay_ScoreServers {
    fn default() -> &'a CMsgTFQuickplay_ScoreServers {
        <CMsgTFQuickplay_ScoreServers as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTFQuickplay_ScoreServers {
    pub fn new() -> CMsgTFQuickplay_ScoreServers {
        ::std::default::Default::default()
    }

    // repeated .CMsgTFQuickplay_ScoreServers.ServerInfo servers = 1;


    pub fn get_servers(&self) -> &[CMsgTFQuickplay_ScoreServers_ServerInfo] {
        &self.servers
    }
    pub fn clear_servers(&mut self) {
        self.servers.clear();
    }

    // Param is passed by value, moved
    pub fn set_servers(&mut self, v: ::protobuf::RepeatedField<CMsgTFQuickplay_ScoreServers_ServerInfo>) {
        self.servers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_servers(&mut self) -> &mut ::protobuf::RepeatedField<CMsgTFQuickplay_ScoreServers_ServerInfo> {
        &mut self.servers
    }

    // Take field
    pub fn take_servers(&mut self) -> ::protobuf::RepeatedField<CMsgTFQuickplay_ScoreServers_ServerInfo> {
        ::std::mem::replace(&mut self.servers, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgTFQuickplay_ScoreServers {
    fn is_initialized(&self) -> bool {
        for v in &self.servers {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.servers)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.servers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.servers {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgTFQuickplay_ScoreServers {
        CMsgTFQuickplay_ScoreServers::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgTFQuickplay_ScoreServers_ServerInfo>>(
                "servers",
                |m: &CMsgTFQuickplay_ScoreServers| { &m.servers },
                |m: &mut CMsgTFQuickplay_ScoreServers| { &mut m.servers },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgTFQuickplay_ScoreServers>(
                "CMsgTFQuickplay_ScoreServers",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgTFQuickplay_ScoreServers {
        static instance: ::protobuf::rt::LazyV2<CMsgTFQuickplay_ScoreServers> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgTFQuickplay_ScoreServers::new)
    }
}

impl ::protobuf::Clear for CMsgTFQuickplay_ScoreServers {
    fn clear(&mut self) {
        self.servers.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgTFQuickplay_ScoreServers {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTFQuickplay_ScoreServers {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgTFQuickplay_ScoreServers_ServerInfo {
    // message fields
    server_address: ::std::option::Option<u32>,
    server_port: ::std::option::Option<u32>,
    num_users: ::std::option::Option<u32>,
    steam_id: ::std::option::Option<u64>,
    max_users: ::std::option::Option<u32>,
    user_score: ::std::option::Option<f32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgTFQuickplay_ScoreServers_ServerInfo {
    fn default() -> &'a CMsgTFQuickplay_ScoreServers_ServerInfo {
        <CMsgTFQuickplay_ScoreServers_ServerInfo as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTFQuickplay_ScoreServers_ServerInfo {
    pub fn new() -> CMsgTFQuickplay_ScoreServers_ServerInfo {
        ::std::default::Default::default()
    }

    // optional uint32 server_address = 1;


    pub fn get_server_address(&self) -> u32 {
        self.server_address.unwrap_or(0)
    }
    pub fn clear_server_address(&mut self) {
        self.server_address = ::std::option::Option::None;
    }

    pub fn has_server_address(&self) -> bool {
        self.server_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_address(&mut self, v: u32) {
        self.server_address = ::std::option::Option::Some(v);
    }

    // optional uint32 server_port = 2;


    pub fn get_server_port(&self) -> u32 {
        self.server_port.unwrap_or(0)
    }
    pub fn clear_server_port(&mut self) {
        self.server_port = ::std::option::Option::None;
    }

    pub fn has_server_port(&self) -> bool {
        self.server_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_port(&mut self, v: u32) {
        self.server_port = ::std::option::Option::Some(v);
    }

    // optional uint32 num_users = 3;


    pub fn get_num_users(&self) -> u32 {
        self.num_users.unwrap_or(0)
    }
    pub fn clear_num_users(&mut self) {
        self.num_users = ::std::option::Option::None;
    }

    pub fn has_num_users(&self) -> bool {
        self.num_users.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_users(&mut self, v: u32) {
        self.num_users = ::std::option::Option::Some(v);
    }

    // optional uint64 steam_id = 4;


    pub fn get_steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }
    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }

    // optional uint32 max_users = 5;


    pub fn get_max_users(&self) -> u32 {
        self.max_users.unwrap_or(0)
    }
    pub fn clear_max_users(&mut self) {
        self.max_users = ::std::option::Option::None;
    }

    pub fn has_max_users(&self) -> bool {
        self.max_users.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_users(&mut self, v: u32) {
        self.max_users = ::std::option::Option::Some(v);
    }

    // optional float user_score = 6;


    pub fn get_user_score(&self) -> f32 {
        self.user_score.unwrap_or(0.)
    }
    pub fn clear_user_score(&mut self) {
        self.user_score = ::std::option::Option::None;
    }

    pub fn has_user_score(&self) -> bool {
        self.user_score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_score(&mut self, v: f32) {
        self.user_score = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgTFQuickplay_ScoreServers_ServerInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.server_address = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.server_port = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.num_users = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.steam_id = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.max_users = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.user_score = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.server_address {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.server_port {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.num_users {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.steam_id {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.max_users {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.user_score {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.server_address {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.server_port {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.num_users {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.steam_id {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.max_users {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.user_score {
            os.write_float(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgTFQuickplay_ScoreServers_ServerInfo {
        CMsgTFQuickplay_ScoreServers_ServerInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "server_address",
                |m: &CMsgTFQuickplay_ScoreServers_ServerInfo| { &m.server_address },
                |m: &mut CMsgTFQuickplay_ScoreServers_ServerInfo| { &mut m.server_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "server_port",
                |m: &CMsgTFQuickplay_ScoreServers_ServerInfo| { &m.server_port },
                |m: &mut CMsgTFQuickplay_ScoreServers_ServerInfo| { &mut m.server_port },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "num_users",
                |m: &CMsgTFQuickplay_ScoreServers_ServerInfo| { &m.num_users },
                |m: &mut CMsgTFQuickplay_ScoreServers_ServerInfo| { &mut m.num_users },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "steam_id",
                |m: &CMsgTFQuickplay_ScoreServers_ServerInfo| { &m.steam_id },
                |m: &mut CMsgTFQuickplay_ScoreServers_ServerInfo| { &mut m.steam_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "max_users",
                |m: &CMsgTFQuickplay_ScoreServers_ServerInfo| { &m.max_users },
                |m: &mut CMsgTFQuickplay_ScoreServers_ServerInfo| { &mut m.max_users },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "user_score",
                |m: &CMsgTFQuickplay_ScoreServers_ServerInfo| { &m.user_score },
                |m: &mut CMsgTFQuickplay_ScoreServers_ServerInfo| { &mut m.user_score },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgTFQuickplay_ScoreServers_ServerInfo>(
                "CMsgTFQuickplay_ScoreServers.ServerInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgTFQuickplay_ScoreServers_ServerInfo {
        static instance: ::protobuf::rt::LazyV2<CMsgTFQuickplay_ScoreServers_ServerInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgTFQuickplay_ScoreServers_ServerInfo::new)
    }
}

impl ::protobuf::Clear for CMsgTFQuickplay_ScoreServers_ServerInfo {
    fn clear(&mut self) {
        self.server_address = ::std::option::Option::None;
        self.server_port = ::std::option::Option::None;
        self.num_users = ::std::option::Option::None;
        self.steam_id = ::std::option::Option::None;
        self.max_users = ::std::option::Option::None;
        self.user_score = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgTFQuickplay_ScoreServers_ServerInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTFQuickplay_ScoreServers_ServerInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgTFQuickplay_ScoreServersResponse {
    // message fields
    pub servers: ::protobuf::RepeatedField<CMsgTFQuickplay_ScoreServersResponse_ServerInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgTFQuickplay_ScoreServersResponse {
    fn default() -> &'a CMsgTFQuickplay_ScoreServersResponse {
        <CMsgTFQuickplay_ScoreServersResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTFQuickplay_ScoreServersResponse {
    pub fn new() -> CMsgTFQuickplay_ScoreServersResponse {
        ::std::default::Default::default()
    }

    // repeated .CMsgTFQuickplay_ScoreServersResponse.ServerInfo servers = 1;


    pub fn get_servers(&self) -> &[CMsgTFQuickplay_ScoreServersResponse_ServerInfo] {
        &self.servers
    }
    pub fn clear_servers(&mut self) {
        self.servers.clear();
    }

    // Param is passed by value, moved
    pub fn set_servers(&mut self, v: ::protobuf::RepeatedField<CMsgTFQuickplay_ScoreServersResponse_ServerInfo>) {
        self.servers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_servers(&mut self) -> &mut ::protobuf::RepeatedField<CMsgTFQuickplay_ScoreServersResponse_ServerInfo> {
        &mut self.servers
    }

    // Take field
    pub fn take_servers(&mut self) -> ::protobuf::RepeatedField<CMsgTFQuickplay_ScoreServersResponse_ServerInfo> {
        ::std::mem::replace(&mut self.servers, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgTFQuickplay_ScoreServersResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.servers {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.servers)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.servers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.servers {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgTFQuickplay_ScoreServersResponse {
        CMsgTFQuickplay_ScoreServersResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgTFQuickplay_ScoreServersResponse_ServerInfo>>(
                "servers",
                |m: &CMsgTFQuickplay_ScoreServersResponse| { &m.servers },
                |m: &mut CMsgTFQuickplay_ScoreServersResponse| { &mut m.servers },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgTFQuickplay_ScoreServersResponse>(
                "CMsgTFQuickplay_ScoreServersResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgTFQuickplay_ScoreServersResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgTFQuickplay_ScoreServersResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgTFQuickplay_ScoreServersResponse::new)
    }
}

impl ::protobuf::Clear for CMsgTFQuickplay_ScoreServersResponse {
    fn clear(&mut self) {
        self.servers.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgTFQuickplay_ScoreServersResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTFQuickplay_ScoreServersResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgTFQuickplay_ScoreServersResponse_ServerInfo {
    // message fields
    server_address: ::std::option::Option<u32>,
    server_port: ::std::option::Option<u32>,
    total_score: ::std::option::Option<f32>,
    steam_id: ::std::option::Option<u64>,
    options_score: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgTFQuickplay_ScoreServersResponse_ServerInfo {
    fn default() -> &'a CMsgTFQuickplay_ScoreServersResponse_ServerInfo {
        <CMsgTFQuickplay_ScoreServersResponse_ServerInfo as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTFQuickplay_ScoreServersResponse_ServerInfo {
    pub fn new() -> CMsgTFQuickplay_ScoreServersResponse_ServerInfo {
        ::std::default::Default::default()
    }

    // optional uint32 server_address = 1;


    pub fn get_server_address(&self) -> u32 {
        self.server_address.unwrap_or(0)
    }
    pub fn clear_server_address(&mut self) {
        self.server_address = ::std::option::Option::None;
    }

    pub fn has_server_address(&self) -> bool {
        self.server_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_address(&mut self, v: u32) {
        self.server_address = ::std::option::Option::Some(v);
    }

    // optional uint32 server_port = 2;


    pub fn get_server_port(&self) -> u32 {
        self.server_port.unwrap_or(0)
    }
    pub fn clear_server_port(&mut self) {
        self.server_port = ::std::option::Option::None;
    }

    pub fn has_server_port(&self) -> bool {
        self.server_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_port(&mut self, v: u32) {
        self.server_port = ::std::option::Option::Some(v);
    }

    // optional float total_score = 3;


    pub fn get_total_score(&self) -> f32 {
        self.total_score.unwrap_or(0.)
    }
    pub fn clear_total_score(&mut self) {
        self.total_score = ::std::option::Option::None;
    }

    pub fn has_total_score(&self) -> bool {
        self.total_score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_score(&mut self, v: f32) {
        self.total_score = ::std::option::Option::Some(v);
    }

    // optional uint64 steam_id = 4;


    pub fn get_steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }
    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }

    // optional uint32 options_score = 5;


    pub fn get_options_score(&self) -> u32 {
        self.options_score.unwrap_or(0)
    }
    pub fn clear_options_score(&mut self) {
        self.options_score = ::std::option::Option::None;
    }

    pub fn has_options_score(&self) -> bool {
        self.options_score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_options_score(&mut self, v: u32) {
        self.options_score = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgTFQuickplay_ScoreServersResponse_ServerInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.server_address = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.server_port = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.total_score = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.steam_id = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.options_score = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.server_address {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.server_port {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.total_score {
            my_size += 5;
        }
        if let Some(v) = self.steam_id {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.options_score {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.server_address {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.server_port {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.total_score {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.steam_id {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.options_score {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgTFQuickplay_ScoreServersResponse_ServerInfo {
        CMsgTFQuickplay_ScoreServersResponse_ServerInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "server_address",
                |m: &CMsgTFQuickplay_ScoreServersResponse_ServerInfo| { &m.server_address },
                |m: &mut CMsgTFQuickplay_ScoreServersResponse_ServerInfo| { &mut m.server_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "server_port",
                |m: &CMsgTFQuickplay_ScoreServersResponse_ServerInfo| { &m.server_port },
                |m: &mut CMsgTFQuickplay_ScoreServersResponse_ServerInfo| { &mut m.server_port },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "total_score",
                |m: &CMsgTFQuickplay_ScoreServersResponse_ServerInfo| { &m.total_score },
                |m: &mut CMsgTFQuickplay_ScoreServersResponse_ServerInfo| { &mut m.total_score },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "steam_id",
                |m: &CMsgTFQuickplay_ScoreServersResponse_ServerInfo| { &m.steam_id },
                |m: &mut CMsgTFQuickplay_ScoreServersResponse_ServerInfo| { &mut m.steam_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "options_score",
                |m: &CMsgTFQuickplay_ScoreServersResponse_ServerInfo| { &m.options_score },
                |m: &mut CMsgTFQuickplay_ScoreServersResponse_ServerInfo| { &mut m.options_score },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgTFQuickplay_ScoreServersResponse_ServerInfo>(
                "CMsgTFQuickplay_ScoreServersResponse.ServerInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgTFQuickplay_ScoreServersResponse_ServerInfo {
        static instance: ::protobuf::rt::LazyV2<CMsgTFQuickplay_ScoreServersResponse_ServerInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgTFQuickplay_ScoreServersResponse_ServerInfo::new)
    }
}

impl ::protobuf::Clear for CMsgTFQuickplay_ScoreServersResponse_ServerInfo {
    fn clear(&mut self) {
        self.server_address = ::std::option::Option::None;
        self.server_port = ::std::option::Option::None;
        self.total_score = ::std::option::Option::None;
        self.steam_id = ::std::option::Option::None;
        self.options_score = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgTFQuickplay_ScoreServersResponse_ServerInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTFQuickplay_ScoreServersResponse_ServerInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgTFQuickplay_PlayerJoining {
    // message fields
    account_id: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgTFQuickplay_PlayerJoining {
    fn default() -> &'a CMsgTFQuickplay_PlayerJoining {
        <CMsgTFQuickplay_PlayerJoining as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTFQuickplay_PlayerJoining {
    pub fn new() -> CMsgTFQuickplay_PlayerJoining {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;


    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }
    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgTFQuickplay_PlayerJoining {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgTFQuickplay_PlayerJoining {
        CMsgTFQuickplay_PlayerJoining::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "account_id",
                |m: &CMsgTFQuickplay_PlayerJoining| { &m.account_id },
                |m: &mut CMsgTFQuickplay_PlayerJoining| { &mut m.account_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgTFQuickplay_PlayerJoining>(
                "CMsgTFQuickplay_PlayerJoining",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgTFQuickplay_PlayerJoining {
        static instance: ::protobuf::rt::LazyV2<CMsgTFQuickplay_PlayerJoining> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgTFQuickplay_PlayerJoining::new)
    }
}

impl ::protobuf::Clear for CMsgTFQuickplay_PlayerJoining {
    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgTFQuickplay_PlayerJoining {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTFQuickplay_PlayerJoining {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGC_GameServer_LevelInfo {
    // message fields
    level_loaded: ::std::option::Option<bool>,
    level_name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGC_GameServer_LevelInfo {
    fn default() -> &'a CMsgGC_GameServer_LevelInfo {
        <CMsgGC_GameServer_LevelInfo as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_GameServer_LevelInfo {
    pub fn new() -> CMsgGC_GameServer_LevelInfo {
        ::std::default::Default::default()
    }

    // optional bool level_loaded = 1;


    pub fn get_level_loaded(&self) -> bool {
        self.level_loaded.unwrap_or(false)
    }
    pub fn clear_level_loaded(&mut self) {
        self.level_loaded = ::std::option::Option::None;
    }

    pub fn has_level_loaded(&self) -> bool {
        self.level_loaded.is_some()
    }

    // Param is passed by value, moved
    pub fn set_level_loaded(&mut self, v: bool) {
        self.level_loaded = ::std::option::Option::Some(v);
    }

    // optional string level_name = 2;


    pub fn get_level_name(&self) -> &str {
        match self.level_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_level_name(&mut self) {
        self.level_name.clear();
    }

    pub fn has_level_name(&self) -> bool {
        self.level_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_level_name(&mut self, v: ::std::string::String) {
        self.level_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_level_name(&mut self) -> &mut ::std::string::String {
        if self.level_name.is_none() {
            self.level_name.set_default();
        }
        self.level_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_level_name(&mut self) -> ::std::string::String {
        self.level_name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgGC_GameServer_LevelInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.level_loaded = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.level_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.level_loaded {
            my_size += 2;
        }
        if let Some(ref v) = self.level_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.level_loaded {
            os.write_bool(1, v)?;
        }
        if let Some(ref v) = self.level_name.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGC_GameServer_LevelInfo {
        CMsgGC_GameServer_LevelInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "level_loaded",
                |m: &CMsgGC_GameServer_LevelInfo| { &m.level_loaded },
                |m: &mut CMsgGC_GameServer_LevelInfo| { &mut m.level_loaded },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "level_name",
                |m: &CMsgGC_GameServer_LevelInfo| { &m.level_name },
                |m: &mut CMsgGC_GameServer_LevelInfo| { &mut m.level_name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGC_GameServer_LevelInfo>(
                "CMsgGC_GameServer_LevelInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGC_GameServer_LevelInfo {
        static instance: ::protobuf::rt::LazyV2<CMsgGC_GameServer_LevelInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGC_GameServer_LevelInfo::new)
    }
}

impl ::protobuf::Clear for CMsgGC_GameServer_LevelInfo {
    fn clear(&mut self) {
        self.level_loaded = ::std::option::Option::None;
        self.level_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGC_GameServer_LevelInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGC_GameServer_LevelInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGC_GameServer_AuthChallenge {
    // message fields
    challenge_string: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGC_GameServer_AuthChallenge {
    fn default() -> &'a CMsgGC_GameServer_AuthChallenge {
        <CMsgGC_GameServer_AuthChallenge as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_GameServer_AuthChallenge {
    pub fn new() -> CMsgGC_GameServer_AuthChallenge {
        ::std::default::Default::default()
    }

    // optional string challenge_string = 1;


    pub fn get_challenge_string(&self) -> &str {
        match self.challenge_string.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_challenge_string(&mut self) {
        self.challenge_string.clear();
    }

    pub fn has_challenge_string(&self) -> bool {
        self.challenge_string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge_string(&mut self, v: ::std::string::String) {
        self.challenge_string = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_challenge_string(&mut self) -> &mut ::std::string::String {
        if self.challenge_string.is_none() {
            self.challenge_string.set_default();
        }
        self.challenge_string.as_mut().unwrap()
    }

    // Take field
    pub fn take_challenge_string(&mut self) -> ::std::string::String {
        self.challenge_string.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgGC_GameServer_AuthChallenge {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.challenge_string)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.challenge_string.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.challenge_string.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGC_GameServer_AuthChallenge {
        CMsgGC_GameServer_AuthChallenge::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "challenge_string",
                |m: &CMsgGC_GameServer_AuthChallenge| { &m.challenge_string },
                |m: &mut CMsgGC_GameServer_AuthChallenge| { &mut m.challenge_string },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGC_GameServer_AuthChallenge>(
                "CMsgGC_GameServer_AuthChallenge",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGC_GameServer_AuthChallenge {
        static instance: ::protobuf::rt::LazyV2<CMsgGC_GameServer_AuthChallenge> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGC_GameServer_AuthChallenge::new)
    }
}

impl ::protobuf::Clear for CMsgGC_GameServer_AuthChallenge {
    fn clear(&mut self) {
        self.challenge_string.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGC_GameServer_AuthChallenge {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGC_GameServer_AuthChallenge {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGC_GameServer_AuthResult {
    // message fields
    authenticated: ::std::option::Option<bool>,
    game_server_standing: ::std::option::Option<i32>,
    game_server_standing_trend: ::std::option::Option<i32>,
    is_valve_server: ::std::option::Option<bool>,
    message: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGC_GameServer_AuthResult {
    fn default() -> &'a CMsgGC_GameServer_AuthResult {
        <CMsgGC_GameServer_AuthResult as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_GameServer_AuthResult {
    pub fn new() -> CMsgGC_GameServer_AuthResult {
        ::std::default::Default::default()
    }

    // optional bool authenticated = 1;


    pub fn get_authenticated(&self) -> bool {
        self.authenticated.unwrap_or(false)
    }
    pub fn clear_authenticated(&mut self) {
        self.authenticated = ::std::option::Option::None;
    }

    pub fn has_authenticated(&self) -> bool {
        self.authenticated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_authenticated(&mut self, v: bool) {
        self.authenticated = ::std::option::Option::Some(v);
    }

    // optional int32 game_server_standing = 2;


    pub fn get_game_server_standing(&self) -> i32 {
        self.game_server_standing.unwrap_or(0)
    }
    pub fn clear_game_server_standing(&mut self) {
        self.game_server_standing = ::std::option::Option::None;
    }

    pub fn has_game_server_standing(&self) -> bool {
        self.game_server_standing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_server_standing(&mut self, v: i32) {
        self.game_server_standing = ::std::option::Option::Some(v);
    }

    // optional int32 game_server_standing_trend = 3;


    pub fn get_game_server_standing_trend(&self) -> i32 {
        self.game_server_standing_trend.unwrap_or(0)
    }
    pub fn clear_game_server_standing_trend(&mut self) {
        self.game_server_standing_trend = ::std::option::Option::None;
    }

    pub fn has_game_server_standing_trend(&self) -> bool {
        self.game_server_standing_trend.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_server_standing_trend(&mut self, v: i32) {
        self.game_server_standing_trend = ::std::option::Option::Some(v);
    }

    // optional bool is_valve_server = 4;


    pub fn get_is_valve_server(&self) -> bool {
        self.is_valve_server.unwrap_or(false)
    }
    pub fn clear_is_valve_server(&mut self) {
        self.is_valve_server = ::std::option::Option::None;
    }

    pub fn has_is_valve_server(&self) -> bool {
        self.is_valve_server.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_valve_server(&mut self, v: bool) {
        self.is_valve_server = ::std::option::Option::Some(v);
    }

    // optional string message = 5;


    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgGC_GameServer_AuthResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.authenticated = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.game_server_standing = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.game_server_standing_trend = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_valve_server = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.authenticated {
            my_size += 2;
        }
        if let Some(v) = self.game_server_standing {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.game_server_standing_trend {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.is_valve_server {
            my_size += 2;
        }
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.authenticated {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.game_server_standing {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.game_server_standing_trend {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.is_valve_server {
            os.write_bool(4, v)?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_string(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGC_GameServer_AuthResult {
        CMsgGC_GameServer_AuthResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "authenticated",
                |m: &CMsgGC_GameServer_AuthResult| { &m.authenticated },
                |m: &mut CMsgGC_GameServer_AuthResult| { &mut m.authenticated },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "game_server_standing",
                |m: &CMsgGC_GameServer_AuthResult| { &m.game_server_standing },
                |m: &mut CMsgGC_GameServer_AuthResult| { &mut m.game_server_standing },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "game_server_standing_trend",
                |m: &CMsgGC_GameServer_AuthResult| { &m.game_server_standing_trend },
                |m: &mut CMsgGC_GameServer_AuthResult| { &mut m.game_server_standing_trend },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_valve_server",
                |m: &CMsgGC_GameServer_AuthResult| { &m.is_valve_server },
                |m: &mut CMsgGC_GameServer_AuthResult| { &mut m.is_valve_server },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message",
                |m: &CMsgGC_GameServer_AuthResult| { &m.message },
                |m: &mut CMsgGC_GameServer_AuthResult| { &mut m.message },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGC_GameServer_AuthResult>(
                "CMsgGC_GameServer_AuthResult",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGC_GameServer_AuthResult {
        static instance: ::protobuf::rt::LazyV2<CMsgGC_GameServer_AuthResult> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGC_GameServer_AuthResult::new)
    }
}

impl ::protobuf::Clear for CMsgGC_GameServer_AuthResult {
    fn clear(&mut self) {
        self.authenticated = ::std::option::Option::None;
        self.game_server_standing = ::std::option::Option::None;
        self.game_server_standing_trend = ::std::option::Option::None;
        self.is_valve_server = ::std::option::Option::None;
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGC_GameServer_AuthResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGC_GameServer_AuthResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGC_GameServer_AuthChallengeResponse {
    // message fields
    game_server_account_id: ::std::option::Option<u32>,
    hashed_challenge_string: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGC_GameServer_AuthChallengeResponse {
    fn default() -> &'a CMsgGC_GameServer_AuthChallengeResponse {
        <CMsgGC_GameServer_AuthChallengeResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_GameServer_AuthChallengeResponse {
    pub fn new() -> CMsgGC_GameServer_AuthChallengeResponse {
        ::std::default::Default::default()
    }

    // optional uint32 game_server_account_id = 1;


    pub fn get_game_server_account_id(&self) -> u32 {
        self.game_server_account_id.unwrap_or(0)
    }
    pub fn clear_game_server_account_id(&mut self) {
        self.game_server_account_id = ::std::option::Option::None;
    }

    pub fn has_game_server_account_id(&self) -> bool {
        self.game_server_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_server_account_id(&mut self, v: u32) {
        self.game_server_account_id = ::std::option::Option::Some(v);
    }

    // optional bytes hashed_challenge_string = 2;


    pub fn get_hashed_challenge_string(&self) -> &[u8] {
        match self.hashed_challenge_string.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_hashed_challenge_string(&mut self) {
        self.hashed_challenge_string.clear();
    }

    pub fn has_hashed_challenge_string(&self) -> bool {
        self.hashed_challenge_string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hashed_challenge_string(&mut self, v: ::std::vec::Vec<u8>) {
        self.hashed_challenge_string = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hashed_challenge_string(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.hashed_challenge_string.is_none() {
            self.hashed_challenge_string.set_default();
        }
        self.hashed_challenge_string.as_mut().unwrap()
    }

    // Take field
    pub fn take_hashed_challenge_string(&mut self) -> ::std::vec::Vec<u8> {
        self.hashed_challenge_string.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgGC_GameServer_AuthChallengeResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.game_server_account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.hashed_challenge_string)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.game_server_account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.hashed_challenge_string.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.game_server_account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.hashed_challenge_string.as_ref() {
            os.write_bytes(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGC_GameServer_AuthChallengeResponse {
        CMsgGC_GameServer_AuthChallengeResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "game_server_account_id",
                |m: &CMsgGC_GameServer_AuthChallengeResponse| { &m.game_server_account_id },
                |m: &mut CMsgGC_GameServer_AuthChallengeResponse| { &mut m.game_server_account_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "hashed_challenge_string",
                |m: &CMsgGC_GameServer_AuthChallengeResponse| { &m.hashed_challenge_string },
                |m: &mut CMsgGC_GameServer_AuthChallengeResponse| { &mut m.hashed_challenge_string },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGC_GameServer_AuthChallengeResponse>(
                "CMsgGC_GameServer_AuthChallengeResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGC_GameServer_AuthChallengeResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgGC_GameServer_AuthChallengeResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGC_GameServer_AuthChallengeResponse::new)
    }
}

impl ::protobuf::Clear for CMsgGC_GameServer_AuthChallengeResponse {
    fn clear(&mut self) {
        self.game_server_account_id = ::std::option::Option::None;
        self.hashed_challenge_string.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGC_GameServer_AuthChallengeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGC_GameServer_AuthChallengeResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGC_GameServer_CreateIdentity {
    // message fields
    account_id: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGC_GameServer_CreateIdentity {
    fn default() -> &'a CMsgGC_GameServer_CreateIdentity {
        <CMsgGC_GameServer_CreateIdentity as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_GameServer_CreateIdentity {
    pub fn new() -> CMsgGC_GameServer_CreateIdentity {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;


    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }
    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGC_GameServer_CreateIdentity {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGC_GameServer_CreateIdentity {
        CMsgGC_GameServer_CreateIdentity::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "account_id",
                |m: &CMsgGC_GameServer_CreateIdentity| { &m.account_id },
                |m: &mut CMsgGC_GameServer_CreateIdentity| { &mut m.account_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGC_GameServer_CreateIdentity>(
                "CMsgGC_GameServer_CreateIdentity",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGC_GameServer_CreateIdentity {
        static instance: ::protobuf::rt::LazyV2<CMsgGC_GameServer_CreateIdentity> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGC_GameServer_CreateIdentity::new)
    }
}

impl ::protobuf::Clear for CMsgGC_GameServer_CreateIdentity {
    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGC_GameServer_CreateIdentity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGC_GameServer_CreateIdentity {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGC_GameServer_CreateIdentityResponse {
    // message fields
    account_created: ::std::option::Option<bool>,
    game_server_account_id: ::std::option::Option<u32>,
    game_server_identity_token: ::protobuf::SingularField<::std::string::String>,
    status: ::std::option::Option<CMsgGC_GameServer_CreateIdentityResponse_EStatus>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGC_GameServer_CreateIdentityResponse {
    fn default() -> &'a CMsgGC_GameServer_CreateIdentityResponse {
        <CMsgGC_GameServer_CreateIdentityResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_GameServer_CreateIdentityResponse {
    pub fn new() -> CMsgGC_GameServer_CreateIdentityResponse {
        ::std::default::Default::default()
    }

    // optional bool account_created = 1;


    pub fn get_account_created(&self) -> bool {
        self.account_created.unwrap_or(false)
    }
    pub fn clear_account_created(&mut self) {
        self.account_created = ::std::option::Option::None;
    }

    pub fn has_account_created(&self) -> bool {
        self.account_created.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_created(&mut self, v: bool) {
        self.account_created = ::std::option::Option::Some(v);
    }

    // optional uint32 game_server_account_id = 2;


    pub fn get_game_server_account_id(&self) -> u32 {
        self.game_server_account_id.unwrap_or(0)
    }
    pub fn clear_game_server_account_id(&mut self) {
        self.game_server_account_id = ::std::option::Option::None;
    }

    pub fn has_game_server_account_id(&self) -> bool {
        self.game_server_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_server_account_id(&mut self, v: u32) {
        self.game_server_account_id = ::std::option::Option::Some(v);
    }

    // optional string game_server_identity_token = 3;


    pub fn get_game_server_identity_token(&self) -> &str {
        match self.game_server_identity_token.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_game_server_identity_token(&mut self) {
        self.game_server_identity_token.clear();
    }

    pub fn has_game_server_identity_token(&self) -> bool {
        self.game_server_identity_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_server_identity_token(&mut self, v: ::std::string::String) {
        self.game_server_identity_token = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_server_identity_token(&mut self) -> &mut ::std::string::String {
        if self.game_server_identity_token.is_none() {
            self.game_server_identity_token.set_default();
        }
        self.game_server_identity_token.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_server_identity_token(&mut self) -> ::std::string::String {
        self.game_server_identity_token.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .CMsgGC_GameServer_CreateIdentityResponse.EStatus status = 4;


    pub fn get_status(&self) -> CMsgGC_GameServer_CreateIdentityResponse_EStatus {
        self.status.unwrap_or(CMsgGC_GameServer_CreateIdentityResponse_EStatus::kStatus_GenericFailure)
    }
    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: CMsgGC_GameServer_CreateIdentityResponse_EStatus) {
        self.status = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGC_GameServer_CreateIdentityResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.account_created = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.game_server_account_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.game_server_identity_token)?;
                },
                4 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.status, 4, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_created {
            my_size += 2;
        }
        if let Some(v) = self.game_server_account_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.game_server_identity_token.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::enum_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_created {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.game_server_account_id {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.game_server_identity_token.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.status {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGC_GameServer_CreateIdentityResponse {
        CMsgGC_GameServer_CreateIdentityResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "account_created",
                |m: &CMsgGC_GameServer_CreateIdentityResponse| { &m.account_created },
                |m: &mut CMsgGC_GameServer_CreateIdentityResponse| { &mut m.account_created },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "game_server_account_id",
                |m: &CMsgGC_GameServer_CreateIdentityResponse| { &m.game_server_account_id },
                |m: &mut CMsgGC_GameServer_CreateIdentityResponse| { &mut m.game_server_account_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "game_server_identity_token",
                |m: &CMsgGC_GameServer_CreateIdentityResponse| { &m.game_server_identity_token },
                |m: &mut CMsgGC_GameServer_CreateIdentityResponse| { &mut m.game_server_identity_token },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CMsgGC_GameServer_CreateIdentityResponse_EStatus>>(
                "status",
                |m: &CMsgGC_GameServer_CreateIdentityResponse| { &m.status },
                |m: &mut CMsgGC_GameServer_CreateIdentityResponse| { &mut m.status },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGC_GameServer_CreateIdentityResponse>(
                "CMsgGC_GameServer_CreateIdentityResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGC_GameServer_CreateIdentityResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgGC_GameServer_CreateIdentityResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGC_GameServer_CreateIdentityResponse::new)
    }
}

impl ::protobuf::Clear for CMsgGC_GameServer_CreateIdentityResponse {
    fn clear(&mut self) {
        self.account_created = ::std::option::Option::None;
        self.game_server_account_id = ::std::option::Option::None;
        self.game_server_identity_token.clear();
        self.status = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGC_GameServer_CreateIdentityResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGC_GameServer_CreateIdentityResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgGC_GameServer_CreateIdentityResponse_EStatus {
    kStatus_GenericFailure = 0,
    kStatus_TooMany = -1,
    kStatus_NoPrivs = -2,
    kStatus_Created = 1,
}

impl ::protobuf::ProtobufEnum for CMsgGC_GameServer_CreateIdentityResponse_EStatus {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgGC_GameServer_CreateIdentityResponse_EStatus> {
        match value {
            0 => ::std::option::Option::Some(CMsgGC_GameServer_CreateIdentityResponse_EStatus::kStatus_GenericFailure),
            -1 => ::std::option::Option::Some(CMsgGC_GameServer_CreateIdentityResponse_EStatus::kStatus_TooMany),
            -2 => ::std::option::Option::Some(CMsgGC_GameServer_CreateIdentityResponse_EStatus::kStatus_NoPrivs),
            1 => ::std::option::Option::Some(CMsgGC_GameServer_CreateIdentityResponse_EStatus::kStatus_Created),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgGC_GameServer_CreateIdentityResponse_EStatus] = &[
            CMsgGC_GameServer_CreateIdentityResponse_EStatus::kStatus_GenericFailure,
            CMsgGC_GameServer_CreateIdentityResponse_EStatus::kStatus_TooMany,
            CMsgGC_GameServer_CreateIdentityResponse_EStatus::kStatus_NoPrivs,
            CMsgGC_GameServer_CreateIdentityResponse_EStatus::kStatus_Created,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<CMsgGC_GameServer_CreateIdentityResponse_EStatus>("CMsgGC_GameServer_CreateIdentityResponse.EStatus", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for CMsgGC_GameServer_CreateIdentityResponse_EStatus {
}

impl ::std::default::Default for CMsgGC_GameServer_CreateIdentityResponse_EStatus {
    fn default() -> Self {
        CMsgGC_GameServer_CreateIdentityResponse_EStatus::kStatus_GenericFailure
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGC_GameServer_CreateIdentityResponse_EStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGC_GameServer_List {
    // message fields
    account_id: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGC_GameServer_List {
    fn default() -> &'a CMsgGC_GameServer_List {
        <CMsgGC_GameServer_List as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_GameServer_List {
    pub fn new() -> CMsgGC_GameServer_List {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;


    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }
    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGC_GameServer_List {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGC_GameServer_List {
        CMsgGC_GameServer_List::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "account_id",
                |m: &CMsgGC_GameServer_List| { &m.account_id },
                |m: &mut CMsgGC_GameServer_List| { &mut m.account_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGC_GameServer_List>(
                "CMsgGC_GameServer_List",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGC_GameServer_List {
        static instance: ::protobuf::rt::LazyV2<CMsgGC_GameServer_List> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGC_GameServer_List::new)
    }
}

impl ::protobuf::Clear for CMsgGC_GameServer_List {
    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGC_GameServer_List {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGC_GameServer_List {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGC_GameServer_ListResponse {
    // message fields
    pub owned_game_servers: ::protobuf::RepeatedField<CMsgGC_GameServer_ListResponse_GameServerIdentity>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGC_GameServer_ListResponse {
    fn default() -> &'a CMsgGC_GameServer_ListResponse {
        <CMsgGC_GameServer_ListResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_GameServer_ListResponse {
    pub fn new() -> CMsgGC_GameServer_ListResponse {
        ::std::default::Default::default()
    }

    // repeated .CMsgGC_GameServer_ListResponse.GameServerIdentity owned_game_servers = 1;


    pub fn get_owned_game_servers(&self) -> &[CMsgGC_GameServer_ListResponse_GameServerIdentity] {
        &self.owned_game_servers
    }
    pub fn clear_owned_game_servers(&mut self) {
        self.owned_game_servers.clear();
    }

    // Param is passed by value, moved
    pub fn set_owned_game_servers(&mut self, v: ::protobuf::RepeatedField<CMsgGC_GameServer_ListResponse_GameServerIdentity>) {
        self.owned_game_servers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_owned_game_servers(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGC_GameServer_ListResponse_GameServerIdentity> {
        &mut self.owned_game_servers
    }

    // Take field
    pub fn take_owned_game_servers(&mut self) -> ::protobuf::RepeatedField<CMsgGC_GameServer_ListResponse_GameServerIdentity> {
        ::std::mem::replace(&mut self.owned_game_servers, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgGC_GameServer_ListResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.owned_game_servers {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.owned_game_servers)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.owned_game_servers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.owned_game_servers {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGC_GameServer_ListResponse {
        CMsgGC_GameServer_ListResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGC_GameServer_ListResponse_GameServerIdentity>>(
                "owned_game_servers",
                |m: &CMsgGC_GameServer_ListResponse| { &m.owned_game_servers },
                |m: &mut CMsgGC_GameServer_ListResponse| { &mut m.owned_game_servers },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGC_GameServer_ListResponse>(
                "CMsgGC_GameServer_ListResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGC_GameServer_ListResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgGC_GameServer_ListResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGC_GameServer_ListResponse::new)
    }
}

impl ::protobuf::Clear for CMsgGC_GameServer_ListResponse {
    fn clear(&mut self) {
        self.owned_game_servers.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGC_GameServer_ListResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGC_GameServer_ListResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGC_GameServer_ListResponse_GameServerIdentity {
    // message fields
    game_server_account_id: ::std::option::Option<u32>,
    game_server_identity_token: ::protobuf::SingularField<::std::string::String>,
    game_server_standing: ::std::option::Option<i32>,
    game_server_standing_trend: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGC_GameServer_ListResponse_GameServerIdentity {
    fn default() -> &'a CMsgGC_GameServer_ListResponse_GameServerIdentity {
        <CMsgGC_GameServer_ListResponse_GameServerIdentity as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_GameServer_ListResponse_GameServerIdentity {
    pub fn new() -> CMsgGC_GameServer_ListResponse_GameServerIdentity {
        ::std::default::Default::default()
    }

    // optional uint32 game_server_account_id = 1;


    pub fn get_game_server_account_id(&self) -> u32 {
        self.game_server_account_id.unwrap_or(0)
    }
    pub fn clear_game_server_account_id(&mut self) {
        self.game_server_account_id = ::std::option::Option::None;
    }

    pub fn has_game_server_account_id(&self) -> bool {
        self.game_server_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_server_account_id(&mut self, v: u32) {
        self.game_server_account_id = ::std::option::Option::Some(v);
    }

    // optional string game_server_identity_token = 2;


    pub fn get_game_server_identity_token(&self) -> &str {
        match self.game_server_identity_token.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_game_server_identity_token(&mut self) {
        self.game_server_identity_token.clear();
    }

    pub fn has_game_server_identity_token(&self) -> bool {
        self.game_server_identity_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_server_identity_token(&mut self, v: ::std::string::String) {
        self.game_server_identity_token = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_server_identity_token(&mut self) -> &mut ::std::string::String {
        if self.game_server_identity_token.is_none() {
            self.game_server_identity_token.set_default();
        }
        self.game_server_identity_token.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_server_identity_token(&mut self) -> ::std::string::String {
        self.game_server_identity_token.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 game_server_standing = 3;


    pub fn get_game_server_standing(&self) -> i32 {
        self.game_server_standing.unwrap_or(0)
    }
    pub fn clear_game_server_standing(&mut self) {
        self.game_server_standing = ::std::option::Option::None;
    }

    pub fn has_game_server_standing(&self) -> bool {
        self.game_server_standing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_server_standing(&mut self, v: i32) {
        self.game_server_standing = ::std::option::Option::Some(v);
    }

    // optional int32 game_server_standing_trend = 4;


    pub fn get_game_server_standing_trend(&self) -> i32 {
        self.game_server_standing_trend.unwrap_or(0)
    }
    pub fn clear_game_server_standing_trend(&mut self) {
        self.game_server_standing_trend = ::std::option::Option::None;
    }

    pub fn has_game_server_standing_trend(&self) -> bool {
        self.game_server_standing_trend.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_server_standing_trend(&mut self, v: i32) {
        self.game_server_standing_trend = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGC_GameServer_ListResponse_GameServerIdentity {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.game_server_account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.game_server_identity_token)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.game_server_standing = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.game_server_standing_trend = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.game_server_account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.game_server_identity_token.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.game_server_standing {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.game_server_standing_trend {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.game_server_account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.game_server_identity_token.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.game_server_standing {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.game_server_standing_trend {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGC_GameServer_ListResponse_GameServerIdentity {
        CMsgGC_GameServer_ListResponse_GameServerIdentity::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "game_server_account_id",
                |m: &CMsgGC_GameServer_ListResponse_GameServerIdentity| { &m.game_server_account_id },
                |m: &mut CMsgGC_GameServer_ListResponse_GameServerIdentity| { &mut m.game_server_account_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "game_server_identity_token",
                |m: &CMsgGC_GameServer_ListResponse_GameServerIdentity| { &m.game_server_identity_token },
                |m: &mut CMsgGC_GameServer_ListResponse_GameServerIdentity| { &mut m.game_server_identity_token },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "game_server_standing",
                |m: &CMsgGC_GameServer_ListResponse_GameServerIdentity| { &m.game_server_standing },
                |m: &mut CMsgGC_GameServer_ListResponse_GameServerIdentity| { &mut m.game_server_standing },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "game_server_standing_trend",
                |m: &CMsgGC_GameServer_ListResponse_GameServerIdentity| { &m.game_server_standing_trend },
                |m: &mut CMsgGC_GameServer_ListResponse_GameServerIdentity| { &mut m.game_server_standing_trend },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGC_GameServer_ListResponse_GameServerIdentity>(
                "CMsgGC_GameServer_ListResponse.GameServerIdentity",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGC_GameServer_ListResponse_GameServerIdentity {
        static instance: ::protobuf::rt::LazyV2<CMsgGC_GameServer_ListResponse_GameServerIdentity> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGC_GameServer_ListResponse_GameServerIdentity::new)
    }
}

impl ::protobuf::Clear for CMsgGC_GameServer_ListResponse_GameServerIdentity {
    fn clear(&mut self) {
        self.game_server_account_id = ::std::option::Option::None;
        self.game_server_identity_token.clear();
        self.game_server_standing = ::std::option::Option::None;
        self.game_server_standing_trend = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGC_GameServer_ListResponse_GameServerIdentity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGC_GameServer_ListResponse_GameServerIdentity {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGC_GameServer_ResetIdentity {
    // message fields
    game_server_account_id: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGC_GameServer_ResetIdentity {
    fn default() -> &'a CMsgGC_GameServer_ResetIdentity {
        <CMsgGC_GameServer_ResetIdentity as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_GameServer_ResetIdentity {
    pub fn new() -> CMsgGC_GameServer_ResetIdentity {
        ::std::default::Default::default()
    }

    // optional uint32 game_server_account_id = 1;


    pub fn get_game_server_account_id(&self) -> u32 {
        self.game_server_account_id.unwrap_or(0)
    }
    pub fn clear_game_server_account_id(&mut self) {
        self.game_server_account_id = ::std::option::Option::None;
    }

    pub fn has_game_server_account_id(&self) -> bool {
        self.game_server_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_server_account_id(&mut self, v: u32) {
        self.game_server_account_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGC_GameServer_ResetIdentity {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.game_server_account_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.game_server_account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.game_server_account_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGC_GameServer_ResetIdentity {
        CMsgGC_GameServer_ResetIdentity::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "game_server_account_id",
                |m: &CMsgGC_GameServer_ResetIdentity| { &m.game_server_account_id },
                |m: &mut CMsgGC_GameServer_ResetIdentity| { &mut m.game_server_account_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGC_GameServer_ResetIdentity>(
                "CMsgGC_GameServer_ResetIdentity",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGC_GameServer_ResetIdentity {
        static instance: ::protobuf::rt::LazyV2<CMsgGC_GameServer_ResetIdentity> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGC_GameServer_ResetIdentity::new)
    }
}

impl ::protobuf::Clear for CMsgGC_GameServer_ResetIdentity {
    fn clear(&mut self) {
        self.game_server_account_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGC_GameServer_ResetIdentity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGC_GameServer_ResetIdentity {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGC_GameServer_ResetIdentityResponse {
    // message fields
    game_server_identity_token_reset: ::std::option::Option<bool>,
    game_server_account_id: ::std::option::Option<u32>,
    game_server_identity_token: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGC_GameServer_ResetIdentityResponse {
    fn default() -> &'a CMsgGC_GameServer_ResetIdentityResponse {
        <CMsgGC_GameServer_ResetIdentityResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_GameServer_ResetIdentityResponse {
    pub fn new() -> CMsgGC_GameServer_ResetIdentityResponse {
        ::std::default::Default::default()
    }

    // optional bool game_server_identity_token_reset = 1;


    pub fn get_game_server_identity_token_reset(&self) -> bool {
        self.game_server_identity_token_reset.unwrap_or(false)
    }
    pub fn clear_game_server_identity_token_reset(&mut self) {
        self.game_server_identity_token_reset = ::std::option::Option::None;
    }

    pub fn has_game_server_identity_token_reset(&self) -> bool {
        self.game_server_identity_token_reset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_server_identity_token_reset(&mut self, v: bool) {
        self.game_server_identity_token_reset = ::std::option::Option::Some(v);
    }

    // optional uint32 game_server_account_id = 2;


    pub fn get_game_server_account_id(&self) -> u32 {
        self.game_server_account_id.unwrap_or(0)
    }
    pub fn clear_game_server_account_id(&mut self) {
        self.game_server_account_id = ::std::option::Option::None;
    }

    pub fn has_game_server_account_id(&self) -> bool {
        self.game_server_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_server_account_id(&mut self, v: u32) {
        self.game_server_account_id = ::std::option::Option::Some(v);
    }

    // optional string game_server_identity_token = 3;


    pub fn get_game_server_identity_token(&self) -> &str {
        match self.game_server_identity_token.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_game_server_identity_token(&mut self) {
        self.game_server_identity_token.clear();
    }

    pub fn has_game_server_identity_token(&self) -> bool {
        self.game_server_identity_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_server_identity_token(&mut self, v: ::std::string::String) {
        self.game_server_identity_token = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_server_identity_token(&mut self) -> &mut ::std::string::String {
        if self.game_server_identity_token.is_none() {
            self.game_server_identity_token.set_default();
        }
        self.game_server_identity_token.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_server_identity_token(&mut self) -> ::std::string::String {
        self.game_server_identity_token.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgGC_GameServer_ResetIdentityResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.game_server_identity_token_reset = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.game_server_account_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.game_server_identity_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.game_server_identity_token_reset {
            my_size += 2;
        }
        if let Some(v) = self.game_server_account_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.game_server_identity_token.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.game_server_identity_token_reset {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.game_server_account_id {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.game_server_identity_token.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGC_GameServer_ResetIdentityResponse {
        CMsgGC_GameServer_ResetIdentityResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "game_server_identity_token_reset",
                |m: &CMsgGC_GameServer_ResetIdentityResponse| { &m.game_server_identity_token_reset },
                |m: &mut CMsgGC_GameServer_ResetIdentityResponse| { &mut m.game_server_identity_token_reset },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "game_server_account_id",
                |m: &CMsgGC_GameServer_ResetIdentityResponse| { &m.game_server_account_id },
                |m: &mut CMsgGC_GameServer_ResetIdentityResponse| { &mut m.game_server_account_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "game_server_identity_token",
                |m: &CMsgGC_GameServer_ResetIdentityResponse| { &m.game_server_identity_token },
                |m: &mut CMsgGC_GameServer_ResetIdentityResponse| { &mut m.game_server_identity_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGC_GameServer_ResetIdentityResponse>(
                "CMsgGC_GameServer_ResetIdentityResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGC_GameServer_ResetIdentityResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgGC_GameServer_ResetIdentityResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGC_GameServer_ResetIdentityResponse::new)
    }
}

impl ::protobuf::Clear for CMsgGC_GameServer_ResetIdentityResponse {
    fn clear(&mut self) {
        self.game_server_identity_token_reset = ::std::option::Option::None;
        self.game_server_account_id = ::std::option::Option::None;
        self.game_server_identity_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGC_GameServer_ResetIdentityResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGC_GameServer_ResetIdentityResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGC_GameServer_AckPolicy {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGC_GameServer_AckPolicy {
    fn default() -> &'a CMsgGC_GameServer_AckPolicy {
        <CMsgGC_GameServer_AckPolicy as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_GameServer_AckPolicy {
    pub fn new() -> CMsgGC_GameServer_AckPolicy {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgGC_GameServer_AckPolicy {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGC_GameServer_AckPolicy {
        CMsgGC_GameServer_AckPolicy::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGC_GameServer_AckPolicy>(
                "CMsgGC_GameServer_AckPolicy",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGC_GameServer_AckPolicy {
        static instance: ::protobuf::rt::LazyV2<CMsgGC_GameServer_AckPolicy> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGC_GameServer_AckPolicy::new)
    }
}

impl ::protobuf::Clear for CMsgGC_GameServer_AckPolicy {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGC_GameServer_AckPolicy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGC_GameServer_AckPolicy {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGC_GameServer_AckPolicyResponse {
    // message fields
    result: ::std::option::Option<u32>,
    message: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGC_GameServer_AckPolicyResponse {
    fn default() -> &'a CMsgGC_GameServer_AckPolicyResponse {
        <CMsgGC_GameServer_AckPolicyResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_GameServer_AckPolicyResponse {
    pub fn new() -> CMsgGC_GameServer_AckPolicyResponse {
        ::std::default::Default::default()
    }

    // optional uint32 result = 1;


    pub fn get_result(&self) -> u32 {
        self.result.unwrap_or(0)
    }
    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: u32) {
        self.result = ::std::option::Option::Some(v);
    }

    // optional string message = 2;


    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgGC_GameServer_AckPolicyResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGC_GameServer_AckPolicyResponse {
        CMsgGC_GameServer_AckPolicyResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "result",
                |m: &CMsgGC_GameServer_AckPolicyResponse| { &m.result },
                |m: &mut CMsgGC_GameServer_AckPolicyResponse| { &mut m.result },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message",
                |m: &CMsgGC_GameServer_AckPolicyResponse| { &m.message },
                |m: &mut CMsgGC_GameServer_AckPolicyResponse| { &mut m.message },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGC_GameServer_AckPolicyResponse>(
                "CMsgGC_GameServer_AckPolicyResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGC_GameServer_AckPolicyResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgGC_GameServer_AckPolicyResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGC_GameServer_AckPolicyResponse::new)
    }
}

impl ::protobuf::Clear for CMsgGC_GameServer_AckPolicyResponse {
    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGC_GameServer_AckPolicyResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGC_GameServer_AckPolicyResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGC_Client_UseServerModificationItem {
    // message fields
    item_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGC_Client_UseServerModificationItem {
    fn default() -> &'a CMsgGC_Client_UseServerModificationItem {
        <CMsgGC_Client_UseServerModificationItem as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_Client_UseServerModificationItem {
    pub fn new() -> CMsgGC_Client_UseServerModificationItem {
        ::std::default::Default::default()
    }

    // optional uint64 item_id = 1;


    pub fn get_item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }
    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGC_Client_UseServerModificationItem {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.item_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.item_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGC_Client_UseServerModificationItem {
        CMsgGC_Client_UseServerModificationItem::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "item_id",
                |m: &CMsgGC_Client_UseServerModificationItem| { &m.item_id },
                |m: &mut CMsgGC_Client_UseServerModificationItem| { &mut m.item_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGC_Client_UseServerModificationItem>(
                "CMsgGC_Client_UseServerModificationItem",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGC_Client_UseServerModificationItem {
        static instance: ::protobuf::rt::LazyV2<CMsgGC_Client_UseServerModificationItem> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGC_Client_UseServerModificationItem::new)
    }
}

impl ::protobuf::Clear for CMsgGC_Client_UseServerModificationItem {
    fn clear(&mut self) {
        self.item_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGC_Client_UseServerModificationItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGC_Client_UseServerModificationItem {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGC_Client_UseServerModificationItem_Response {
    // message fields
    response_code: ::std::option::Option<CMsgGC_Client_UseServerModificationItem_Response_EServerModificationItemResponse>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGC_Client_UseServerModificationItem_Response {
    fn default() -> &'a CMsgGC_Client_UseServerModificationItem_Response {
        <CMsgGC_Client_UseServerModificationItem_Response as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_Client_UseServerModificationItem_Response {
    pub fn new() -> CMsgGC_Client_UseServerModificationItem_Response {
        ::std::default::Default::default()
    }

    // optional .CMsgGC_Client_UseServerModificationItem_Response.EServerModificationItemResponse response_code = 1;


    pub fn get_response_code(&self) -> CMsgGC_Client_UseServerModificationItem_Response_EServerModificationItemResponse {
        self.response_code.unwrap_or(CMsgGC_Client_UseServerModificationItem_Response_EServerModificationItemResponse::kServerModificationItemResponse_AlreadyInUse)
    }
    pub fn clear_response_code(&mut self) {
        self.response_code = ::std::option::Option::None;
    }

    pub fn has_response_code(&self) -> bool {
        self.response_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response_code(&mut self, v: CMsgGC_Client_UseServerModificationItem_Response_EServerModificationItemResponse) {
        self.response_code = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGC_Client_UseServerModificationItem_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.response_code, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.response_code {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.response_code {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGC_Client_UseServerModificationItem_Response {
        CMsgGC_Client_UseServerModificationItem_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CMsgGC_Client_UseServerModificationItem_Response_EServerModificationItemResponse>>(
                "response_code",
                |m: &CMsgGC_Client_UseServerModificationItem_Response| { &m.response_code },
                |m: &mut CMsgGC_Client_UseServerModificationItem_Response| { &mut m.response_code },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGC_Client_UseServerModificationItem_Response>(
                "CMsgGC_Client_UseServerModificationItem_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGC_Client_UseServerModificationItem_Response {
        static instance: ::protobuf::rt::LazyV2<CMsgGC_Client_UseServerModificationItem_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGC_Client_UseServerModificationItem_Response::new)
    }
}

impl ::protobuf::Clear for CMsgGC_Client_UseServerModificationItem_Response {
    fn clear(&mut self) {
        self.response_code = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGC_Client_UseServerModificationItem_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGC_Client_UseServerModificationItem_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgGC_Client_UseServerModificationItem_Response_EServerModificationItemResponse {
    kServerModificationItemResponse_AlreadyInUse = 1,
    kServerModificationItemResponse_NotOnAuthenticatedServer = 2,
    kServerModificationItemResponse_ServerReject = 3,
    kServerModificationItemResponse_InternalError = 4,
    kServerModificationItemResponse_EventAlreadyActive = 5,
}

impl ::protobuf::ProtobufEnum for CMsgGC_Client_UseServerModificationItem_Response_EServerModificationItemResponse {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgGC_Client_UseServerModificationItem_Response_EServerModificationItemResponse> {
        match value {
            1 => ::std::option::Option::Some(CMsgGC_Client_UseServerModificationItem_Response_EServerModificationItemResponse::kServerModificationItemResponse_AlreadyInUse),
            2 => ::std::option::Option::Some(CMsgGC_Client_UseServerModificationItem_Response_EServerModificationItemResponse::kServerModificationItemResponse_NotOnAuthenticatedServer),
            3 => ::std::option::Option::Some(CMsgGC_Client_UseServerModificationItem_Response_EServerModificationItemResponse::kServerModificationItemResponse_ServerReject),
            4 => ::std::option::Option::Some(CMsgGC_Client_UseServerModificationItem_Response_EServerModificationItemResponse::kServerModificationItemResponse_InternalError),
            5 => ::std::option::Option::Some(CMsgGC_Client_UseServerModificationItem_Response_EServerModificationItemResponse::kServerModificationItemResponse_EventAlreadyActive),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgGC_Client_UseServerModificationItem_Response_EServerModificationItemResponse] = &[
            CMsgGC_Client_UseServerModificationItem_Response_EServerModificationItemResponse::kServerModificationItemResponse_AlreadyInUse,
            CMsgGC_Client_UseServerModificationItem_Response_EServerModificationItemResponse::kServerModificationItemResponse_NotOnAuthenticatedServer,
            CMsgGC_Client_UseServerModificationItem_Response_EServerModificationItemResponse::kServerModificationItemResponse_ServerReject,
            CMsgGC_Client_UseServerModificationItem_Response_EServerModificationItemResponse::kServerModificationItemResponse_InternalError,
            CMsgGC_Client_UseServerModificationItem_Response_EServerModificationItemResponse::kServerModificationItemResponse_EventAlreadyActive,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<CMsgGC_Client_UseServerModificationItem_Response_EServerModificationItemResponse>("CMsgGC_Client_UseServerModificationItem_Response.EServerModificationItemResponse", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for CMsgGC_Client_UseServerModificationItem_Response_EServerModificationItemResponse {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for CMsgGC_Client_UseServerModificationItem_Response_EServerModificationItemResponse {
    fn default() -> Self {
        CMsgGC_Client_UseServerModificationItem_Response_EServerModificationItemResponse::kServerModificationItemResponse_AlreadyInUse
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGC_Client_UseServerModificationItem_Response_EServerModificationItemResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGC_GameServer_UseServerModificationItem {
    // message fields
    modification_type: ::std::option::Option<EServerModificationItemType>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGC_GameServer_UseServerModificationItem {
    fn default() -> &'a CMsgGC_GameServer_UseServerModificationItem {
        <CMsgGC_GameServer_UseServerModificationItem as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_GameServer_UseServerModificationItem {
    pub fn new() -> CMsgGC_GameServer_UseServerModificationItem {
        ::std::default::Default::default()
    }

    // optional .EServerModificationItemType modification_type = 1;


    pub fn get_modification_type(&self) -> EServerModificationItemType {
        self.modification_type.unwrap_or(EServerModificationItemType::kGameServerModificationItem_Halloween)
    }
    pub fn clear_modification_type(&mut self) {
        self.modification_type = ::std::option::Option::None;
    }

    pub fn has_modification_type(&self) -> bool {
        self.modification_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modification_type(&mut self, v: EServerModificationItemType) {
        self.modification_type = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGC_GameServer_UseServerModificationItem {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.modification_type, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.modification_type {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.modification_type {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGC_GameServer_UseServerModificationItem {
        CMsgGC_GameServer_UseServerModificationItem::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EServerModificationItemType>>(
                "modification_type",
                |m: &CMsgGC_GameServer_UseServerModificationItem| { &m.modification_type },
                |m: &mut CMsgGC_GameServer_UseServerModificationItem| { &mut m.modification_type },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGC_GameServer_UseServerModificationItem>(
                "CMsgGC_GameServer_UseServerModificationItem",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGC_GameServer_UseServerModificationItem {
        static instance: ::protobuf::rt::LazyV2<CMsgGC_GameServer_UseServerModificationItem> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGC_GameServer_UseServerModificationItem::new)
    }
}

impl ::protobuf::Clear for CMsgGC_GameServer_UseServerModificationItem {
    fn clear(&mut self) {
        self.modification_type = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGC_GameServer_UseServerModificationItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGC_GameServer_UseServerModificationItem {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGC_GameServer_UseServerModificationItem_Response {
    // message fields
    modification_type: ::std::option::Option<EServerModificationItemType>,
    server_response_code: ::std::option::Option<CMsgGC_GameServer_UseServerModificationItem_Response_EServerModificationItemServerResponse>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGC_GameServer_UseServerModificationItem_Response {
    fn default() -> &'a CMsgGC_GameServer_UseServerModificationItem_Response {
        <CMsgGC_GameServer_UseServerModificationItem_Response as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_GameServer_UseServerModificationItem_Response {
    pub fn new() -> CMsgGC_GameServer_UseServerModificationItem_Response {
        ::std::default::Default::default()
    }

    // optional .EServerModificationItemType modification_type = 1;


    pub fn get_modification_type(&self) -> EServerModificationItemType {
        self.modification_type.unwrap_or(EServerModificationItemType::kGameServerModificationItem_Halloween)
    }
    pub fn clear_modification_type(&mut self) {
        self.modification_type = ::std::option::Option::None;
    }

    pub fn has_modification_type(&self) -> bool {
        self.modification_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modification_type(&mut self, v: EServerModificationItemType) {
        self.modification_type = ::std::option::Option::Some(v);
    }

    // optional .CMsgGC_GameServer_UseServerModificationItem_Response.EServerModificationItemServerResponse server_response_code = 2;


    pub fn get_server_response_code(&self) -> CMsgGC_GameServer_UseServerModificationItem_Response_EServerModificationItemServerResponse {
        self.server_response_code.unwrap_or(CMsgGC_GameServer_UseServerModificationItem_Response_EServerModificationItemServerResponse::kServerModificationItemServerResponse_Accepted)
    }
    pub fn clear_server_response_code(&mut self) {
        self.server_response_code = ::std::option::Option::None;
    }

    pub fn has_server_response_code(&self) -> bool {
        self.server_response_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_response_code(&mut self, v: CMsgGC_GameServer_UseServerModificationItem_Response_EServerModificationItemServerResponse) {
        self.server_response_code = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGC_GameServer_UseServerModificationItem_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.modification_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.server_response_code, 2, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.modification_type {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.server_response_code {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.modification_type {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.server_response_code {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGC_GameServer_UseServerModificationItem_Response {
        CMsgGC_GameServer_UseServerModificationItem_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EServerModificationItemType>>(
                "modification_type",
                |m: &CMsgGC_GameServer_UseServerModificationItem_Response| { &m.modification_type },
                |m: &mut CMsgGC_GameServer_UseServerModificationItem_Response| { &mut m.modification_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CMsgGC_GameServer_UseServerModificationItem_Response_EServerModificationItemServerResponse>>(
                "server_response_code",
                |m: &CMsgGC_GameServer_UseServerModificationItem_Response| { &m.server_response_code },
                |m: &mut CMsgGC_GameServer_UseServerModificationItem_Response| { &mut m.server_response_code },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGC_GameServer_UseServerModificationItem_Response>(
                "CMsgGC_GameServer_UseServerModificationItem_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGC_GameServer_UseServerModificationItem_Response {
        static instance: ::protobuf::rt::LazyV2<CMsgGC_GameServer_UseServerModificationItem_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGC_GameServer_UseServerModificationItem_Response::new)
    }
}

impl ::protobuf::Clear for CMsgGC_GameServer_UseServerModificationItem_Response {
    fn clear(&mut self) {
        self.modification_type = ::std::option::Option::None;
        self.server_response_code = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGC_GameServer_UseServerModificationItem_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGC_GameServer_UseServerModificationItem_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgGC_GameServer_UseServerModificationItem_Response_EServerModificationItemServerResponse {
    kServerModificationItemServerResponse_Accepted = 1,
    kServerModificationItemServerResponse_NoVoteCalled = 2,
    kServerModificationItemServerResponse_VoteFailed = 3,
}

impl ::protobuf::ProtobufEnum for CMsgGC_GameServer_UseServerModificationItem_Response_EServerModificationItemServerResponse {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgGC_GameServer_UseServerModificationItem_Response_EServerModificationItemServerResponse> {
        match value {
            1 => ::std::option::Option::Some(CMsgGC_GameServer_UseServerModificationItem_Response_EServerModificationItemServerResponse::kServerModificationItemServerResponse_Accepted),
            2 => ::std::option::Option::Some(CMsgGC_GameServer_UseServerModificationItem_Response_EServerModificationItemServerResponse::kServerModificationItemServerResponse_NoVoteCalled),
            3 => ::std::option::Option::Some(CMsgGC_GameServer_UseServerModificationItem_Response_EServerModificationItemServerResponse::kServerModificationItemServerResponse_VoteFailed),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgGC_GameServer_UseServerModificationItem_Response_EServerModificationItemServerResponse] = &[
            CMsgGC_GameServer_UseServerModificationItem_Response_EServerModificationItemServerResponse::kServerModificationItemServerResponse_Accepted,
            CMsgGC_GameServer_UseServerModificationItem_Response_EServerModificationItemServerResponse::kServerModificationItemServerResponse_NoVoteCalled,
            CMsgGC_GameServer_UseServerModificationItem_Response_EServerModificationItemServerResponse::kServerModificationItemServerResponse_VoteFailed,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<CMsgGC_GameServer_UseServerModificationItem_Response_EServerModificationItemServerResponse>("CMsgGC_GameServer_UseServerModificationItem_Response.EServerModificationItemServerResponse", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for CMsgGC_GameServer_UseServerModificationItem_Response_EServerModificationItemServerResponse {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for CMsgGC_GameServer_UseServerModificationItem_Response_EServerModificationItemServerResponse {
    fn default() -> Self {
        CMsgGC_GameServer_UseServerModificationItem_Response_EServerModificationItemServerResponse::kServerModificationItemServerResponse_Accepted
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGC_GameServer_UseServerModificationItem_Response_EServerModificationItemServerResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGC_GameServer_ServerModificationItemExpired {
    // message fields
    modification_type: ::std::option::Option<EServerModificationItemType>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGC_GameServer_ServerModificationItemExpired {
    fn default() -> &'a CMsgGC_GameServer_ServerModificationItemExpired {
        <CMsgGC_GameServer_ServerModificationItemExpired as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_GameServer_ServerModificationItemExpired {
    pub fn new() -> CMsgGC_GameServer_ServerModificationItemExpired {
        ::std::default::Default::default()
    }

    // optional .EServerModificationItemType modification_type = 1;


    pub fn get_modification_type(&self) -> EServerModificationItemType {
        self.modification_type.unwrap_or(EServerModificationItemType::kGameServerModificationItem_Halloween)
    }
    pub fn clear_modification_type(&mut self) {
        self.modification_type = ::std::option::Option::None;
    }

    pub fn has_modification_type(&self) -> bool {
        self.modification_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modification_type(&mut self, v: EServerModificationItemType) {
        self.modification_type = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGC_GameServer_ServerModificationItemExpired {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.modification_type, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.modification_type {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.modification_type {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGC_GameServer_ServerModificationItemExpired {
        CMsgGC_GameServer_ServerModificationItemExpired::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EServerModificationItemType>>(
                "modification_type",
                |m: &CMsgGC_GameServer_ServerModificationItemExpired| { &m.modification_type },
                |m: &mut CMsgGC_GameServer_ServerModificationItemExpired| { &mut m.modification_type },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGC_GameServer_ServerModificationItemExpired>(
                "CMsgGC_GameServer_ServerModificationItemExpired",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGC_GameServer_ServerModificationItemExpired {
        static instance: ::protobuf::rt::LazyV2<CMsgGC_GameServer_ServerModificationItemExpired> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGC_GameServer_ServerModificationItemExpired::new)
    }
}

impl ::protobuf::Clear for CMsgGC_GameServer_ServerModificationItemExpired {
    fn clear(&mut self) {
        self.modification_type = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGC_GameServer_ServerModificationItemExpired {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGC_GameServer_ServerModificationItemExpired {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGC_GameServer_ServerModificationItem {
    // message fields
    modification_type: ::std::option::Option<EServerModificationItemType>,
    active: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGC_GameServer_ServerModificationItem {
    fn default() -> &'a CMsgGC_GameServer_ServerModificationItem {
        <CMsgGC_GameServer_ServerModificationItem as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_GameServer_ServerModificationItem {
    pub fn new() -> CMsgGC_GameServer_ServerModificationItem {
        ::std::default::Default::default()
    }

    // optional .EServerModificationItemType modification_type = 1;


    pub fn get_modification_type(&self) -> EServerModificationItemType {
        self.modification_type.unwrap_or(EServerModificationItemType::kGameServerModificationItem_Halloween)
    }
    pub fn clear_modification_type(&mut self) {
        self.modification_type = ::std::option::Option::None;
    }

    pub fn has_modification_type(&self) -> bool {
        self.modification_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modification_type(&mut self, v: EServerModificationItemType) {
        self.modification_type = ::std::option::Option::Some(v);
    }

    // optional bool active = 2;


    pub fn get_active(&self) -> bool {
        self.active.unwrap_or(false)
    }
    pub fn clear_active(&mut self) {
        self.active = ::std::option::Option::None;
    }

    pub fn has_active(&self) -> bool {
        self.active.is_some()
    }

    // Param is passed by value, moved
    pub fn set_active(&mut self, v: bool) {
        self.active = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGC_GameServer_ServerModificationItem {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.modification_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.active = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.modification_type {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.active {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.modification_type {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.active {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGC_GameServer_ServerModificationItem {
        CMsgGC_GameServer_ServerModificationItem::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EServerModificationItemType>>(
                "modification_type",
                |m: &CMsgGC_GameServer_ServerModificationItem| { &m.modification_type },
                |m: &mut CMsgGC_GameServer_ServerModificationItem| { &mut m.modification_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "active",
                |m: &CMsgGC_GameServer_ServerModificationItem| { &m.active },
                |m: &mut CMsgGC_GameServer_ServerModificationItem| { &mut m.active },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGC_GameServer_ServerModificationItem>(
                "CMsgGC_GameServer_ServerModificationItem",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGC_GameServer_ServerModificationItem {
        static instance: ::protobuf::rt::LazyV2<CMsgGC_GameServer_ServerModificationItem> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGC_GameServer_ServerModificationItem::new)
    }
}

impl ::protobuf::Clear for CMsgGC_GameServer_ServerModificationItem {
    fn clear(&mut self) {
        self.modification_type = ::std::option::Option::None;
        self.active = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGC_GameServer_ServerModificationItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGC_GameServer_ServerModificationItem {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGC_Halloween_ReservedItem {
    // message fields
    pub x: ::std::vec::Vec<f32>,
    pub y: ::std::vec::Vec<f32>,
    pub z: ::std::vec::Vec<f32>,
    spawn_meta_info: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGC_Halloween_ReservedItem {
    fn default() -> &'a CMsgGC_Halloween_ReservedItem {
        <CMsgGC_Halloween_ReservedItem as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_Halloween_ReservedItem {
    pub fn new() -> CMsgGC_Halloween_ReservedItem {
        ::std::default::Default::default()
    }

    // repeated float x = 1;


    pub fn get_x(&self) -> &[f32] {
        &self.x
    }
    pub fn clear_x(&mut self) {
        self.x.clear();
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: ::std::vec::Vec<f32>) {
        self.x = v;
    }

    // Mutable pointer to the field.
    pub fn mut_x(&mut self) -> &mut ::std::vec::Vec<f32> {
        &mut self.x
    }

    // Take field
    pub fn take_x(&mut self) -> ::std::vec::Vec<f32> {
        ::std::mem::replace(&mut self.x, ::std::vec::Vec::new())
    }

    // repeated float y = 2;


    pub fn get_y(&self) -> &[f32] {
        &self.y
    }
    pub fn clear_y(&mut self) {
        self.y.clear();
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: ::std::vec::Vec<f32>) {
        self.y = v;
    }

    // Mutable pointer to the field.
    pub fn mut_y(&mut self) -> &mut ::std::vec::Vec<f32> {
        &mut self.y
    }

    // Take field
    pub fn take_y(&mut self) -> ::std::vec::Vec<f32> {
        ::std::mem::replace(&mut self.y, ::std::vec::Vec::new())
    }

    // repeated float z = 3;


    pub fn get_z(&self) -> &[f32] {
        &self.z
    }
    pub fn clear_z(&mut self) {
        self.z.clear();
    }

    // Param is passed by value, moved
    pub fn set_z(&mut self, v: ::std::vec::Vec<f32>) {
        self.z = v;
    }

    // Mutable pointer to the field.
    pub fn mut_z(&mut self) -> &mut ::std::vec::Vec<f32> {
        &mut self.z
    }

    // Take field
    pub fn take_z(&mut self) -> ::std::vec::Vec<f32> {
        ::std::mem::replace(&mut self.z, ::std::vec::Vec::new())
    }

    // optional uint32 spawn_meta_info = 7;


    pub fn get_spawn_meta_info(&self) -> u32 {
        self.spawn_meta_info.unwrap_or(0)
    }
    pub fn clear_spawn_meta_info(&mut self) {
        self.spawn_meta_info = ::std::option::Option::None;
    }

    pub fn has_spawn_meta_info(&self) -> bool {
        self.spawn_meta_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spawn_meta_info(&mut self, v: u32) {
        self.spawn_meta_info = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGC_Halloween_ReservedItem {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_float_into(wire_type, is, &mut self.x)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_float_into(wire_type, is, &mut self.y)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_float_into(wire_type, is, &mut self.z)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.spawn_meta_info = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += 5 * self.x.len() as u32;
        my_size += 5 * self.y.len() as u32;
        my_size += 5 * self.z.len() as u32;
        if let Some(v) = self.spawn_meta_info {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.x {
            os.write_float(1, *v)?;
        };
        for v in &self.y {
            os.write_float(2, *v)?;
        };
        for v in &self.z {
            os.write_float(3, *v)?;
        };
        if let Some(v) = self.spawn_meta_info {
            os.write_uint32(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGC_Halloween_ReservedItem {
        CMsgGC_Halloween_ReservedItem::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "x",
                |m: &CMsgGC_Halloween_ReservedItem| { &m.x },
                |m: &mut CMsgGC_Halloween_ReservedItem| { &mut m.x },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "y",
                |m: &CMsgGC_Halloween_ReservedItem| { &m.y },
                |m: &mut CMsgGC_Halloween_ReservedItem| { &mut m.y },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "z",
                |m: &CMsgGC_Halloween_ReservedItem| { &m.z },
                |m: &mut CMsgGC_Halloween_ReservedItem| { &mut m.z },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "spawn_meta_info",
                |m: &CMsgGC_Halloween_ReservedItem| { &m.spawn_meta_info },
                |m: &mut CMsgGC_Halloween_ReservedItem| { &mut m.spawn_meta_info },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGC_Halloween_ReservedItem>(
                "CMsgGC_Halloween_ReservedItem",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGC_Halloween_ReservedItem {
        static instance: ::protobuf::rt::LazyV2<CMsgGC_Halloween_ReservedItem> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGC_Halloween_ReservedItem::new)
    }
}

impl ::protobuf::Clear for CMsgGC_Halloween_ReservedItem {
    fn clear(&mut self) {
        self.x.clear();
        self.y.clear();
        self.z.clear();
        self.spawn_meta_info = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGC_Halloween_ReservedItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGC_Halloween_ReservedItem {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGC_Halloween_GrantItem {
    // message fields
    recipient_account_id: ::std::option::Option<u32>,
    level_id: ::std::option::Option<u32>,
    flagged: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGC_Halloween_GrantItem {
    fn default() -> &'a CMsgGC_Halloween_GrantItem {
        <CMsgGC_Halloween_GrantItem as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_Halloween_GrantItem {
    pub fn new() -> CMsgGC_Halloween_GrantItem {
        ::std::default::Default::default()
    }

    // optional uint32 recipient_account_id = 1;


    pub fn get_recipient_account_id(&self) -> u32 {
        self.recipient_account_id.unwrap_or(0)
    }
    pub fn clear_recipient_account_id(&mut self) {
        self.recipient_account_id = ::std::option::Option::None;
    }

    pub fn has_recipient_account_id(&self) -> bool {
        self.recipient_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recipient_account_id(&mut self, v: u32) {
        self.recipient_account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 level_id = 2;


    pub fn get_level_id(&self) -> u32 {
        self.level_id.unwrap_or(0)
    }
    pub fn clear_level_id(&mut self) {
        self.level_id = ::std::option::Option::None;
    }

    pub fn has_level_id(&self) -> bool {
        self.level_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_level_id(&mut self, v: u32) {
        self.level_id = ::std::option::Option::Some(v);
    }

    // optional bool flagged = 3;


    pub fn get_flagged(&self) -> bool {
        self.flagged.unwrap_or(false)
    }
    pub fn clear_flagged(&mut self) {
        self.flagged = ::std::option::Option::None;
    }

    pub fn has_flagged(&self) -> bool {
        self.flagged.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flagged(&mut self, v: bool) {
        self.flagged = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGC_Halloween_GrantItem {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.recipient_account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.level_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.flagged = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.recipient_account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.level_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.flagged {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.recipient_account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.level_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.flagged {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGC_Halloween_GrantItem {
        CMsgGC_Halloween_GrantItem::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "recipient_account_id",
                |m: &CMsgGC_Halloween_GrantItem| { &m.recipient_account_id },
                |m: &mut CMsgGC_Halloween_GrantItem| { &mut m.recipient_account_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "level_id",
                |m: &CMsgGC_Halloween_GrantItem| { &m.level_id },
                |m: &mut CMsgGC_Halloween_GrantItem| { &mut m.level_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "flagged",
                |m: &CMsgGC_Halloween_GrantItem| { &m.flagged },
                |m: &mut CMsgGC_Halloween_GrantItem| { &mut m.flagged },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGC_Halloween_GrantItem>(
                "CMsgGC_Halloween_GrantItem",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGC_Halloween_GrantItem {
        static instance: ::protobuf::rt::LazyV2<CMsgGC_Halloween_GrantItem> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGC_Halloween_GrantItem::new)
    }
}

impl ::protobuf::Clear for CMsgGC_Halloween_GrantItem {
    fn clear(&mut self) {
        self.recipient_account_id = ::std::option::Option::None;
        self.level_id = ::std::option::Option::None;
        self.flagged = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGC_Halloween_GrantItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGC_Halloween_GrantItem {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGC_Halloween_GrantItemResponse {
    // message fields
    recipient_account_id: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGC_Halloween_GrantItemResponse {
    fn default() -> &'a CMsgGC_Halloween_GrantItemResponse {
        <CMsgGC_Halloween_GrantItemResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_Halloween_GrantItemResponse {
    pub fn new() -> CMsgGC_Halloween_GrantItemResponse {
        ::std::default::Default::default()
    }

    // optional uint32 recipient_account_id = 1;


    pub fn get_recipient_account_id(&self) -> u32 {
        self.recipient_account_id.unwrap_or(0)
    }
    pub fn clear_recipient_account_id(&mut self) {
        self.recipient_account_id = ::std::option::Option::None;
    }

    pub fn has_recipient_account_id(&self) -> bool {
        self.recipient_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recipient_account_id(&mut self, v: u32) {
        self.recipient_account_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGC_Halloween_GrantItemResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.recipient_account_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.recipient_account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.recipient_account_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGC_Halloween_GrantItemResponse {
        CMsgGC_Halloween_GrantItemResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "recipient_account_id",
                |m: &CMsgGC_Halloween_GrantItemResponse| { &m.recipient_account_id },
                |m: &mut CMsgGC_Halloween_GrantItemResponse| { &mut m.recipient_account_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGC_Halloween_GrantItemResponse>(
                "CMsgGC_Halloween_GrantItemResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGC_Halloween_GrantItemResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgGC_Halloween_GrantItemResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGC_Halloween_GrantItemResponse::new)
    }
}

impl ::protobuf::Clear for CMsgGC_Halloween_GrantItemResponse {
    fn clear(&mut self) {
        self.recipient_account_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGC_Halloween_GrantItemResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGC_Halloween_GrantItemResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGC_Halloween_ItemClaimed {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGC_Halloween_ItemClaimed {
    fn default() -> &'a CMsgGC_Halloween_ItemClaimed {
        <CMsgGC_Halloween_ItemClaimed as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_Halloween_ItemClaimed {
    pub fn new() -> CMsgGC_Halloween_ItemClaimed {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgGC_Halloween_ItemClaimed {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGC_Halloween_ItemClaimed {
        CMsgGC_Halloween_ItemClaimed::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGC_Halloween_ItemClaimed>(
                "CMsgGC_Halloween_ItemClaimed",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGC_Halloween_ItemClaimed {
        static instance: ::protobuf::rt::LazyV2<CMsgGC_Halloween_ItemClaimed> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGC_Halloween_ItemClaimed::new)
    }
}

impl ::protobuf::Clear for CMsgGC_Halloween_ItemClaimed {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGC_Halloween_ItemClaimed {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGC_Halloween_ItemClaimed {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGC_PickupItemEligibility_Query {
    // message fields
    account_id: ::std::option::Option<u32>,
    seconds_ago: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGC_PickupItemEligibility_Query {
    fn default() -> &'a CMsgGC_PickupItemEligibility_Query {
        <CMsgGC_PickupItemEligibility_Query as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_PickupItemEligibility_Query {
    pub fn new() -> CMsgGC_PickupItemEligibility_Query {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;


    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }
    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 seconds_ago = 2;


    pub fn get_seconds_ago(&self) -> u32 {
        self.seconds_ago.unwrap_or(0)
    }
    pub fn clear_seconds_ago(&mut self) {
        self.seconds_ago = ::std::option::Option::None;
    }

    pub fn has_seconds_ago(&self) -> bool {
        self.seconds_ago.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds_ago(&mut self, v: u32) {
        self.seconds_ago = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGC_PickupItemEligibility_Query {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.seconds_ago = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.seconds_ago {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.seconds_ago {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGC_PickupItemEligibility_Query {
        CMsgGC_PickupItemEligibility_Query::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "account_id",
                |m: &CMsgGC_PickupItemEligibility_Query| { &m.account_id },
                |m: &mut CMsgGC_PickupItemEligibility_Query| { &mut m.account_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "seconds_ago",
                |m: &CMsgGC_PickupItemEligibility_Query| { &m.seconds_ago },
                |m: &mut CMsgGC_PickupItemEligibility_Query| { &mut m.seconds_ago },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGC_PickupItemEligibility_Query>(
                "CMsgGC_PickupItemEligibility_Query",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGC_PickupItemEligibility_Query {
        static instance: ::protobuf::rt::LazyV2<CMsgGC_PickupItemEligibility_Query> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGC_PickupItemEligibility_Query::new)
    }
}

impl ::protobuf::Clear for CMsgGC_PickupItemEligibility_Query {
    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.seconds_ago = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGC_PickupItemEligibility_Query {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGC_PickupItemEligibility_Query {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGC_PickupItemEligibility_QueryResponse {
    // message fields
    account_id: ::std::option::Option<u32>,
    was_eligible: ::std::option::Option<bool>,
    level_id: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGC_PickupItemEligibility_QueryResponse {
    fn default() -> &'a CMsgGC_PickupItemEligibility_QueryResponse {
        <CMsgGC_PickupItemEligibility_QueryResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_PickupItemEligibility_QueryResponse {
    pub fn new() -> CMsgGC_PickupItemEligibility_QueryResponse {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;


    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }
    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional bool was_eligible = 2;


    pub fn get_was_eligible(&self) -> bool {
        self.was_eligible.unwrap_or(false)
    }
    pub fn clear_was_eligible(&mut self) {
        self.was_eligible = ::std::option::Option::None;
    }

    pub fn has_was_eligible(&self) -> bool {
        self.was_eligible.is_some()
    }

    // Param is passed by value, moved
    pub fn set_was_eligible(&mut self, v: bool) {
        self.was_eligible = ::std::option::Option::Some(v);
    }

    // optional uint32 level_id = 3;


    pub fn get_level_id(&self) -> u32 {
        self.level_id.unwrap_or(0)
    }
    pub fn clear_level_id(&mut self) {
        self.level_id = ::std::option::Option::None;
    }

    pub fn has_level_id(&self) -> bool {
        self.level_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_level_id(&mut self, v: u32) {
        self.level_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGC_PickupItemEligibility_QueryResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.was_eligible = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.level_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.was_eligible {
            my_size += 2;
        }
        if let Some(v) = self.level_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.was_eligible {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.level_id {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGC_PickupItemEligibility_QueryResponse {
        CMsgGC_PickupItemEligibility_QueryResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "account_id",
                |m: &CMsgGC_PickupItemEligibility_QueryResponse| { &m.account_id },
                |m: &mut CMsgGC_PickupItemEligibility_QueryResponse| { &mut m.account_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "was_eligible",
                |m: &CMsgGC_PickupItemEligibility_QueryResponse| { &m.was_eligible },
                |m: &mut CMsgGC_PickupItemEligibility_QueryResponse| { &mut m.was_eligible },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "level_id",
                |m: &CMsgGC_PickupItemEligibility_QueryResponse| { &m.level_id },
                |m: &mut CMsgGC_PickupItemEligibility_QueryResponse| { &mut m.level_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGC_PickupItemEligibility_QueryResponse>(
                "CMsgGC_PickupItemEligibility_QueryResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGC_PickupItemEligibility_QueryResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgGC_PickupItemEligibility_QueryResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGC_PickupItemEligibility_QueryResponse::new)
    }
}

impl ::protobuf::Clear for CMsgGC_PickupItemEligibility_QueryResponse {
    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.was_eligible = ::std::option::Option::None;
        self.level_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGC_PickupItemEligibility_QueryResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGC_PickupItemEligibility_QueryResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CSOTFPartyMember {
    // message fields
    owns_ticket: ::std::option::Option<bool>,
    completed_missions: ::std::option::Option<u32>,
    badge_level: ::std::option::Option<u32>,
    competitive_access: ::std::option::Option<bool>,
    experience: ::std::option::Option<u32>,
    pub player_criteria: ::protobuf::SingularPtrField<CTFPerPlayerMatchCriteriaProto>,
    pub activity: ::protobuf::SingularPtrField<CSOTFPartyMember_Activity>,
    casual_banned: ::std::option::Option<bool>,
    ranked_banned: ::std::option::Option<bool>,
    casual_low_priority: ::std::option::Option<bool>,
    ranked_low_priority: ::std::option::Option<bool>,
    lobby_standby: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CSOTFPartyMember {
    fn default() -> &'a CSOTFPartyMember {
        <CSOTFPartyMember as ::protobuf::Message>::default_instance()
    }
}

impl CSOTFPartyMember {
    pub fn new() -> CSOTFPartyMember {
        ::std::default::Default::default()
    }

    // optional bool owns_ticket = 2;


    pub fn get_owns_ticket(&self) -> bool {
        self.owns_ticket.unwrap_or(false)
    }
    pub fn clear_owns_ticket(&mut self) {
        self.owns_ticket = ::std::option::Option::None;
    }

    pub fn has_owns_ticket(&self) -> bool {
        self.owns_ticket.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owns_ticket(&mut self, v: bool) {
        self.owns_ticket = ::std::option::Option::Some(v);
    }

    // optional uint32 completed_missions = 3;


    pub fn get_completed_missions(&self) -> u32 {
        self.completed_missions.unwrap_or(0)
    }
    pub fn clear_completed_missions(&mut self) {
        self.completed_missions = ::std::option::Option::None;
    }

    pub fn has_completed_missions(&self) -> bool {
        self.completed_missions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_completed_missions(&mut self, v: u32) {
        self.completed_missions = ::std::option::Option::Some(v);
    }

    // optional uint32 badge_level = 4;


    pub fn get_badge_level(&self) -> u32 {
        self.badge_level.unwrap_or(0)
    }
    pub fn clear_badge_level(&mut self) {
        self.badge_level = ::std::option::Option::None;
    }

    pub fn has_badge_level(&self) -> bool {
        self.badge_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_badge_level(&mut self, v: u32) {
        self.badge_level = ::std::option::Option::Some(v);
    }

    // optional bool competitive_access = 9;


    pub fn get_competitive_access(&self) -> bool {
        self.competitive_access.unwrap_or(false)
    }
    pub fn clear_competitive_access(&mut self) {
        self.competitive_access = ::std::option::Option::None;
    }

    pub fn has_competitive_access(&self) -> bool {
        self.competitive_access.is_some()
    }

    // Param is passed by value, moved
    pub fn set_competitive_access(&mut self, v: bool) {
        self.competitive_access = ::std::option::Option::Some(v);
    }

    // optional uint32 experience = 14;


    pub fn get_experience(&self) -> u32 {
        self.experience.unwrap_or(0)
    }
    pub fn clear_experience(&mut self) {
        self.experience = ::std::option::Option::None;
    }

    pub fn has_experience(&self) -> bool {
        self.experience.is_some()
    }

    // Param is passed by value, moved
    pub fn set_experience(&mut self, v: u32) {
        self.experience = ::std::option::Option::Some(v);
    }

    // optional .CTFPerPlayerMatchCriteriaProto player_criteria = 16;


    pub fn get_player_criteria(&self) -> &CTFPerPlayerMatchCriteriaProto {
        self.player_criteria.as_ref().unwrap_or_else(|| <CTFPerPlayerMatchCriteriaProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_player_criteria(&mut self) {
        self.player_criteria.clear();
    }

    pub fn has_player_criteria(&self) -> bool {
        self.player_criteria.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_criteria(&mut self, v: CTFPerPlayerMatchCriteriaProto) {
        self.player_criteria = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_player_criteria(&mut self) -> &mut CTFPerPlayerMatchCriteriaProto {
        if self.player_criteria.is_none() {
            self.player_criteria.set_default();
        }
        self.player_criteria.as_mut().unwrap()
    }

    // Take field
    pub fn take_player_criteria(&mut self) -> CTFPerPlayerMatchCriteriaProto {
        self.player_criteria.take().unwrap_or_else(|| CTFPerPlayerMatchCriteriaProto::new())
    }

    // optional .CSOTFPartyMember.Activity activity = 17;


    pub fn get_activity(&self) -> &CSOTFPartyMember_Activity {
        self.activity.as_ref().unwrap_or_else(|| <CSOTFPartyMember_Activity as ::protobuf::Message>::default_instance())
    }
    pub fn clear_activity(&mut self) {
        self.activity.clear();
    }

    pub fn has_activity(&self) -> bool {
        self.activity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_activity(&mut self, v: CSOTFPartyMember_Activity) {
        self.activity = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_activity(&mut self) -> &mut CSOTFPartyMember_Activity {
        if self.activity.is_none() {
            self.activity.set_default();
        }
        self.activity.as_mut().unwrap()
    }

    // Take field
    pub fn take_activity(&mut self) -> CSOTFPartyMember_Activity {
        self.activity.take().unwrap_or_else(|| CSOTFPartyMember_Activity::new())
    }

    // optional bool casual_banned = 18;


    pub fn get_casual_banned(&self) -> bool {
        self.casual_banned.unwrap_or(false)
    }
    pub fn clear_casual_banned(&mut self) {
        self.casual_banned = ::std::option::Option::None;
    }

    pub fn has_casual_banned(&self) -> bool {
        self.casual_banned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_casual_banned(&mut self, v: bool) {
        self.casual_banned = ::std::option::Option::Some(v);
    }

    // optional bool ranked_banned = 19;


    pub fn get_ranked_banned(&self) -> bool {
        self.ranked_banned.unwrap_or(false)
    }
    pub fn clear_ranked_banned(&mut self) {
        self.ranked_banned = ::std::option::Option::None;
    }

    pub fn has_ranked_banned(&self) -> bool {
        self.ranked_banned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ranked_banned(&mut self, v: bool) {
        self.ranked_banned = ::std::option::Option::Some(v);
    }

    // optional bool casual_low_priority = 20;


    pub fn get_casual_low_priority(&self) -> bool {
        self.casual_low_priority.unwrap_or(false)
    }
    pub fn clear_casual_low_priority(&mut self) {
        self.casual_low_priority = ::std::option::Option::None;
    }

    pub fn has_casual_low_priority(&self) -> bool {
        self.casual_low_priority.is_some()
    }

    // Param is passed by value, moved
    pub fn set_casual_low_priority(&mut self, v: bool) {
        self.casual_low_priority = ::std::option::Option::Some(v);
    }

    // optional bool ranked_low_priority = 21;


    pub fn get_ranked_low_priority(&self) -> bool {
        self.ranked_low_priority.unwrap_or(false)
    }
    pub fn clear_ranked_low_priority(&mut self) {
        self.ranked_low_priority = ::std::option::Option::None;
    }

    pub fn has_ranked_low_priority(&self) -> bool {
        self.ranked_low_priority.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ranked_low_priority(&mut self, v: bool) {
        self.ranked_low_priority = ::std::option::Option::Some(v);
    }

    // optional bool lobby_standby = 22;


    pub fn get_lobby_standby(&self) -> bool {
        self.lobby_standby.unwrap_or(false)
    }
    pub fn clear_lobby_standby(&mut self) {
        self.lobby_standby = ::std::option::Option::None;
    }

    pub fn has_lobby_standby(&self) -> bool {
        self.lobby_standby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_standby(&mut self, v: bool) {
        self.lobby_standby = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CSOTFPartyMember {
    fn is_initialized(&self) -> bool {
        for v in &self.player_criteria {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.activity {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.owns_ticket = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.completed_missions = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.badge_level = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.competitive_access = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.experience = ::std::option::Option::Some(tmp);
                },
                16 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.player_criteria)?;
                },
                17 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.activity)?;
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.casual_banned = ::std::option::Option::Some(tmp);
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.ranked_banned = ::std::option::Option::Some(tmp);
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.casual_low_priority = ::std::option::Option::Some(tmp);
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.ranked_low_priority = ::std::option::Option::Some(tmp);
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.lobby_standby = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.owns_ticket {
            my_size += 2;
        }
        if let Some(v) = self.completed_missions {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.badge_level {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.competitive_access {
            my_size += 2;
        }
        if let Some(v) = self.experience {
            my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.player_criteria.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.activity.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.casual_banned {
            my_size += 3;
        }
        if let Some(v) = self.ranked_banned {
            my_size += 3;
        }
        if let Some(v) = self.casual_low_priority {
            my_size += 3;
        }
        if let Some(v) = self.ranked_low_priority {
            my_size += 3;
        }
        if let Some(v) = self.lobby_standby {
            my_size += 3;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.owns_ticket {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.completed_missions {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.badge_level {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.competitive_access {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.experience {
            os.write_uint32(14, v)?;
        }
        if let Some(ref v) = self.player_criteria.as_ref() {
            os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.activity.as_ref() {
            os.write_tag(17, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.casual_banned {
            os.write_bool(18, v)?;
        }
        if let Some(v) = self.ranked_banned {
            os.write_bool(19, v)?;
        }
        if let Some(v) = self.casual_low_priority {
            os.write_bool(20, v)?;
        }
        if let Some(v) = self.ranked_low_priority {
            os.write_bool(21, v)?;
        }
        if let Some(v) = self.lobby_standby {
            os.write_bool(22, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CSOTFPartyMember {
        CSOTFPartyMember::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "owns_ticket",
                |m: &CSOTFPartyMember| { &m.owns_ticket },
                |m: &mut CSOTFPartyMember| { &mut m.owns_ticket },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "completed_missions",
                |m: &CSOTFPartyMember| { &m.completed_missions },
                |m: &mut CSOTFPartyMember| { &mut m.completed_missions },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "badge_level",
                |m: &CSOTFPartyMember| { &m.badge_level },
                |m: &mut CSOTFPartyMember| { &mut m.badge_level },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "competitive_access",
                |m: &CSOTFPartyMember| { &m.competitive_access },
                |m: &mut CSOTFPartyMember| { &mut m.competitive_access },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "experience",
                |m: &CSOTFPartyMember| { &m.experience },
                |m: &mut CSOTFPartyMember| { &mut m.experience },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CTFPerPlayerMatchCriteriaProto>>(
                "player_criteria",
                |m: &CSOTFPartyMember| { &m.player_criteria },
                |m: &mut CSOTFPartyMember| { &mut m.player_criteria },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CSOTFPartyMember_Activity>>(
                "activity",
                |m: &CSOTFPartyMember| { &m.activity },
                |m: &mut CSOTFPartyMember| { &mut m.activity },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "casual_banned",
                |m: &CSOTFPartyMember| { &m.casual_banned },
                |m: &mut CSOTFPartyMember| { &mut m.casual_banned },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "ranked_banned",
                |m: &CSOTFPartyMember| { &m.ranked_banned },
                |m: &mut CSOTFPartyMember| { &mut m.ranked_banned },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "casual_low_priority",
                |m: &CSOTFPartyMember| { &m.casual_low_priority },
                |m: &mut CSOTFPartyMember| { &mut m.casual_low_priority },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "ranked_low_priority",
                |m: &CSOTFPartyMember| { &m.ranked_low_priority },
                |m: &mut CSOTFPartyMember| { &mut m.ranked_low_priority },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "lobby_standby",
                |m: &CSOTFPartyMember| { &m.lobby_standby },
                |m: &mut CSOTFPartyMember| { &mut m.lobby_standby },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CSOTFPartyMember>(
                "CSOTFPartyMember",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CSOTFPartyMember {
        static instance: ::protobuf::rt::LazyV2<CSOTFPartyMember> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CSOTFPartyMember::new)
    }
}

impl ::protobuf::Clear for CSOTFPartyMember {
    fn clear(&mut self) {
        self.owns_ticket = ::std::option::Option::None;
        self.completed_missions = ::std::option::Option::None;
        self.badge_level = ::std::option::Option::None;
        self.competitive_access = ::std::option::Option::None;
        self.experience = ::std::option::Option::None;
        self.player_criteria.clear();
        self.activity.clear();
        self.casual_banned = ::std::option::Option::None;
        self.ranked_banned = ::std::option::Option::None;
        self.casual_low_priority = ::std::option::Option::None;
        self.ranked_low_priority = ::std::option::Option::None;
        self.lobby_standby = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSOTFPartyMember {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOTFPartyMember {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CSOTFPartyMember_Activity {
    // message fields
    lobby_id: ::std::option::Option<u64>,
    lobby_match_group: ::std::option::Option<ETFMatchGroup>,
    multiqueue_blocked: ::std::option::Option<bool>,
    online: ::std::option::Option<bool>,
    client_version: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CSOTFPartyMember_Activity {
    fn default() -> &'a CSOTFPartyMember_Activity {
        <CSOTFPartyMember_Activity as ::protobuf::Message>::default_instance()
    }
}

impl CSOTFPartyMember_Activity {
    pub fn new() -> CSOTFPartyMember_Activity {
        ::std::default::Default::default()
    }

    // optional fixed64 lobby_id = 1;


    pub fn get_lobby_id(&self) -> u64 {
        self.lobby_id.unwrap_or(0)
    }
    pub fn clear_lobby_id(&mut self) {
        self.lobby_id = ::std::option::Option::None;
    }

    pub fn has_lobby_id(&self) -> bool {
        self.lobby_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_id(&mut self, v: u64) {
        self.lobby_id = ::std::option::Option::Some(v);
    }

    // optional .ETFMatchGroup lobby_match_group = 2;


    pub fn get_lobby_match_group(&self) -> ETFMatchGroup {
        self.lobby_match_group.unwrap_or(ETFMatchGroup::k_eTFMatchGroup_Invalid)
    }
    pub fn clear_lobby_match_group(&mut self) {
        self.lobby_match_group = ::std::option::Option::None;
    }

    pub fn has_lobby_match_group(&self) -> bool {
        self.lobby_match_group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_match_group(&mut self, v: ETFMatchGroup) {
        self.lobby_match_group = ::std::option::Option::Some(v);
    }

    // optional bool multiqueue_blocked = 3;


    pub fn get_multiqueue_blocked(&self) -> bool {
        self.multiqueue_blocked.unwrap_or(false)
    }
    pub fn clear_multiqueue_blocked(&mut self) {
        self.multiqueue_blocked = ::std::option::Option::None;
    }

    pub fn has_multiqueue_blocked(&self) -> bool {
        self.multiqueue_blocked.is_some()
    }

    // Param is passed by value, moved
    pub fn set_multiqueue_blocked(&mut self, v: bool) {
        self.multiqueue_blocked = ::std::option::Option::Some(v);
    }

    // optional bool online = 4;


    pub fn get_online(&self) -> bool {
        self.online.unwrap_or(false)
    }
    pub fn clear_online(&mut self) {
        self.online = ::std::option::Option::None;
    }

    pub fn has_online(&self) -> bool {
        self.online.is_some()
    }

    // Param is passed by value, moved
    pub fn set_online(&mut self, v: bool) {
        self.online = ::std::option::Option::Some(v);
    }

    // optional uint32 client_version = 5;


    pub fn get_client_version(&self) -> u32 {
        self.client_version.unwrap_or(0)
    }
    pub fn clear_client_version(&mut self) {
        self.client_version = ::std::option::Option::None;
    }

    pub fn has_client_version(&self) -> bool {
        self.client_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_version(&mut self, v: u32) {
        self.client_version = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CSOTFPartyMember_Activity {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.lobby_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.lobby_match_group, 2, &mut self.unknown_fields)?
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.multiqueue_blocked = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.online = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.client_version = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.lobby_id {
            my_size += 9;
        }
        if let Some(v) = self.lobby_match_group {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        if let Some(v) = self.multiqueue_blocked {
            my_size += 2;
        }
        if let Some(v) = self.online {
            my_size += 2;
        }
        if let Some(v) = self.client_version {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.lobby_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.lobby_match_group {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.multiqueue_blocked {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.online {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.client_version {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CSOTFPartyMember_Activity {
        CSOTFPartyMember_Activity::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "lobby_id",
                |m: &CSOTFPartyMember_Activity| { &m.lobby_id },
                |m: &mut CSOTFPartyMember_Activity| { &mut m.lobby_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ETFMatchGroup>>(
                "lobby_match_group",
                |m: &CSOTFPartyMember_Activity| { &m.lobby_match_group },
                |m: &mut CSOTFPartyMember_Activity| { &mut m.lobby_match_group },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "multiqueue_blocked",
                |m: &CSOTFPartyMember_Activity| { &m.multiqueue_blocked },
                |m: &mut CSOTFPartyMember_Activity| { &mut m.multiqueue_blocked },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "online",
                |m: &CSOTFPartyMember_Activity| { &m.online },
                |m: &mut CSOTFPartyMember_Activity| { &mut m.online },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "client_version",
                |m: &CSOTFPartyMember_Activity| { &m.client_version },
                |m: &mut CSOTFPartyMember_Activity| { &mut m.client_version },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CSOTFPartyMember_Activity>(
                "CSOTFPartyMember.Activity",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CSOTFPartyMember_Activity {
        static instance: ::protobuf::rt::LazyV2<CSOTFPartyMember_Activity> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CSOTFPartyMember_Activity::new)
    }
}

impl ::protobuf::Clear for CSOTFPartyMember_Activity {
    fn clear(&mut self) {
        self.lobby_id = ::std::option::Option::None;
        self.lobby_match_group = ::std::option::Option::None;
        self.multiqueue_blocked = ::std::option::Option::None;
        self.online = ::std::option::Option::None;
        self.client_version = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSOTFPartyMember_Activity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOTFPartyMember_Activity {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TFPendingPartyMember {
    // message fields
    steamid: ::std::option::Option<u64>,
    field_type: ::std::option::Option<TFPendingPartyMember_EType>,
    inviter: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TFPendingPartyMember {
    fn default() -> &'a TFPendingPartyMember {
        <TFPendingPartyMember as ::protobuf::Message>::default_instance()
    }
}

impl TFPendingPartyMember {
    pub fn new() -> TFPendingPartyMember {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;


    pub fn get_steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }
    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional .TFPendingPartyMember.EType type = 2;


    pub fn get_field_type(&self) -> TFPendingPartyMember_EType {
        self.field_type.unwrap_or(TFPendingPartyMember_EType::Invited)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: TFPendingPartyMember_EType) {
        self.field_type = ::std::option::Option::Some(v);
    }

    // optional fixed64 inviter = 3;


    pub fn get_inviter(&self) -> u64 {
        self.inviter.unwrap_or(0)
    }
    pub fn clear_inviter(&mut self) {
        self.inviter = ::std::option::Option::None;
    }

    pub fn has_inviter(&self) -> bool {
        self.inviter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inviter(&mut self, v: u64) {
        self.inviter = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for TFPendingPartyMember {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 2, &mut self.unknown_fields)?
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.inviter = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 9;
        }
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        if let Some(v) = self.inviter {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.field_type {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.inviter {
            os.write_fixed64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TFPendingPartyMember {
        TFPendingPartyMember::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steamid",
                |m: &TFPendingPartyMember| { &m.steamid },
                |m: &mut TFPendingPartyMember| { &mut m.steamid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TFPendingPartyMember_EType>>(
                "type",
                |m: &TFPendingPartyMember| { &m.field_type },
                |m: &mut TFPendingPartyMember| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "inviter",
                |m: &TFPendingPartyMember| { &m.inviter },
                |m: &mut TFPendingPartyMember| { &mut m.inviter },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TFPendingPartyMember>(
                "TFPendingPartyMember",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TFPendingPartyMember {
        static instance: ::protobuf::rt::LazyV2<TFPendingPartyMember> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TFPendingPartyMember::new)
    }
}

impl ::protobuf::Clear for TFPendingPartyMember {
    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.field_type = ::std::option::Option::None;
        self.inviter = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TFPendingPartyMember {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TFPendingPartyMember {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum TFPendingPartyMember_EType {
    Invited = 0,
    RequestedToJoin = 1,
}

impl ::protobuf::ProtobufEnum for TFPendingPartyMember_EType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TFPendingPartyMember_EType> {
        match value {
            0 => ::std::option::Option::Some(TFPendingPartyMember_EType::Invited),
            1 => ::std::option::Option::Some(TFPendingPartyMember_EType::RequestedToJoin),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [TFPendingPartyMember_EType] = &[
            TFPendingPartyMember_EType::Invited,
            TFPendingPartyMember_EType::RequestedToJoin,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<TFPendingPartyMember_EType>("TFPendingPartyMember.EType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for TFPendingPartyMember_EType {
}

impl ::std::default::Default for TFPendingPartyMember_EType {
    fn default() -> Self {
        TFPendingPartyMember_EType::Invited
    }
}

impl ::protobuf::reflect::ProtobufValue for TFPendingPartyMember_EType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TFSyncedMMUIState {
    // message fields
    menu_step: ::std::option::Option<ETFSyncedMMMenuStep>,
    match_group: ::std::option::Option<ETFMatchGroup>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TFSyncedMMUIState {
    fn default() -> &'a TFSyncedMMUIState {
        <TFSyncedMMUIState as ::protobuf::Message>::default_instance()
    }
}

impl TFSyncedMMUIState {
    pub fn new() -> TFSyncedMMUIState {
        ::std::default::Default::default()
    }

    // optional .ETFSyncedMMMenuStep menu_step = 1;


    pub fn get_menu_step(&self) -> ETFSyncedMMMenuStep {
        self.menu_step.unwrap_or(ETFSyncedMMMenuStep::k_eTFSyncedMMMenuStep_None)
    }
    pub fn clear_menu_step(&mut self) {
        self.menu_step = ::std::option::Option::None;
    }

    pub fn has_menu_step(&self) -> bool {
        self.menu_step.is_some()
    }

    // Param is passed by value, moved
    pub fn set_menu_step(&mut self, v: ETFSyncedMMMenuStep) {
        self.menu_step = ::std::option::Option::Some(v);
    }

    // optional .ETFMatchGroup match_group = 2;


    pub fn get_match_group(&self) -> ETFMatchGroup {
        self.match_group.unwrap_or(ETFMatchGroup::k_eTFMatchGroup_Invalid)
    }
    pub fn clear_match_group(&mut self) {
        self.match_group = ::std::option::Option::None;
    }

    pub fn has_match_group(&self) -> bool {
        self.match_group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_group(&mut self, v: ETFMatchGroup) {
        self.match_group = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for TFSyncedMMUIState {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.menu_step, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.match_group, 2, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.menu_step {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.match_group {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.menu_step {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.match_group {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TFSyncedMMUIState {
        TFSyncedMMUIState::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ETFSyncedMMMenuStep>>(
                "menu_step",
                |m: &TFSyncedMMUIState| { &m.menu_step },
                |m: &mut TFSyncedMMUIState| { &mut m.menu_step },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ETFMatchGroup>>(
                "match_group",
                |m: &TFSyncedMMUIState| { &m.match_group },
                |m: &mut TFSyncedMMUIState| { &mut m.match_group },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TFSyncedMMUIState>(
                "TFSyncedMMUIState",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TFSyncedMMUIState {
        static instance: ::protobuf::rt::LazyV2<TFSyncedMMUIState> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TFSyncedMMUIState::new)
    }
}

impl ::protobuf::Clear for TFSyncedMMUIState {
    fn clear(&mut self) {
        self.menu_step = ::std::option::Option::None;
        self.match_group = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TFSyncedMMUIState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TFSyncedMMUIState {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CTFGroupMatchCriteriaProto {
    // message fields
    late_join_ok: ::std::option::Option<bool>,
    custom_ping_tolerance: ::std::option::Option<u32>,
    mvm_mannup_tour: ::protobuf::SingularField<::std::string::String>,
    pub mvm_mannup_missions: ::protobuf::RepeatedField<::std::string::String>,
    pub mvm_bootcamp_missions: ::protobuf::RepeatedField<::std::string::String>,
    pub casual_criteria: ::protobuf::SingularPtrField<CTFCasualMatchCriteria>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CTFGroupMatchCriteriaProto {
    fn default() -> &'a CTFGroupMatchCriteriaProto {
        <CTFGroupMatchCriteriaProto as ::protobuf::Message>::default_instance()
    }
}

impl CTFGroupMatchCriteriaProto {
    pub fn new() -> CTFGroupMatchCriteriaProto {
        ::std::default::Default::default()
    }

    // optional bool late_join_ok = 5;


    pub fn get_late_join_ok(&self) -> bool {
        self.late_join_ok.unwrap_or(false)
    }
    pub fn clear_late_join_ok(&mut self) {
        self.late_join_ok = ::std::option::Option::None;
    }

    pub fn has_late_join_ok(&self) -> bool {
        self.late_join_ok.is_some()
    }

    // Param is passed by value, moved
    pub fn set_late_join_ok(&mut self, v: bool) {
        self.late_join_ok = ::std::option::Option::Some(v);
    }

    // optional uint32 custom_ping_tolerance = 13;


    pub fn get_custom_ping_tolerance(&self) -> u32 {
        self.custom_ping_tolerance.unwrap_or(0u32)
    }
    pub fn clear_custom_ping_tolerance(&mut self) {
        self.custom_ping_tolerance = ::std::option::Option::None;
    }

    pub fn has_custom_ping_tolerance(&self) -> bool {
        self.custom_ping_tolerance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_ping_tolerance(&mut self, v: u32) {
        self.custom_ping_tolerance = ::std::option::Option::Some(v);
    }

    // optional string mvm_mannup_tour = 10;


    pub fn get_mvm_mannup_tour(&self) -> &str {
        match self.mvm_mannup_tour.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_mvm_mannup_tour(&mut self) {
        self.mvm_mannup_tour.clear();
    }

    pub fn has_mvm_mannup_tour(&self) -> bool {
        self.mvm_mannup_tour.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mvm_mannup_tour(&mut self, v: ::std::string::String) {
        self.mvm_mannup_tour = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mvm_mannup_tour(&mut self) -> &mut ::std::string::String {
        if self.mvm_mannup_tour.is_none() {
            self.mvm_mannup_tour.set_default();
        }
        self.mvm_mannup_tour.as_mut().unwrap()
    }

    // Take field
    pub fn take_mvm_mannup_tour(&mut self) -> ::std::string::String {
        self.mvm_mannup_tour.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated string mvm_mannup_missions = 15;


    pub fn get_mvm_mannup_missions(&self) -> &[::std::string::String] {
        &self.mvm_mannup_missions
    }
    pub fn clear_mvm_mannup_missions(&mut self) {
        self.mvm_mannup_missions.clear();
    }

    // Param is passed by value, moved
    pub fn set_mvm_mannup_missions(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.mvm_mannup_missions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_mvm_mannup_missions(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.mvm_mannup_missions
    }

    // Take field
    pub fn take_mvm_mannup_missions(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.mvm_mannup_missions, ::protobuf::RepeatedField::new())
    }

    // repeated string mvm_bootcamp_missions = 16;


    pub fn get_mvm_bootcamp_missions(&self) -> &[::std::string::String] {
        &self.mvm_bootcamp_missions
    }
    pub fn clear_mvm_bootcamp_missions(&mut self) {
        self.mvm_bootcamp_missions.clear();
    }

    // Param is passed by value, moved
    pub fn set_mvm_bootcamp_missions(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.mvm_bootcamp_missions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_mvm_bootcamp_missions(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.mvm_bootcamp_missions
    }

    // Take field
    pub fn take_mvm_bootcamp_missions(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.mvm_bootcamp_missions, ::protobuf::RepeatedField::new())
    }

    // optional .CTFCasualMatchCriteria casual_criteria = 12;


    pub fn get_casual_criteria(&self) -> &CTFCasualMatchCriteria {
        self.casual_criteria.as_ref().unwrap_or_else(|| <CTFCasualMatchCriteria as ::protobuf::Message>::default_instance())
    }
    pub fn clear_casual_criteria(&mut self) {
        self.casual_criteria.clear();
    }

    pub fn has_casual_criteria(&self) -> bool {
        self.casual_criteria.is_some()
    }

    // Param is passed by value, moved
    pub fn set_casual_criteria(&mut self, v: CTFCasualMatchCriteria) {
        self.casual_criteria = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_casual_criteria(&mut self) -> &mut CTFCasualMatchCriteria {
        if self.casual_criteria.is_none() {
            self.casual_criteria.set_default();
        }
        self.casual_criteria.as_mut().unwrap()
    }

    // Take field
    pub fn take_casual_criteria(&mut self) -> CTFCasualMatchCriteria {
        self.casual_criteria.take().unwrap_or_else(|| CTFCasualMatchCriteria::new())
    }
}

impl ::protobuf::Message for CTFGroupMatchCriteriaProto {
    fn is_initialized(&self) -> bool {
        for v in &self.casual_criteria {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.late_join_ok = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.custom_ping_tolerance = ::std::option::Option::Some(tmp);
                },
                10 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.mvm_mannup_tour)?;
                },
                15 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.mvm_mannup_missions)?;
                },
                16 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.mvm_bootcamp_missions)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.casual_criteria)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.late_join_ok {
            my_size += 2;
        }
        if let Some(v) = self.custom_ping_tolerance {
            my_size += ::protobuf::rt::value_size(13, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.mvm_mannup_tour.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        for value in &self.mvm_mannup_missions {
            my_size += ::protobuf::rt::string_size(15, &value);
        };
        for value in &self.mvm_bootcamp_missions {
            my_size += ::protobuf::rt::string_size(16, &value);
        };
        if let Some(ref v) = self.casual_criteria.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.late_join_ok {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.custom_ping_tolerance {
            os.write_uint32(13, v)?;
        }
        if let Some(ref v) = self.mvm_mannup_tour.as_ref() {
            os.write_string(10, &v)?;
        }
        for v in &self.mvm_mannup_missions {
            os.write_string(15, &v)?;
        };
        for v in &self.mvm_bootcamp_missions {
            os.write_string(16, &v)?;
        };
        if let Some(ref v) = self.casual_criteria.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CTFGroupMatchCriteriaProto {
        CTFGroupMatchCriteriaProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "late_join_ok",
                |m: &CTFGroupMatchCriteriaProto| { &m.late_join_ok },
                |m: &mut CTFGroupMatchCriteriaProto| { &mut m.late_join_ok },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "custom_ping_tolerance",
                |m: &CTFGroupMatchCriteriaProto| { &m.custom_ping_tolerance },
                |m: &mut CTFGroupMatchCriteriaProto| { &mut m.custom_ping_tolerance },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "mvm_mannup_tour",
                |m: &CTFGroupMatchCriteriaProto| { &m.mvm_mannup_tour },
                |m: &mut CTFGroupMatchCriteriaProto| { &mut m.mvm_mannup_tour },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "mvm_mannup_missions",
                |m: &CTFGroupMatchCriteriaProto| { &m.mvm_mannup_missions },
                |m: &mut CTFGroupMatchCriteriaProto| { &mut m.mvm_mannup_missions },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "mvm_bootcamp_missions",
                |m: &CTFGroupMatchCriteriaProto| { &m.mvm_bootcamp_missions },
                |m: &mut CTFGroupMatchCriteriaProto| { &mut m.mvm_bootcamp_missions },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CTFCasualMatchCriteria>>(
                "casual_criteria",
                |m: &CTFGroupMatchCriteriaProto| { &m.casual_criteria },
                |m: &mut CTFGroupMatchCriteriaProto| { &mut m.casual_criteria },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CTFGroupMatchCriteriaProto>(
                "CTFGroupMatchCriteriaProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CTFGroupMatchCriteriaProto {
        static instance: ::protobuf::rt::LazyV2<CTFGroupMatchCriteriaProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CTFGroupMatchCriteriaProto::new)
    }
}

impl ::protobuf::Clear for CTFGroupMatchCriteriaProto {
    fn clear(&mut self) {
        self.late_join_ok = ::std::option::Option::None;
        self.custom_ping_tolerance = ::std::option::Option::None;
        self.mvm_mannup_tour.clear();
        self.mvm_mannup_missions.clear();
        self.mvm_bootcamp_missions.clear();
        self.casual_criteria.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CTFGroupMatchCriteriaProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CTFGroupMatchCriteriaProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CTFCasualMatchCriteria {
    // message fields
    pub selected_maps_bits: ::std::vec::Vec<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CTFCasualMatchCriteria {
    fn default() -> &'a CTFCasualMatchCriteria {
        <CTFCasualMatchCriteria as ::protobuf::Message>::default_instance()
    }
}

impl CTFCasualMatchCriteria {
    pub fn new() -> CTFCasualMatchCriteria {
        ::std::default::Default::default()
    }

    // repeated fixed32 selected_maps_bits = 3;


    pub fn get_selected_maps_bits(&self) -> &[u32] {
        &self.selected_maps_bits
    }
    pub fn clear_selected_maps_bits(&mut self) {
        self.selected_maps_bits.clear();
    }

    // Param is passed by value, moved
    pub fn set_selected_maps_bits(&mut self, v: ::std::vec::Vec<u32>) {
        self.selected_maps_bits = v;
    }

    // Mutable pointer to the field.
    pub fn mut_selected_maps_bits(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.selected_maps_bits
    }

    // Take field
    pub fn take_selected_maps_bits(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.selected_maps_bits, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CTFCasualMatchCriteria {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                3 => {
                    ::protobuf::rt::read_repeated_fixed32_into(wire_type, is, &mut self.selected_maps_bits)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += 5 * self.selected_maps_bits.len() as u32;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.selected_maps_bits {
            os.write_fixed32(3, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CTFCasualMatchCriteria {
        CTFCasualMatchCriteria::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "selected_maps_bits",
                |m: &CTFCasualMatchCriteria| { &m.selected_maps_bits },
                |m: &mut CTFCasualMatchCriteria| { &mut m.selected_maps_bits },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CTFCasualMatchCriteria>(
                "CTFCasualMatchCriteria",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CTFCasualMatchCriteria {
        static instance: ::protobuf::rt::LazyV2<CTFCasualMatchCriteria> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CTFCasualMatchCriteria::new)
    }
}

impl ::protobuf::Clear for CTFCasualMatchCriteria {
    fn clear(&mut self) {
        self.selected_maps_bits.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CTFCasualMatchCriteria {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CTFCasualMatchCriteria {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CTFPerPlayerMatchCriteriaProto {
    // message fields
    mvm_squad_surplus: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CTFPerPlayerMatchCriteriaProto {
    fn default() -> &'a CTFPerPlayerMatchCriteriaProto {
        <CTFPerPlayerMatchCriteriaProto as ::protobuf::Message>::default_instance()
    }
}

impl CTFPerPlayerMatchCriteriaProto {
    pub fn new() -> CTFPerPlayerMatchCriteriaProto {
        ::std::default::Default::default()
    }

    // optional bool mvm_squad_surplus = 1;


    pub fn get_mvm_squad_surplus(&self) -> bool {
        self.mvm_squad_surplus.unwrap_or(false)
    }
    pub fn clear_mvm_squad_surplus(&mut self) {
        self.mvm_squad_surplus = ::std::option::Option::None;
    }

    pub fn has_mvm_squad_surplus(&self) -> bool {
        self.mvm_squad_surplus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mvm_squad_surplus(&mut self, v: bool) {
        self.mvm_squad_surplus = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CTFPerPlayerMatchCriteriaProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.mvm_squad_surplus = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.mvm_squad_surplus {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.mvm_squad_surplus {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CTFPerPlayerMatchCriteriaProto {
        CTFPerPlayerMatchCriteriaProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "mvm_squad_surplus",
                |m: &CTFPerPlayerMatchCriteriaProto| { &m.mvm_squad_surplus },
                |m: &mut CTFPerPlayerMatchCriteriaProto| { &mut m.mvm_squad_surplus },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CTFPerPlayerMatchCriteriaProto>(
                "CTFPerPlayerMatchCriteriaProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CTFPerPlayerMatchCriteriaProto {
        static instance: ::protobuf::rt::LazyV2<CTFPerPlayerMatchCriteriaProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CTFPerPlayerMatchCriteriaProto::new)
    }
}

impl ::protobuf::Clear for CTFPerPlayerMatchCriteriaProto {
    fn clear(&mut self) {
        self.mvm_squad_surplus = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CTFPerPlayerMatchCriteriaProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CTFPerPlayerMatchCriteriaProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CTFPartyOptions {
    // message fields
    overwrite_existing: ::std::option::Option<bool>,
    pub group_criteria: ::protobuf::SingularPtrField<CTFGroupMatchCriteriaProto>,
    pub player_criteria: ::protobuf::SingularPtrField<CTFPerPlayerMatchCriteriaProto>,
    pub player_uistate: ::protobuf::SingularPtrField<TFSyncedMMUIState>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CTFPartyOptions {
    fn default() -> &'a CTFPartyOptions {
        <CTFPartyOptions as ::protobuf::Message>::default_instance()
    }
}

impl CTFPartyOptions {
    pub fn new() -> CTFPartyOptions {
        ::std::default::Default::default()
    }

    // optional bool overwrite_existing = 1;


    pub fn get_overwrite_existing(&self) -> bool {
        self.overwrite_existing.unwrap_or(false)
    }
    pub fn clear_overwrite_existing(&mut self) {
        self.overwrite_existing = ::std::option::Option::None;
    }

    pub fn has_overwrite_existing(&self) -> bool {
        self.overwrite_existing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_overwrite_existing(&mut self, v: bool) {
        self.overwrite_existing = ::std::option::Option::Some(v);
    }

    // optional .CTFGroupMatchCriteriaProto group_criteria = 2;


    pub fn get_group_criteria(&self) -> &CTFGroupMatchCriteriaProto {
        self.group_criteria.as_ref().unwrap_or_else(|| <CTFGroupMatchCriteriaProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_group_criteria(&mut self) {
        self.group_criteria.clear();
    }

    pub fn has_group_criteria(&self) -> bool {
        self.group_criteria.is_some()
    }

    // Param is passed by value, moved
    pub fn set_group_criteria(&mut self, v: CTFGroupMatchCriteriaProto) {
        self.group_criteria = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_group_criteria(&mut self) -> &mut CTFGroupMatchCriteriaProto {
        if self.group_criteria.is_none() {
            self.group_criteria.set_default();
        }
        self.group_criteria.as_mut().unwrap()
    }

    // Take field
    pub fn take_group_criteria(&mut self) -> CTFGroupMatchCriteriaProto {
        self.group_criteria.take().unwrap_or_else(|| CTFGroupMatchCriteriaProto::new())
    }

    // optional .CTFPerPlayerMatchCriteriaProto player_criteria = 3;


    pub fn get_player_criteria(&self) -> &CTFPerPlayerMatchCriteriaProto {
        self.player_criteria.as_ref().unwrap_or_else(|| <CTFPerPlayerMatchCriteriaProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_player_criteria(&mut self) {
        self.player_criteria.clear();
    }

    pub fn has_player_criteria(&self) -> bool {
        self.player_criteria.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_criteria(&mut self, v: CTFPerPlayerMatchCriteriaProto) {
        self.player_criteria = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_player_criteria(&mut self) -> &mut CTFPerPlayerMatchCriteriaProto {
        if self.player_criteria.is_none() {
            self.player_criteria.set_default();
        }
        self.player_criteria.as_mut().unwrap()
    }

    // Take field
    pub fn take_player_criteria(&mut self) -> CTFPerPlayerMatchCriteriaProto {
        self.player_criteria.take().unwrap_or_else(|| CTFPerPlayerMatchCriteriaProto::new())
    }

    // optional .TFSyncedMMUIState player_uistate = 5;


    pub fn get_player_uistate(&self) -> &TFSyncedMMUIState {
        self.player_uistate.as_ref().unwrap_or_else(|| <TFSyncedMMUIState as ::protobuf::Message>::default_instance())
    }
    pub fn clear_player_uistate(&mut self) {
        self.player_uistate.clear();
    }

    pub fn has_player_uistate(&self) -> bool {
        self.player_uistate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_uistate(&mut self, v: TFSyncedMMUIState) {
        self.player_uistate = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_player_uistate(&mut self) -> &mut TFSyncedMMUIState {
        if self.player_uistate.is_none() {
            self.player_uistate.set_default();
        }
        self.player_uistate.as_mut().unwrap()
    }

    // Take field
    pub fn take_player_uistate(&mut self) -> TFSyncedMMUIState {
        self.player_uistate.take().unwrap_or_else(|| TFSyncedMMUIState::new())
    }
}

impl ::protobuf::Message for CTFPartyOptions {
    fn is_initialized(&self) -> bool {
        for v in &self.group_criteria {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.player_criteria {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.player_uistate {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.overwrite_existing = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.group_criteria)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.player_criteria)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.player_uistate)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.overwrite_existing {
            my_size += 2;
        }
        if let Some(ref v) = self.group_criteria.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.player_criteria.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.player_uistate.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.overwrite_existing {
            os.write_bool(1, v)?;
        }
        if let Some(ref v) = self.group_criteria.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.player_criteria.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.player_uistate.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CTFPartyOptions {
        CTFPartyOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "overwrite_existing",
                |m: &CTFPartyOptions| { &m.overwrite_existing },
                |m: &mut CTFPartyOptions| { &mut m.overwrite_existing },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CTFGroupMatchCriteriaProto>>(
                "group_criteria",
                |m: &CTFPartyOptions| { &m.group_criteria },
                |m: &mut CTFPartyOptions| { &mut m.group_criteria },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CTFPerPlayerMatchCriteriaProto>>(
                "player_criteria",
                |m: &CTFPartyOptions| { &m.player_criteria },
                |m: &mut CTFPartyOptions| { &mut m.player_criteria },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TFSyncedMMUIState>>(
                "player_uistate",
                |m: &CTFPartyOptions| { &m.player_uistate },
                |m: &mut CTFPartyOptions| { &mut m.player_uistate },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CTFPartyOptions>(
                "CTFPartyOptions",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CTFPartyOptions {
        static instance: ::protobuf::rt::LazyV2<CTFPartyOptions> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CTFPartyOptions::new)
    }
}

impl ::protobuf::Clear for CTFPartyOptions {
    fn clear(&mut self) {
        self.overwrite_existing = ::std::option::Option::None;
        self.group_criteria.clear();
        self.player_criteria.clear();
        self.player_uistate.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CTFPartyOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CTFPartyOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgPartySetOptions {
    // message fields
    party_id: ::std::option::Option<u64>,
    pub options: ::protobuf::SingularPtrField<CTFPartyOptions>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgPartySetOptions {
    fn default() -> &'a CMsgPartySetOptions {
        <CMsgPartySetOptions as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPartySetOptions {
    pub fn new() -> CMsgPartySetOptions {
        ::std::default::Default::default()
    }

    // optional fixed64 party_id = 1;


    pub fn get_party_id(&self) -> u64 {
        self.party_id.unwrap_or(0)
    }
    pub fn clear_party_id(&mut self) {
        self.party_id = ::std::option::Option::None;
    }

    pub fn has_party_id(&self) -> bool {
        self.party_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_party_id(&mut self, v: u64) {
        self.party_id = ::std::option::Option::Some(v);
    }

    // optional .CTFPartyOptions options = 2;


    pub fn get_options(&self) -> &CTFPartyOptions {
        self.options.as_ref().unwrap_or_else(|| <CTFPartyOptions as ::protobuf::Message>::default_instance())
    }
    pub fn clear_options(&mut self) {
        self.options.clear();
    }

    pub fn has_options(&self) -> bool {
        self.options.is_some()
    }

    // Param is passed by value, moved
    pub fn set_options(&mut self, v: CTFPartyOptions) {
        self.options = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_options(&mut self) -> &mut CTFPartyOptions {
        if self.options.is_none() {
            self.options.set_default();
        }
        self.options.as_mut().unwrap()
    }

    // Take field
    pub fn take_options(&mut self) -> CTFPartyOptions {
        self.options.take().unwrap_or_else(|| CTFPartyOptions::new())
    }
}

impl ::protobuf::Message for CMsgPartySetOptions {
    fn is_initialized(&self) -> bool {
        for v in &self.options {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.party_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.options)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.party_id {
            my_size += 9;
        }
        if let Some(ref v) = self.options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.party_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(ref v) = self.options.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgPartySetOptions {
        CMsgPartySetOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "party_id",
                |m: &CMsgPartySetOptions| { &m.party_id },
                |m: &mut CMsgPartySetOptions| { &mut m.party_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CTFPartyOptions>>(
                "options",
                |m: &CMsgPartySetOptions| { &m.options },
                |m: &mut CMsgPartySetOptions| { &mut m.options },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgPartySetOptions>(
                "CMsgPartySetOptions",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgPartySetOptions {
        static instance: ::protobuf::rt::LazyV2<CMsgPartySetOptions> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgPartySetOptions::new)
    }
}

impl ::protobuf::Clear for CMsgPartySetOptions {
    fn clear(&mut self) {
        self.party_id = ::std::option::Option::None;
        self.options.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgPartySetOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPartySetOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgPartySetOptionsResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgPartySetOptionsResponse {
    fn default() -> &'a CMsgPartySetOptionsResponse {
        <CMsgPartySetOptionsResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPartySetOptionsResponse {
    pub fn new() -> CMsgPartySetOptionsResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgPartySetOptionsResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgPartySetOptionsResponse {
        CMsgPartySetOptionsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgPartySetOptionsResponse>(
                "CMsgPartySetOptionsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgPartySetOptionsResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgPartySetOptionsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgPartySetOptionsResponse::new)
    }
}

impl ::protobuf::Clear for CMsgPartySetOptionsResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgPartySetOptionsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPartySetOptionsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgPartyQueueForMatch {
    // message fields
    party_id: ::std::option::Option<u64>,
    pub final_options: ::protobuf::SingularPtrField<CTFPartyOptions>,
    match_group: ::std::option::Option<ETFMatchGroup>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgPartyQueueForMatch {
    fn default() -> &'a CMsgPartyQueueForMatch {
        <CMsgPartyQueueForMatch as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPartyQueueForMatch {
    pub fn new() -> CMsgPartyQueueForMatch {
        ::std::default::Default::default()
    }

    // optional fixed64 party_id = 1;


    pub fn get_party_id(&self) -> u64 {
        self.party_id.unwrap_or(0)
    }
    pub fn clear_party_id(&mut self) {
        self.party_id = ::std::option::Option::None;
    }

    pub fn has_party_id(&self) -> bool {
        self.party_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_party_id(&mut self, v: u64) {
        self.party_id = ::std::option::Option::Some(v);
    }

    // optional .CTFPartyOptions final_options = 2;


    pub fn get_final_options(&self) -> &CTFPartyOptions {
        self.final_options.as_ref().unwrap_or_else(|| <CTFPartyOptions as ::protobuf::Message>::default_instance())
    }
    pub fn clear_final_options(&mut self) {
        self.final_options.clear();
    }

    pub fn has_final_options(&self) -> bool {
        self.final_options.is_some()
    }

    // Param is passed by value, moved
    pub fn set_final_options(&mut self, v: CTFPartyOptions) {
        self.final_options = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_final_options(&mut self) -> &mut CTFPartyOptions {
        if self.final_options.is_none() {
            self.final_options.set_default();
        }
        self.final_options.as_mut().unwrap()
    }

    // Take field
    pub fn take_final_options(&mut self) -> CTFPartyOptions {
        self.final_options.take().unwrap_or_else(|| CTFPartyOptions::new())
    }

    // optional .ETFMatchGroup match_group = 3;


    pub fn get_match_group(&self) -> ETFMatchGroup {
        self.match_group.unwrap_or(ETFMatchGroup::k_eTFMatchGroup_Invalid)
    }
    pub fn clear_match_group(&mut self) {
        self.match_group = ::std::option::Option::None;
    }

    pub fn has_match_group(&self) -> bool {
        self.match_group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_group(&mut self, v: ETFMatchGroup) {
        self.match_group = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgPartyQueueForMatch {
    fn is_initialized(&self) -> bool {
        for v in &self.final_options {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.party_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.final_options)?;
                },
                3 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.match_group, 3, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.party_id {
            my_size += 9;
        }
        if let Some(ref v) = self.final_options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.match_group {
            my_size += ::protobuf::rt::enum_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.party_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(ref v) = self.final_options.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.match_group {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgPartyQueueForMatch {
        CMsgPartyQueueForMatch::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "party_id",
                |m: &CMsgPartyQueueForMatch| { &m.party_id },
                |m: &mut CMsgPartyQueueForMatch| { &mut m.party_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CTFPartyOptions>>(
                "final_options",
                |m: &CMsgPartyQueueForMatch| { &m.final_options },
                |m: &mut CMsgPartyQueueForMatch| { &mut m.final_options },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ETFMatchGroup>>(
                "match_group",
                |m: &CMsgPartyQueueForMatch| { &m.match_group },
                |m: &mut CMsgPartyQueueForMatch| { &mut m.match_group },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgPartyQueueForMatch>(
                "CMsgPartyQueueForMatch",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgPartyQueueForMatch {
        static instance: ::protobuf::rt::LazyV2<CMsgPartyQueueForMatch> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgPartyQueueForMatch::new)
    }
}

impl ::protobuf::Clear for CMsgPartyQueueForMatch {
    fn clear(&mut self) {
        self.party_id = ::std::option::Option::None;
        self.final_options.clear();
        self.match_group = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgPartyQueueForMatch {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPartyQueueForMatch {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgPartyQueueForMatchResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgPartyQueueForMatchResponse {
    fn default() -> &'a CMsgPartyQueueForMatchResponse {
        <CMsgPartyQueueForMatchResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPartyQueueForMatchResponse {
    pub fn new() -> CMsgPartyQueueForMatchResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgPartyQueueForMatchResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgPartyQueueForMatchResponse {
        CMsgPartyQueueForMatchResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgPartyQueueForMatchResponse>(
                "CMsgPartyQueueForMatchResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgPartyQueueForMatchResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgPartyQueueForMatchResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgPartyQueueForMatchResponse::new)
    }
}

impl ::protobuf::Clear for CMsgPartyQueueForMatchResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgPartyQueueForMatchResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPartyQueueForMatchResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgPartyQueueForStandby {
    // message fields
    party_id: ::std::option::Option<u64>,
    party_lobby_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgPartyQueueForStandby {
    fn default() -> &'a CMsgPartyQueueForStandby {
        <CMsgPartyQueueForStandby as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPartyQueueForStandby {
    pub fn new() -> CMsgPartyQueueForStandby {
        ::std::default::Default::default()
    }

    // optional fixed64 party_id = 1;


    pub fn get_party_id(&self) -> u64 {
        self.party_id.unwrap_or(0)
    }
    pub fn clear_party_id(&mut self) {
        self.party_id = ::std::option::Option::None;
    }

    pub fn has_party_id(&self) -> bool {
        self.party_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_party_id(&mut self, v: u64) {
        self.party_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 party_lobby_id = 2;


    pub fn get_party_lobby_id(&self) -> u64 {
        self.party_lobby_id.unwrap_or(0)
    }
    pub fn clear_party_lobby_id(&mut self) {
        self.party_lobby_id = ::std::option::Option::None;
    }

    pub fn has_party_lobby_id(&self) -> bool {
        self.party_lobby_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_party_lobby_id(&mut self, v: u64) {
        self.party_lobby_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgPartyQueueForStandby {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.party_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.party_lobby_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.party_id {
            my_size += 9;
        }
        if let Some(v) = self.party_lobby_id {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.party_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.party_lobby_id {
            os.write_fixed64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgPartyQueueForStandby {
        CMsgPartyQueueForStandby::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "party_id",
                |m: &CMsgPartyQueueForStandby| { &m.party_id },
                |m: &mut CMsgPartyQueueForStandby| { &mut m.party_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "party_lobby_id",
                |m: &CMsgPartyQueueForStandby| { &m.party_lobby_id },
                |m: &mut CMsgPartyQueueForStandby| { &mut m.party_lobby_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgPartyQueueForStandby>(
                "CMsgPartyQueueForStandby",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgPartyQueueForStandby {
        static instance: ::protobuf::rt::LazyV2<CMsgPartyQueueForStandby> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgPartyQueueForStandby::new)
    }
}

impl ::protobuf::Clear for CMsgPartyQueueForStandby {
    fn clear(&mut self) {
        self.party_id = ::std::option::Option::None;
        self.party_lobby_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgPartyQueueForStandby {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPartyQueueForStandby {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgPartyQueueForStandbyResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgPartyQueueForStandbyResponse {
    fn default() -> &'a CMsgPartyQueueForStandbyResponse {
        <CMsgPartyQueueForStandbyResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPartyQueueForStandbyResponse {
    pub fn new() -> CMsgPartyQueueForStandbyResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgPartyQueueForStandbyResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgPartyQueueForStandbyResponse {
        CMsgPartyQueueForStandbyResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgPartyQueueForStandbyResponse>(
                "CMsgPartyQueueForStandbyResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgPartyQueueForStandbyResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgPartyQueueForStandbyResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgPartyQueueForStandbyResponse::new)
    }
}

impl ::protobuf::Clear for CMsgPartyQueueForStandbyResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgPartyQueueForStandbyResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPartyQueueForStandbyResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgPartyRemoveFromQueue {
    // message fields
    party_id: ::std::option::Option<u64>,
    match_group: ::std::option::Option<ETFMatchGroup>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgPartyRemoveFromQueue {
    fn default() -> &'a CMsgPartyRemoveFromQueue {
        <CMsgPartyRemoveFromQueue as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPartyRemoveFromQueue {
    pub fn new() -> CMsgPartyRemoveFromQueue {
        ::std::default::Default::default()
    }

    // optional fixed64 party_id = 1;


    pub fn get_party_id(&self) -> u64 {
        self.party_id.unwrap_or(0)
    }
    pub fn clear_party_id(&mut self) {
        self.party_id = ::std::option::Option::None;
    }

    pub fn has_party_id(&self) -> bool {
        self.party_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_party_id(&mut self, v: u64) {
        self.party_id = ::std::option::Option::Some(v);
    }

    // optional .ETFMatchGroup match_group = 2;


    pub fn get_match_group(&self) -> ETFMatchGroup {
        self.match_group.unwrap_or(ETFMatchGroup::k_eTFMatchGroup_Invalid)
    }
    pub fn clear_match_group(&mut self) {
        self.match_group = ::std::option::Option::None;
    }

    pub fn has_match_group(&self) -> bool {
        self.match_group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_group(&mut self, v: ETFMatchGroup) {
        self.match_group = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgPartyRemoveFromQueue {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.party_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.match_group, 2, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.party_id {
            my_size += 9;
        }
        if let Some(v) = self.match_group {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.party_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.match_group {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgPartyRemoveFromQueue {
        CMsgPartyRemoveFromQueue::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "party_id",
                |m: &CMsgPartyRemoveFromQueue| { &m.party_id },
                |m: &mut CMsgPartyRemoveFromQueue| { &mut m.party_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ETFMatchGroup>>(
                "match_group",
                |m: &CMsgPartyRemoveFromQueue| { &m.match_group },
                |m: &mut CMsgPartyRemoveFromQueue| { &mut m.match_group },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgPartyRemoveFromQueue>(
                "CMsgPartyRemoveFromQueue",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgPartyRemoveFromQueue {
        static instance: ::protobuf::rt::LazyV2<CMsgPartyRemoveFromQueue> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgPartyRemoveFromQueue::new)
    }
}

impl ::protobuf::Clear for CMsgPartyRemoveFromQueue {
    fn clear(&mut self) {
        self.party_id = ::std::option::Option::None;
        self.match_group = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgPartyRemoveFromQueue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPartyRemoveFromQueue {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgPartyRemoveFromQueueResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgPartyRemoveFromQueueResponse {
    fn default() -> &'a CMsgPartyRemoveFromQueueResponse {
        <CMsgPartyRemoveFromQueueResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPartyRemoveFromQueueResponse {
    pub fn new() -> CMsgPartyRemoveFromQueueResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgPartyRemoveFromQueueResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgPartyRemoveFromQueueResponse {
        CMsgPartyRemoveFromQueueResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgPartyRemoveFromQueueResponse>(
                "CMsgPartyRemoveFromQueueResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgPartyRemoveFromQueueResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgPartyRemoveFromQueueResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgPartyRemoveFromQueueResponse::new)
    }
}

impl ::protobuf::Clear for CMsgPartyRemoveFromQueueResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgPartyRemoveFromQueueResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPartyRemoveFromQueueResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgPartyRemoveFromStandbyQueue {
    // message fields
    party_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgPartyRemoveFromStandbyQueue {
    fn default() -> &'a CMsgPartyRemoveFromStandbyQueue {
        <CMsgPartyRemoveFromStandbyQueue as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPartyRemoveFromStandbyQueue {
    pub fn new() -> CMsgPartyRemoveFromStandbyQueue {
        ::std::default::Default::default()
    }

    // optional fixed64 party_id = 1;


    pub fn get_party_id(&self) -> u64 {
        self.party_id.unwrap_or(0)
    }
    pub fn clear_party_id(&mut self) {
        self.party_id = ::std::option::Option::None;
    }

    pub fn has_party_id(&self) -> bool {
        self.party_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_party_id(&mut self, v: u64) {
        self.party_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgPartyRemoveFromStandbyQueue {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.party_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.party_id {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.party_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgPartyRemoveFromStandbyQueue {
        CMsgPartyRemoveFromStandbyQueue::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "party_id",
                |m: &CMsgPartyRemoveFromStandbyQueue| { &m.party_id },
                |m: &mut CMsgPartyRemoveFromStandbyQueue| { &mut m.party_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgPartyRemoveFromStandbyQueue>(
                "CMsgPartyRemoveFromStandbyQueue",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgPartyRemoveFromStandbyQueue {
        static instance: ::protobuf::rt::LazyV2<CMsgPartyRemoveFromStandbyQueue> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgPartyRemoveFromStandbyQueue::new)
    }
}

impl ::protobuf::Clear for CMsgPartyRemoveFromStandbyQueue {
    fn clear(&mut self) {
        self.party_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgPartyRemoveFromStandbyQueue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPartyRemoveFromStandbyQueue {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgPartyRemoveFromStandbyQueueResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgPartyRemoveFromStandbyQueueResponse {
    fn default() -> &'a CMsgPartyRemoveFromStandbyQueueResponse {
        <CMsgPartyRemoveFromStandbyQueueResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPartyRemoveFromStandbyQueueResponse {
    pub fn new() -> CMsgPartyRemoveFromStandbyQueueResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgPartyRemoveFromStandbyQueueResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgPartyRemoveFromStandbyQueueResponse {
        CMsgPartyRemoveFromStandbyQueueResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgPartyRemoveFromStandbyQueueResponse>(
                "CMsgPartyRemoveFromStandbyQueueResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgPartyRemoveFromStandbyQueueResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgPartyRemoveFromStandbyQueueResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgPartyRemoveFromStandbyQueueResponse::new)
    }
}

impl ::protobuf::Clear for CMsgPartyRemoveFromStandbyQueueResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgPartyRemoveFromStandbyQueueResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPartyRemoveFromStandbyQueueResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgPartyInvitePlayer {
    // message fields
    party_id: ::std::option::Option<u64>,
    player_id: ::std::option::Option<u64>,
    expecting_request_to_join: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgPartyInvitePlayer {
    fn default() -> &'a CMsgPartyInvitePlayer {
        <CMsgPartyInvitePlayer as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPartyInvitePlayer {
    pub fn new() -> CMsgPartyInvitePlayer {
        ::std::default::Default::default()
    }

    // optional fixed64 party_id = 1;


    pub fn get_party_id(&self) -> u64 {
        self.party_id.unwrap_or(0)
    }
    pub fn clear_party_id(&mut self) {
        self.party_id = ::std::option::Option::None;
    }

    pub fn has_party_id(&self) -> bool {
        self.party_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_party_id(&mut self, v: u64) {
        self.party_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 player_id = 2;


    pub fn get_player_id(&self) -> u64 {
        self.player_id.unwrap_or(0)
    }
    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: u64) {
        self.player_id = ::std::option::Option::Some(v);
    }

    // optional bool expecting_request_to_join = 3;


    pub fn get_expecting_request_to_join(&self) -> bool {
        self.expecting_request_to_join.unwrap_or(false)
    }
    pub fn clear_expecting_request_to_join(&mut self) {
        self.expecting_request_to_join = ::std::option::Option::None;
    }

    pub fn has_expecting_request_to_join(&self) -> bool {
        self.expecting_request_to_join.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expecting_request_to_join(&mut self, v: bool) {
        self.expecting_request_to_join = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgPartyInvitePlayer {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.party_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.player_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.expecting_request_to_join = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.party_id {
            my_size += 9;
        }
        if let Some(v) = self.player_id {
            my_size += 9;
        }
        if let Some(v) = self.expecting_request_to_join {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.party_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.player_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.expecting_request_to_join {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgPartyInvitePlayer {
        CMsgPartyInvitePlayer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "party_id",
                |m: &CMsgPartyInvitePlayer| { &m.party_id },
                |m: &mut CMsgPartyInvitePlayer| { &mut m.party_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "player_id",
                |m: &CMsgPartyInvitePlayer| { &m.player_id },
                |m: &mut CMsgPartyInvitePlayer| { &mut m.player_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "expecting_request_to_join",
                |m: &CMsgPartyInvitePlayer| { &m.expecting_request_to_join },
                |m: &mut CMsgPartyInvitePlayer| { &mut m.expecting_request_to_join },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgPartyInvitePlayer>(
                "CMsgPartyInvitePlayer",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgPartyInvitePlayer {
        static instance: ::protobuf::rt::LazyV2<CMsgPartyInvitePlayer> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgPartyInvitePlayer::new)
    }
}

impl ::protobuf::Clear for CMsgPartyInvitePlayer {
    fn clear(&mut self) {
        self.party_id = ::std::option::Option::None;
        self.player_id = ::std::option::Option::None;
        self.expecting_request_to_join = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgPartyInvitePlayer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPartyInvitePlayer {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgPartyRequestJoinPlayer {
    // message fields
    current_party_id: ::std::option::Option<u64>,
    join_player_id: ::std::option::Option<u64>,
    join_party_id: ::std::option::Option<u64>,
    expecting_invite: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgPartyRequestJoinPlayer {
    fn default() -> &'a CMsgPartyRequestJoinPlayer {
        <CMsgPartyRequestJoinPlayer as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPartyRequestJoinPlayer {
    pub fn new() -> CMsgPartyRequestJoinPlayer {
        ::std::default::Default::default()
    }

    // optional fixed64 current_party_id = 1;


    pub fn get_current_party_id(&self) -> u64 {
        self.current_party_id.unwrap_or(0)
    }
    pub fn clear_current_party_id(&mut self) {
        self.current_party_id = ::std::option::Option::None;
    }

    pub fn has_current_party_id(&self) -> bool {
        self.current_party_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_current_party_id(&mut self, v: u64) {
        self.current_party_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 join_player_id = 2;


    pub fn get_join_player_id(&self) -> u64 {
        self.join_player_id.unwrap_or(0)
    }
    pub fn clear_join_player_id(&mut self) {
        self.join_player_id = ::std::option::Option::None;
    }

    pub fn has_join_player_id(&self) -> bool {
        self.join_player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_join_player_id(&mut self, v: u64) {
        self.join_player_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 join_party_id = 3;


    pub fn get_join_party_id(&self) -> u64 {
        self.join_party_id.unwrap_or(0)
    }
    pub fn clear_join_party_id(&mut self) {
        self.join_party_id = ::std::option::Option::None;
    }

    pub fn has_join_party_id(&self) -> bool {
        self.join_party_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_join_party_id(&mut self, v: u64) {
        self.join_party_id = ::std::option::Option::Some(v);
    }

    // optional bool expecting_invite = 4;


    pub fn get_expecting_invite(&self) -> bool {
        self.expecting_invite.unwrap_or(false)
    }
    pub fn clear_expecting_invite(&mut self) {
        self.expecting_invite = ::std::option::Option::None;
    }

    pub fn has_expecting_invite(&self) -> bool {
        self.expecting_invite.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expecting_invite(&mut self, v: bool) {
        self.expecting_invite = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgPartyRequestJoinPlayer {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.current_party_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.join_player_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.join_party_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.expecting_invite = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.current_party_id {
            my_size += 9;
        }
        if let Some(v) = self.join_player_id {
            my_size += 9;
        }
        if let Some(v) = self.join_party_id {
            my_size += 9;
        }
        if let Some(v) = self.expecting_invite {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.current_party_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.join_player_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.join_party_id {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.expecting_invite {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgPartyRequestJoinPlayer {
        CMsgPartyRequestJoinPlayer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "current_party_id",
                |m: &CMsgPartyRequestJoinPlayer| { &m.current_party_id },
                |m: &mut CMsgPartyRequestJoinPlayer| { &mut m.current_party_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "join_player_id",
                |m: &CMsgPartyRequestJoinPlayer| { &m.join_player_id },
                |m: &mut CMsgPartyRequestJoinPlayer| { &mut m.join_player_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "join_party_id",
                |m: &CMsgPartyRequestJoinPlayer| { &m.join_party_id },
                |m: &mut CMsgPartyRequestJoinPlayer| { &mut m.join_party_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "expecting_invite",
                |m: &CMsgPartyRequestJoinPlayer| { &m.expecting_invite },
                |m: &mut CMsgPartyRequestJoinPlayer| { &mut m.expecting_invite },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgPartyRequestJoinPlayer>(
                "CMsgPartyRequestJoinPlayer",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgPartyRequestJoinPlayer {
        static instance: ::protobuf::rt::LazyV2<CMsgPartyRequestJoinPlayer> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgPartyRequestJoinPlayer::new)
    }
}

impl ::protobuf::Clear for CMsgPartyRequestJoinPlayer {
    fn clear(&mut self) {
        self.current_party_id = ::std::option::Option::None;
        self.join_player_id = ::std::option::Option::None;
        self.join_party_id = ::std::option::Option::None;
        self.expecting_invite = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgPartyRequestJoinPlayer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPartyRequestJoinPlayer {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgPartyClearPendingPlayer {
    // message fields
    party_id: ::std::option::Option<u64>,
    pending_player_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgPartyClearPendingPlayer {
    fn default() -> &'a CMsgPartyClearPendingPlayer {
        <CMsgPartyClearPendingPlayer as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPartyClearPendingPlayer {
    pub fn new() -> CMsgPartyClearPendingPlayer {
        ::std::default::Default::default()
    }

    // optional fixed64 party_id = 1;


    pub fn get_party_id(&self) -> u64 {
        self.party_id.unwrap_or(0)
    }
    pub fn clear_party_id(&mut self) {
        self.party_id = ::std::option::Option::None;
    }

    pub fn has_party_id(&self) -> bool {
        self.party_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_party_id(&mut self, v: u64) {
        self.party_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 pending_player_id = 2;


    pub fn get_pending_player_id(&self) -> u64 {
        self.pending_player_id.unwrap_or(0)
    }
    pub fn clear_pending_player_id(&mut self) {
        self.pending_player_id = ::std::option::Option::None;
    }

    pub fn has_pending_player_id(&self) -> bool {
        self.pending_player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pending_player_id(&mut self, v: u64) {
        self.pending_player_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgPartyClearPendingPlayer {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.party_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.pending_player_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.party_id {
            my_size += 9;
        }
        if let Some(v) = self.pending_player_id {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.party_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.pending_player_id {
            os.write_fixed64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgPartyClearPendingPlayer {
        CMsgPartyClearPendingPlayer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "party_id",
                |m: &CMsgPartyClearPendingPlayer| { &m.party_id },
                |m: &mut CMsgPartyClearPendingPlayer| { &mut m.party_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "pending_player_id",
                |m: &CMsgPartyClearPendingPlayer| { &m.pending_player_id },
                |m: &mut CMsgPartyClearPendingPlayer| { &mut m.pending_player_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgPartyClearPendingPlayer>(
                "CMsgPartyClearPendingPlayer",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgPartyClearPendingPlayer {
        static instance: ::protobuf::rt::LazyV2<CMsgPartyClearPendingPlayer> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgPartyClearPendingPlayer::new)
    }
}

impl ::protobuf::Clear for CMsgPartyClearPendingPlayer {
    fn clear(&mut self) {
        self.party_id = ::std::option::Option::None;
        self.pending_player_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgPartyClearPendingPlayer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPartyClearPendingPlayer {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgPartyClearPendingPlayerResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgPartyClearPendingPlayerResponse {
    fn default() -> &'a CMsgPartyClearPendingPlayerResponse {
        <CMsgPartyClearPendingPlayerResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPartyClearPendingPlayerResponse {
    pub fn new() -> CMsgPartyClearPendingPlayerResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgPartyClearPendingPlayerResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgPartyClearPendingPlayerResponse {
        CMsgPartyClearPendingPlayerResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgPartyClearPendingPlayerResponse>(
                "CMsgPartyClearPendingPlayerResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgPartyClearPendingPlayerResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgPartyClearPendingPlayerResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgPartyClearPendingPlayerResponse::new)
    }
}

impl ::protobuf::Clear for CMsgPartyClearPendingPlayerResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgPartyClearPendingPlayerResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPartyClearPendingPlayerResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgPartyClearOtherPartyRequest {
    // message fields
    other_party_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgPartyClearOtherPartyRequest {
    fn default() -> &'a CMsgPartyClearOtherPartyRequest {
        <CMsgPartyClearOtherPartyRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPartyClearOtherPartyRequest {
    pub fn new() -> CMsgPartyClearOtherPartyRequest {
        ::std::default::Default::default()
    }

    // optional fixed64 other_party_id = 1;


    pub fn get_other_party_id(&self) -> u64 {
        self.other_party_id.unwrap_or(0)
    }
    pub fn clear_other_party_id(&mut self) {
        self.other_party_id = ::std::option::Option::None;
    }

    pub fn has_other_party_id(&self) -> bool {
        self.other_party_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_other_party_id(&mut self, v: u64) {
        self.other_party_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgPartyClearOtherPartyRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.other_party_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.other_party_id {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.other_party_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgPartyClearOtherPartyRequest {
        CMsgPartyClearOtherPartyRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "other_party_id",
                |m: &CMsgPartyClearOtherPartyRequest| { &m.other_party_id },
                |m: &mut CMsgPartyClearOtherPartyRequest| { &mut m.other_party_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgPartyClearOtherPartyRequest>(
                "CMsgPartyClearOtherPartyRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgPartyClearOtherPartyRequest {
        static instance: ::protobuf::rt::LazyV2<CMsgPartyClearOtherPartyRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgPartyClearOtherPartyRequest::new)
    }
}

impl ::protobuf::Clear for CMsgPartyClearOtherPartyRequest {
    fn clear(&mut self) {
        self.other_party_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgPartyClearOtherPartyRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPartyClearOtherPartyRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgPartyClearOtherPartyRequestResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgPartyClearOtherPartyRequestResponse {
    fn default() -> &'a CMsgPartyClearOtherPartyRequestResponse {
        <CMsgPartyClearOtherPartyRequestResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPartyClearOtherPartyRequestResponse {
    pub fn new() -> CMsgPartyClearOtherPartyRequestResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgPartyClearOtherPartyRequestResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgPartyClearOtherPartyRequestResponse {
        CMsgPartyClearOtherPartyRequestResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgPartyClearOtherPartyRequestResponse>(
                "CMsgPartyClearOtherPartyRequestResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgPartyClearOtherPartyRequestResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgPartyClearOtherPartyRequestResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgPartyClearOtherPartyRequestResponse::new)
    }
}

impl ::protobuf::Clear for CMsgPartyClearOtherPartyRequestResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgPartyClearOtherPartyRequestResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPartyClearOtherPartyRequestResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgPartyPromoteToLeader {
    // message fields
    party_id: ::std::option::Option<u64>,
    new_leader_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgPartyPromoteToLeader {
    fn default() -> &'a CMsgPartyPromoteToLeader {
        <CMsgPartyPromoteToLeader as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPartyPromoteToLeader {
    pub fn new() -> CMsgPartyPromoteToLeader {
        ::std::default::Default::default()
    }

    // optional fixed64 party_id = 1;


    pub fn get_party_id(&self) -> u64 {
        self.party_id.unwrap_or(0)
    }
    pub fn clear_party_id(&mut self) {
        self.party_id = ::std::option::Option::None;
    }

    pub fn has_party_id(&self) -> bool {
        self.party_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_party_id(&mut self, v: u64) {
        self.party_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 new_leader_id = 2;


    pub fn get_new_leader_id(&self) -> u64 {
        self.new_leader_id.unwrap_or(0)
    }
    pub fn clear_new_leader_id(&mut self) {
        self.new_leader_id = ::std::option::Option::None;
    }

    pub fn has_new_leader_id(&self) -> bool {
        self.new_leader_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_new_leader_id(&mut self, v: u64) {
        self.new_leader_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgPartyPromoteToLeader {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.party_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.new_leader_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.party_id {
            my_size += 9;
        }
        if let Some(v) = self.new_leader_id {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.party_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.new_leader_id {
            os.write_fixed64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgPartyPromoteToLeader {
        CMsgPartyPromoteToLeader::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "party_id",
                |m: &CMsgPartyPromoteToLeader| { &m.party_id },
                |m: &mut CMsgPartyPromoteToLeader| { &mut m.party_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "new_leader_id",
                |m: &CMsgPartyPromoteToLeader| { &m.new_leader_id },
                |m: &mut CMsgPartyPromoteToLeader| { &mut m.new_leader_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgPartyPromoteToLeader>(
                "CMsgPartyPromoteToLeader",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgPartyPromoteToLeader {
        static instance: ::protobuf::rt::LazyV2<CMsgPartyPromoteToLeader> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgPartyPromoteToLeader::new)
    }
}

impl ::protobuf::Clear for CMsgPartyPromoteToLeader {
    fn clear(&mut self) {
        self.party_id = ::std::option::Option::None;
        self.new_leader_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgPartyPromoteToLeader {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPartyPromoteToLeader {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgPartyKickMember {
    // message fields
    party_id: ::std::option::Option<u64>,
    target_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgPartyKickMember {
    fn default() -> &'a CMsgPartyKickMember {
        <CMsgPartyKickMember as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPartyKickMember {
    pub fn new() -> CMsgPartyKickMember {
        ::std::default::Default::default()
    }

    // optional fixed64 party_id = 1;


    pub fn get_party_id(&self) -> u64 {
        self.party_id.unwrap_or(0)
    }
    pub fn clear_party_id(&mut self) {
        self.party_id = ::std::option::Option::None;
    }

    pub fn has_party_id(&self) -> bool {
        self.party_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_party_id(&mut self, v: u64) {
        self.party_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 target_id = 2;


    pub fn get_target_id(&self) -> u64 {
        self.target_id.unwrap_or(0)
    }
    pub fn clear_target_id(&mut self) {
        self.target_id = ::std::option::Option::None;
    }

    pub fn has_target_id(&self) -> bool {
        self.target_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_id(&mut self, v: u64) {
        self.target_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgPartyKickMember {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.party_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.target_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.party_id {
            my_size += 9;
        }
        if let Some(v) = self.target_id {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.party_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.target_id {
            os.write_fixed64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgPartyKickMember {
        CMsgPartyKickMember::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "party_id",
                |m: &CMsgPartyKickMember| { &m.party_id },
                |m: &mut CMsgPartyKickMember| { &mut m.party_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "target_id",
                |m: &CMsgPartyKickMember| { &m.target_id },
                |m: &mut CMsgPartyKickMember| { &mut m.target_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgPartyKickMember>(
                "CMsgPartyKickMember",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgPartyKickMember {
        static instance: ::protobuf::rt::LazyV2<CMsgPartyKickMember> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgPartyKickMember::new)
    }
}

impl ::protobuf::Clear for CMsgPartyKickMember {
    fn clear(&mut self) {
        self.party_id = ::std::option::Option::None;
        self.target_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgPartyKickMember {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPartyKickMember {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgPartySendChat {
    // message fields
    party_id: ::std::option::Option<u64>,
    msg: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgPartySendChat {
    fn default() -> &'a CMsgPartySendChat {
        <CMsgPartySendChat as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPartySendChat {
    pub fn new() -> CMsgPartySendChat {
        ::std::default::Default::default()
    }

    // optional fixed64 party_id = 1;


    pub fn get_party_id(&self) -> u64 {
        self.party_id.unwrap_or(0)
    }
    pub fn clear_party_id(&mut self) {
        self.party_id = ::std::option::Option::None;
    }

    pub fn has_party_id(&self) -> bool {
        self.party_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_party_id(&mut self, v: u64) {
        self.party_id = ::std::option::Option::Some(v);
    }

    // optional string msg = 2;


    pub fn get_msg(&self) -> &str {
        match self.msg.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_msg(&mut self) {
        self.msg.clear();
    }

    pub fn has_msg(&self) -> bool {
        self.msg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msg(&mut self, v: ::std::string::String) {
        self.msg = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_msg(&mut self) -> &mut ::std::string::String {
        if self.msg.is_none() {
            self.msg.set_default();
        }
        self.msg.as_mut().unwrap()
    }

    // Take field
    pub fn take_msg(&mut self) -> ::std::string::String {
        self.msg.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgPartySendChat {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.party_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.msg)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.party_id {
            my_size += 9;
        }
        if let Some(ref v) = self.msg.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.party_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(ref v) = self.msg.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgPartySendChat {
        CMsgPartySendChat::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "party_id",
                |m: &CMsgPartySendChat| { &m.party_id },
                |m: &mut CMsgPartySendChat| { &mut m.party_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "msg",
                |m: &CMsgPartySendChat| { &m.msg },
                |m: &mut CMsgPartySendChat| { &mut m.msg },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgPartySendChat>(
                "CMsgPartySendChat",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgPartySendChat {
        static instance: ::protobuf::rt::LazyV2<CMsgPartySendChat> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgPartySendChat::new)
    }
}

impl ::protobuf::Clear for CMsgPartySendChat {
    fn clear(&mut self) {
        self.party_id = ::std::option::Option::None;
        self.msg.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgPartySendChat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPartySendChat {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgPartyChatMsg {
    // message fields
    field_type: ::std::option::Option<ETFPartyChatType>,
    actor_id: ::std::option::Option<u64>,
    msg: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgPartyChatMsg {
    fn default() -> &'a CMsgPartyChatMsg {
        <CMsgPartyChatMsg as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPartyChatMsg {
    pub fn new() -> CMsgPartyChatMsg {
        ::std::default::Default::default()
    }

    // optional .ETFPartyChatType type = 1;


    pub fn get_field_type(&self) -> ETFPartyChatType {
        self.field_type.unwrap_or(ETFPartyChatType::k_eTFPartyChatType_Invalid)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ETFPartyChatType) {
        self.field_type = ::std::option::Option::Some(v);
    }

    // optional fixed64 actor_id = 2;


    pub fn get_actor_id(&self) -> u64 {
        self.actor_id.unwrap_or(0)
    }
    pub fn clear_actor_id(&mut self) {
        self.actor_id = ::std::option::Option::None;
    }

    pub fn has_actor_id(&self) -> bool {
        self.actor_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_actor_id(&mut self, v: u64) {
        self.actor_id = ::std::option::Option::Some(v);
    }

    // optional string msg = 3;


    pub fn get_msg(&self) -> &str {
        match self.msg.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_msg(&mut self) {
        self.msg.clear();
    }

    pub fn has_msg(&self) -> bool {
        self.msg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msg(&mut self, v: ::std::string::String) {
        self.msg = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_msg(&mut self) -> &mut ::std::string::String {
        if self.msg.is_none() {
            self.msg.set_default();
        }
        self.msg.as_mut().unwrap()
    }

    // Take field
    pub fn take_msg(&mut self) -> ::std::string::String {
        self.msg.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgPartyChatMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.actor_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.msg)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.actor_id {
            my_size += 9;
        }
        if let Some(ref v) = self.msg.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.actor_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(ref v) = self.msg.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgPartyChatMsg {
        CMsgPartyChatMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ETFPartyChatType>>(
                "type",
                |m: &CMsgPartyChatMsg| { &m.field_type },
                |m: &mut CMsgPartyChatMsg| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "actor_id",
                |m: &CMsgPartyChatMsg| { &m.actor_id },
                |m: &mut CMsgPartyChatMsg| { &mut m.actor_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "msg",
                |m: &CMsgPartyChatMsg| { &m.msg },
                |m: &mut CMsgPartyChatMsg| { &mut m.msg },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgPartyChatMsg>(
                "CMsgPartyChatMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgPartyChatMsg {
        static instance: ::protobuf::rt::LazyV2<CMsgPartyChatMsg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgPartyChatMsg::new)
    }
}

impl ::protobuf::Clear for CMsgPartyChatMsg {
    fn clear(&mut self) {
        self.field_type = ::std::option::Option::None;
        self.actor_id = ::std::option::Option::None;
        self.msg.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgPartyChatMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPartyChatMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CSOTFParty {
    // message fields
    party_id: ::std::option::Option<u64>,
    leader_id: ::std::option::Option<u64>,
    pub member_ids: ::std::vec::Vec<u64>,
    pub members: ::protobuf::RepeatedField<CSOTFPartyMember>,
    associated_lobby_id: ::std::option::Option<u64>,
    associated_lobby_match_group: ::std::option::Option<ETFMatchGroup>,
    pub matchmaking_queues: ::protobuf::RepeatedField<CSOTFParty_QueueEntry>,
    pub group_criteria: ::protobuf::SingularPtrField<CTFGroupMatchCriteriaProto>,
    casual_banned_time: ::std::option::Option<u32>,
    casual_low_priority_time: ::std::option::Option<u32>,
    ranked_banned_time: ::std::option::Option<u32>,
    ranked_low_priority_time: ::std::option::Option<u32>,
    pub leader_ui_state: ::protobuf::SingularPtrField<TFSyncedMMUIState>,
    pub pending_members: ::protobuf::RepeatedField<TFPendingPartyMember>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CSOTFParty {
    fn default() -> &'a CSOTFParty {
        <CSOTFParty as ::protobuf::Message>::default_instance()
    }
}

impl CSOTFParty {
    pub fn new() -> CSOTFParty {
        ::std::default::Default::default()
    }

    // optional uint64 party_id = 1;


    pub fn get_party_id(&self) -> u64 {
        self.party_id.unwrap_or(0)
    }
    pub fn clear_party_id(&mut self) {
        self.party_id = ::std::option::Option::None;
    }

    pub fn has_party_id(&self) -> bool {
        self.party_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_party_id(&mut self, v: u64) {
        self.party_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 leader_id = 2;


    pub fn get_leader_id(&self) -> u64 {
        self.leader_id.unwrap_or(0)
    }
    pub fn clear_leader_id(&mut self) {
        self.leader_id = ::std::option::Option::None;
    }

    pub fn has_leader_id(&self) -> bool {
        self.leader_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leader_id(&mut self, v: u64) {
        self.leader_id = ::std::option::Option::Some(v);
    }

    // repeated fixed64 member_ids = 3;


    pub fn get_member_ids(&self) -> &[u64] {
        &self.member_ids
    }
    pub fn clear_member_ids(&mut self) {
        self.member_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_member_ids(&mut self, v: ::std::vec::Vec<u64>) {
        self.member_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_member_ids(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.member_ids
    }

    // Take field
    pub fn take_member_ids(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.member_ids, ::std::vec::Vec::new())
    }

    // repeated .CSOTFPartyMember members = 13;


    pub fn get_members(&self) -> &[CSOTFPartyMember] {
        &self.members
    }
    pub fn clear_members(&mut self) {
        self.members.clear();
    }

    // Param is passed by value, moved
    pub fn set_members(&mut self, v: ::protobuf::RepeatedField<CSOTFPartyMember>) {
        self.members = v;
    }

    // Mutable pointer to the field.
    pub fn mut_members(&mut self) -> &mut ::protobuf::RepeatedField<CSOTFPartyMember> {
        &mut self.members
    }

    // Take field
    pub fn take_members(&mut self) -> ::protobuf::RepeatedField<CSOTFPartyMember> {
        ::std::mem::replace(&mut self.members, ::protobuf::RepeatedField::new())
    }

    // optional uint64 associated_lobby_id = 35;


    pub fn get_associated_lobby_id(&self) -> u64 {
        self.associated_lobby_id.unwrap_or(0)
    }
    pub fn clear_associated_lobby_id(&mut self) {
        self.associated_lobby_id = ::std::option::Option::None;
    }

    pub fn has_associated_lobby_id(&self) -> bool {
        self.associated_lobby_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_associated_lobby_id(&mut self, v: u64) {
        self.associated_lobby_id = ::std::option::Option::Some(v);
    }

    // optional .ETFMatchGroup associated_lobby_match_group = 40;


    pub fn get_associated_lobby_match_group(&self) -> ETFMatchGroup {
        self.associated_lobby_match_group.unwrap_or(ETFMatchGroup::k_eTFMatchGroup_Invalid)
    }
    pub fn clear_associated_lobby_match_group(&mut self) {
        self.associated_lobby_match_group = ::std::option::Option::None;
    }

    pub fn has_associated_lobby_match_group(&self) -> bool {
        self.associated_lobby_match_group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_associated_lobby_match_group(&mut self, v: ETFMatchGroup) {
        self.associated_lobby_match_group = ::std::option::Option::Some(v);
    }

    // repeated .CSOTFParty.QueueEntry matchmaking_queues = 43;


    pub fn get_matchmaking_queues(&self) -> &[CSOTFParty_QueueEntry] {
        &self.matchmaking_queues
    }
    pub fn clear_matchmaking_queues(&mut self) {
        self.matchmaking_queues.clear();
    }

    // Param is passed by value, moved
    pub fn set_matchmaking_queues(&mut self, v: ::protobuf::RepeatedField<CSOTFParty_QueueEntry>) {
        self.matchmaking_queues = v;
    }

    // Mutable pointer to the field.
    pub fn mut_matchmaking_queues(&mut self) -> &mut ::protobuf::RepeatedField<CSOTFParty_QueueEntry> {
        &mut self.matchmaking_queues
    }

    // Take field
    pub fn take_matchmaking_queues(&mut self) -> ::protobuf::RepeatedField<CSOTFParty_QueueEntry> {
        ::std::mem::replace(&mut self.matchmaking_queues, ::protobuf::RepeatedField::new())
    }

    // optional .CTFGroupMatchCriteriaProto group_criteria = 37;


    pub fn get_group_criteria(&self) -> &CTFGroupMatchCriteriaProto {
        self.group_criteria.as_ref().unwrap_or_else(|| <CTFGroupMatchCriteriaProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_group_criteria(&mut self) {
        self.group_criteria.clear();
    }

    pub fn has_group_criteria(&self) -> bool {
        self.group_criteria.is_some()
    }

    // Param is passed by value, moved
    pub fn set_group_criteria(&mut self, v: CTFGroupMatchCriteriaProto) {
        self.group_criteria = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_group_criteria(&mut self) -> &mut CTFGroupMatchCriteriaProto {
        if self.group_criteria.is_none() {
            self.group_criteria.set_default();
        }
        self.group_criteria.as_mut().unwrap()
    }

    // Take field
    pub fn take_group_criteria(&mut self) -> CTFGroupMatchCriteriaProto {
        self.group_criteria.take().unwrap_or_else(|| CTFGroupMatchCriteriaProto::new())
    }

    // optional uint32 casual_banned_time = 18;


    pub fn get_casual_banned_time(&self) -> u32 {
        self.casual_banned_time.unwrap_or(0)
    }
    pub fn clear_casual_banned_time(&mut self) {
        self.casual_banned_time = ::std::option::Option::None;
    }

    pub fn has_casual_banned_time(&self) -> bool {
        self.casual_banned_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_casual_banned_time(&mut self, v: u32) {
        self.casual_banned_time = ::std::option::Option::Some(v);
    }

    // optional uint32 casual_low_priority_time = 20;


    pub fn get_casual_low_priority_time(&self) -> u32 {
        self.casual_low_priority_time.unwrap_or(0)
    }
    pub fn clear_casual_low_priority_time(&mut self) {
        self.casual_low_priority_time = ::std::option::Option::None;
    }

    pub fn has_casual_low_priority_time(&self) -> bool {
        self.casual_low_priority_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_casual_low_priority_time(&mut self, v: u32) {
        self.casual_low_priority_time = ::std::option::Option::Some(v);
    }

    // optional uint32 ranked_banned_time = 41;


    pub fn get_ranked_banned_time(&self) -> u32 {
        self.ranked_banned_time.unwrap_or(0)
    }
    pub fn clear_ranked_banned_time(&mut self) {
        self.ranked_banned_time = ::std::option::Option::None;
    }

    pub fn has_ranked_banned_time(&self) -> bool {
        self.ranked_banned_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ranked_banned_time(&mut self, v: u32) {
        self.ranked_banned_time = ::std::option::Option::Some(v);
    }

    // optional uint32 ranked_low_priority_time = 42;


    pub fn get_ranked_low_priority_time(&self) -> u32 {
        self.ranked_low_priority_time.unwrap_or(0)
    }
    pub fn clear_ranked_low_priority_time(&mut self) {
        self.ranked_low_priority_time = ::std::option::Option::None;
    }

    pub fn has_ranked_low_priority_time(&self) -> bool {
        self.ranked_low_priority_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ranked_low_priority_time(&mut self, v: u32) {
        self.ranked_low_priority_time = ::std::option::Option::Some(v);
    }

    // optional .TFSyncedMMUIState leader_ui_state = 44;


    pub fn get_leader_ui_state(&self) -> &TFSyncedMMUIState {
        self.leader_ui_state.as_ref().unwrap_or_else(|| <TFSyncedMMUIState as ::protobuf::Message>::default_instance())
    }
    pub fn clear_leader_ui_state(&mut self) {
        self.leader_ui_state.clear();
    }

    pub fn has_leader_ui_state(&self) -> bool {
        self.leader_ui_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leader_ui_state(&mut self, v: TFSyncedMMUIState) {
        self.leader_ui_state = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_leader_ui_state(&mut self) -> &mut TFSyncedMMUIState {
        if self.leader_ui_state.is_none() {
            self.leader_ui_state.set_default();
        }
        self.leader_ui_state.as_mut().unwrap()
    }

    // Take field
    pub fn take_leader_ui_state(&mut self) -> TFSyncedMMUIState {
        self.leader_ui_state.take().unwrap_or_else(|| TFSyncedMMUIState::new())
    }

    // repeated .TFPendingPartyMember pending_members = 39;


    pub fn get_pending_members(&self) -> &[TFPendingPartyMember] {
        &self.pending_members
    }
    pub fn clear_pending_members(&mut self) {
        self.pending_members.clear();
    }

    // Param is passed by value, moved
    pub fn set_pending_members(&mut self, v: ::protobuf::RepeatedField<TFPendingPartyMember>) {
        self.pending_members = v;
    }

    // Mutable pointer to the field.
    pub fn mut_pending_members(&mut self) -> &mut ::protobuf::RepeatedField<TFPendingPartyMember> {
        &mut self.pending_members
    }

    // Take field
    pub fn take_pending_members(&mut self) -> ::protobuf::RepeatedField<TFPendingPartyMember> {
        ::std::mem::replace(&mut self.pending_members, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CSOTFParty {
    fn is_initialized(&self) -> bool {
        for v in &self.members {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.matchmaking_queues {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.group_criteria {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.leader_ui_state {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pending_members {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.party_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.leader_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_fixed64_into(wire_type, is, &mut self.member_ids)?;
                },
                13 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.members)?;
                },
                35 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.associated_lobby_id = ::std::option::Option::Some(tmp);
                },
                40 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.associated_lobby_match_group, 40, &mut self.unknown_fields)?
                },
                43 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.matchmaking_queues)?;
                },
                37 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.group_criteria)?;
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.casual_banned_time = ::std::option::Option::Some(tmp);
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.casual_low_priority_time = ::std::option::Option::Some(tmp);
                },
                41 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ranked_banned_time = ::std::option::Option::Some(tmp);
                },
                42 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ranked_low_priority_time = ::std::option::Option::Some(tmp);
                },
                44 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.leader_ui_state)?;
                },
                39 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.pending_members)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.party_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.leader_id {
            my_size += 9;
        }
        my_size += 9 * self.member_ids.len() as u32;
        for value in &self.members {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.associated_lobby_id {
            my_size += ::protobuf::rt::value_size(35, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.associated_lobby_match_group {
            my_size += ::protobuf::rt::enum_size(40, v);
        }
        for value in &self.matchmaking_queues {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.group_criteria.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.casual_banned_time {
            my_size += ::protobuf::rt::value_size(18, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.casual_low_priority_time {
            my_size += ::protobuf::rt::value_size(20, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ranked_banned_time {
            my_size += ::protobuf::rt::value_size(41, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ranked_low_priority_time {
            my_size += ::protobuf::rt::value_size(42, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.leader_ui_state.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.pending_members {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.party_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.leader_id {
            os.write_fixed64(2, v)?;
        }
        for v in &self.member_ids {
            os.write_fixed64(3, *v)?;
        };
        for v in &self.members {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.associated_lobby_id {
            os.write_uint64(35, v)?;
        }
        if let Some(v) = self.associated_lobby_match_group {
            os.write_enum(40, ::protobuf::ProtobufEnum::value(&v))?;
        }
        for v in &self.matchmaking_queues {
            os.write_tag(43, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.group_criteria.as_ref() {
            os.write_tag(37, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.casual_banned_time {
            os.write_uint32(18, v)?;
        }
        if let Some(v) = self.casual_low_priority_time {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.ranked_banned_time {
            os.write_uint32(41, v)?;
        }
        if let Some(v) = self.ranked_low_priority_time {
            os.write_uint32(42, v)?;
        }
        if let Some(ref v) = self.leader_ui_state.as_ref() {
            os.write_tag(44, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.pending_members {
            os.write_tag(39, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CSOTFParty {
        CSOTFParty::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "party_id",
                |m: &CSOTFParty| { &m.party_id },
                |m: &mut CSOTFParty| { &mut m.party_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "leader_id",
                |m: &CSOTFParty| { &m.leader_id },
                |m: &mut CSOTFParty| { &mut m.leader_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "member_ids",
                |m: &CSOTFParty| { &m.member_ids },
                |m: &mut CSOTFParty| { &mut m.member_ids },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CSOTFPartyMember>>(
                "members",
                |m: &CSOTFParty| { &m.members },
                |m: &mut CSOTFParty| { &mut m.members },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "associated_lobby_id",
                |m: &CSOTFParty| { &m.associated_lobby_id },
                |m: &mut CSOTFParty| { &mut m.associated_lobby_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ETFMatchGroup>>(
                "associated_lobby_match_group",
                |m: &CSOTFParty| { &m.associated_lobby_match_group },
                |m: &mut CSOTFParty| { &mut m.associated_lobby_match_group },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CSOTFParty_QueueEntry>>(
                "matchmaking_queues",
                |m: &CSOTFParty| { &m.matchmaking_queues },
                |m: &mut CSOTFParty| { &mut m.matchmaking_queues },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CTFGroupMatchCriteriaProto>>(
                "group_criteria",
                |m: &CSOTFParty| { &m.group_criteria },
                |m: &mut CSOTFParty| { &mut m.group_criteria },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "casual_banned_time",
                |m: &CSOTFParty| { &m.casual_banned_time },
                |m: &mut CSOTFParty| { &mut m.casual_banned_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "casual_low_priority_time",
                |m: &CSOTFParty| { &m.casual_low_priority_time },
                |m: &mut CSOTFParty| { &mut m.casual_low_priority_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ranked_banned_time",
                |m: &CSOTFParty| { &m.ranked_banned_time },
                |m: &mut CSOTFParty| { &mut m.ranked_banned_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ranked_low_priority_time",
                |m: &CSOTFParty| { &m.ranked_low_priority_time },
                |m: &mut CSOTFParty| { &mut m.ranked_low_priority_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TFSyncedMMUIState>>(
                "leader_ui_state",
                |m: &CSOTFParty| { &m.leader_ui_state },
                |m: &mut CSOTFParty| { &mut m.leader_ui_state },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TFPendingPartyMember>>(
                "pending_members",
                |m: &CSOTFParty| { &m.pending_members },
                |m: &mut CSOTFParty| { &mut m.pending_members },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CSOTFParty>(
                "CSOTFParty",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CSOTFParty {
        static instance: ::protobuf::rt::LazyV2<CSOTFParty> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CSOTFParty::new)
    }
}

impl ::protobuf::Clear for CSOTFParty {
    fn clear(&mut self) {
        self.party_id = ::std::option::Option::None;
        self.leader_id = ::std::option::Option::None;
        self.member_ids.clear();
        self.members.clear();
        self.associated_lobby_id = ::std::option::Option::None;
        self.associated_lobby_match_group = ::std::option::Option::None;
        self.matchmaking_queues.clear();
        self.group_criteria.clear();
        self.casual_banned_time = ::std::option::Option::None;
        self.casual_low_priority_time = ::std::option::Option::None;
        self.ranked_banned_time = ::std::option::Option::None;
        self.ranked_low_priority_time = ::std::option::Option::None;
        self.leader_ui_state.clear();
        self.pending_members.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSOTFParty {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOTFParty {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CSOTFParty_QueueEntry {
    // message fields
    match_group: ::std::option::Option<ETFMatchGroup>,
    queued_time: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CSOTFParty_QueueEntry {
    fn default() -> &'a CSOTFParty_QueueEntry {
        <CSOTFParty_QueueEntry as ::protobuf::Message>::default_instance()
    }
}

impl CSOTFParty_QueueEntry {
    pub fn new() -> CSOTFParty_QueueEntry {
        ::std::default::Default::default()
    }

    // optional .ETFMatchGroup match_group = 1;


    pub fn get_match_group(&self) -> ETFMatchGroup {
        self.match_group.unwrap_or(ETFMatchGroup::k_eTFMatchGroup_Invalid)
    }
    pub fn clear_match_group(&mut self) {
        self.match_group = ::std::option::Option::None;
    }

    pub fn has_match_group(&self) -> bool {
        self.match_group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_group(&mut self, v: ETFMatchGroup) {
        self.match_group = ::std::option::Option::Some(v);
    }

    // optional fixed32 queued_time = 2;


    pub fn get_queued_time(&self) -> u32 {
        self.queued_time.unwrap_or(0)
    }
    pub fn clear_queued_time(&mut self) {
        self.queued_time = ::std::option::Option::None;
    }

    pub fn has_queued_time(&self) -> bool {
        self.queued_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_queued_time(&mut self, v: u32) {
        self.queued_time = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CSOTFParty_QueueEntry {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.match_group, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.queued_time = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.match_group {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.queued_time {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.match_group {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.queued_time {
            os.write_fixed32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CSOTFParty_QueueEntry {
        CSOTFParty_QueueEntry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ETFMatchGroup>>(
                "match_group",
                |m: &CSOTFParty_QueueEntry| { &m.match_group },
                |m: &mut CSOTFParty_QueueEntry| { &mut m.match_group },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "queued_time",
                |m: &CSOTFParty_QueueEntry| { &m.queued_time },
                |m: &mut CSOTFParty_QueueEntry| { &mut m.queued_time },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CSOTFParty_QueueEntry>(
                "CSOTFParty.QueueEntry",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CSOTFParty_QueueEntry {
        static instance: ::protobuf::rt::LazyV2<CSOTFParty_QueueEntry> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CSOTFParty_QueueEntry::new)
    }
}

impl ::protobuf::Clear for CSOTFParty_QueueEntry {
    fn clear(&mut self) {
        self.match_group = ::std::option::Option::None;
        self.queued_time = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSOTFParty_QueueEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOTFParty_QueueEntry {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CSOTFPartyInvite {
    // message fields
    group_id: ::std::option::Option<u64>,
    inviter: ::std::option::Option<u64>,
    pub members: ::protobuf::RepeatedField<CSOTFPartyInvite_PartyMember>,
    field_type: ::std::option::Option<CSOTFPartyInvite_Type>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CSOTFPartyInvite {
    fn default() -> &'a CSOTFPartyInvite {
        <CSOTFPartyInvite as ::protobuf::Message>::default_instance()
    }
}

impl CSOTFPartyInvite {
    pub fn new() -> CSOTFPartyInvite {
        ::std::default::Default::default()
    }

    // optional uint64 group_id = 1;


    pub fn get_group_id(&self) -> u64 {
        self.group_id.unwrap_or(0)
    }
    pub fn clear_group_id(&mut self) {
        self.group_id = ::std::option::Option::None;
    }

    pub fn has_group_id(&self) -> bool {
        self.group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_group_id(&mut self, v: u64) {
        self.group_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 inviter = 2;


    pub fn get_inviter(&self) -> u64 {
        self.inviter.unwrap_or(0)
    }
    pub fn clear_inviter(&mut self) {
        self.inviter = ::std::option::Option::None;
    }

    pub fn has_inviter(&self) -> bool {
        self.inviter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inviter(&mut self, v: u64) {
        self.inviter = ::std::option::Option::Some(v);
    }

    // repeated .CSOTFPartyInvite.PartyMember members = 4;


    pub fn get_members(&self) -> &[CSOTFPartyInvite_PartyMember] {
        &self.members
    }
    pub fn clear_members(&mut self) {
        self.members.clear();
    }

    // Param is passed by value, moved
    pub fn set_members(&mut self, v: ::protobuf::RepeatedField<CSOTFPartyInvite_PartyMember>) {
        self.members = v;
    }

    // Mutable pointer to the field.
    pub fn mut_members(&mut self) -> &mut ::protobuf::RepeatedField<CSOTFPartyInvite_PartyMember> {
        &mut self.members
    }

    // Take field
    pub fn take_members(&mut self) -> ::protobuf::RepeatedField<CSOTFPartyInvite_PartyMember> {
        ::std::mem::replace(&mut self.members, ::protobuf::RepeatedField::new())
    }

    // optional .CSOTFPartyInvite.Type type = 5;


    pub fn get_field_type(&self) -> CSOTFPartyInvite_Type {
        self.field_type.unwrap_or(CSOTFPartyInvite_Type::PENDING_INVITE)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: CSOTFPartyInvite_Type) {
        self.field_type = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CSOTFPartyInvite {
    fn is_initialized(&self) -> bool {
        for v in &self.members {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.group_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.inviter = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.members)?;
                },
                5 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 5, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.inviter {
            my_size += 9;
        }
        for value in &self.members {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.inviter {
            os.write_fixed64(2, v)?;
        }
        for v in &self.members {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.field_type {
            os.write_enum(5, ::protobuf::ProtobufEnum::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CSOTFPartyInvite {
        CSOTFPartyInvite::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "group_id",
                |m: &CSOTFPartyInvite| { &m.group_id },
                |m: &mut CSOTFPartyInvite| { &mut m.group_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "inviter",
                |m: &CSOTFPartyInvite| { &m.inviter },
                |m: &mut CSOTFPartyInvite| { &mut m.inviter },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CSOTFPartyInvite_PartyMember>>(
                "members",
                |m: &CSOTFPartyInvite| { &m.members },
                |m: &mut CSOTFPartyInvite| { &mut m.members },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CSOTFPartyInvite_Type>>(
                "type",
                |m: &CSOTFPartyInvite| { &m.field_type },
                |m: &mut CSOTFPartyInvite| { &mut m.field_type },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CSOTFPartyInvite>(
                "CSOTFPartyInvite",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CSOTFPartyInvite {
        static instance: ::protobuf::rt::LazyV2<CSOTFPartyInvite> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CSOTFPartyInvite::new)
    }
}

impl ::protobuf::Clear for CSOTFPartyInvite {
    fn clear(&mut self) {
        self.group_id = ::std::option::Option::None;
        self.inviter = ::std::option::Option::None;
        self.members.clear();
        self.field_type = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSOTFPartyInvite {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOTFPartyInvite {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CSOTFPartyInvite_PartyMember {
    // message fields
    steamid: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CSOTFPartyInvite_PartyMember {
    fn default() -> &'a CSOTFPartyInvite_PartyMember {
        <CSOTFPartyInvite_PartyMember as ::protobuf::Message>::default_instance()
    }
}

impl CSOTFPartyInvite_PartyMember {
    pub fn new() -> CSOTFPartyInvite_PartyMember {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 2;


    pub fn get_steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }
    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CSOTFPartyInvite_PartyMember {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CSOTFPartyInvite_PartyMember {
        CSOTFPartyInvite_PartyMember::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steamid",
                |m: &CSOTFPartyInvite_PartyMember| { &m.steamid },
                |m: &mut CSOTFPartyInvite_PartyMember| { &mut m.steamid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CSOTFPartyInvite_PartyMember>(
                "CSOTFPartyInvite.PartyMember",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CSOTFPartyInvite_PartyMember {
        static instance: ::protobuf::rt::LazyV2<CSOTFPartyInvite_PartyMember> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CSOTFPartyInvite_PartyMember::new)
    }
}

impl ::protobuf::Clear for CSOTFPartyInvite_PartyMember {
    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSOTFPartyInvite_PartyMember {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOTFPartyInvite_PartyMember {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CSOTFPartyInvite_Type {
    PENDING_INVITE = 1,
    PENDING_JOIN_REQUEST = 2,
}

impl ::protobuf::ProtobufEnum for CSOTFPartyInvite_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CSOTFPartyInvite_Type> {
        match value {
            1 => ::std::option::Option::Some(CSOTFPartyInvite_Type::PENDING_INVITE),
            2 => ::std::option::Option::Some(CSOTFPartyInvite_Type::PENDING_JOIN_REQUEST),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CSOTFPartyInvite_Type] = &[
            CSOTFPartyInvite_Type::PENDING_INVITE,
            CSOTFPartyInvite_Type::PENDING_JOIN_REQUEST,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<CSOTFPartyInvite_Type>("CSOTFPartyInvite.Type", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for CSOTFPartyInvite_Type {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for CSOTFPartyInvite_Type {
    fn default() -> Self {
        CSOTFPartyInvite_Type::PENDING_INVITE
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOTFPartyInvite_Type {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CTFLobbyPlayerProto {
    // message fields
    id: ::std::option::Option<u64>,
    team: ::std::option::Option<TF_GC_TEAM>,
    connect_state: ::std::option::Option<CTFLobbyPlayerProto_ConnectState>,
    name: ::protobuf::SingularField<::std::string::String>,
    original_party_id: ::std::option::Option<u64>,
    squad_surplus: ::std::option::Option<bool>,
    badge_level: ::std::option::Option<u32>,
    last_connect_time: ::std::option::Option<u32>,
    field_type: ::std::option::Option<CTFLobbyPlayerProto_Type>,
    normalized_rating: ::std::option::Option<f64>,
    normalized_uncertainty: ::std::option::Option<f64>,
    rank: ::std::option::Option<u32>,
    chat_suspension: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CTFLobbyPlayerProto {
    fn default() -> &'a CTFLobbyPlayerProto {
        <CTFLobbyPlayerProto as ::protobuf::Message>::default_instance()
    }
}

impl CTFLobbyPlayerProto {
    pub fn new() -> CTFLobbyPlayerProto {
        ::std::default::Default::default()
    }

    // optional fixed64 id = 1;


    pub fn get_id(&self) -> u64 {
        self.id.unwrap_or(0)
    }
    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u64) {
        self.id = ::std::option::Option::Some(v);
    }

    // optional .TF_GC_TEAM team = 3;


    pub fn get_team(&self) -> TF_GC_TEAM {
        self.team.unwrap_or(TF_GC_TEAM::TF_GC_TEAM_DEFENDERS)
    }
    pub fn clear_team(&mut self) {
        self.team = ::std::option::Option::None;
    }

    pub fn has_team(&self) -> bool {
        self.team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team(&mut self, v: TF_GC_TEAM) {
        self.team = ::std::option::Option::Some(v);
    }

    // optional .CTFLobbyPlayerProto.ConnectState connect_state = 13;


    pub fn get_connect_state(&self) -> CTFLobbyPlayerProto_ConnectState {
        self.connect_state.unwrap_or(CTFLobbyPlayerProto_ConnectState::INVALID)
    }
    pub fn clear_connect_state(&mut self) {
        self.connect_state = ::std::option::Option::None;
    }

    pub fn has_connect_state(&self) -> bool {
        self.connect_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connect_state(&mut self, v: CTFLobbyPlayerProto_ConnectState) {
        self.connect_state = ::std::option::Option::Some(v);
    }

    // optional string name = 6;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 original_party_id = 12;


    pub fn get_original_party_id(&self) -> u64 {
        self.original_party_id.unwrap_or(0)
    }
    pub fn clear_original_party_id(&mut self) {
        self.original_party_id = ::std::option::Option::None;
    }

    pub fn has_original_party_id(&self) -> bool {
        self.original_party_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_original_party_id(&mut self, v: u64) {
        self.original_party_id = ::std::option::Option::Some(v);
    }

    // optional bool squad_surplus = 14;


    pub fn get_squad_surplus(&self) -> bool {
        self.squad_surplus.unwrap_or(false)
    }
    pub fn clear_squad_surplus(&mut self) {
        self.squad_surplus = ::std::option::Option::None;
    }

    pub fn has_squad_surplus(&self) -> bool {
        self.squad_surplus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_squad_surplus(&mut self, v: bool) {
        self.squad_surplus = ::std::option::Option::Some(v);
    }

    // optional uint32 badge_level = 15;


    pub fn get_badge_level(&self) -> u32 {
        self.badge_level.unwrap_or(0)
    }
    pub fn clear_badge_level(&mut self) {
        self.badge_level = ::std::option::Option::None;
    }

    pub fn has_badge_level(&self) -> bool {
        self.badge_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_badge_level(&mut self, v: u32) {
        self.badge_level = ::std::option::Option::Some(v);
    }

    // optional uint32 last_connect_time = 17;


    pub fn get_last_connect_time(&self) -> u32 {
        self.last_connect_time.unwrap_or(0)
    }
    pub fn clear_last_connect_time(&mut self) {
        self.last_connect_time = ::std::option::Option::None;
    }

    pub fn has_last_connect_time(&self) -> bool {
        self.last_connect_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_connect_time(&mut self, v: u32) {
        self.last_connect_time = ::std::option::Option::Some(v);
    }

    // optional .CTFLobbyPlayerProto.Type type = 19;


    pub fn get_field_type(&self) -> CTFLobbyPlayerProto_Type {
        self.field_type.unwrap_or(CTFLobbyPlayerProto_Type::INVALID_PLAYER)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: CTFLobbyPlayerProto_Type) {
        self.field_type = ::std::option::Option::Some(v);
    }

    // optional double normalized_rating = 20;


    pub fn get_normalized_rating(&self) -> f64 {
        self.normalized_rating.unwrap_or(0.)
    }
    pub fn clear_normalized_rating(&mut self) {
        self.normalized_rating = ::std::option::Option::None;
    }

    pub fn has_normalized_rating(&self) -> bool {
        self.normalized_rating.is_some()
    }

    // Param is passed by value, moved
    pub fn set_normalized_rating(&mut self, v: f64) {
        self.normalized_rating = ::std::option::Option::Some(v);
    }

    // optional double normalized_uncertainty = 22;


    pub fn get_normalized_uncertainty(&self) -> f64 {
        self.normalized_uncertainty.unwrap_or(0.)
    }
    pub fn clear_normalized_uncertainty(&mut self) {
        self.normalized_uncertainty = ::std::option::Option::None;
    }

    pub fn has_normalized_uncertainty(&self) -> bool {
        self.normalized_uncertainty.is_some()
    }

    // Param is passed by value, moved
    pub fn set_normalized_uncertainty(&mut self, v: f64) {
        self.normalized_uncertainty = ::std::option::Option::Some(v);
    }

    // optional uint32 rank = 21;


    pub fn get_rank(&self) -> u32 {
        self.rank.unwrap_or(0)
    }
    pub fn clear_rank(&mut self) {
        self.rank = ::std::option::Option::None;
    }

    pub fn has_rank(&self) -> bool {
        self.rank.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rank(&mut self, v: u32) {
        self.rank = ::std::option::Option::Some(v);
    }

    // optional bool chat_suspension = 23;


    pub fn get_chat_suspension(&self) -> bool {
        self.chat_suspension.unwrap_or(false)
    }
    pub fn clear_chat_suspension(&mut self) {
        self.chat_suspension = ::std::option::Option::None;
    }

    pub fn has_chat_suspension(&self) -> bool {
        self.chat_suspension.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_suspension(&mut self, v: bool) {
        self.chat_suspension = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CTFLobbyPlayerProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.team, 3, &mut self.unknown_fields)?
                },
                13 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.connect_state, 13, &mut self.unknown_fields)?
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.original_party_id = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.squad_surplus = ::std::option::Option::Some(tmp);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.badge_level = ::std::option::Option::Some(tmp);
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.last_connect_time = ::std::option::Option::Some(tmp);
                },
                19 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 19, &mut self.unknown_fields)?
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.normalized_rating = ::std::option::Option::Some(tmp);
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.normalized_uncertainty = ::std::option::Option::Some(tmp);
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rank = ::std::option::Option::Some(tmp);
                },
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.chat_suspension = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += 9;
        }
        if let Some(v) = self.team {
            my_size += ::protobuf::rt::enum_size(3, v);
        }
        if let Some(v) = self.connect_state {
            my_size += ::protobuf::rt::enum_size(13, v);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.original_party_id {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.squad_surplus {
            my_size += 2;
        }
        if let Some(v) = self.badge_level {
            my_size += ::protobuf::rt::value_size(15, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.last_connect_time {
            my_size += ::protobuf::rt::value_size(17, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(19, v);
        }
        if let Some(v) = self.normalized_rating {
            my_size += 10;
        }
        if let Some(v) = self.normalized_uncertainty {
            my_size += 10;
        }
        if let Some(v) = self.rank {
            my_size += ::protobuf::rt::value_size(21, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.chat_suspension {
            my_size += 3;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.team {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.connect_state {
            os.write_enum(13, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(v) = self.original_party_id {
            os.write_uint64(12, v)?;
        }
        if let Some(v) = self.squad_surplus {
            os.write_bool(14, v)?;
        }
        if let Some(v) = self.badge_level {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.last_connect_time {
            os.write_uint32(17, v)?;
        }
        if let Some(v) = self.field_type {
            os.write_enum(19, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.normalized_rating {
            os.write_double(20, v)?;
        }
        if let Some(v) = self.normalized_uncertainty {
            os.write_double(22, v)?;
        }
        if let Some(v) = self.rank {
            os.write_uint32(21, v)?;
        }
        if let Some(v) = self.chat_suspension {
            os.write_bool(23, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CTFLobbyPlayerProto {
        CTFLobbyPlayerProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "id",
                |m: &CTFLobbyPlayerProto| { &m.id },
                |m: &mut CTFLobbyPlayerProto| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TF_GC_TEAM>>(
                "team",
                |m: &CTFLobbyPlayerProto| { &m.team },
                |m: &mut CTFLobbyPlayerProto| { &mut m.team },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CTFLobbyPlayerProto_ConnectState>>(
                "connect_state",
                |m: &CTFLobbyPlayerProto| { &m.connect_state },
                |m: &mut CTFLobbyPlayerProto| { &mut m.connect_state },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &CTFLobbyPlayerProto| { &m.name },
                |m: &mut CTFLobbyPlayerProto| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "original_party_id",
                |m: &CTFLobbyPlayerProto| { &m.original_party_id },
                |m: &mut CTFLobbyPlayerProto| { &mut m.original_party_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "squad_surplus",
                |m: &CTFLobbyPlayerProto| { &m.squad_surplus },
                |m: &mut CTFLobbyPlayerProto| { &mut m.squad_surplus },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "badge_level",
                |m: &CTFLobbyPlayerProto| { &m.badge_level },
                |m: &mut CTFLobbyPlayerProto| { &mut m.badge_level },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "last_connect_time",
                |m: &CTFLobbyPlayerProto| { &m.last_connect_time },
                |m: &mut CTFLobbyPlayerProto| { &mut m.last_connect_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CTFLobbyPlayerProto_Type>>(
                "type",
                |m: &CTFLobbyPlayerProto| { &m.field_type },
                |m: &mut CTFLobbyPlayerProto| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "normalized_rating",
                |m: &CTFLobbyPlayerProto| { &m.normalized_rating },
                |m: &mut CTFLobbyPlayerProto| { &mut m.normalized_rating },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "normalized_uncertainty",
                |m: &CTFLobbyPlayerProto| { &m.normalized_uncertainty },
                |m: &mut CTFLobbyPlayerProto| { &mut m.normalized_uncertainty },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "rank",
                |m: &CTFLobbyPlayerProto| { &m.rank },
                |m: &mut CTFLobbyPlayerProto| { &mut m.rank },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "chat_suspension",
                |m: &CTFLobbyPlayerProto| { &m.chat_suspension },
                |m: &mut CTFLobbyPlayerProto| { &mut m.chat_suspension },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CTFLobbyPlayerProto>(
                "CTFLobbyPlayerProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CTFLobbyPlayerProto {
        static instance: ::protobuf::rt::LazyV2<CTFLobbyPlayerProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CTFLobbyPlayerProto::new)
    }
}

impl ::protobuf::Clear for CTFLobbyPlayerProto {
    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.team = ::std::option::Option::None;
        self.connect_state = ::std::option::Option::None;
        self.name.clear();
        self.original_party_id = ::std::option::Option::None;
        self.squad_surplus = ::std::option::Option::None;
        self.badge_level = ::std::option::Option::None;
        self.last_connect_time = ::std::option::Option::None;
        self.field_type = ::std::option::Option::None;
        self.normalized_rating = ::std::option::Option::None;
        self.normalized_uncertainty = ::std::option::Option::None;
        self.rank = ::std::option::Option::None;
        self.chat_suspension = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CTFLobbyPlayerProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CTFLobbyPlayerProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CTFLobbyPlayerProto_ConnectState {
    INVALID = 0,
    RESERVATION_PENDING = 1,
    RESERVED = 2,
    CONNECTED = 3,
    DISCONNECTED = 5,
}

impl ::protobuf::ProtobufEnum for CTFLobbyPlayerProto_ConnectState {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CTFLobbyPlayerProto_ConnectState> {
        match value {
            0 => ::std::option::Option::Some(CTFLobbyPlayerProto_ConnectState::INVALID),
            1 => ::std::option::Option::Some(CTFLobbyPlayerProto_ConnectState::RESERVATION_PENDING),
            2 => ::std::option::Option::Some(CTFLobbyPlayerProto_ConnectState::RESERVED),
            3 => ::std::option::Option::Some(CTFLobbyPlayerProto_ConnectState::CONNECTED),
            5 => ::std::option::Option::Some(CTFLobbyPlayerProto_ConnectState::DISCONNECTED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CTFLobbyPlayerProto_ConnectState] = &[
            CTFLobbyPlayerProto_ConnectState::INVALID,
            CTFLobbyPlayerProto_ConnectState::RESERVATION_PENDING,
            CTFLobbyPlayerProto_ConnectState::RESERVED,
            CTFLobbyPlayerProto_ConnectState::CONNECTED,
            CTFLobbyPlayerProto_ConnectState::DISCONNECTED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<CTFLobbyPlayerProto_ConnectState>("CTFLobbyPlayerProto.ConnectState", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for CTFLobbyPlayerProto_ConnectState {
}

impl ::std::default::Default for CTFLobbyPlayerProto_ConnectState {
    fn default() -> Self {
        CTFLobbyPlayerProto_ConnectState::INVALID
    }
}

impl ::protobuf::reflect::ProtobufValue for CTFLobbyPlayerProto_ConnectState {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CTFLobbyPlayerProto_Type {
    INVALID_PLAYER = 0,
    MATCH_PLAYER = 1,
    STANDBY_PLAYER = 2,
    OBSERVING_PLAYER = 3,
}

impl ::protobuf::ProtobufEnum for CTFLobbyPlayerProto_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CTFLobbyPlayerProto_Type> {
        match value {
            0 => ::std::option::Option::Some(CTFLobbyPlayerProto_Type::INVALID_PLAYER),
            1 => ::std::option::Option::Some(CTFLobbyPlayerProto_Type::MATCH_PLAYER),
            2 => ::std::option::Option::Some(CTFLobbyPlayerProto_Type::STANDBY_PLAYER),
            3 => ::std::option::Option::Some(CTFLobbyPlayerProto_Type::OBSERVING_PLAYER),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CTFLobbyPlayerProto_Type] = &[
            CTFLobbyPlayerProto_Type::INVALID_PLAYER,
            CTFLobbyPlayerProto_Type::MATCH_PLAYER,
            CTFLobbyPlayerProto_Type::STANDBY_PLAYER,
            CTFLobbyPlayerProto_Type::OBSERVING_PLAYER,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<CTFLobbyPlayerProto_Type>("CTFLobbyPlayerProto.Type", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for CTFLobbyPlayerProto_Type {
}

impl ::std::default::Default for CTFLobbyPlayerProto_Type {
    fn default() -> Self {
        CTFLobbyPlayerProto_Type::INVALID_PLAYER
    }
}

impl ::protobuf::reflect::ProtobufValue for CTFLobbyPlayerProto_Type {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CTFLobbyInviteProto {
    // message fields
    lobby_id: ::std::option::Option<u64>,
    match_group: ::std::option::Option<ETFMatchGroup>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CTFLobbyInviteProto {
    fn default() -> &'a CTFLobbyInviteProto {
        <CTFLobbyInviteProto as ::protobuf::Message>::default_instance()
    }
}

impl CTFLobbyInviteProto {
    pub fn new() -> CTFLobbyInviteProto {
        ::std::default::Default::default()
    }

    // optional fixed64 lobby_id = 1;


    pub fn get_lobby_id(&self) -> u64 {
        self.lobby_id.unwrap_or(0)
    }
    pub fn clear_lobby_id(&mut self) {
        self.lobby_id = ::std::option::Option::None;
    }

    pub fn has_lobby_id(&self) -> bool {
        self.lobby_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_id(&mut self, v: u64) {
        self.lobby_id = ::std::option::Option::Some(v);
    }

    // optional .ETFMatchGroup match_group = 2;


    pub fn get_match_group(&self) -> ETFMatchGroup {
        self.match_group.unwrap_or(ETFMatchGroup::k_eTFMatchGroup_Invalid)
    }
    pub fn clear_match_group(&mut self) {
        self.match_group = ::std::option::Option::None;
    }

    pub fn has_match_group(&self) -> bool {
        self.match_group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_group(&mut self, v: ETFMatchGroup) {
        self.match_group = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CTFLobbyInviteProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.lobby_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.match_group, 2, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.lobby_id {
            my_size += 9;
        }
        if let Some(v) = self.match_group {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.lobby_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.match_group {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CTFLobbyInviteProto {
        CTFLobbyInviteProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "lobby_id",
                |m: &CTFLobbyInviteProto| { &m.lobby_id },
                |m: &mut CTFLobbyInviteProto| { &mut m.lobby_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ETFMatchGroup>>(
                "match_group",
                |m: &CTFLobbyInviteProto| { &m.match_group },
                |m: &mut CTFLobbyInviteProto| { &mut m.match_group },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CTFLobbyInviteProto>(
                "CTFLobbyInviteProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CTFLobbyInviteProto {
        static instance: ::protobuf::rt::LazyV2<CTFLobbyInviteProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CTFLobbyInviteProto::new)
    }
}

impl ::protobuf::Clear for CTFLobbyInviteProto {
    fn clear(&mut self) {
        self.lobby_id = ::std::option::Option::None;
        self.match_group = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CTFLobbyInviteProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CTFLobbyInviteProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CSOTFGameServerLobby {
    // message fields
    lobby_id: ::std::option::Option<u64>,
    pub members: ::protobuf::RepeatedField<CTFLobbyPlayerProto>,
    server_id: ::std::option::Option<u64>,
    state: ::std::option::Option<CSOTFGameServerLobby_State>,
    connect: ::protobuf::SingularField<::std::string::String>,
    game_state: ::std::option::Option<TF_GC_GameState>,
    initial_average_mm_rating: ::std::option::Option<f64>,
    mannup_tour_name: ::protobuf::SingularField<::std::string::String>,
    map_name: ::protobuf::SingularField<::std::string::String>,
    mission_name: ::protobuf::SingularField<::std::string::String>,
    match_group: ::std::option::Option<u32>,
    match_id: ::std::option::Option<u64>,
    formed_time: ::std::option::Option<u32>,
    flags: ::std::option::Option<u32>,
    late_join_eligible: ::std::option::Option<bool>,
    fixed_match_size: ::std::option::Option<u32>,
    is_war_match: ::std::option::Option<CSOTFGameServerLobby_WarMatch>,
    pub next_maps_for_vote: ::std::vec::Vec<u32>,
    lobby_mm_version: ::std::option::Option<u32>,
    pub pending_members: ::protobuf::RepeatedField<CTFLobbyPlayerProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CSOTFGameServerLobby {
    fn default() -> &'a CSOTFGameServerLobby {
        <CSOTFGameServerLobby as ::protobuf::Message>::default_instance()
    }
}

impl CSOTFGameServerLobby {
    pub fn new() -> CSOTFGameServerLobby {
        ::std::default::Default::default()
    }

    // optional uint64 lobby_id = 1;


    pub fn get_lobby_id(&self) -> u64 {
        self.lobby_id.unwrap_or(0)
    }
    pub fn clear_lobby_id(&mut self) {
        self.lobby_id = ::std::option::Option::None;
    }

    pub fn has_lobby_id(&self) -> bool {
        self.lobby_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_id(&mut self, v: u64) {
        self.lobby_id = ::std::option::Option::Some(v);
    }

    // repeated .CTFLobbyPlayerProto members = 2;


    pub fn get_members(&self) -> &[CTFLobbyPlayerProto] {
        &self.members
    }
    pub fn clear_members(&mut self) {
        self.members.clear();
    }

    // Param is passed by value, moved
    pub fn set_members(&mut self, v: ::protobuf::RepeatedField<CTFLobbyPlayerProto>) {
        self.members = v;
    }

    // Mutable pointer to the field.
    pub fn mut_members(&mut self) -> &mut ::protobuf::RepeatedField<CTFLobbyPlayerProto> {
        &mut self.members
    }

    // Take field
    pub fn take_members(&mut self) -> ::protobuf::RepeatedField<CTFLobbyPlayerProto> {
        ::std::mem::replace(&mut self.members, ::protobuf::RepeatedField::new())
    }

    // optional fixed64 server_id = 6;


    pub fn get_server_id(&self) -> u64 {
        self.server_id.unwrap_or(0u64)
    }
    pub fn clear_server_id(&mut self) {
        self.server_id = ::std::option::Option::None;
    }

    pub fn has_server_id(&self) -> bool {
        self.server_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_id(&mut self, v: u64) {
        self.server_id = ::std::option::Option::Some(v);
    }

    // optional .CSOTFGameServerLobby.State state = 4;


    pub fn get_state(&self) -> CSOTFGameServerLobby_State {
        self.state.unwrap_or(CSOTFGameServerLobby_State::UNKNOWN)
    }
    pub fn clear_state(&mut self) {
        self.state = ::std::option::Option::None;
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: CSOTFGameServerLobby_State) {
        self.state = ::std::option::Option::Some(v);
    }

    // optional string connect = 5;


    pub fn get_connect(&self) -> &str {
        match self.connect.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_connect(&mut self) {
        self.connect.clear();
    }

    pub fn has_connect(&self) -> bool {
        self.connect.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connect(&mut self, v: ::std::string::String) {
        self.connect = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_connect(&mut self) -> &mut ::std::string::String {
        if self.connect.is_none() {
            self.connect.set_default();
        }
        self.connect.as_mut().unwrap()
    }

    // Take field
    pub fn take_connect(&mut self) -> ::std::string::String {
        self.connect.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .TF_GC_GameState game_state = 22;


    pub fn get_game_state(&self) -> TF_GC_GameState {
        self.game_state.unwrap_or(TF_GC_GameState::TF_GC_GAMESTATE_STATE_INIT)
    }
    pub fn clear_game_state(&mut self) {
        self.game_state = ::std::option::Option::None;
    }

    pub fn has_game_state(&self) -> bool {
        self.game_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_state(&mut self, v: TF_GC_GameState) {
        self.game_state = ::std::option::Option::Some(v);
    }

    // optional double initial_average_mm_rating = 32;


    pub fn get_initial_average_mm_rating(&self) -> f64 {
        self.initial_average_mm_rating.unwrap_or(0.)
    }
    pub fn clear_initial_average_mm_rating(&mut self) {
        self.initial_average_mm_rating = ::std::option::Option::None;
    }

    pub fn has_initial_average_mm_rating(&self) -> bool {
        self.initial_average_mm_rating.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initial_average_mm_rating(&mut self, v: f64) {
        self.initial_average_mm_rating = ::std::option::Option::Some(v);
    }

    // optional string mannup_tour_name = 42;


    pub fn get_mannup_tour_name(&self) -> &str {
        match self.mannup_tour_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_mannup_tour_name(&mut self) {
        self.mannup_tour_name.clear();
    }

    pub fn has_mannup_tour_name(&self) -> bool {
        self.mannup_tour_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mannup_tour_name(&mut self, v: ::std::string::String) {
        self.mannup_tour_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mannup_tour_name(&mut self) -> &mut ::std::string::String {
        if self.mannup_tour_name.is_none() {
            self.mannup_tour_name.set_default();
        }
        self.mannup_tour_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_mannup_tour_name(&mut self) -> ::std::string::String {
        self.mannup_tour_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string map_name = 38;


    pub fn get_map_name(&self) -> &str {
        match self.map_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_map_name(&mut self) {
        self.map_name.clear();
    }

    pub fn has_map_name(&self) -> bool {
        self.map_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map_name(&mut self, v: ::std::string::String) {
        self.map_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_map_name(&mut self) -> &mut ::std::string::String {
        if self.map_name.is_none() {
            self.map_name.set_default();
        }
        self.map_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_map_name(&mut self) -> ::std::string::String {
        self.map_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string mission_name = 39;


    pub fn get_mission_name(&self) -> &str {
        match self.mission_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_mission_name(&mut self) {
        self.mission_name.clear();
    }

    pub fn has_mission_name(&self) -> bool {
        self.mission_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mission_name(&mut self, v: ::std::string::String) {
        self.mission_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mission_name(&mut self) -> &mut ::std::string::String {
        if self.mission_name.is_none() {
            self.mission_name.set_default();
        }
        self.mission_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_mission_name(&mut self) -> ::std::string::String {
        self.mission_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 match_group = 41;


    pub fn get_match_group(&self) -> u32 {
        self.match_group.unwrap_or(0)
    }
    pub fn clear_match_group(&mut self) {
        self.match_group = ::std::option::Option::None;
    }

    pub fn has_match_group(&self) -> bool {
        self.match_group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_group(&mut self, v: u32) {
        self.match_group = ::std::option::Option::Some(v);
    }

    // optional uint64 match_id = 30;


    pub fn get_match_id(&self) -> u64 {
        self.match_id.unwrap_or(0u64)
    }
    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional uint32 formed_time = 36;


    pub fn get_formed_time(&self) -> u32 {
        self.formed_time.unwrap_or(0)
    }
    pub fn clear_formed_time(&mut self) {
        self.formed_time = ::std::option::Option::None;
    }

    pub fn has_formed_time(&self) -> bool {
        self.formed_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_formed_time(&mut self, v: u32) {
        self.formed_time = ::std::option::Option::Some(v);
    }

    // optional uint32 flags = 43;


    pub fn get_flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }
    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional bool late_join_eligible = 44;


    pub fn get_late_join_eligible(&self) -> bool {
        self.late_join_eligible.unwrap_or(false)
    }
    pub fn clear_late_join_eligible(&mut self) {
        self.late_join_eligible = ::std::option::Option::None;
    }

    pub fn has_late_join_eligible(&self) -> bool {
        self.late_join_eligible.is_some()
    }

    // Param is passed by value, moved
    pub fn set_late_join_eligible(&mut self, v: bool) {
        self.late_join_eligible = ::std::option::Option::Some(v);
    }

    // optional uint32 fixed_match_size = 45;


    pub fn get_fixed_match_size(&self) -> u32 {
        self.fixed_match_size.unwrap_or(0)
    }
    pub fn clear_fixed_match_size(&mut self) {
        self.fixed_match_size = ::std::option::Option::None;
    }

    pub fn has_fixed_match_size(&self) -> bool {
        self.fixed_match_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fixed_match_size(&mut self, v: u32) {
        self.fixed_match_size = ::std::option::Option::Some(v);
    }

    // optional .CSOTFGameServerLobby.WarMatch is_war_match = 46;


    pub fn get_is_war_match(&self) -> CSOTFGameServerLobby_WarMatch {
        self.is_war_match.unwrap_or(CSOTFGameServerLobby_WarMatch::NOPE)
    }
    pub fn clear_is_war_match(&mut self) {
        self.is_war_match = ::std::option::Option::None;
    }

    pub fn has_is_war_match(&self) -> bool {
        self.is_war_match.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_war_match(&mut self, v: CSOTFGameServerLobby_WarMatch) {
        self.is_war_match = ::std::option::Option::Some(v);
    }

    // repeated uint32 next_maps_for_vote = 47;


    pub fn get_next_maps_for_vote(&self) -> &[u32] {
        &self.next_maps_for_vote
    }
    pub fn clear_next_maps_for_vote(&mut self) {
        self.next_maps_for_vote.clear();
    }

    // Param is passed by value, moved
    pub fn set_next_maps_for_vote(&mut self, v: ::std::vec::Vec<u32>) {
        self.next_maps_for_vote = v;
    }

    // Mutable pointer to the field.
    pub fn mut_next_maps_for_vote(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.next_maps_for_vote
    }

    // Take field
    pub fn take_next_maps_for_vote(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.next_maps_for_vote, ::std::vec::Vec::new())
    }

    // optional uint32 lobby_mm_version = 48;


    pub fn get_lobby_mm_version(&self) -> u32 {
        self.lobby_mm_version.unwrap_or(0)
    }
    pub fn clear_lobby_mm_version(&mut self) {
        self.lobby_mm_version = ::std::option::Option::None;
    }

    pub fn has_lobby_mm_version(&self) -> bool {
        self.lobby_mm_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_mm_version(&mut self, v: u32) {
        self.lobby_mm_version = ::std::option::Option::Some(v);
    }

    // repeated .CTFLobbyPlayerProto pending_members = 49;


    pub fn get_pending_members(&self) -> &[CTFLobbyPlayerProto] {
        &self.pending_members
    }
    pub fn clear_pending_members(&mut self) {
        self.pending_members.clear();
    }

    // Param is passed by value, moved
    pub fn set_pending_members(&mut self, v: ::protobuf::RepeatedField<CTFLobbyPlayerProto>) {
        self.pending_members = v;
    }

    // Mutable pointer to the field.
    pub fn mut_pending_members(&mut self) -> &mut ::protobuf::RepeatedField<CTFLobbyPlayerProto> {
        &mut self.pending_members
    }

    // Take field
    pub fn take_pending_members(&mut self) -> ::protobuf::RepeatedField<CTFLobbyPlayerProto> {
        ::std::mem::replace(&mut self.pending_members, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CSOTFGameServerLobby {
    fn is_initialized(&self) -> bool {
        for v in &self.members {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pending_members {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.lobby_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.members)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.server_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.state, 4, &mut self.unknown_fields)?
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.connect)?;
                },
                22 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.game_state, 22, &mut self.unknown_fields)?
                },
                32 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.initial_average_mm_rating = ::std::option::Option::Some(tmp);
                },
                42 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.mannup_tour_name)?;
                },
                38 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.map_name)?;
                },
                39 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.mission_name)?;
                },
                41 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.match_group = ::std::option::Option::Some(tmp);
                },
                30 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.match_id = ::std::option::Option::Some(tmp);
                },
                36 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.formed_time = ::std::option::Option::Some(tmp);
                },
                43 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.flags = ::std::option::Option::Some(tmp);
                },
                44 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.late_join_eligible = ::std::option::Option::Some(tmp);
                },
                45 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.fixed_match_size = ::std::option::Option::Some(tmp);
                },
                46 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.is_war_match, 46, &mut self.unknown_fields)?
                },
                47 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.next_maps_for_vote)?;
                },
                48 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.lobby_mm_version = ::std::option::Option::Some(tmp);
                },
                49 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.pending_members)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.lobby_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.members {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.server_id {
            my_size += 9;
        }
        if let Some(v) = self.state {
            my_size += ::protobuf::rt::enum_size(4, v);
        }
        if let Some(ref v) = self.connect.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.game_state {
            my_size += ::protobuf::rt::enum_size(22, v);
        }
        if let Some(v) = self.initial_average_mm_rating {
            my_size += 10;
        }
        if let Some(ref v) = self.mannup_tour_name.as_ref() {
            my_size += ::protobuf::rt::string_size(42, &v);
        }
        if let Some(ref v) = self.map_name.as_ref() {
            my_size += ::protobuf::rt::string_size(38, &v);
        }
        if let Some(ref v) = self.mission_name.as_ref() {
            my_size += ::protobuf::rt::string_size(39, &v);
        }
        if let Some(v) = self.match_group {
            my_size += ::protobuf::rt::value_size(41, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::value_size(30, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.formed_time {
            my_size += ::protobuf::rt::value_size(36, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::value_size(43, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.late_join_eligible {
            my_size += 3;
        }
        if let Some(v) = self.fixed_match_size {
            my_size += ::protobuf::rt::value_size(45, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.is_war_match {
            my_size += ::protobuf::rt::enum_size(46, v);
        }
        for value in &self.next_maps_for_vote {
            my_size += ::protobuf::rt::value_size(47, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.lobby_mm_version {
            my_size += ::protobuf::rt::value_size(48, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.pending_members {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.lobby_id {
            os.write_uint64(1, v)?;
        }
        for v in &self.members {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.server_id {
            os.write_fixed64(6, v)?;
        }
        if let Some(v) = self.state {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.connect.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(v) = self.game_state {
            os.write_enum(22, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.initial_average_mm_rating {
            os.write_double(32, v)?;
        }
        if let Some(ref v) = self.mannup_tour_name.as_ref() {
            os.write_string(42, &v)?;
        }
        if let Some(ref v) = self.map_name.as_ref() {
            os.write_string(38, &v)?;
        }
        if let Some(ref v) = self.mission_name.as_ref() {
            os.write_string(39, &v)?;
        }
        if let Some(v) = self.match_group {
            os.write_uint32(41, v)?;
        }
        if let Some(v) = self.match_id {
            os.write_uint64(30, v)?;
        }
        if let Some(v) = self.formed_time {
            os.write_uint32(36, v)?;
        }
        if let Some(v) = self.flags {
            os.write_uint32(43, v)?;
        }
        if let Some(v) = self.late_join_eligible {
            os.write_bool(44, v)?;
        }
        if let Some(v) = self.fixed_match_size {
            os.write_uint32(45, v)?;
        }
        if let Some(v) = self.is_war_match {
            os.write_enum(46, ::protobuf::ProtobufEnum::value(&v))?;
        }
        for v in &self.next_maps_for_vote {
            os.write_uint32(47, *v)?;
        };
        if let Some(v) = self.lobby_mm_version {
            os.write_uint32(48, v)?;
        }
        for v in &self.pending_members {
            os.write_tag(49, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CSOTFGameServerLobby {
        CSOTFGameServerLobby::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "lobby_id",
                |m: &CSOTFGameServerLobby| { &m.lobby_id },
                |m: &mut CSOTFGameServerLobby| { &mut m.lobby_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CTFLobbyPlayerProto>>(
                "members",
                |m: &CSOTFGameServerLobby| { &m.members },
                |m: &mut CSOTFGameServerLobby| { &mut m.members },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "server_id",
                |m: &CSOTFGameServerLobby| { &m.server_id },
                |m: &mut CSOTFGameServerLobby| { &mut m.server_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CSOTFGameServerLobby_State>>(
                "state",
                |m: &CSOTFGameServerLobby| { &m.state },
                |m: &mut CSOTFGameServerLobby| { &mut m.state },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "connect",
                |m: &CSOTFGameServerLobby| { &m.connect },
                |m: &mut CSOTFGameServerLobby| { &mut m.connect },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TF_GC_GameState>>(
                "game_state",
                |m: &CSOTFGameServerLobby| { &m.game_state },
                |m: &mut CSOTFGameServerLobby| { &mut m.game_state },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "initial_average_mm_rating",
                |m: &CSOTFGameServerLobby| { &m.initial_average_mm_rating },
                |m: &mut CSOTFGameServerLobby| { &mut m.initial_average_mm_rating },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "mannup_tour_name",
                |m: &CSOTFGameServerLobby| { &m.mannup_tour_name },
                |m: &mut CSOTFGameServerLobby| { &mut m.mannup_tour_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "map_name",
                |m: &CSOTFGameServerLobby| { &m.map_name },
                |m: &mut CSOTFGameServerLobby| { &mut m.map_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "mission_name",
                |m: &CSOTFGameServerLobby| { &m.mission_name },
                |m: &mut CSOTFGameServerLobby| { &mut m.mission_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "match_group",
                |m: &CSOTFGameServerLobby| { &m.match_group },
                |m: &mut CSOTFGameServerLobby| { &mut m.match_group },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "match_id",
                |m: &CSOTFGameServerLobby| { &m.match_id },
                |m: &mut CSOTFGameServerLobby| { &mut m.match_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "formed_time",
                |m: &CSOTFGameServerLobby| { &m.formed_time },
                |m: &mut CSOTFGameServerLobby| { &mut m.formed_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "flags",
                |m: &CSOTFGameServerLobby| { &m.flags },
                |m: &mut CSOTFGameServerLobby| { &mut m.flags },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "late_join_eligible",
                |m: &CSOTFGameServerLobby| { &m.late_join_eligible },
                |m: &mut CSOTFGameServerLobby| { &mut m.late_join_eligible },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "fixed_match_size",
                |m: &CSOTFGameServerLobby| { &m.fixed_match_size },
                |m: &mut CSOTFGameServerLobby| { &mut m.fixed_match_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CSOTFGameServerLobby_WarMatch>>(
                "is_war_match",
                |m: &CSOTFGameServerLobby| { &m.is_war_match },
                |m: &mut CSOTFGameServerLobby| { &mut m.is_war_match },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "next_maps_for_vote",
                |m: &CSOTFGameServerLobby| { &m.next_maps_for_vote },
                |m: &mut CSOTFGameServerLobby| { &mut m.next_maps_for_vote },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "lobby_mm_version",
                |m: &CSOTFGameServerLobby| { &m.lobby_mm_version },
                |m: &mut CSOTFGameServerLobby| { &mut m.lobby_mm_version },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CTFLobbyPlayerProto>>(
                "pending_members",
                |m: &CSOTFGameServerLobby| { &m.pending_members },
                |m: &mut CSOTFGameServerLobby| { &mut m.pending_members },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CSOTFGameServerLobby>(
                "CSOTFGameServerLobby",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CSOTFGameServerLobby {
        static instance: ::protobuf::rt::LazyV2<CSOTFGameServerLobby> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CSOTFGameServerLobby::new)
    }
}

impl ::protobuf::Clear for CSOTFGameServerLobby {
    fn clear(&mut self) {
        self.lobby_id = ::std::option::Option::None;
        self.members.clear();
        self.server_id = ::std::option::Option::None;
        self.state = ::std::option::Option::None;
        self.connect.clear();
        self.game_state = ::std::option::Option::None;
        self.initial_average_mm_rating = ::std::option::Option::None;
        self.mannup_tour_name.clear();
        self.map_name.clear();
        self.mission_name.clear();
        self.match_group = ::std::option::Option::None;
        self.match_id = ::std::option::Option::None;
        self.formed_time = ::std::option::Option::None;
        self.flags = ::std::option::Option::None;
        self.late_join_eligible = ::std::option::Option::None;
        self.fixed_match_size = ::std::option::Option::None;
        self.is_war_match = ::std::option::Option::None;
        self.next_maps_for_vote.clear();
        self.lobby_mm_version = ::std::option::Option::None;
        self.pending_members.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSOTFGameServerLobby {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOTFGameServerLobby {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CSOTFGameServerLobby_State {
    UNKNOWN = 0,
    SERVERSETUP = 1,
    RUN = 2,
}

impl ::protobuf::ProtobufEnum for CSOTFGameServerLobby_State {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CSOTFGameServerLobby_State> {
        match value {
            0 => ::std::option::Option::Some(CSOTFGameServerLobby_State::UNKNOWN),
            1 => ::std::option::Option::Some(CSOTFGameServerLobby_State::SERVERSETUP),
            2 => ::std::option::Option::Some(CSOTFGameServerLobby_State::RUN),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CSOTFGameServerLobby_State] = &[
            CSOTFGameServerLobby_State::UNKNOWN,
            CSOTFGameServerLobby_State::SERVERSETUP,
            CSOTFGameServerLobby_State::RUN,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<CSOTFGameServerLobby_State>("CSOTFGameServerLobby.State", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for CSOTFGameServerLobby_State {
}

impl ::std::default::Default for CSOTFGameServerLobby_State {
    fn default() -> Self {
        CSOTFGameServerLobby_State::UNKNOWN
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOTFGameServerLobby_State {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CSOTFGameServerLobby_WarMatch {
    NOPE = 0,
    INVADERS_ARE_PYRO = 1,
    INVADERS_ARE_HEAVY = 2,
}

impl ::protobuf::ProtobufEnum for CSOTFGameServerLobby_WarMatch {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CSOTFGameServerLobby_WarMatch> {
        match value {
            0 => ::std::option::Option::Some(CSOTFGameServerLobby_WarMatch::NOPE),
            1 => ::std::option::Option::Some(CSOTFGameServerLobby_WarMatch::INVADERS_ARE_PYRO),
            2 => ::std::option::Option::Some(CSOTFGameServerLobby_WarMatch::INVADERS_ARE_HEAVY),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CSOTFGameServerLobby_WarMatch] = &[
            CSOTFGameServerLobby_WarMatch::NOPE,
            CSOTFGameServerLobby_WarMatch::INVADERS_ARE_PYRO,
            CSOTFGameServerLobby_WarMatch::INVADERS_ARE_HEAVY,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<CSOTFGameServerLobby_WarMatch>("CSOTFGameServerLobby.WarMatch", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for CSOTFGameServerLobby_WarMatch {
}

impl ::std::default::Default for CSOTFGameServerLobby_WarMatch {
    fn default() -> Self {
        CSOTFGameServerLobby_WarMatch::NOPE
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOTFGameServerLobby_WarMatch {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgExitMatchmaking {
    // message fields
    explicit_abandon: ::std::option::Option<bool>,
    party_id: ::std::option::Option<u64>,
    lobby_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgExitMatchmaking {
    fn default() -> &'a CMsgExitMatchmaking {
        <CMsgExitMatchmaking as ::protobuf::Message>::default_instance()
    }
}

impl CMsgExitMatchmaking {
    pub fn new() -> CMsgExitMatchmaking {
        ::std::default::Default::default()
    }

    // optional bool explicit_abandon = 1;


    pub fn get_explicit_abandon(&self) -> bool {
        self.explicit_abandon.unwrap_or(false)
    }
    pub fn clear_explicit_abandon(&mut self) {
        self.explicit_abandon = ::std::option::Option::None;
    }

    pub fn has_explicit_abandon(&self) -> bool {
        self.explicit_abandon.is_some()
    }

    // Param is passed by value, moved
    pub fn set_explicit_abandon(&mut self, v: bool) {
        self.explicit_abandon = ::std::option::Option::Some(v);
    }

    // optional uint64 party_id = 2;


    pub fn get_party_id(&self) -> u64 {
        self.party_id.unwrap_or(0)
    }
    pub fn clear_party_id(&mut self) {
        self.party_id = ::std::option::Option::None;
    }

    pub fn has_party_id(&self) -> bool {
        self.party_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_party_id(&mut self, v: u64) {
        self.party_id = ::std::option::Option::Some(v);
    }

    // optional uint64 lobby_id = 3;


    pub fn get_lobby_id(&self) -> u64 {
        self.lobby_id.unwrap_or(0)
    }
    pub fn clear_lobby_id(&mut self) {
        self.lobby_id = ::std::option::Option::None;
    }

    pub fn has_lobby_id(&self) -> bool {
        self.lobby_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_id(&mut self, v: u64) {
        self.lobby_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgExitMatchmaking {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.explicit_abandon = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.party_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.lobby_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.explicit_abandon {
            my_size += 2;
        }
        if let Some(v) = self.party_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.lobby_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.explicit_abandon {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.party_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.lobby_id {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgExitMatchmaking {
        CMsgExitMatchmaking::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "explicit_abandon",
                |m: &CMsgExitMatchmaking| { &m.explicit_abandon },
                |m: &mut CMsgExitMatchmaking| { &mut m.explicit_abandon },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "party_id",
                |m: &CMsgExitMatchmaking| { &m.party_id },
                |m: &mut CMsgExitMatchmaking| { &mut m.party_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "lobby_id",
                |m: &CMsgExitMatchmaking| { &m.lobby_id },
                |m: &mut CMsgExitMatchmaking| { &mut m.lobby_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgExitMatchmaking>(
                "CMsgExitMatchmaking",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgExitMatchmaking {
        static instance: ::protobuf::rt::LazyV2<CMsgExitMatchmaking> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgExitMatchmaking::new)
    }
}

impl ::protobuf::Clear for CMsgExitMatchmaking {
    fn clear(&mut self) {
        self.explicit_abandon = ::std::option::Option::None;
        self.party_id = ::std::option::Option::None;
        self.lobby_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgExitMatchmaking {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgExitMatchmaking {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgAcceptLobbyInvite {
    // message fields
    invited_lobby_id: ::std::option::Option<u64>,
    abandoning_match_id: ::std::option::Option<u64>,
    pub abandoning_invite_lobby_ids: ::std::vec::Vec<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgAcceptLobbyInvite {
    fn default() -> &'a CMsgAcceptLobbyInvite {
        <CMsgAcceptLobbyInvite as ::protobuf::Message>::default_instance()
    }
}

impl CMsgAcceptLobbyInvite {
    pub fn new() -> CMsgAcceptLobbyInvite {
        ::std::default::Default::default()
    }

    // optional uint64 invited_lobby_id = 1;


    pub fn get_invited_lobby_id(&self) -> u64 {
        self.invited_lobby_id.unwrap_or(0)
    }
    pub fn clear_invited_lobby_id(&mut self) {
        self.invited_lobby_id = ::std::option::Option::None;
    }

    pub fn has_invited_lobby_id(&self) -> bool {
        self.invited_lobby_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_invited_lobby_id(&mut self, v: u64) {
        self.invited_lobby_id = ::std::option::Option::Some(v);
    }

    // optional uint64 abandoning_match_id = 2;


    pub fn get_abandoning_match_id(&self) -> u64 {
        self.abandoning_match_id.unwrap_or(0)
    }
    pub fn clear_abandoning_match_id(&mut self) {
        self.abandoning_match_id = ::std::option::Option::None;
    }

    pub fn has_abandoning_match_id(&self) -> bool {
        self.abandoning_match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_abandoning_match_id(&mut self, v: u64) {
        self.abandoning_match_id = ::std::option::Option::Some(v);
    }

    // repeated uint64 abandoning_invite_lobby_ids = 3;


    pub fn get_abandoning_invite_lobby_ids(&self) -> &[u64] {
        &self.abandoning_invite_lobby_ids
    }
    pub fn clear_abandoning_invite_lobby_ids(&mut self) {
        self.abandoning_invite_lobby_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_abandoning_invite_lobby_ids(&mut self, v: ::std::vec::Vec<u64>) {
        self.abandoning_invite_lobby_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_abandoning_invite_lobby_ids(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.abandoning_invite_lobby_ids
    }

    // Take field
    pub fn take_abandoning_invite_lobby_ids(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.abandoning_invite_lobby_ids, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgAcceptLobbyInvite {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.invited_lobby_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.abandoning_match_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.abandoning_invite_lobby_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.invited_lobby_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.abandoning_match_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.abandoning_invite_lobby_ids {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.invited_lobby_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.abandoning_match_id {
            os.write_uint64(2, v)?;
        }
        for v in &self.abandoning_invite_lobby_ids {
            os.write_uint64(3, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgAcceptLobbyInvite {
        CMsgAcceptLobbyInvite::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "invited_lobby_id",
                |m: &CMsgAcceptLobbyInvite| { &m.invited_lobby_id },
                |m: &mut CMsgAcceptLobbyInvite| { &mut m.invited_lobby_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "abandoning_match_id",
                |m: &CMsgAcceptLobbyInvite| { &m.abandoning_match_id },
                |m: &mut CMsgAcceptLobbyInvite| { &mut m.abandoning_match_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "abandoning_invite_lobby_ids",
                |m: &CMsgAcceptLobbyInvite| { &m.abandoning_invite_lobby_ids },
                |m: &mut CMsgAcceptLobbyInvite| { &mut m.abandoning_invite_lobby_ids },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgAcceptLobbyInvite>(
                "CMsgAcceptLobbyInvite",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgAcceptLobbyInvite {
        static instance: ::protobuf::rt::LazyV2<CMsgAcceptLobbyInvite> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgAcceptLobbyInvite::new)
    }
}

impl ::protobuf::Clear for CMsgAcceptLobbyInvite {
    fn clear(&mut self) {
        self.invited_lobby_id = ::std::option::Option::None;
        self.abandoning_match_id = ::std::option::Option::None;
        self.abandoning_invite_lobby_ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgAcceptLobbyInvite {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgAcceptLobbyInvite {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgAcceptLobbyInviteReply {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgAcceptLobbyInviteReply {
    fn default() -> &'a CMsgAcceptLobbyInviteReply {
        <CMsgAcceptLobbyInviteReply as ::protobuf::Message>::default_instance()
    }
}

impl CMsgAcceptLobbyInviteReply {
    pub fn new() -> CMsgAcceptLobbyInviteReply {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgAcceptLobbyInviteReply {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgAcceptLobbyInviteReply {
        CMsgAcceptLobbyInviteReply::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgAcceptLobbyInviteReply>(
                "CMsgAcceptLobbyInviteReply",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgAcceptLobbyInviteReply {
        static instance: ::protobuf::rt::LazyV2<CMsgAcceptLobbyInviteReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgAcceptLobbyInviteReply::new)
    }
}

impl ::protobuf::Clear for CMsgAcceptLobbyInviteReply {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgAcceptLobbyInviteReply {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgAcceptLobbyInviteReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgMatchmakingSearchCountRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgMatchmakingSearchCountRequest {
    fn default() -> &'a CMsgMatchmakingSearchCountRequest {
        <CMsgMatchmakingSearchCountRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgMatchmakingSearchCountRequest {
    pub fn new() -> CMsgMatchmakingSearchCountRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgMatchmakingSearchCountRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgMatchmakingSearchCountRequest {
        CMsgMatchmakingSearchCountRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgMatchmakingSearchCountRequest>(
                "CMsgMatchmakingSearchCountRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgMatchmakingSearchCountRequest {
        static instance: ::protobuf::rt::LazyV2<CMsgMatchmakingSearchCountRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgMatchmakingSearchCountRequest::new)
    }
}

impl ::protobuf::Clear for CMsgMatchmakingSearchCountRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgMatchmakingSearchCountRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgMatchmakingSearchCountRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgMatchmakingSearchCountResponse {
    // message fields
    pub searching_players_by_group: ::std::vec::Vec<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgMatchmakingSearchCountResponse {
    fn default() -> &'a CMsgMatchmakingSearchCountResponse {
        <CMsgMatchmakingSearchCountResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgMatchmakingSearchCountResponse {
    pub fn new() -> CMsgMatchmakingSearchCountResponse {
        ::std::default::Default::default()
    }

    // repeated uint32 searching_players_by_group = 1;


    pub fn get_searching_players_by_group(&self) -> &[u32] {
        &self.searching_players_by_group
    }
    pub fn clear_searching_players_by_group(&mut self) {
        self.searching_players_by_group.clear();
    }

    // Param is passed by value, moved
    pub fn set_searching_players_by_group(&mut self, v: ::std::vec::Vec<u32>) {
        self.searching_players_by_group = v;
    }

    // Mutable pointer to the field.
    pub fn mut_searching_players_by_group(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.searching_players_by_group
    }

    // Take field
    pub fn take_searching_players_by_group(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.searching_players_by_group, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgMatchmakingSearchCountResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.searching_players_by_group)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.searching_players_by_group {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.searching_players_by_group {
            os.write_uint32(1, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgMatchmakingSearchCountResponse {
        CMsgMatchmakingSearchCountResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "searching_players_by_group",
                |m: &CMsgMatchmakingSearchCountResponse| { &m.searching_players_by_group },
                |m: &mut CMsgMatchmakingSearchCountResponse| { &mut m.searching_players_by_group },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgMatchmakingSearchCountResponse>(
                "CMsgMatchmakingSearchCountResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgMatchmakingSearchCountResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgMatchmakingSearchCountResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgMatchmakingSearchCountResponse::new)
    }
}

impl ::protobuf::Clear for CMsgMatchmakingSearchCountResponse {
    fn clear(&mut self) {
        self.searching_players_by_group.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgMatchmakingSearchCountResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgMatchmakingSearchCountResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgKickedFromMatchmakingQueue {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgKickedFromMatchmakingQueue {
    fn default() -> &'a CMsgKickedFromMatchmakingQueue {
        <CMsgKickedFromMatchmakingQueue as ::protobuf::Message>::default_instance()
    }
}

impl CMsgKickedFromMatchmakingQueue {
    pub fn new() -> CMsgKickedFromMatchmakingQueue {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgKickedFromMatchmakingQueue {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgKickedFromMatchmakingQueue {
        CMsgKickedFromMatchmakingQueue::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgKickedFromMatchmakingQueue>(
                "CMsgKickedFromMatchmakingQueue",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgKickedFromMatchmakingQueue {
        static instance: ::protobuf::rt::LazyV2<CMsgKickedFromMatchmakingQueue> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgKickedFromMatchmakingQueue::new)
    }
}

impl ::protobuf::Clear for CMsgKickedFromMatchmakingQueue {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgKickedFromMatchmakingQueue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgKickedFromMatchmakingQueue {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGameServerMatchmakingStatus {
    // message fields
    server_version: ::std::option::Option<u32>,
    matchmaking_state: ::std::option::Option<ServerMatchmakingState>,
    map: ::protobuf::SingularField<::std::string::String>,
    tags: ::protobuf::SingularField<::std::string::String>,
    bot_count: ::std::option::Option<u32>,
    num_spectators: ::std::option::Option<u32>,
    max_players: ::std::option::Option<u32>,
    slots_free: ::std::option::Option<u32>,
    server_region: ::std::option::Option<u32>,
    server_loadavg: ::std::option::Option<f32>,
    server_trusted: ::std::option::Option<bool>,
    server_dedicated: ::std::option::Option<bool>,
    strict: ::std::option::Option<u32>,
    fake_ip: ::protobuf::SingularField<::std::string::String>,
    pub players: ::protobuf::RepeatedField<CMsgGameServerMatchmakingStatus_Player>,
    game_state: ::std::option::Option<TF_GC_GameState>,
    event: ::std::option::Option<CMsgGameServerMatchmakingStatus_Event>,
    mvm_wave: ::std::option::Option<u32>,
    mvm_credits_acquired: ::std::option::Option<u32>,
    mvm_credits_dropped: ::std::option::Option<u32>,
    match_group: ::std::option::Option<i32>,
    lobby_mm_version: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGameServerMatchmakingStatus {
    fn default() -> &'a CMsgGameServerMatchmakingStatus {
        <CMsgGameServerMatchmakingStatus as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGameServerMatchmakingStatus {
    pub fn new() -> CMsgGameServerMatchmakingStatus {
        ::std::default::Default::default()
    }

    // optional uint32 server_version = 16;


    pub fn get_server_version(&self) -> u32 {
        self.server_version.unwrap_or(1225u32)
    }
    pub fn clear_server_version(&mut self) {
        self.server_version = ::std::option::Option::None;
    }

    pub fn has_server_version(&self) -> bool {
        self.server_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_version(&mut self, v: u32) {
        self.server_version = ::std::option::Option::Some(v);
    }

    // optional .ServerMatchmakingState matchmaking_state = 1;


    pub fn get_matchmaking_state(&self) -> ServerMatchmakingState {
        self.matchmaking_state.unwrap_or(ServerMatchmakingState::ServerMatchmakingState_INVALID)
    }
    pub fn clear_matchmaking_state(&mut self) {
        self.matchmaking_state = ::std::option::Option::None;
    }

    pub fn has_matchmaking_state(&self) -> bool {
        self.matchmaking_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matchmaking_state(&mut self, v: ServerMatchmakingState) {
        self.matchmaking_state = ::std::option::Option::Some(v);
    }

    // optional string map = 3;


    pub fn get_map(&self) -> &str {
        match self.map.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_map(&mut self) {
        self.map.clear();
    }

    pub fn has_map(&self) -> bool {
        self.map.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map(&mut self, v: ::std::string::String) {
        self.map = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_map(&mut self) -> &mut ::std::string::String {
        if self.map.is_none() {
            self.map.set_default();
        }
        self.map.as_mut().unwrap()
    }

    // Take field
    pub fn take_map(&mut self) -> ::std::string::String {
        self.map.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string tags = 4;


    pub fn get_tags(&self) -> &str {
        match self.tags.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_tags(&mut self) {
        self.tags.clear();
    }

    pub fn has_tags(&self) -> bool {
        self.tags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tags(&mut self, v: ::std::string::String) {
        self.tags = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tags(&mut self) -> &mut ::std::string::String {
        if self.tags.is_none() {
            self.tags.set_default();
        }
        self.tags.as_mut().unwrap()
    }

    // Take field
    pub fn take_tags(&mut self) -> ::std::string::String {
        self.tags.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 bot_count = 5;


    pub fn get_bot_count(&self) -> u32 {
        self.bot_count.unwrap_or(0)
    }
    pub fn clear_bot_count(&mut self) {
        self.bot_count = ::std::option::Option::None;
    }

    pub fn has_bot_count(&self) -> bool {
        self.bot_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bot_count(&mut self, v: u32) {
        self.bot_count = ::std::option::Option::Some(v);
    }

    // optional uint32 num_spectators = 6;


    pub fn get_num_spectators(&self) -> u32 {
        self.num_spectators.unwrap_or(0)
    }
    pub fn clear_num_spectators(&mut self) {
        self.num_spectators = ::std::option::Option::None;
    }

    pub fn has_num_spectators(&self) -> bool {
        self.num_spectators.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_spectators(&mut self, v: u32) {
        self.num_spectators = ::std::option::Option::Some(v);
    }

    // optional uint32 max_players = 7;


    pub fn get_max_players(&self) -> u32 {
        self.max_players.unwrap_or(0)
    }
    pub fn clear_max_players(&mut self) {
        self.max_players = ::std::option::Option::None;
    }

    pub fn has_max_players(&self) -> bool {
        self.max_players.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_players(&mut self, v: u32) {
        self.max_players = ::std::option::Option::Some(v);
    }

    // optional uint32 slots_free = 8;


    pub fn get_slots_free(&self) -> u32 {
        self.slots_free.unwrap_or(0)
    }
    pub fn clear_slots_free(&mut self) {
        self.slots_free = ::std::option::Option::None;
    }

    pub fn has_slots_free(&self) -> bool {
        self.slots_free.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slots_free(&mut self, v: u32) {
        self.slots_free = ::std::option::Option::Some(v);
    }

    // optional uint32 server_region = 9;


    pub fn get_server_region(&self) -> u32 {
        self.server_region.unwrap_or(0)
    }
    pub fn clear_server_region(&mut self) {
        self.server_region = ::std::option::Option::None;
    }

    pub fn has_server_region(&self) -> bool {
        self.server_region.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_region(&mut self, v: u32) {
        self.server_region = ::std::option::Option::Some(v);
    }

    // optional float server_loadavg = 10;


    pub fn get_server_loadavg(&self) -> f32 {
        self.server_loadavg.unwrap_or(0.)
    }
    pub fn clear_server_loadavg(&mut self) {
        self.server_loadavg = ::std::option::Option::None;
    }

    pub fn has_server_loadavg(&self) -> bool {
        self.server_loadavg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_loadavg(&mut self, v: f32) {
        self.server_loadavg = ::std::option::Option::Some(v);
    }

    // optional bool server_trusted = 11;


    pub fn get_server_trusted(&self) -> bool {
        self.server_trusted.unwrap_or(false)
    }
    pub fn clear_server_trusted(&mut self) {
        self.server_trusted = ::std::option::Option::None;
    }

    pub fn has_server_trusted(&self) -> bool {
        self.server_trusted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_trusted(&mut self, v: bool) {
        self.server_trusted = ::std::option::Option::Some(v);
    }

    // optional bool server_dedicated = 12;


    pub fn get_server_dedicated(&self) -> bool {
        self.server_dedicated.unwrap_or(false)
    }
    pub fn clear_server_dedicated(&mut self) {
        self.server_dedicated = ::std::option::Option::None;
    }

    pub fn has_server_dedicated(&self) -> bool {
        self.server_dedicated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_dedicated(&mut self, v: bool) {
        self.server_dedicated = ::std::option::Option::Some(v);
    }

    // optional uint32 strict = 17;


    pub fn get_strict(&self) -> u32 {
        self.strict.unwrap_or(0)
    }
    pub fn clear_strict(&mut self) {
        self.strict = ::std::option::Option::None;
    }

    pub fn has_strict(&self) -> bool {
        self.strict.is_some()
    }

    // Param is passed by value, moved
    pub fn set_strict(&mut self, v: u32) {
        self.strict = ::std::option::Option::Some(v);
    }

    // optional string fake_ip = 25;


    pub fn get_fake_ip(&self) -> &str {
        match self.fake_ip.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_fake_ip(&mut self) {
        self.fake_ip.clear();
    }

    pub fn has_fake_ip(&self) -> bool {
        self.fake_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fake_ip(&mut self, v: ::std::string::String) {
        self.fake_ip = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fake_ip(&mut self) -> &mut ::std::string::String {
        if self.fake_ip.is_none() {
            self.fake_ip.set_default();
        }
        self.fake_ip.as_mut().unwrap()
    }

    // Take field
    pub fn take_fake_ip(&mut self) -> ::std::string::String {
        self.fake_ip.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .CMsgGameServerMatchmakingStatus.Player players = 13;


    pub fn get_players(&self) -> &[CMsgGameServerMatchmakingStatus_Player] {
        &self.players
    }
    pub fn clear_players(&mut self) {
        self.players.clear();
    }

    // Param is passed by value, moved
    pub fn set_players(&mut self, v: ::protobuf::RepeatedField<CMsgGameServerMatchmakingStatus_Player>) {
        self.players = v;
    }

    // Mutable pointer to the field.
    pub fn mut_players(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGameServerMatchmakingStatus_Player> {
        &mut self.players
    }

    // Take field
    pub fn take_players(&mut self) -> ::protobuf::RepeatedField<CMsgGameServerMatchmakingStatus_Player> {
        ::std::mem::replace(&mut self.players, ::protobuf::RepeatedField::new())
    }

    // optional .TF_GC_GameState game_state = 14;


    pub fn get_game_state(&self) -> TF_GC_GameState {
        self.game_state.unwrap_or(TF_GC_GameState::TF_GC_GAMESTATE_STATE_INIT)
    }
    pub fn clear_game_state(&mut self) {
        self.game_state = ::std::option::Option::None;
    }

    pub fn has_game_state(&self) -> bool {
        self.game_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_state(&mut self, v: TF_GC_GameState) {
        self.game_state = ::std::option::Option::Some(v);
    }

    // optional .CMsgGameServerMatchmakingStatus.Event event = 15;


    pub fn get_event(&self) -> CMsgGameServerMatchmakingStatus_Event {
        self.event.unwrap_or(CMsgGameServerMatchmakingStatus_Event::None)
    }
    pub fn clear_event(&mut self) {
        self.event = ::std::option::Option::None;
    }

    pub fn has_event(&self) -> bool {
        self.event.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event(&mut self, v: CMsgGameServerMatchmakingStatus_Event) {
        self.event = ::std::option::Option::Some(v);
    }

    // optional uint32 mvm_wave = 18;


    pub fn get_mvm_wave(&self) -> u32 {
        self.mvm_wave.unwrap_or(0)
    }
    pub fn clear_mvm_wave(&mut self) {
        self.mvm_wave = ::std::option::Option::None;
    }

    pub fn has_mvm_wave(&self) -> bool {
        self.mvm_wave.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mvm_wave(&mut self, v: u32) {
        self.mvm_wave = ::std::option::Option::Some(v);
    }

    // optional uint32 mvm_credits_acquired = 19;


    pub fn get_mvm_credits_acquired(&self) -> u32 {
        self.mvm_credits_acquired.unwrap_or(0)
    }
    pub fn clear_mvm_credits_acquired(&mut self) {
        self.mvm_credits_acquired = ::std::option::Option::None;
    }

    pub fn has_mvm_credits_acquired(&self) -> bool {
        self.mvm_credits_acquired.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mvm_credits_acquired(&mut self, v: u32) {
        self.mvm_credits_acquired = ::std::option::Option::Some(v);
    }

    // optional uint32 mvm_credits_dropped = 20;


    pub fn get_mvm_credits_dropped(&self) -> u32 {
        self.mvm_credits_dropped.unwrap_or(0)
    }
    pub fn clear_mvm_credits_dropped(&mut self) {
        self.mvm_credits_dropped = ::std::option::Option::None;
    }

    pub fn has_mvm_credits_dropped(&self) -> bool {
        self.mvm_credits_dropped.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mvm_credits_dropped(&mut self, v: u32) {
        self.mvm_credits_dropped = ::std::option::Option::Some(v);
    }

    // optional sint32 match_group = 23;


    pub fn get_match_group(&self) -> i32 {
        self.match_group.unwrap_or(-1i32)
    }
    pub fn clear_match_group(&mut self) {
        self.match_group = ::std::option::Option::None;
    }

    pub fn has_match_group(&self) -> bool {
        self.match_group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_group(&mut self, v: i32) {
        self.match_group = ::std::option::Option::Some(v);
    }

    // optional uint32 lobby_mm_version = 24;


    pub fn get_lobby_mm_version(&self) -> u32 {
        self.lobby_mm_version.unwrap_or(0)
    }
    pub fn clear_lobby_mm_version(&mut self) {
        self.lobby_mm_version = ::std::option::Option::None;
    }

    pub fn has_lobby_mm_version(&self) -> bool {
        self.lobby_mm_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_mm_version(&mut self, v: u32) {
        self.lobby_mm_version = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGameServerMatchmakingStatus {
    fn is_initialized(&self) -> bool {
        for v in &self.players {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.server_version = ::std::option::Option::Some(tmp);
                },
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.matchmaking_state, 1, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.map)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.tags)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.bot_count = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.num_spectators = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.max_players = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.slots_free = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.server_region = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.server_loadavg = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.server_trusted = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.server_dedicated = ::std::option::Option::Some(tmp);
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.strict = ::std::option::Option::Some(tmp);
                },
                25 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.fake_ip)?;
                },
                13 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.players)?;
                },
                14 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.game_state, 14, &mut self.unknown_fields)?
                },
                15 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.event, 15, &mut self.unknown_fields)?
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.mvm_wave = ::std::option::Option::Some(tmp);
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.mvm_credits_acquired = ::std::option::Option::Some(tmp);
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.mvm_credits_dropped = ::std::option::Option::Some(tmp);
                },
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.match_group = ::std::option::Option::Some(tmp);
                },
                24 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.lobby_mm_version = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.server_version {
            my_size += ::protobuf::rt::value_size(16, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.matchmaking_state {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(ref v) = self.map.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.tags.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.bot_count {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.num_spectators {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.max_players {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.slots_free {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.server_region {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.server_loadavg {
            my_size += 5;
        }
        if let Some(v) = self.server_trusted {
            my_size += 2;
        }
        if let Some(v) = self.server_dedicated {
            my_size += 2;
        }
        if let Some(v) = self.strict {
            my_size += ::protobuf::rt::value_size(17, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.fake_ip.as_ref() {
            my_size += ::protobuf::rt::string_size(25, &v);
        }
        for value in &self.players {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.game_state {
            my_size += ::protobuf::rt::enum_size(14, v);
        }
        if let Some(v) = self.event {
            my_size += ::protobuf::rt::enum_size(15, v);
        }
        if let Some(v) = self.mvm_wave {
            my_size += ::protobuf::rt::value_size(18, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.mvm_credits_acquired {
            my_size += ::protobuf::rt::value_size(19, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.mvm_credits_dropped {
            my_size += ::protobuf::rt::value_size(20, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.match_group {
            my_size += ::protobuf::rt::value_varint_zigzag_size(23, v);
        }
        if let Some(v) = self.lobby_mm_version {
            my_size += ::protobuf::rt::value_size(24, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.server_version {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.matchmaking_state {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.map.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.tags.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(v) = self.bot_count {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.num_spectators {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.max_players {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.slots_free {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.server_region {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.server_loadavg {
            os.write_float(10, v)?;
        }
        if let Some(v) = self.server_trusted {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.server_dedicated {
            os.write_bool(12, v)?;
        }
        if let Some(v) = self.strict {
            os.write_uint32(17, v)?;
        }
        if let Some(ref v) = self.fake_ip.as_ref() {
            os.write_string(25, &v)?;
        }
        for v in &self.players {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.game_state {
            os.write_enum(14, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.event {
            os.write_enum(15, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.mvm_wave {
            os.write_uint32(18, v)?;
        }
        if let Some(v) = self.mvm_credits_acquired {
            os.write_uint32(19, v)?;
        }
        if let Some(v) = self.mvm_credits_dropped {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.match_group {
            os.write_sint32(23, v)?;
        }
        if let Some(v) = self.lobby_mm_version {
            os.write_uint32(24, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGameServerMatchmakingStatus {
        CMsgGameServerMatchmakingStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "server_version",
                |m: &CMsgGameServerMatchmakingStatus| { &m.server_version },
                |m: &mut CMsgGameServerMatchmakingStatus| { &mut m.server_version },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ServerMatchmakingState>>(
                "matchmaking_state",
                |m: &CMsgGameServerMatchmakingStatus| { &m.matchmaking_state },
                |m: &mut CMsgGameServerMatchmakingStatus| { &mut m.matchmaking_state },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "map",
                |m: &CMsgGameServerMatchmakingStatus| { &m.map },
                |m: &mut CMsgGameServerMatchmakingStatus| { &mut m.map },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "tags",
                |m: &CMsgGameServerMatchmakingStatus| { &m.tags },
                |m: &mut CMsgGameServerMatchmakingStatus| { &mut m.tags },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "bot_count",
                |m: &CMsgGameServerMatchmakingStatus| { &m.bot_count },
                |m: &mut CMsgGameServerMatchmakingStatus| { &mut m.bot_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "num_spectators",
                |m: &CMsgGameServerMatchmakingStatus| { &m.num_spectators },
                |m: &mut CMsgGameServerMatchmakingStatus| { &mut m.num_spectators },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "max_players",
                |m: &CMsgGameServerMatchmakingStatus| { &m.max_players },
                |m: &mut CMsgGameServerMatchmakingStatus| { &mut m.max_players },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "slots_free",
                |m: &CMsgGameServerMatchmakingStatus| { &m.slots_free },
                |m: &mut CMsgGameServerMatchmakingStatus| { &mut m.slots_free },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "server_region",
                |m: &CMsgGameServerMatchmakingStatus| { &m.server_region },
                |m: &mut CMsgGameServerMatchmakingStatus| { &mut m.server_region },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "server_loadavg",
                |m: &CMsgGameServerMatchmakingStatus| { &m.server_loadavg },
                |m: &mut CMsgGameServerMatchmakingStatus| { &mut m.server_loadavg },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "server_trusted",
                |m: &CMsgGameServerMatchmakingStatus| { &m.server_trusted },
                |m: &mut CMsgGameServerMatchmakingStatus| { &mut m.server_trusted },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "server_dedicated",
                |m: &CMsgGameServerMatchmakingStatus| { &m.server_dedicated },
                |m: &mut CMsgGameServerMatchmakingStatus| { &mut m.server_dedicated },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "strict",
                |m: &CMsgGameServerMatchmakingStatus| { &m.strict },
                |m: &mut CMsgGameServerMatchmakingStatus| { &mut m.strict },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "fake_ip",
                |m: &CMsgGameServerMatchmakingStatus| { &m.fake_ip },
                |m: &mut CMsgGameServerMatchmakingStatus| { &mut m.fake_ip },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGameServerMatchmakingStatus_Player>>(
                "players",
                |m: &CMsgGameServerMatchmakingStatus| { &m.players },
                |m: &mut CMsgGameServerMatchmakingStatus| { &mut m.players },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TF_GC_GameState>>(
                "game_state",
                |m: &CMsgGameServerMatchmakingStatus| { &m.game_state },
                |m: &mut CMsgGameServerMatchmakingStatus| { &mut m.game_state },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CMsgGameServerMatchmakingStatus_Event>>(
                "event",
                |m: &CMsgGameServerMatchmakingStatus| { &m.event },
                |m: &mut CMsgGameServerMatchmakingStatus| { &mut m.event },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "mvm_wave",
                |m: &CMsgGameServerMatchmakingStatus| { &m.mvm_wave },
                |m: &mut CMsgGameServerMatchmakingStatus| { &mut m.mvm_wave },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "mvm_credits_acquired",
                |m: &CMsgGameServerMatchmakingStatus| { &m.mvm_credits_acquired },
                |m: &mut CMsgGameServerMatchmakingStatus| { &mut m.mvm_credits_acquired },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "mvm_credits_dropped",
                |m: &CMsgGameServerMatchmakingStatus| { &m.mvm_credits_dropped },
                |m: &mut CMsgGameServerMatchmakingStatus| { &mut m.mvm_credits_dropped },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                "match_group",
                |m: &CMsgGameServerMatchmakingStatus| { &m.match_group },
                |m: &mut CMsgGameServerMatchmakingStatus| { &mut m.match_group },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "lobby_mm_version",
                |m: &CMsgGameServerMatchmakingStatus| { &m.lobby_mm_version },
                |m: &mut CMsgGameServerMatchmakingStatus| { &mut m.lobby_mm_version },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGameServerMatchmakingStatus>(
                "CMsgGameServerMatchmakingStatus",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGameServerMatchmakingStatus {
        static instance: ::protobuf::rt::LazyV2<CMsgGameServerMatchmakingStatus> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGameServerMatchmakingStatus::new)
    }
}

impl ::protobuf::Clear for CMsgGameServerMatchmakingStatus {
    fn clear(&mut self) {
        self.server_version = ::std::option::Option::None;
        self.matchmaking_state = ::std::option::Option::None;
        self.map.clear();
        self.tags.clear();
        self.bot_count = ::std::option::Option::None;
        self.num_spectators = ::std::option::Option::None;
        self.max_players = ::std::option::Option::None;
        self.slots_free = ::std::option::Option::None;
        self.server_region = ::std::option::Option::None;
        self.server_loadavg = ::std::option::Option::None;
        self.server_trusted = ::std::option::Option::None;
        self.server_dedicated = ::std::option::Option::None;
        self.strict = ::std::option::Option::None;
        self.fake_ip.clear();
        self.players.clear();
        self.game_state = ::std::option::Option::None;
        self.event = ::std::option::Option::None;
        self.mvm_wave = ::std::option::Option::None;
        self.mvm_credits_acquired = ::std::option::Option::None;
        self.mvm_credits_dropped = ::std::option::Option::None;
        self.match_group = ::std::option::Option::None;
        self.lobby_mm_version = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGameServerMatchmakingStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGameServerMatchmakingStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGameServerMatchmakingStatus_Player {
    // message fields
    steam_id: ::std::option::Option<u64>,
    connect_state: ::std::option::Option<CMsgGameServerMatchmakingStatus_PlayerConnectState>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGameServerMatchmakingStatus_Player {
    fn default() -> &'a CMsgGameServerMatchmakingStatus_Player {
        <CMsgGameServerMatchmakingStatus_Player as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGameServerMatchmakingStatus_Player {
    pub fn new() -> CMsgGameServerMatchmakingStatus_Player {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id = 1;


    pub fn get_steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }
    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }

    // optional .CMsgGameServerMatchmakingStatus.PlayerConnectState connect_state = 2;


    pub fn get_connect_state(&self) -> CMsgGameServerMatchmakingStatus_PlayerConnectState {
        self.connect_state.unwrap_or(CMsgGameServerMatchmakingStatus_PlayerConnectState::INVALID)
    }
    pub fn clear_connect_state(&mut self) {
        self.connect_state = ::std::option::Option::None;
    }

    pub fn has_connect_state(&self) -> bool {
        self.connect_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connect_state(&mut self, v: CMsgGameServerMatchmakingStatus_PlayerConnectState) {
        self.connect_state = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGameServerMatchmakingStatus_Player {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steam_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.connect_state, 2, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id {
            my_size += 9;
        }
        if let Some(v) = self.connect_state {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steam_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.connect_state {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGameServerMatchmakingStatus_Player {
        CMsgGameServerMatchmakingStatus_Player::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steam_id",
                |m: &CMsgGameServerMatchmakingStatus_Player| { &m.steam_id },
                |m: &mut CMsgGameServerMatchmakingStatus_Player| { &mut m.steam_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CMsgGameServerMatchmakingStatus_PlayerConnectState>>(
                "connect_state",
                |m: &CMsgGameServerMatchmakingStatus_Player| { &m.connect_state },
                |m: &mut CMsgGameServerMatchmakingStatus_Player| { &mut m.connect_state },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGameServerMatchmakingStatus_Player>(
                "CMsgGameServerMatchmakingStatus.Player",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGameServerMatchmakingStatus_Player {
        static instance: ::protobuf::rt::LazyV2<CMsgGameServerMatchmakingStatus_Player> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGameServerMatchmakingStatus_Player::new)
    }
}

impl ::protobuf::Clear for CMsgGameServerMatchmakingStatus_Player {
    fn clear(&mut self) {
        self.steam_id = ::std::option::Option::None;
        self.connect_state = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGameServerMatchmakingStatus_Player {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGameServerMatchmakingStatus_Player {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgGameServerMatchmakingStatus_PlayerConnectState {
    INVALID = 0,
    CONNECTED = 1,
    RESERVED = 2,
}

impl ::protobuf::ProtobufEnum for CMsgGameServerMatchmakingStatus_PlayerConnectState {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgGameServerMatchmakingStatus_PlayerConnectState> {
        match value {
            0 => ::std::option::Option::Some(CMsgGameServerMatchmakingStatus_PlayerConnectState::INVALID),
            1 => ::std::option::Option::Some(CMsgGameServerMatchmakingStatus_PlayerConnectState::CONNECTED),
            2 => ::std::option::Option::Some(CMsgGameServerMatchmakingStatus_PlayerConnectState::RESERVED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgGameServerMatchmakingStatus_PlayerConnectState] = &[
            CMsgGameServerMatchmakingStatus_PlayerConnectState::INVALID,
            CMsgGameServerMatchmakingStatus_PlayerConnectState::CONNECTED,
            CMsgGameServerMatchmakingStatus_PlayerConnectState::RESERVED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<CMsgGameServerMatchmakingStatus_PlayerConnectState>("CMsgGameServerMatchmakingStatus.PlayerConnectState", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for CMsgGameServerMatchmakingStatus_PlayerConnectState {
}

impl ::std::default::Default for CMsgGameServerMatchmakingStatus_PlayerConnectState {
    fn default() -> Self {
        CMsgGameServerMatchmakingStatus_PlayerConnectState::INVALID
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGameServerMatchmakingStatus_PlayerConnectState {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgGameServerMatchmakingStatus_Event {
    None = 0,
    MvMVictory = 1,
    MvMDefeat = 2,
    AcknowledgePlayers = 3,
}

impl ::protobuf::ProtobufEnum for CMsgGameServerMatchmakingStatus_Event {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgGameServerMatchmakingStatus_Event> {
        match value {
            0 => ::std::option::Option::Some(CMsgGameServerMatchmakingStatus_Event::None),
            1 => ::std::option::Option::Some(CMsgGameServerMatchmakingStatus_Event::MvMVictory),
            2 => ::std::option::Option::Some(CMsgGameServerMatchmakingStatus_Event::MvMDefeat),
            3 => ::std::option::Option::Some(CMsgGameServerMatchmakingStatus_Event::AcknowledgePlayers),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgGameServerMatchmakingStatus_Event] = &[
            CMsgGameServerMatchmakingStatus_Event::None,
            CMsgGameServerMatchmakingStatus_Event::MvMVictory,
            CMsgGameServerMatchmakingStatus_Event::MvMDefeat,
            CMsgGameServerMatchmakingStatus_Event::AcknowledgePlayers,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<CMsgGameServerMatchmakingStatus_Event>("CMsgGameServerMatchmakingStatus.Event", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for CMsgGameServerMatchmakingStatus_Event {
}

impl ::std::default::Default for CMsgGameServerMatchmakingStatus_Event {
    fn default() -> Self {
        CMsgGameServerMatchmakingStatus_Event::None
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGameServerMatchmakingStatus_Event {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgMatchmakingProgress {
    // message fields
    avg_wait_time_new: ::std::option::Option<u32>,
    avg_wait_time_join_late: ::std::option::Option<u32>,
    your_wait_time: ::std::option::Option<u32>,
    matching_worldwide_searching_players: ::std::option::Option<u32>,
    matching_near_you_searching_players: ::std::option::Option<u32>,
    total_worldwide_searching_players: ::std::option::Option<u32>,
    total_near_you_searching_players: ::std::option::Option<u32>,
    matching_worldwide_active_players: ::std::option::Option<u32>,
    matching_near_you_active_players: ::std::option::Option<u32>,
    total_worldwide_active_players: ::std::option::Option<u32>,
    total_near_you_active_players: ::std::option::Option<u32>,
    matching_worldwide_empty_gameservers: ::std::option::Option<u32>,
    matching_near_you_empty_gameservers: ::std::option::Option<u32>,
    total_worldwide_empty_gameservers: ::std::option::Option<u32>,
    total_near_you_empty_gameservers: ::std::option::Option<u32>,
    urgency_pct: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgMatchmakingProgress {
    fn default() -> &'a CMsgMatchmakingProgress {
        <CMsgMatchmakingProgress as ::protobuf::Message>::default_instance()
    }
}

impl CMsgMatchmakingProgress {
    pub fn new() -> CMsgMatchmakingProgress {
        ::std::default::Default::default()
    }

    // optional uint32 avg_wait_time_new = 4;


    pub fn get_avg_wait_time_new(&self) -> u32 {
        self.avg_wait_time_new.unwrap_or(0)
    }
    pub fn clear_avg_wait_time_new(&mut self) {
        self.avg_wait_time_new = ::std::option::Option::None;
    }

    pub fn has_avg_wait_time_new(&self) -> bool {
        self.avg_wait_time_new.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avg_wait_time_new(&mut self, v: u32) {
        self.avg_wait_time_new = ::std::option::Option::Some(v);
    }

    // optional uint32 avg_wait_time_join_late = 5;


    pub fn get_avg_wait_time_join_late(&self) -> u32 {
        self.avg_wait_time_join_late.unwrap_or(0)
    }
    pub fn clear_avg_wait_time_join_late(&mut self) {
        self.avg_wait_time_join_late = ::std::option::Option::None;
    }

    pub fn has_avg_wait_time_join_late(&self) -> bool {
        self.avg_wait_time_join_late.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avg_wait_time_join_late(&mut self, v: u32) {
        self.avg_wait_time_join_late = ::std::option::Option::Some(v);
    }

    // optional uint32 your_wait_time = 6;


    pub fn get_your_wait_time(&self) -> u32 {
        self.your_wait_time.unwrap_or(0)
    }
    pub fn clear_your_wait_time(&mut self) {
        self.your_wait_time = ::std::option::Option::None;
    }

    pub fn has_your_wait_time(&self) -> bool {
        self.your_wait_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_your_wait_time(&mut self, v: u32) {
        self.your_wait_time = ::std::option::Option::Some(v);
    }

    // optional uint32 matching_worldwide_searching_players = 8;


    pub fn get_matching_worldwide_searching_players(&self) -> u32 {
        self.matching_worldwide_searching_players.unwrap_or(0)
    }
    pub fn clear_matching_worldwide_searching_players(&mut self) {
        self.matching_worldwide_searching_players = ::std::option::Option::None;
    }

    pub fn has_matching_worldwide_searching_players(&self) -> bool {
        self.matching_worldwide_searching_players.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matching_worldwide_searching_players(&mut self, v: u32) {
        self.matching_worldwide_searching_players = ::std::option::Option::Some(v);
    }

    // optional uint32 matching_near_you_searching_players = 9;


    pub fn get_matching_near_you_searching_players(&self) -> u32 {
        self.matching_near_you_searching_players.unwrap_or(0)
    }
    pub fn clear_matching_near_you_searching_players(&mut self) {
        self.matching_near_you_searching_players = ::std::option::Option::None;
    }

    pub fn has_matching_near_you_searching_players(&self) -> bool {
        self.matching_near_you_searching_players.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matching_near_you_searching_players(&mut self, v: u32) {
        self.matching_near_you_searching_players = ::std::option::Option::Some(v);
    }

    // optional uint32 total_worldwide_searching_players = 13;


    pub fn get_total_worldwide_searching_players(&self) -> u32 {
        self.total_worldwide_searching_players.unwrap_or(0)
    }
    pub fn clear_total_worldwide_searching_players(&mut self) {
        self.total_worldwide_searching_players = ::std::option::Option::None;
    }

    pub fn has_total_worldwide_searching_players(&self) -> bool {
        self.total_worldwide_searching_players.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_worldwide_searching_players(&mut self, v: u32) {
        self.total_worldwide_searching_players = ::std::option::Option::Some(v);
    }

    // optional uint32 total_near_you_searching_players = 14;


    pub fn get_total_near_you_searching_players(&self) -> u32 {
        self.total_near_you_searching_players.unwrap_or(0)
    }
    pub fn clear_total_near_you_searching_players(&mut self) {
        self.total_near_you_searching_players = ::std::option::Option::None;
    }

    pub fn has_total_near_you_searching_players(&self) -> bool {
        self.total_near_you_searching_players.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_near_you_searching_players(&mut self, v: u32) {
        self.total_near_you_searching_players = ::std::option::Option::Some(v);
    }

    // optional uint32 matching_worldwide_active_players = 15;


    pub fn get_matching_worldwide_active_players(&self) -> u32 {
        self.matching_worldwide_active_players.unwrap_or(0)
    }
    pub fn clear_matching_worldwide_active_players(&mut self) {
        self.matching_worldwide_active_players = ::std::option::Option::None;
    }

    pub fn has_matching_worldwide_active_players(&self) -> bool {
        self.matching_worldwide_active_players.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matching_worldwide_active_players(&mut self, v: u32) {
        self.matching_worldwide_active_players = ::std::option::Option::Some(v);
    }

    // optional uint32 matching_near_you_active_players = 16;


    pub fn get_matching_near_you_active_players(&self) -> u32 {
        self.matching_near_you_active_players.unwrap_or(0)
    }
    pub fn clear_matching_near_you_active_players(&mut self) {
        self.matching_near_you_active_players = ::std::option::Option::None;
    }

    pub fn has_matching_near_you_active_players(&self) -> bool {
        self.matching_near_you_active_players.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matching_near_you_active_players(&mut self, v: u32) {
        self.matching_near_you_active_players = ::std::option::Option::Some(v);
    }

    // optional uint32 total_worldwide_active_players = 17;


    pub fn get_total_worldwide_active_players(&self) -> u32 {
        self.total_worldwide_active_players.unwrap_or(0)
    }
    pub fn clear_total_worldwide_active_players(&mut self) {
        self.total_worldwide_active_players = ::std::option::Option::None;
    }

    pub fn has_total_worldwide_active_players(&self) -> bool {
        self.total_worldwide_active_players.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_worldwide_active_players(&mut self, v: u32) {
        self.total_worldwide_active_players = ::std::option::Option::Some(v);
    }

    // optional uint32 total_near_you_active_players = 18;


    pub fn get_total_near_you_active_players(&self) -> u32 {
        self.total_near_you_active_players.unwrap_or(0)
    }
    pub fn clear_total_near_you_active_players(&mut self) {
        self.total_near_you_active_players = ::std::option::Option::None;
    }

    pub fn has_total_near_you_active_players(&self) -> bool {
        self.total_near_you_active_players.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_near_you_active_players(&mut self, v: u32) {
        self.total_near_you_active_players = ::std::option::Option::Some(v);
    }

    // optional uint32 matching_worldwide_empty_gameservers = 19;


    pub fn get_matching_worldwide_empty_gameservers(&self) -> u32 {
        self.matching_worldwide_empty_gameservers.unwrap_or(0)
    }
    pub fn clear_matching_worldwide_empty_gameservers(&mut self) {
        self.matching_worldwide_empty_gameservers = ::std::option::Option::None;
    }

    pub fn has_matching_worldwide_empty_gameservers(&self) -> bool {
        self.matching_worldwide_empty_gameservers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matching_worldwide_empty_gameservers(&mut self, v: u32) {
        self.matching_worldwide_empty_gameservers = ::std::option::Option::Some(v);
    }

    // optional uint32 matching_near_you_empty_gameservers = 20;


    pub fn get_matching_near_you_empty_gameservers(&self) -> u32 {
        self.matching_near_you_empty_gameservers.unwrap_or(0)
    }
    pub fn clear_matching_near_you_empty_gameservers(&mut self) {
        self.matching_near_you_empty_gameservers = ::std::option::Option::None;
    }

    pub fn has_matching_near_you_empty_gameservers(&self) -> bool {
        self.matching_near_you_empty_gameservers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matching_near_you_empty_gameservers(&mut self, v: u32) {
        self.matching_near_you_empty_gameservers = ::std::option::Option::Some(v);
    }

    // optional uint32 total_worldwide_empty_gameservers = 21;


    pub fn get_total_worldwide_empty_gameservers(&self) -> u32 {
        self.total_worldwide_empty_gameservers.unwrap_or(0)
    }
    pub fn clear_total_worldwide_empty_gameservers(&mut self) {
        self.total_worldwide_empty_gameservers = ::std::option::Option::None;
    }

    pub fn has_total_worldwide_empty_gameservers(&self) -> bool {
        self.total_worldwide_empty_gameservers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_worldwide_empty_gameservers(&mut self, v: u32) {
        self.total_worldwide_empty_gameservers = ::std::option::Option::Some(v);
    }

    // optional uint32 total_near_you_empty_gameservers = 22;


    pub fn get_total_near_you_empty_gameservers(&self) -> u32 {
        self.total_near_you_empty_gameservers.unwrap_or(0)
    }
    pub fn clear_total_near_you_empty_gameservers(&mut self) {
        self.total_near_you_empty_gameservers = ::std::option::Option::None;
    }

    pub fn has_total_near_you_empty_gameservers(&self) -> bool {
        self.total_near_you_empty_gameservers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_near_you_empty_gameservers(&mut self, v: u32) {
        self.total_near_you_empty_gameservers = ::std::option::Option::Some(v);
    }

    // optional uint32 urgency_pct = 1;


    pub fn get_urgency_pct(&self) -> u32 {
        self.urgency_pct.unwrap_or(0)
    }
    pub fn clear_urgency_pct(&mut self) {
        self.urgency_pct = ::std::option::Option::None;
    }

    pub fn has_urgency_pct(&self) -> bool {
        self.urgency_pct.is_some()
    }

    // Param is passed by value, moved
    pub fn set_urgency_pct(&mut self, v: u32) {
        self.urgency_pct = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgMatchmakingProgress {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.avg_wait_time_new = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.avg_wait_time_join_late = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.your_wait_time = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.matching_worldwide_searching_players = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.matching_near_you_searching_players = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.total_worldwide_searching_players = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.total_near_you_searching_players = ::std::option::Option::Some(tmp);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.matching_worldwide_active_players = ::std::option::Option::Some(tmp);
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.matching_near_you_active_players = ::std::option::Option::Some(tmp);
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.total_worldwide_active_players = ::std::option::Option::Some(tmp);
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.total_near_you_active_players = ::std::option::Option::Some(tmp);
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.matching_worldwide_empty_gameservers = ::std::option::Option::Some(tmp);
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.matching_near_you_empty_gameservers = ::std::option::Option::Some(tmp);
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.total_worldwide_empty_gameservers = ::std::option::Option::Some(tmp);
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.total_near_you_empty_gameservers = ::std::option::Option::Some(tmp);
                },
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.urgency_pct = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.avg_wait_time_new {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.avg_wait_time_join_late {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.your_wait_time {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.matching_worldwide_searching_players {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.matching_near_you_searching_players {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.total_worldwide_searching_players {
            my_size += ::protobuf::rt::value_size(13, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.total_near_you_searching_players {
            my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.matching_worldwide_active_players {
            my_size += ::protobuf::rt::value_size(15, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.matching_near_you_active_players {
            my_size += ::protobuf::rt::value_size(16, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.total_worldwide_active_players {
            my_size += ::protobuf::rt::value_size(17, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.total_near_you_active_players {
            my_size += ::protobuf::rt::value_size(18, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.matching_worldwide_empty_gameservers {
            my_size += ::protobuf::rt::value_size(19, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.matching_near_you_empty_gameservers {
            my_size += ::protobuf::rt::value_size(20, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.total_worldwide_empty_gameservers {
            my_size += ::protobuf::rt::value_size(21, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.total_near_you_empty_gameservers {
            my_size += ::protobuf::rt::value_size(22, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.urgency_pct {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.avg_wait_time_new {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.avg_wait_time_join_late {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.your_wait_time {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.matching_worldwide_searching_players {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.matching_near_you_searching_players {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.total_worldwide_searching_players {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.total_near_you_searching_players {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.matching_worldwide_active_players {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.matching_near_you_active_players {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.total_worldwide_active_players {
            os.write_uint32(17, v)?;
        }
        if let Some(v) = self.total_near_you_active_players {
            os.write_uint32(18, v)?;
        }
        if let Some(v) = self.matching_worldwide_empty_gameservers {
            os.write_uint32(19, v)?;
        }
        if let Some(v) = self.matching_near_you_empty_gameservers {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.total_worldwide_empty_gameservers {
            os.write_uint32(21, v)?;
        }
        if let Some(v) = self.total_near_you_empty_gameservers {
            os.write_uint32(22, v)?;
        }
        if let Some(v) = self.urgency_pct {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgMatchmakingProgress {
        CMsgMatchmakingProgress::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "avg_wait_time_new",
                |m: &CMsgMatchmakingProgress| { &m.avg_wait_time_new },
                |m: &mut CMsgMatchmakingProgress| { &mut m.avg_wait_time_new },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "avg_wait_time_join_late",
                |m: &CMsgMatchmakingProgress| { &m.avg_wait_time_join_late },
                |m: &mut CMsgMatchmakingProgress| { &mut m.avg_wait_time_join_late },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "your_wait_time",
                |m: &CMsgMatchmakingProgress| { &m.your_wait_time },
                |m: &mut CMsgMatchmakingProgress| { &mut m.your_wait_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "matching_worldwide_searching_players",
                |m: &CMsgMatchmakingProgress| { &m.matching_worldwide_searching_players },
                |m: &mut CMsgMatchmakingProgress| { &mut m.matching_worldwide_searching_players },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "matching_near_you_searching_players",
                |m: &CMsgMatchmakingProgress| { &m.matching_near_you_searching_players },
                |m: &mut CMsgMatchmakingProgress| { &mut m.matching_near_you_searching_players },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "total_worldwide_searching_players",
                |m: &CMsgMatchmakingProgress| { &m.total_worldwide_searching_players },
                |m: &mut CMsgMatchmakingProgress| { &mut m.total_worldwide_searching_players },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "total_near_you_searching_players",
                |m: &CMsgMatchmakingProgress| { &m.total_near_you_searching_players },
                |m: &mut CMsgMatchmakingProgress| { &mut m.total_near_you_searching_players },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "matching_worldwide_active_players",
                |m: &CMsgMatchmakingProgress| { &m.matching_worldwide_active_players },
                |m: &mut CMsgMatchmakingProgress| { &mut m.matching_worldwide_active_players },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "matching_near_you_active_players",
                |m: &CMsgMatchmakingProgress| { &m.matching_near_you_active_players },
                |m: &mut CMsgMatchmakingProgress| { &mut m.matching_near_you_active_players },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "total_worldwide_active_players",
                |m: &CMsgMatchmakingProgress| { &m.total_worldwide_active_players },
                |m: &mut CMsgMatchmakingProgress| { &mut m.total_worldwide_active_players },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "total_near_you_active_players",
                |m: &CMsgMatchmakingProgress| { &m.total_near_you_active_players },
                |m: &mut CMsgMatchmakingProgress| { &mut m.total_near_you_active_players },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "matching_worldwide_empty_gameservers",
                |m: &CMsgMatchmakingProgress| { &m.matching_worldwide_empty_gameservers },
                |m: &mut CMsgMatchmakingProgress| { &mut m.matching_worldwide_empty_gameservers },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "matching_near_you_empty_gameservers",
                |m: &CMsgMatchmakingProgress| { &m.matching_near_you_empty_gameservers },
                |m: &mut CMsgMatchmakingProgress| { &mut m.matching_near_you_empty_gameservers },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "total_worldwide_empty_gameservers",
                |m: &CMsgMatchmakingProgress| { &m.total_worldwide_empty_gameservers },
                |m: &mut CMsgMatchmakingProgress| { &mut m.total_worldwide_empty_gameservers },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "total_near_you_empty_gameservers",
                |m: &CMsgMatchmakingProgress| { &m.total_near_you_empty_gameservers },
                |m: &mut CMsgMatchmakingProgress| { &mut m.total_near_you_empty_gameservers },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "urgency_pct",
                |m: &CMsgMatchmakingProgress| { &m.urgency_pct },
                |m: &mut CMsgMatchmakingProgress| { &mut m.urgency_pct },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgMatchmakingProgress>(
                "CMsgMatchmakingProgress",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgMatchmakingProgress {
        static instance: ::protobuf::rt::LazyV2<CMsgMatchmakingProgress> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgMatchmakingProgress::new)
    }
}

impl ::protobuf::Clear for CMsgMatchmakingProgress {
    fn clear(&mut self) {
        self.avg_wait_time_new = ::std::option::Option::None;
        self.avg_wait_time_join_late = ::std::option::Option::None;
        self.your_wait_time = ::std::option::Option::None;
        self.matching_worldwide_searching_players = ::std::option::Option::None;
        self.matching_near_you_searching_players = ::std::option::Option::None;
        self.total_worldwide_searching_players = ::std::option::Option::None;
        self.total_near_you_searching_players = ::std::option::Option::None;
        self.matching_worldwide_active_players = ::std::option::Option::None;
        self.matching_near_you_active_players = ::std::option::Option::None;
        self.total_worldwide_active_players = ::std::option::Option::None;
        self.total_near_you_active_players = ::std::option::Option::None;
        self.matching_worldwide_empty_gameservers = ::std::option::Option::None;
        self.matching_near_you_empty_gameservers = ::std::option::Option::None;
        self.total_worldwide_empty_gameservers = ::std::option::Option::None;
        self.total_near_you_empty_gameservers = ::std::option::Option::None;
        self.urgency_pct = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgMatchmakingProgress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgMatchmakingProgress {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgMvMVictoryInfo {
    // message fields
    pub players: ::protobuf::RepeatedField<CMsgMvMVictoryInfo_Player>,
    tour_name: ::protobuf::SingularField<::std::string::String>,
    mission_name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgMvMVictoryInfo {
    fn default() -> &'a CMsgMvMVictoryInfo {
        <CMsgMvMVictoryInfo as ::protobuf::Message>::default_instance()
    }
}

impl CMsgMvMVictoryInfo {
    pub fn new() -> CMsgMvMVictoryInfo {
        ::std::default::Default::default()
    }

    // repeated .CMsgMvMVictoryInfo.Player players = 1;


    pub fn get_players(&self) -> &[CMsgMvMVictoryInfo_Player] {
        &self.players
    }
    pub fn clear_players(&mut self) {
        self.players.clear();
    }

    // Param is passed by value, moved
    pub fn set_players(&mut self, v: ::protobuf::RepeatedField<CMsgMvMVictoryInfo_Player>) {
        self.players = v;
    }

    // Mutable pointer to the field.
    pub fn mut_players(&mut self) -> &mut ::protobuf::RepeatedField<CMsgMvMVictoryInfo_Player> {
        &mut self.players
    }

    // Take field
    pub fn take_players(&mut self) -> ::protobuf::RepeatedField<CMsgMvMVictoryInfo_Player> {
        ::std::mem::replace(&mut self.players, ::protobuf::RepeatedField::new())
    }

    // optional string tour_name = 2;


    pub fn get_tour_name(&self) -> &str {
        match self.tour_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_tour_name(&mut self) {
        self.tour_name.clear();
    }

    pub fn has_tour_name(&self) -> bool {
        self.tour_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tour_name(&mut self, v: ::std::string::String) {
        self.tour_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tour_name(&mut self) -> &mut ::std::string::String {
        if self.tour_name.is_none() {
            self.tour_name.set_default();
        }
        self.tour_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_tour_name(&mut self) -> ::std::string::String {
        self.tour_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string mission_name = 3;


    pub fn get_mission_name(&self) -> &str {
        match self.mission_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_mission_name(&mut self) {
        self.mission_name.clear();
    }

    pub fn has_mission_name(&self) -> bool {
        self.mission_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mission_name(&mut self, v: ::std::string::String) {
        self.mission_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mission_name(&mut self) -> &mut ::std::string::String {
        if self.mission_name.is_none() {
            self.mission_name.set_default();
        }
        self.mission_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_mission_name(&mut self) -> ::std::string::String {
        self.mission_name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgMvMVictoryInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.players {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.players)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.tour_name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.mission_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.players {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.tour_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.mission_name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.players {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.tour_name.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.mission_name.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgMvMVictoryInfo {
        CMsgMvMVictoryInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgMvMVictoryInfo_Player>>(
                "players",
                |m: &CMsgMvMVictoryInfo| { &m.players },
                |m: &mut CMsgMvMVictoryInfo| { &mut m.players },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "tour_name",
                |m: &CMsgMvMVictoryInfo| { &m.tour_name },
                |m: &mut CMsgMvMVictoryInfo| { &mut m.tour_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "mission_name",
                |m: &CMsgMvMVictoryInfo| { &m.mission_name },
                |m: &mut CMsgMvMVictoryInfo| { &mut m.mission_name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgMvMVictoryInfo>(
                "CMsgMvMVictoryInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgMvMVictoryInfo {
        static instance: ::protobuf::rt::LazyV2<CMsgMvMVictoryInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgMvMVictoryInfo::new)
    }
}

impl ::protobuf::Clear for CMsgMvMVictoryInfo {
    fn clear(&mut self) {
        self.players.clear();
        self.tour_name.clear();
        self.mission_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgMvMVictoryInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgMvMVictoryInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgMvMVictoryInfo_Item {
    // message fields
    grant_reason: ::std::option::Option<CMsgMvMVictoryInfo_GrantReason>,
    item_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    squad_surplus_claimer_steam_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgMvMVictoryInfo_Item {
    fn default() -> &'a CMsgMvMVictoryInfo_Item {
        <CMsgMvMVictoryInfo_Item as ::protobuf::Message>::default_instance()
    }
}

impl CMsgMvMVictoryInfo_Item {
    pub fn new() -> CMsgMvMVictoryInfo_Item {
        ::std::default::Default::default()
    }

    // optional .CMsgMvMVictoryInfo.GrantReason grant_reason = 1;


    pub fn get_grant_reason(&self) -> CMsgMvMVictoryInfo_GrantReason {
        self.grant_reason.unwrap_or(CMsgMvMVictoryInfo_GrantReason::INVALID)
    }
    pub fn clear_grant_reason(&mut self) {
        self.grant_reason = ::std::option::Option::None;
    }

    pub fn has_grant_reason(&self) -> bool {
        self.grant_reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_grant_reason(&mut self, v: CMsgMvMVictoryInfo_GrantReason) {
        self.grant_reason = ::std::option::Option::Some(v);
    }

    // optional bytes item_data = 2;


    pub fn get_item_data(&self) -> &[u8] {
        match self.item_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_item_data(&mut self) {
        self.item_data.clear();
    }

    pub fn has_item_data(&self) -> bool {
        self.item_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.item_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_item_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.item_data.is_none() {
            self.item_data.set_default();
        }
        self.item_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_item_data(&mut self) -> ::std::vec::Vec<u8> {
        self.item_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional fixed64 squad_surplus_claimer_steam_id = 3;


    pub fn get_squad_surplus_claimer_steam_id(&self) -> u64 {
        self.squad_surplus_claimer_steam_id.unwrap_or(0)
    }
    pub fn clear_squad_surplus_claimer_steam_id(&mut self) {
        self.squad_surplus_claimer_steam_id = ::std::option::Option::None;
    }

    pub fn has_squad_surplus_claimer_steam_id(&self) -> bool {
        self.squad_surplus_claimer_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_squad_surplus_claimer_steam_id(&mut self, v: u64) {
        self.squad_surplus_claimer_steam_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgMvMVictoryInfo_Item {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.grant_reason, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.item_data)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.squad_surplus_claimer_steam_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.grant_reason {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(ref v) = self.item_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.squad_surplus_claimer_steam_id {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.grant_reason {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.item_data.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(v) = self.squad_surplus_claimer_steam_id {
            os.write_fixed64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgMvMVictoryInfo_Item {
        CMsgMvMVictoryInfo_Item::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CMsgMvMVictoryInfo_GrantReason>>(
                "grant_reason",
                |m: &CMsgMvMVictoryInfo_Item| { &m.grant_reason },
                |m: &mut CMsgMvMVictoryInfo_Item| { &mut m.grant_reason },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "item_data",
                |m: &CMsgMvMVictoryInfo_Item| { &m.item_data },
                |m: &mut CMsgMvMVictoryInfo_Item| { &mut m.item_data },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "squad_surplus_claimer_steam_id",
                |m: &CMsgMvMVictoryInfo_Item| { &m.squad_surplus_claimer_steam_id },
                |m: &mut CMsgMvMVictoryInfo_Item| { &mut m.squad_surplus_claimer_steam_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgMvMVictoryInfo_Item>(
                "CMsgMvMVictoryInfo.Item",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgMvMVictoryInfo_Item {
        static instance: ::protobuf::rt::LazyV2<CMsgMvMVictoryInfo_Item> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgMvMVictoryInfo_Item::new)
    }
}

impl ::protobuf::Clear for CMsgMvMVictoryInfo_Item {
    fn clear(&mut self) {
        self.grant_reason = ::std::option::Option::None;
        self.item_data.clear();
        self.squad_surplus_claimer_steam_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgMvMVictoryInfo_Item {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgMvMVictoryInfo_Item {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgMvMVictoryInfo_Player {
    // message fields
    steam_id: ::std::option::Option<u64>,
    badge_granted: ::std::option::Option<bool>,
    badge_progress_updated: ::std::option::Option<bool>,
    badge_leveled: ::std::option::Option<bool>,
    badge_level: ::std::option::Option<u32>,
    badge_progress_bits: ::std::option::Option<u32>,
    pub items: ::protobuf::RepeatedField<CMsgMvMVictoryInfo_Item>,
    voucher_missing: ::std::option::Option<bool>,
    badge_points: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgMvMVictoryInfo_Player {
    fn default() -> &'a CMsgMvMVictoryInfo_Player {
        <CMsgMvMVictoryInfo_Player as ::protobuf::Message>::default_instance()
    }
}

impl CMsgMvMVictoryInfo_Player {
    pub fn new() -> CMsgMvMVictoryInfo_Player {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id = 1;


    pub fn get_steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }
    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }

    // optional bool badge_granted = 3;


    pub fn get_badge_granted(&self) -> bool {
        self.badge_granted.unwrap_or(false)
    }
    pub fn clear_badge_granted(&mut self) {
        self.badge_granted = ::std::option::Option::None;
    }

    pub fn has_badge_granted(&self) -> bool {
        self.badge_granted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_badge_granted(&mut self, v: bool) {
        self.badge_granted = ::std::option::Option::Some(v);
    }

    // optional bool badge_progress_updated = 4;


    pub fn get_badge_progress_updated(&self) -> bool {
        self.badge_progress_updated.unwrap_or(false)
    }
    pub fn clear_badge_progress_updated(&mut self) {
        self.badge_progress_updated = ::std::option::Option::None;
    }

    pub fn has_badge_progress_updated(&self) -> bool {
        self.badge_progress_updated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_badge_progress_updated(&mut self, v: bool) {
        self.badge_progress_updated = ::std::option::Option::Some(v);
    }

    // optional bool badge_leveled = 5;


    pub fn get_badge_leveled(&self) -> bool {
        self.badge_leveled.unwrap_or(false)
    }
    pub fn clear_badge_leveled(&mut self) {
        self.badge_leveled = ::std::option::Option::None;
    }

    pub fn has_badge_leveled(&self) -> bool {
        self.badge_leveled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_badge_leveled(&mut self, v: bool) {
        self.badge_leveled = ::std::option::Option::Some(v);
    }

    // optional uint32 badge_level = 6;


    pub fn get_badge_level(&self) -> u32 {
        self.badge_level.unwrap_or(0)
    }
    pub fn clear_badge_level(&mut self) {
        self.badge_level = ::std::option::Option::None;
    }

    pub fn has_badge_level(&self) -> bool {
        self.badge_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_badge_level(&mut self, v: u32) {
        self.badge_level = ::std::option::Option::Some(v);
    }

    // optional uint32 badge_progress_bits = 7;


    pub fn get_badge_progress_bits(&self) -> u32 {
        self.badge_progress_bits.unwrap_or(0)
    }
    pub fn clear_badge_progress_bits(&mut self) {
        self.badge_progress_bits = ::std::option::Option::None;
    }

    pub fn has_badge_progress_bits(&self) -> bool {
        self.badge_progress_bits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_badge_progress_bits(&mut self, v: u32) {
        self.badge_progress_bits = ::std::option::Option::Some(v);
    }

    // repeated .CMsgMvMVictoryInfo.Item items = 8;


    pub fn get_items(&self) -> &[CMsgMvMVictoryInfo_Item] {
        &self.items
    }
    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<CMsgMvMVictoryInfo_Item>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<CMsgMvMVictoryInfo_Item> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<CMsgMvMVictoryInfo_Item> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }

    // optional bool voucher_missing = 9;


    pub fn get_voucher_missing(&self) -> bool {
        self.voucher_missing.unwrap_or(false)
    }
    pub fn clear_voucher_missing(&mut self) {
        self.voucher_missing = ::std::option::Option::None;
    }

    pub fn has_voucher_missing(&self) -> bool {
        self.voucher_missing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_voucher_missing(&mut self, v: bool) {
        self.voucher_missing = ::std::option::Option::Some(v);
    }

    // optional uint32 badge_points = 10;


    pub fn get_badge_points(&self) -> u32 {
        self.badge_points.unwrap_or(0)
    }
    pub fn clear_badge_points(&mut self) {
        self.badge_points = ::std::option::Option::None;
    }

    pub fn has_badge_points(&self) -> bool {
        self.badge_points.is_some()
    }

    // Param is passed by value, moved
    pub fn set_badge_points(&mut self, v: u32) {
        self.badge_points = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgMvMVictoryInfo_Player {
    fn is_initialized(&self) -> bool {
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steam_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.badge_granted = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.badge_progress_updated = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.badge_leveled = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.badge_level = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.badge_progress_bits = ::std::option::Option::Some(tmp);
                },
                8 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.voucher_missing = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.badge_points = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id {
            my_size += 9;
        }
        if let Some(v) = self.badge_granted {
            my_size += 2;
        }
        if let Some(v) = self.badge_progress_updated {
            my_size += 2;
        }
        if let Some(v) = self.badge_leveled {
            my_size += 2;
        }
        if let Some(v) = self.badge_level {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.badge_progress_bits {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.voucher_missing {
            my_size += 2;
        }
        if let Some(v) = self.badge_points {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steam_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.badge_granted {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.badge_progress_updated {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.badge_leveled {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.badge_level {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.badge_progress_bits {
            os.write_uint32(7, v)?;
        }
        for v in &self.items {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.voucher_missing {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.badge_points {
            os.write_uint32(10, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgMvMVictoryInfo_Player {
        CMsgMvMVictoryInfo_Player::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steam_id",
                |m: &CMsgMvMVictoryInfo_Player| { &m.steam_id },
                |m: &mut CMsgMvMVictoryInfo_Player| { &mut m.steam_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "badge_granted",
                |m: &CMsgMvMVictoryInfo_Player| { &m.badge_granted },
                |m: &mut CMsgMvMVictoryInfo_Player| { &mut m.badge_granted },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "badge_progress_updated",
                |m: &CMsgMvMVictoryInfo_Player| { &m.badge_progress_updated },
                |m: &mut CMsgMvMVictoryInfo_Player| { &mut m.badge_progress_updated },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "badge_leveled",
                |m: &CMsgMvMVictoryInfo_Player| { &m.badge_leveled },
                |m: &mut CMsgMvMVictoryInfo_Player| { &mut m.badge_leveled },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "badge_level",
                |m: &CMsgMvMVictoryInfo_Player| { &m.badge_level },
                |m: &mut CMsgMvMVictoryInfo_Player| { &mut m.badge_level },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "badge_progress_bits",
                |m: &CMsgMvMVictoryInfo_Player| { &m.badge_progress_bits },
                |m: &mut CMsgMvMVictoryInfo_Player| { &mut m.badge_progress_bits },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgMvMVictoryInfo_Item>>(
                "items",
                |m: &CMsgMvMVictoryInfo_Player| { &m.items },
                |m: &mut CMsgMvMVictoryInfo_Player| { &mut m.items },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "voucher_missing",
                |m: &CMsgMvMVictoryInfo_Player| { &m.voucher_missing },
                |m: &mut CMsgMvMVictoryInfo_Player| { &mut m.voucher_missing },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "badge_points",
                |m: &CMsgMvMVictoryInfo_Player| { &m.badge_points },
                |m: &mut CMsgMvMVictoryInfo_Player| { &mut m.badge_points },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgMvMVictoryInfo_Player>(
                "CMsgMvMVictoryInfo.Player",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgMvMVictoryInfo_Player {
        static instance: ::protobuf::rt::LazyV2<CMsgMvMVictoryInfo_Player> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgMvMVictoryInfo_Player::new)
    }
}

impl ::protobuf::Clear for CMsgMvMVictoryInfo_Player {
    fn clear(&mut self) {
        self.steam_id = ::std::option::Option::None;
        self.badge_granted = ::std::option::Option::None;
        self.badge_progress_updated = ::std::option::Option::None;
        self.badge_leveled = ::std::option::Option::None;
        self.badge_level = ::std::option::Option::None;
        self.badge_progress_bits = ::std::option::Option::None;
        self.items.clear();
        self.voucher_missing = ::std::option::Option::None;
        self.badge_points = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgMvMVictoryInfo_Player {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgMvMVictoryInfo_Player {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgMvMVictoryInfo_GrantReason {
    INVALID = 0,
    BADGE_LEVELED = 1,
    SQUAD_SURPLUS = 2,
    MANN_UP = 3,
    HELP_A_NOOB = 4,
}

impl ::protobuf::ProtobufEnum for CMsgMvMVictoryInfo_GrantReason {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgMvMVictoryInfo_GrantReason> {
        match value {
            0 => ::std::option::Option::Some(CMsgMvMVictoryInfo_GrantReason::INVALID),
            1 => ::std::option::Option::Some(CMsgMvMVictoryInfo_GrantReason::BADGE_LEVELED),
            2 => ::std::option::Option::Some(CMsgMvMVictoryInfo_GrantReason::SQUAD_SURPLUS),
            3 => ::std::option::Option::Some(CMsgMvMVictoryInfo_GrantReason::MANN_UP),
            4 => ::std::option::Option::Some(CMsgMvMVictoryInfo_GrantReason::HELP_A_NOOB),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgMvMVictoryInfo_GrantReason] = &[
            CMsgMvMVictoryInfo_GrantReason::INVALID,
            CMsgMvMVictoryInfo_GrantReason::BADGE_LEVELED,
            CMsgMvMVictoryInfo_GrantReason::SQUAD_SURPLUS,
            CMsgMvMVictoryInfo_GrantReason::MANN_UP,
            CMsgMvMVictoryInfo_GrantReason::HELP_A_NOOB,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<CMsgMvMVictoryInfo_GrantReason>("CMsgMvMVictoryInfo.GrantReason", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for CMsgMvMVictoryInfo_GrantReason {
}

impl ::std::default::Default for CMsgMvMVictoryInfo_GrantReason {
    fn default() -> Self {
        CMsgMvMVictoryInfo_GrantReason::INVALID
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgMvMVictoryInfo_GrantReason {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CGCMsgTFHelloResponse {
    // message fields
    version_check: ::std::option::Option<u32>,
    pub version_checksum: ::std::vec::Vec<u64>,
    version_verbose: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CGCMsgTFHelloResponse {
    fn default() -> &'a CGCMsgTFHelloResponse {
        <CGCMsgTFHelloResponse as ::protobuf::Message>::default_instance()
    }
}

impl CGCMsgTFHelloResponse {
    pub fn new() -> CGCMsgTFHelloResponse {
        ::std::default::Default::default()
    }

    // optional uint32 version_check = 1;


    pub fn get_version_check(&self) -> u32 {
        self.version_check.unwrap_or(0)
    }
    pub fn clear_version_check(&mut self) {
        self.version_check = ::std::option::Option::None;
    }

    pub fn has_version_check(&self) -> bool {
        self.version_check.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version_check(&mut self, v: u32) {
        self.version_check = ::std::option::Option::Some(v);
    }

    // repeated uint64 version_checksum = 2;


    pub fn get_version_checksum(&self) -> &[u64] {
        &self.version_checksum
    }
    pub fn clear_version_checksum(&mut self) {
        self.version_checksum.clear();
    }

    // Param is passed by value, moved
    pub fn set_version_checksum(&mut self, v: ::std::vec::Vec<u64>) {
        self.version_checksum = v;
    }

    // Mutable pointer to the field.
    pub fn mut_version_checksum(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.version_checksum
    }

    // Take field
    pub fn take_version_checksum(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.version_checksum, ::std::vec::Vec::new())
    }

    // optional uint32 version_verbose = 3;


    pub fn get_version_verbose(&self) -> u32 {
        self.version_verbose.unwrap_or(0)
    }
    pub fn clear_version_verbose(&mut self) {
        self.version_verbose = ::std::option::Option::None;
    }

    pub fn has_version_verbose(&self) -> bool {
        self.version_verbose.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version_verbose(&mut self, v: u32) {
        self.version_verbose = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CGCMsgTFHelloResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.version_check = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.version_checksum)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.version_verbose = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.version_check {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.version_checksum {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.version_verbose {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.version_check {
            os.write_uint32(1, v)?;
        }
        for v in &self.version_checksum {
            os.write_uint64(2, *v)?;
        };
        if let Some(v) = self.version_verbose {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CGCMsgTFHelloResponse {
        CGCMsgTFHelloResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "version_check",
                |m: &CGCMsgTFHelloResponse| { &m.version_check },
                |m: &mut CGCMsgTFHelloResponse| { &mut m.version_check },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "version_checksum",
                |m: &CGCMsgTFHelloResponse| { &m.version_checksum },
                |m: &mut CGCMsgTFHelloResponse| { &mut m.version_checksum },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "version_verbose",
                |m: &CGCMsgTFHelloResponse| { &m.version_verbose },
                |m: &mut CGCMsgTFHelloResponse| { &mut m.version_verbose },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CGCMsgTFHelloResponse>(
                "CGCMsgTFHelloResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CGCMsgTFHelloResponse {
        static instance: ::protobuf::rt::LazyV2<CGCMsgTFHelloResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CGCMsgTFHelloResponse::new)
    }
}

impl ::protobuf::Clear for CGCMsgTFHelloResponse {
    fn clear(&mut self) {
        self.version_check = ::std::option::Option::None;
        self.version_checksum.clear();
        self.version_verbose = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CGCMsgTFHelloResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CGCMsgTFHelloResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CGCMsgTFSync {
    // message fields
    version_checksum: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    version_check: ::std::option::Option<u32>,
    version_check_ex: ::std::option::Option<u32>,
    version_check_ex2: ::std::option::Option<u32>,
    version_checksum_ex: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CGCMsgTFSync {
    fn default() -> &'a CGCMsgTFSync {
        <CGCMsgTFSync as ::protobuf::Message>::default_instance()
    }
}

impl CGCMsgTFSync {
    pub fn new() -> CGCMsgTFSync {
        ::std::default::Default::default()
    }

    // optional bytes version_checksum = 1;


    pub fn get_version_checksum(&self) -> &[u8] {
        match self.version_checksum.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_version_checksum(&mut self) {
        self.version_checksum.clear();
    }

    pub fn has_version_checksum(&self) -> bool {
        self.version_checksum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version_checksum(&mut self, v: ::std::vec::Vec<u8>) {
        self.version_checksum = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version_checksum(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.version_checksum.is_none() {
            self.version_checksum.set_default();
        }
        self.version_checksum.as_mut().unwrap()
    }

    // Take field
    pub fn take_version_checksum(&mut self) -> ::std::vec::Vec<u8> {
        self.version_checksum.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 version_check = 2;


    pub fn get_version_check(&self) -> u32 {
        self.version_check.unwrap_or(0)
    }
    pub fn clear_version_check(&mut self) {
        self.version_check = ::std::option::Option::None;
    }

    pub fn has_version_check(&self) -> bool {
        self.version_check.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version_check(&mut self, v: u32) {
        self.version_check = ::std::option::Option::Some(v);
    }

    // optional uint32 version_check_ex = 3;


    pub fn get_version_check_ex(&self) -> u32 {
        self.version_check_ex.unwrap_or(0)
    }
    pub fn clear_version_check_ex(&mut self) {
        self.version_check_ex = ::std::option::Option::None;
    }

    pub fn has_version_check_ex(&self) -> bool {
        self.version_check_ex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version_check_ex(&mut self, v: u32) {
        self.version_check_ex = ::std::option::Option::Some(v);
    }

    // optional uint32 version_check_ex2 = 4;


    pub fn get_version_check_ex2(&self) -> u32 {
        self.version_check_ex2.unwrap_or(0)
    }
    pub fn clear_version_check_ex2(&mut self) {
        self.version_check_ex2 = ::std::option::Option::None;
    }

    pub fn has_version_check_ex2(&self) -> bool {
        self.version_check_ex2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version_check_ex2(&mut self, v: u32) {
        self.version_check_ex2 = ::std::option::Option::Some(v);
    }

    // optional bytes version_checksum_ex = 5;


    pub fn get_version_checksum_ex(&self) -> &[u8] {
        match self.version_checksum_ex.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_version_checksum_ex(&mut self) {
        self.version_checksum_ex.clear();
    }

    pub fn has_version_checksum_ex(&self) -> bool {
        self.version_checksum_ex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version_checksum_ex(&mut self, v: ::std::vec::Vec<u8>) {
        self.version_checksum_ex = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version_checksum_ex(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.version_checksum_ex.is_none() {
            self.version_checksum_ex.set_default();
        }
        self.version_checksum_ex.as_mut().unwrap()
    }

    // Take field
    pub fn take_version_checksum_ex(&mut self) -> ::std::vec::Vec<u8> {
        self.version_checksum_ex.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CGCMsgTFSync {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.version_checksum)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.version_check = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.version_check_ex = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.version_check_ex2 = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.version_checksum_ex)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.version_checksum.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.version_check {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.version_check_ex {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.version_check_ex2 {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.version_checksum_ex.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.version_checksum.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(v) = self.version_check {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.version_check_ex {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.version_check_ex2 {
            os.write_uint32(4, v)?;
        }
        if let Some(ref v) = self.version_checksum_ex.as_ref() {
            os.write_bytes(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CGCMsgTFSync {
        CGCMsgTFSync::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "version_checksum",
                |m: &CGCMsgTFSync| { &m.version_checksum },
                |m: &mut CGCMsgTFSync| { &mut m.version_checksum },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "version_check",
                |m: &CGCMsgTFSync| { &m.version_check },
                |m: &mut CGCMsgTFSync| { &mut m.version_check },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "version_check_ex",
                |m: &CGCMsgTFSync| { &m.version_check_ex },
                |m: &mut CGCMsgTFSync| { &mut m.version_check_ex },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "version_check_ex2",
                |m: &CGCMsgTFSync| { &m.version_check_ex2 },
                |m: &mut CGCMsgTFSync| { &mut m.version_check_ex2 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "version_checksum_ex",
                |m: &CGCMsgTFSync| { &m.version_checksum_ex },
                |m: &mut CGCMsgTFSync| { &mut m.version_checksum_ex },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CGCMsgTFSync>(
                "CGCMsgTFSync",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CGCMsgTFSync {
        static instance: ::protobuf::rt::LazyV2<CGCMsgTFSync> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CGCMsgTFSync::new)
    }
}

impl ::protobuf::Clear for CGCMsgTFSync {
    fn clear(&mut self) {
        self.version_checksum.clear();
        self.version_check = ::std::option::Option::None;
        self.version_check_ex = ::std::option::Option::None;
        self.version_check_ex2 = ::std::option::Option::None;
        self.version_checksum_ex.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CGCMsgTFSync {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CGCMsgTFSync {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CGCMsgTFSyncEx {
    // message fields
    version_checksum: ::protobuf::SingularField<::std::string::String>,
    version_checksum_ex: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    version_check: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CGCMsgTFSyncEx {
    fn default() -> &'a CGCMsgTFSyncEx {
        <CGCMsgTFSyncEx as ::protobuf::Message>::default_instance()
    }
}

impl CGCMsgTFSyncEx {
    pub fn new() -> CGCMsgTFSyncEx {
        ::std::default::Default::default()
    }

    // optional string version_checksum = 1;


    pub fn get_version_checksum(&self) -> &str {
        match self.version_checksum.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_version_checksum(&mut self) {
        self.version_checksum.clear();
    }

    pub fn has_version_checksum(&self) -> bool {
        self.version_checksum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version_checksum(&mut self, v: ::std::string::String) {
        self.version_checksum = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version_checksum(&mut self) -> &mut ::std::string::String {
        if self.version_checksum.is_none() {
            self.version_checksum.set_default();
        }
        self.version_checksum.as_mut().unwrap()
    }

    // Take field
    pub fn take_version_checksum(&mut self) -> ::std::string::String {
        self.version_checksum.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes version_checksum_ex = 2;


    pub fn get_version_checksum_ex(&self) -> &[u8] {
        match self.version_checksum_ex.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_version_checksum_ex(&mut self) {
        self.version_checksum_ex.clear();
    }

    pub fn has_version_checksum_ex(&self) -> bool {
        self.version_checksum_ex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version_checksum_ex(&mut self, v: ::std::vec::Vec<u8>) {
        self.version_checksum_ex = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version_checksum_ex(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.version_checksum_ex.is_none() {
            self.version_checksum_ex.set_default();
        }
        self.version_checksum_ex.as_mut().unwrap()
    }

    // Take field
    pub fn take_version_checksum_ex(&mut self) -> ::std::vec::Vec<u8> {
        self.version_checksum_ex.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 version_check = 3;


    pub fn get_version_check(&self) -> u32 {
        self.version_check.unwrap_or(0)
    }
    pub fn clear_version_check(&mut self) {
        self.version_check = ::std::option::Option::None;
    }

    pub fn has_version_check(&self) -> bool {
        self.version_check.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version_check(&mut self, v: u32) {
        self.version_check = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CGCMsgTFSyncEx {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.version_checksum)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.version_checksum_ex)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.version_check = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.version_checksum.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.version_checksum_ex.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.version_check {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.version_checksum.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.version_checksum_ex.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(v) = self.version_check {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CGCMsgTFSyncEx {
        CGCMsgTFSyncEx::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "version_checksum",
                |m: &CGCMsgTFSyncEx| { &m.version_checksum },
                |m: &mut CGCMsgTFSyncEx| { &mut m.version_checksum },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "version_checksum_ex",
                |m: &CGCMsgTFSyncEx| { &m.version_checksum_ex },
                |m: &mut CGCMsgTFSyncEx| { &mut m.version_checksum_ex },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "version_check",
                |m: &CGCMsgTFSyncEx| { &m.version_check },
                |m: &mut CGCMsgTFSyncEx| { &mut m.version_check },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CGCMsgTFSyncEx>(
                "CGCMsgTFSyncEx",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CGCMsgTFSyncEx {
        static instance: ::protobuf::rt::LazyV2<CGCMsgTFSyncEx> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CGCMsgTFSyncEx::new)
    }
}

impl ::protobuf::Clear for CGCMsgTFSyncEx {
    fn clear(&mut self) {
        self.version_checksum.clear();
        self.version_checksum_ex.clear();
        self.version_check = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CGCMsgTFSyncEx {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CGCMsgTFSyncEx {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgMvMVictory {
    // message fields
    legacy_mission_index: ::std::option::Option<u32>,
    tour_name_mannup: ::protobuf::SingularField<::std::string::String>,
    mission_name: ::protobuf::SingularField<::std::string::String>,
    pub players: ::protobuf::RepeatedField<CMsgMvMVictory_Player>,
    lobby_id: ::std::option::Option<u64>,
    event_time: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgMvMVictory {
    fn default() -> &'a CMsgMvMVictory {
        <CMsgMvMVictory as ::protobuf::Message>::default_instance()
    }
}

impl CMsgMvMVictory {
    pub fn new() -> CMsgMvMVictory {
        ::std::default::Default::default()
    }

    // optional uint32 legacy_mission_index = 1;


    pub fn get_legacy_mission_index(&self) -> u32 {
        self.legacy_mission_index.unwrap_or(0)
    }
    pub fn clear_legacy_mission_index(&mut self) {
        self.legacy_mission_index = ::std::option::Option::None;
    }

    pub fn has_legacy_mission_index(&self) -> bool {
        self.legacy_mission_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_legacy_mission_index(&mut self, v: u32) {
        self.legacy_mission_index = ::std::option::Option::Some(v);
    }

    // optional string tour_name_mannup = 5;


    pub fn get_tour_name_mannup(&self) -> &str {
        match self.tour_name_mannup.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_tour_name_mannup(&mut self) {
        self.tour_name_mannup.clear();
    }

    pub fn has_tour_name_mannup(&self) -> bool {
        self.tour_name_mannup.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tour_name_mannup(&mut self, v: ::std::string::String) {
        self.tour_name_mannup = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tour_name_mannup(&mut self) -> &mut ::std::string::String {
        if self.tour_name_mannup.is_none() {
            self.tour_name_mannup.set_default();
        }
        self.tour_name_mannup.as_mut().unwrap()
    }

    // Take field
    pub fn take_tour_name_mannup(&mut self) -> ::std::string::String {
        self.tour_name_mannup.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string mission_name = 6;


    pub fn get_mission_name(&self) -> &str {
        match self.mission_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_mission_name(&mut self) {
        self.mission_name.clear();
    }

    pub fn has_mission_name(&self) -> bool {
        self.mission_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mission_name(&mut self, v: ::std::string::String) {
        self.mission_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mission_name(&mut self) -> &mut ::std::string::String {
        if self.mission_name.is_none() {
            self.mission_name.set_default();
        }
        self.mission_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_mission_name(&mut self) -> ::std::string::String {
        self.mission_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .CMsgMvMVictory.Player players = 2;


    pub fn get_players(&self) -> &[CMsgMvMVictory_Player] {
        &self.players
    }
    pub fn clear_players(&mut self) {
        self.players.clear();
    }

    // Param is passed by value, moved
    pub fn set_players(&mut self, v: ::protobuf::RepeatedField<CMsgMvMVictory_Player>) {
        self.players = v;
    }

    // Mutable pointer to the field.
    pub fn mut_players(&mut self) -> &mut ::protobuf::RepeatedField<CMsgMvMVictory_Player> {
        &mut self.players
    }

    // Take field
    pub fn take_players(&mut self) -> ::protobuf::RepeatedField<CMsgMvMVictory_Player> {
        ::std::mem::replace(&mut self.players, ::protobuf::RepeatedField::new())
    }

    // optional uint64 lobby_id = 3;


    pub fn get_lobby_id(&self) -> u64 {
        self.lobby_id.unwrap_or(0)
    }
    pub fn clear_lobby_id(&mut self) {
        self.lobby_id = ::std::option::Option::None;
    }

    pub fn has_lobby_id(&self) -> bool {
        self.lobby_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_id(&mut self, v: u64) {
        self.lobby_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 event_time = 4;


    pub fn get_event_time(&self) -> u32 {
        self.event_time.unwrap_or(0)
    }
    pub fn clear_event_time(&mut self) {
        self.event_time = ::std::option::Option::None;
    }

    pub fn has_event_time(&self) -> bool {
        self.event_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_time(&mut self, v: u32) {
        self.event_time = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgMvMVictory {
    fn is_initialized(&self) -> bool {
        for v in &self.players {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.legacy_mission_index = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.tour_name_mannup)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.mission_name)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.players)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.lobby_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.event_time = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.legacy_mission_index {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.tour_name_mannup.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.mission_name.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        for value in &self.players {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.lobby_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.event_time {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.legacy_mission_index {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.tour_name_mannup.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.mission_name.as_ref() {
            os.write_string(6, &v)?;
        }
        for v in &self.players {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.lobby_id {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.event_time {
            os.write_fixed32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgMvMVictory {
        CMsgMvMVictory::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "legacy_mission_index",
                |m: &CMsgMvMVictory| { &m.legacy_mission_index },
                |m: &mut CMsgMvMVictory| { &mut m.legacy_mission_index },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "tour_name_mannup",
                |m: &CMsgMvMVictory| { &m.tour_name_mannup },
                |m: &mut CMsgMvMVictory| { &mut m.tour_name_mannup },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "mission_name",
                |m: &CMsgMvMVictory| { &m.mission_name },
                |m: &mut CMsgMvMVictory| { &mut m.mission_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgMvMVictory_Player>>(
                "players",
                |m: &CMsgMvMVictory| { &m.players },
                |m: &mut CMsgMvMVictory| { &mut m.players },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "lobby_id",
                |m: &CMsgMvMVictory| { &m.lobby_id },
                |m: &mut CMsgMvMVictory| { &mut m.lobby_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "event_time",
                |m: &CMsgMvMVictory| { &m.event_time },
                |m: &mut CMsgMvMVictory| { &mut m.event_time },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgMvMVictory>(
                "CMsgMvMVictory",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgMvMVictory {
        static instance: ::protobuf::rt::LazyV2<CMsgMvMVictory> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgMvMVictory::new)
    }
}

impl ::protobuf::Clear for CMsgMvMVictory {
    fn clear(&mut self) {
        self.legacy_mission_index = ::std::option::Option::None;
        self.tour_name_mannup.clear();
        self.mission_name.clear();
        self.players.clear();
        self.lobby_id = ::std::option::Option::None;
        self.event_time = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgMvMVictory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgMvMVictory {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgMvMVictory_Player {
    // message fields
    steam_id: ::std::option::Option<u64>,
    squad_surplus: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgMvMVictory_Player {
    fn default() -> &'a CMsgMvMVictory_Player {
        <CMsgMvMVictory_Player as ::protobuf::Message>::default_instance()
    }
}

impl CMsgMvMVictory_Player {
    pub fn new() -> CMsgMvMVictory_Player {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id = 1;


    pub fn get_steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }
    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }

    // optional bool squad_surplus = 2;


    pub fn get_squad_surplus(&self) -> bool {
        self.squad_surplus.unwrap_or(false)
    }
    pub fn clear_squad_surplus(&mut self) {
        self.squad_surplus = ::std::option::Option::None;
    }

    pub fn has_squad_surplus(&self) -> bool {
        self.squad_surplus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_squad_surplus(&mut self, v: bool) {
        self.squad_surplus = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgMvMVictory_Player {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steam_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.squad_surplus = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id {
            my_size += 9;
        }
        if let Some(v) = self.squad_surplus {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steam_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.squad_surplus {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgMvMVictory_Player {
        CMsgMvMVictory_Player::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steam_id",
                |m: &CMsgMvMVictory_Player| { &m.steam_id },
                |m: &mut CMsgMvMVictory_Player| { &mut m.steam_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "squad_surplus",
                |m: &CMsgMvMVictory_Player| { &m.squad_surplus },
                |m: &mut CMsgMvMVictory_Player| { &mut m.squad_surplus },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgMvMVictory_Player>(
                "CMsgMvMVictory.Player",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgMvMVictory_Player {
        static instance: ::protobuf::rt::LazyV2<CMsgMvMVictory_Player> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgMvMVictory_Player::new)
    }
}

impl ::protobuf::Clear for CMsgMvMVictory_Player {
    fn clear(&mut self) {
        self.steam_id = ::std::option::Option::None;
        self.squad_surplus = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgMvMVictory_Player {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgMvMVictory_Player {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgMvMMannUpVictoryReply {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgMvMMannUpVictoryReply {
    fn default() -> &'a CMsgMvMMannUpVictoryReply {
        <CMsgMvMMannUpVictoryReply as ::protobuf::Message>::default_instance()
    }
}

impl CMsgMvMMannUpVictoryReply {
    pub fn new() -> CMsgMvMMannUpVictoryReply {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgMvMMannUpVictoryReply {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgMvMMannUpVictoryReply {
        CMsgMvMMannUpVictoryReply::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgMvMMannUpVictoryReply>(
                "CMsgMvMMannUpVictoryReply",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgMvMMannUpVictoryReply {
        static instance: ::protobuf::rt::LazyV2<CMsgMvMMannUpVictoryReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgMvMMannUpVictoryReply::new)
    }
}

impl ::protobuf::Clear for CMsgMvMMannUpVictoryReply {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgMvMMannUpVictoryReply {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgMvMMannUpVictoryReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGameServerKickingLobby {
    // message fields
    lobby_id: ::std::option::Option<u64>,
    match_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGameServerKickingLobby {
    fn default() -> &'a CMsgGameServerKickingLobby {
        <CMsgGameServerKickingLobby as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGameServerKickingLobby {
    pub fn new() -> CMsgGameServerKickingLobby {
        ::std::default::Default::default()
    }

    // optional uint64 lobby_id = 3;


    pub fn get_lobby_id(&self) -> u64 {
        self.lobby_id.unwrap_or(0)
    }
    pub fn clear_lobby_id(&mut self) {
        self.lobby_id = ::std::option::Option::None;
    }

    pub fn has_lobby_id(&self) -> bool {
        self.lobby_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_id(&mut self, v: u64) {
        self.lobby_id = ::std::option::Option::Some(v);
    }

    // optional uint64 match_id = 4;


    pub fn get_match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }
    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGameServerKickingLobby {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.lobby_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.match_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.lobby_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.lobby_id {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.match_id {
            os.write_uint64(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGameServerKickingLobby {
        CMsgGameServerKickingLobby::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "lobby_id",
                |m: &CMsgGameServerKickingLobby| { &m.lobby_id },
                |m: &mut CMsgGameServerKickingLobby| { &mut m.lobby_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "match_id",
                |m: &CMsgGameServerKickingLobby| { &m.match_id },
                |m: &mut CMsgGameServerKickingLobby| { &mut m.match_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGameServerKickingLobby>(
                "CMsgGameServerKickingLobby",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGameServerKickingLobby {
        static instance: ::protobuf::rt::LazyV2<CMsgGameServerKickingLobby> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGameServerKickingLobby::new)
    }
}

impl ::protobuf::Clear for CMsgGameServerKickingLobby {
    fn clear(&mut self) {
        self.lobby_id = ::std::option::Option::None;
        self.match_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGameServerKickingLobby {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGameServerKickingLobby {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGameServerKickingLobbyResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGameServerKickingLobbyResponse {
    fn default() -> &'a CMsgGameServerKickingLobbyResponse {
        <CMsgGameServerKickingLobbyResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGameServerKickingLobbyResponse {
    pub fn new() -> CMsgGameServerKickingLobbyResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgGameServerKickingLobbyResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGameServerKickingLobbyResponse {
        CMsgGameServerKickingLobbyResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGameServerKickingLobbyResponse>(
                "CMsgGameServerKickingLobbyResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGameServerKickingLobbyResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgGameServerKickingLobbyResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGameServerKickingLobbyResponse::new)
    }
}

impl ::protobuf::Clear for CMsgGameServerKickingLobbyResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGameServerKickingLobbyResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGameServerKickingLobbyResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgLeaveGameAndPrepareToJoinParty {
    // message fields
    party_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgLeaveGameAndPrepareToJoinParty {
    fn default() -> &'a CMsgLeaveGameAndPrepareToJoinParty {
        <CMsgLeaveGameAndPrepareToJoinParty as ::protobuf::Message>::default_instance()
    }
}

impl CMsgLeaveGameAndPrepareToJoinParty {
    pub fn new() -> CMsgLeaveGameAndPrepareToJoinParty {
        ::std::default::Default::default()
    }

    // optional fixed64 party_id = 1;


    pub fn get_party_id(&self) -> u64 {
        self.party_id.unwrap_or(0)
    }
    pub fn clear_party_id(&mut self) {
        self.party_id = ::std::option::Option::None;
    }

    pub fn has_party_id(&self) -> bool {
        self.party_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_party_id(&mut self, v: u64) {
        self.party_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgLeaveGameAndPrepareToJoinParty {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.party_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.party_id {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.party_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgLeaveGameAndPrepareToJoinParty {
        CMsgLeaveGameAndPrepareToJoinParty::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "party_id",
                |m: &CMsgLeaveGameAndPrepareToJoinParty| { &m.party_id },
                |m: &mut CMsgLeaveGameAndPrepareToJoinParty| { &mut m.party_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgLeaveGameAndPrepareToJoinParty>(
                "CMsgLeaveGameAndPrepareToJoinParty",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgLeaveGameAndPrepareToJoinParty {
        static instance: ::protobuf::rt::LazyV2<CMsgLeaveGameAndPrepareToJoinParty> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgLeaveGameAndPrepareToJoinParty::new)
    }
}

impl ::protobuf::Clear for CMsgLeaveGameAndPrepareToJoinParty {
    fn clear(&mut self) {
        self.party_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgLeaveGameAndPrepareToJoinParty {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgLeaveGameAndPrepareToJoinParty {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgPlayerLeftMatch {
    // message fields
    steam_id: ::std::option::Option<u64>,
    leave_reason: ::std::option::Option<TFMatchLeaveReason>,
    was_abandon: ::std::option::Option<bool>,
    lobby_id: ::std::option::Option<u64>,
    match_id: ::std::option::Option<u64>,
    pub xp_breakdown: ::protobuf::RepeatedField<CMsgTFXPSource>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgPlayerLeftMatch {
    fn default() -> &'a CMsgPlayerLeftMatch {
        <CMsgPlayerLeftMatch as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPlayerLeftMatch {
    pub fn new() -> CMsgPlayerLeftMatch {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id = 1;


    pub fn get_steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }
    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }

    // optional .TFMatchLeaveReason leave_reason = 2;


    pub fn get_leave_reason(&self) -> TFMatchLeaveReason {
        self.leave_reason.unwrap_or(TFMatchLeaveReason::TFMatchLeaveReason_UNSPECIFIED)
    }
    pub fn clear_leave_reason(&mut self) {
        self.leave_reason = ::std::option::Option::None;
    }

    pub fn has_leave_reason(&self) -> bool {
        self.leave_reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leave_reason(&mut self, v: TFMatchLeaveReason) {
        self.leave_reason = ::std::option::Option::Some(v);
    }

    // optional bool was_abandon = 3;


    pub fn get_was_abandon(&self) -> bool {
        self.was_abandon.unwrap_or(false)
    }
    pub fn clear_was_abandon(&mut self) {
        self.was_abandon = ::std::option::Option::None;
    }

    pub fn has_was_abandon(&self) -> bool {
        self.was_abandon.is_some()
    }

    // Param is passed by value, moved
    pub fn set_was_abandon(&mut self, v: bool) {
        self.was_abandon = ::std::option::Option::Some(v);
    }

    // optional uint64 lobby_id = 4;


    pub fn get_lobby_id(&self) -> u64 {
        self.lobby_id.unwrap_or(0)
    }
    pub fn clear_lobby_id(&mut self) {
        self.lobby_id = ::std::option::Option::None;
    }

    pub fn has_lobby_id(&self) -> bool {
        self.lobby_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_id(&mut self, v: u64) {
        self.lobby_id = ::std::option::Option::Some(v);
    }

    // optional uint64 match_id = 5;


    pub fn get_match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }
    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // repeated .CMsgTFXPSource xp_breakdown = 6;


    pub fn get_xp_breakdown(&self) -> &[CMsgTFXPSource] {
        &self.xp_breakdown
    }
    pub fn clear_xp_breakdown(&mut self) {
        self.xp_breakdown.clear();
    }

    // Param is passed by value, moved
    pub fn set_xp_breakdown(&mut self, v: ::protobuf::RepeatedField<CMsgTFXPSource>) {
        self.xp_breakdown = v;
    }

    // Mutable pointer to the field.
    pub fn mut_xp_breakdown(&mut self) -> &mut ::protobuf::RepeatedField<CMsgTFXPSource> {
        &mut self.xp_breakdown
    }

    // Take field
    pub fn take_xp_breakdown(&mut self) -> ::protobuf::RepeatedField<CMsgTFXPSource> {
        ::std::mem::replace(&mut self.xp_breakdown, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgPlayerLeftMatch {
    fn is_initialized(&self) -> bool {
        for v in &self.xp_breakdown {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steam_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.leave_reason, 2, &mut self.unknown_fields)?
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.was_abandon = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.lobby_id = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.match_id = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.xp_breakdown)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id {
            my_size += 9;
        }
        if let Some(v) = self.leave_reason {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        if let Some(v) = self.was_abandon {
            my_size += 2;
        }
        if let Some(v) = self.lobby_id {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.xp_breakdown {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steam_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.leave_reason {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.was_abandon {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.lobby_id {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.match_id {
            os.write_uint64(5, v)?;
        }
        for v in &self.xp_breakdown {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgPlayerLeftMatch {
        CMsgPlayerLeftMatch::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steam_id",
                |m: &CMsgPlayerLeftMatch| { &m.steam_id },
                |m: &mut CMsgPlayerLeftMatch| { &mut m.steam_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TFMatchLeaveReason>>(
                "leave_reason",
                |m: &CMsgPlayerLeftMatch| { &m.leave_reason },
                |m: &mut CMsgPlayerLeftMatch| { &mut m.leave_reason },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "was_abandon",
                |m: &CMsgPlayerLeftMatch| { &m.was_abandon },
                |m: &mut CMsgPlayerLeftMatch| { &mut m.was_abandon },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "lobby_id",
                |m: &CMsgPlayerLeftMatch| { &m.lobby_id },
                |m: &mut CMsgPlayerLeftMatch| { &mut m.lobby_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "match_id",
                |m: &CMsgPlayerLeftMatch| { &m.match_id },
                |m: &mut CMsgPlayerLeftMatch| { &mut m.match_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgTFXPSource>>(
                "xp_breakdown",
                |m: &CMsgPlayerLeftMatch| { &m.xp_breakdown },
                |m: &mut CMsgPlayerLeftMatch| { &mut m.xp_breakdown },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgPlayerLeftMatch>(
                "CMsgPlayerLeftMatch",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgPlayerLeftMatch {
        static instance: ::protobuf::rt::LazyV2<CMsgPlayerLeftMatch> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgPlayerLeftMatch::new)
    }
}

impl ::protobuf::Clear for CMsgPlayerLeftMatch {
    fn clear(&mut self) {
        self.steam_id = ::std::option::Option::None;
        self.leave_reason = ::std::option::Option::None;
        self.was_abandon = ::std::option::Option::None;
        self.lobby_id = ::std::option::Option::None;
        self.match_id = ::std::option::Option::None;
        self.xp_breakdown.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgPlayerLeftMatch {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPlayerLeftMatch {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgPlayerLeftMatchResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgPlayerLeftMatchResponse {
    fn default() -> &'a CMsgPlayerLeftMatchResponse {
        <CMsgPlayerLeftMatchResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPlayerLeftMatchResponse {
    pub fn new() -> CMsgPlayerLeftMatchResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgPlayerLeftMatchResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgPlayerLeftMatchResponse {
        CMsgPlayerLeftMatchResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgPlayerLeftMatchResponse>(
                "CMsgPlayerLeftMatchResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgPlayerLeftMatchResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgPlayerLeftMatchResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgPlayerLeftMatchResponse::new)
    }
}

impl ::protobuf::Clear for CMsgPlayerLeftMatchResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgPlayerLeftMatchResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPlayerLeftMatchResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgProcessMatchVoteKick {
    // message fields
    match_id: ::std::option::Option<u64>,
    initiator_steam_id: ::std::option::Option<u64>,
    target_steam_id: ::std::option::Option<u64>,
    reason: ::std::option::Option<TFVoteKickReason>,
    pub votes: ::protobuf::RepeatedField<CMsgProcessMatchVoteKick_Vote>,
    default_pass: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgProcessMatchVoteKick {
    fn default() -> &'a CMsgProcessMatchVoteKick {
        <CMsgProcessMatchVoteKick as ::protobuf::Message>::default_instance()
    }
}

impl CMsgProcessMatchVoteKick {
    pub fn new() -> CMsgProcessMatchVoteKick {
        ::std::default::Default::default()
    }

    // optional fixed64 match_id = 1;


    pub fn get_match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }
    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 initiator_steam_id = 2;


    pub fn get_initiator_steam_id(&self) -> u64 {
        self.initiator_steam_id.unwrap_or(0)
    }
    pub fn clear_initiator_steam_id(&mut self) {
        self.initiator_steam_id = ::std::option::Option::None;
    }

    pub fn has_initiator_steam_id(&self) -> bool {
        self.initiator_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initiator_steam_id(&mut self, v: u64) {
        self.initiator_steam_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 target_steam_id = 3;


    pub fn get_target_steam_id(&self) -> u64 {
        self.target_steam_id.unwrap_or(0)
    }
    pub fn clear_target_steam_id(&mut self) {
        self.target_steam_id = ::std::option::Option::None;
    }

    pub fn has_target_steam_id(&self) -> bool {
        self.target_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_steam_id(&mut self, v: u64) {
        self.target_steam_id = ::std::option::Option::Some(v);
    }

    // optional .TFVoteKickReason reason = 4;


    pub fn get_reason(&self) -> TFVoteKickReason {
        self.reason.unwrap_or(TFVoteKickReason::TFVoteKickReason_Other)
    }
    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: TFVoteKickReason) {
        self.reason = ::std::option::Option::Some(v);
    }

    // repeated .CMsgProcessMatchVoteKick.Vote votes = 5;


    pub fn get_votes(&self) -> &[CMsgProcessMatchVoteKick_Vote] {
        &self.votes
    }
    pub fn clear_votes(&mut self) {
        self.votes.clear();
    }

    // Param is passed by value, moved
    pub fn set_votes(&mut self, v: ::protobuf::RepeatedField<CMsgProcessMatchVoteKick_Vote>) {
        self.votes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_votes(&mut self) -> &mut ::protobuf::RepeatedField<CMsgProcessMatchVoteKick_Vote> {
        &mut self.votes
    }

    // Take field
    pub fn take_votes(&mut self) -> ::protobuf::RepeatedField<CMsgProcessMatchVoteKick_Vote> {
        ::std::mem::replace(&mut self.votes, ::protobuf::RepeatedField::new())
    }

    // optional bool default_pass = 6;


    pub fn get_default_pass(&self) -> bool {
        self.default_pass.unwrap_or(false)
    }
    pub fn clear_default_pass(&mut self) {
        self.default_pass = ::std::option::Option::None;
    }

    pub fn has_default_pass(&self) -> bool {
        self.default_pass.is_some()
    }

    // Param is passed by value, moved
    pub fn set_default_pass(&mut self, v: bool) {
        self.default_pass = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgProcessMatchVoteKick {
    fn is_initialized(&self) -> bool {
        for v in &self.votes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.match_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.initiator_steam_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.target_steam_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.reason, 4, &mut self.unknown_fields)?
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.votes)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.default_pass = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += 9;
        }
        if let Some(v) = self.initiator_steam_id {
            my_size += 9;
        }
        if let Some(v) = self.target_steam_id {
            my_size += 9;
        }
        if let Some(v) = self.reason {
            my_size += ::protobuf::rt::enum_size(4, v);
        }
        for value in &self.votes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.default_pass {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.match_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.initiator_steam_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.target_steam_id {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.reason {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&v))?;
        }
        for v in &self.votes {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.default_pass {
            os.write_bool(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgProcessMatchVoteKick {
        CMsgProcessMatchVoteKick::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "match_id",
                |m: &CMsgProcessMatchVoteKick| { &m.match_id },
                |m: &mut CMsgProcessMatchVoteKick| { &mut m.match_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "initiator_steam_id",
                |m: &CMsgProcessMatchVoteKick| { &m.initiator_steam_id },
                |m: &mut CMsgProcessMatchVoteKick| { &mut m.initiator_steam_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "target_steam_id",
                |m: &CMsgProcessMatchVoteKick| { &m.target_steam_id },
                |m: &mut CMsgProcessMatchVoteKick| { &mut m.target_steam_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TFVoteKickReason>>(
                "reason",
                |m: &CMsgProcessMatchVoteKick| { &m.reason },
                |m: &mut CMsgProcessMatchVoteKick| { &mut m.reason },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgProcessMatchVoteKick_Vote>>(
                "votes",
                |m: &CMsgProcessMatchVoteKick| { &m.votes },
                |m: &mut CMsgProcessMatchVoteKick| { &mut m.votes },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "default_pass",
                |m: &CMsgProcessMatchVoteKick| { &m.default_pass },
                |m: &mut CMsgProcessMatchVoteKick| { &mut m.default_pass },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgProcessMatchVoteKick>(
                "CMsgProcessMatchVoteKick",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgProcessMatchVoteKick {
        static instance: ::protobuf::rt::LazyV2<CMsgProcessMatchVoteKick> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgProcessMatchVoteKick::new)
    }
}

impl ::protobuf::Clear for CMsgProcessMatchVoteKick {
    fn clear(&mut self) {
        self.match_id = ::std::option::Option::None;
        self.initiator_steam_id = ::std::option::Option::None;
        self.target_steam_id = ::std::option::Option::None;
        self.reason = ::std::option::Option::None;
        self.votes.clear();
        self.default_pass = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgProcessMatchVoteKick {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgProcessMatchVoteKick {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgProcessMatchVoteKick_Vote {
    // message fields
    steam_id: ::std::option::Option<u64>,
    vote_yay: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgProcessMatchVoteKick_Vote {
    fn default() -> &'a CMsgProcessMatchVoteKick_Vote {
        <CMsgProcessMatchVoteKick_Vote as ::protobuf::Message>::default_instance()
    }
}

impl CMsgProcessMatchVoteKick_Vote {
    pub fn new() -> CMsgProcessMatchVoteKick_Vote {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id = 1;


    pub fn get_steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }
    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }

    // optional bool vote_yay = 2;


    pub fn get_vote_yay(&self) -> bool {
        self.vote_yay.unwrap_or(false)
    }
    pub fn clear_vote_yay(&mut self) {
        self.vote_yay = ::std::option::Option::None;
    }

    pub fn has_vote_yay(&self) -> bool {
        self.vote_yay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vote_yay(&mut self, v: bool) {
        self.vote_yay = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgProcessMatchVoteKick_Vote {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steam_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.vote_yay = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id {
            my_size += 9;
        }
        if let Some(v) = self.vote_yay {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steam_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.vote_yay {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgProcessMatchVoteKick_Vote {
        CMsgProcessMatchVoteKick_Vote::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steam_id",
                |m: &CMsgProcessMatchVoteKick_Vote| { &m.steam_id },
                |m: &mut CMsgProcessMatchVoteKick_Vote| { &mut m.steam_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "vote_yay",
                |m: &CMsgProcessMatchVoteKick_Vote| { &m.vote_yay },
                |m: &mut CMsgProcessMatchVoteKick_Vote| { &mut m.vote_yay },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgProcessMatchVoteKick_Vote>(
                "CMsgProcessMatchVoteKick.Vote",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgProcessMatchVoteKick_Vote {
        static instance: ::protobuf::rt::LazyV2<CMsgProcessMatchVoteKick_Vote> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgProcessMatchVoteKick_Vote::new)
    }
}

impl ::protobuf::Clear for CMsgProcessMatchVoteKick_Vote {
    fn clear(&mut self) {
        self.steam_id = ::std::option::Option::None;
        self.vote_yay = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgProcessMatchVoteKick_Vote {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgProcessMatchVoteKick_Vote {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgProcessMatchVoteKickResponse {
    // message fields
    rip: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgProcessMatchVoteKickResponse {
    fn default() -> &'a CMsgProcessMatchVoteKickResponse {
        <CMsgProcessMatchVoteKickResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgProcessMatchVoteKickResponse {
    pub fn new() -> CMsgProcessMatchVoteKickResponse {
        ::std::default::Default::default()
    }

    // optional bool rip = 1;


    pub fn get_rip(&self) -> bool {
        self.rip.unwrap_or(false)
    }
    pub fn clear_rip(&mut self) {
        self.rip = ::std::option::Option::None;
    }

    pub fn has_rip(&self) -> bool {
        self.rip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rip(&mut self, v: bool) {
        self.rip = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgProcessMatchVoteKickResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.rip = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.rip {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.rip {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgProcessMatchVoteKickResponse {
        CMsgProcessMatchVoteKickResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "rip",
                |m: &CMsgProcessMatchVoteKickResponse| { &m.rip },
                |m: &mut CMsgProcessMatchVoteKickResponse| { &mut m.rip },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgProcessMatchVoteKickResponse>(
                "CMsgProcessMatchVoteKickResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgProcessMatchVoteKickResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgProcessMatchVoteKickResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgProcessMatchVoteKickResponse::new)
    }
}

impl ::protobuf::Clear for CMsgProcessMatchVoteKickResponse {
    fn clear(&mut self) {
        self.rip = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgProcessMatchVoteKickResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgProcessMatchVoteKickResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgPlayerVoteKickedAfterLeavingMatchResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgPlayerVoteKickedAfterLeavingMatchResponse {
    fn default() -> &'a CMsgPlayerVoteKickedAfterLeavingMatchResponse {
        <CMsgPlayerVoteKickedAfterLeavingMatchResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPlayerVoteKickedAfterLeavingMatchResponse {
    pub fn new() -> CMsgPlayerVoteKickedAfterLeavingMatchResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgPlayerVoteKickedAfterLeavingMatchResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgPlayerVoteKickedAfterLeavingMatchResponse {
        CMsgPlayerVoteKickedAfterLeavingMatchResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgPlayerVoteKickedAfterLeavingMatchResponse>(
                "CMsgPlayerVoteKickedAfterLeavingMatchResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgPlayerVoteKickedAfterLeavingMatchResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgPlayerVoteKickedAfterLeavingMatchResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgPlayerVoteKickedAfterLeavingMatchResponse::new)
    }
}

impl ::protobuf::Clear for CMsgPlayerVoteKickedAfterLeavingMatchResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgPlayerVoteKickedAfterLeavingMatchResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPlayerVoteKickedAfterLeavingMatchResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgHalloween_ServerBossEvent {
    // message fields
    event_counter: ::std::option::Option<u32>,
    timestamp: ::std::option::Option<u32>,
    boss_type: ::std::option::Option<u32>,
    boss_level: ::std::option::Option<u32>,
    event_type: ::std::option::Option<u32>,
    players_involved: ::std::option::Option<u32>,
    elapsed_time: ::std::option::Option<f32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgHalloween_ServerBossEvent {
    fn default() -> &'a CMsgHalloween_ServerBossEvent {
        <CMsgHalloween_ServerBossEvent as ::protobuf::Message>::default_instance()
    }
}

impl CMsgHalloween_ServerBossEvent {
    pub fn new() -> CMsgHalloween_ServerBossEvent {
        ::std::default::Default::default()
    }

    // optional uint32 event_counter = 1;


    pub fn get_event_counter(&self) -> u32 {
        self.event_counter.unwrap_or(0)
    }
    pub fn clear_event_counter(&mut self) {
        self.event_counter = ::std::option::Option::None;
    }

    pub fn has_event_counter(&self) -> bool {
        self.event_counter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_counter(&mut self, v: u32) {
        self.event_counter = ::std::option::Option::Some(v);
    }

    // optional uint32 timestamp = 2;


    pub fn get_timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 boss_type = 3;


    pub fn get_boss_type(&self) -> u32 {
        self.boss_type.unwrap_or(0)
    }
    pub fn clear_boss_type(&mut self) {
        self.boss_type = ::std::option::Option::None;
    }

    pub fn has_boss_type(&self) -> bool {
        self.boss_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_boss_type(&mut self, v: u32) {
        self.boss_type = ::std::option::Option::Some(v);
    }

    // optional uint32 boss_level = 4;


    pub fn get_boss_level(&self) -> u32 {
        self.boss_level.unwrap_or(0)
    }
    pub fn clear_boss_level(&mut self) {
        self.boss_level = ::std::option::Option::None;
    }

    pub fn has_boss_level(&self) -> bool {
        self.boss_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_boss_level(&mut self, v: u32) {
        self.boss_level = ::std::option::Option::Some(v);
    }

    // optional uint32 event_type = 5;


    pub fn get_event_type(&self) -> u32 {
        self.event_type.unwrap_or(0)
    }
    pub fn clear_event_type(&mut self) {
        self.event_type = ::std::option::Option::None;
    }

    pub fn has_event_type(&self) -> bool {
        self.event_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_type(&mut self, v: u32) {
        self.event_type = ::std::option::Option::Some(v);
    }

    // optional uint32 players_involved = 6;


    pub fn get_players_involved(&self) -> u32 {
        self.players_involved.unwrap_or(0)
    }
    pub fn clear_players_involved(&mut self) {
        self.players_involved = ::std::option::Option::None;
    }

    pub fn has_players_involved(&self) -> bool {
        self.players_involved.is_some()
    }

    // Param is passed by value, moved
    pub fn set_players_involved(&mut self, v: u32) {
        self.players_involved = ::std::option::Option::Some(v);
    }

    // optional float elapsed_time = 7;


    pub fn get_elapsed_time(&self) -> f32 {
        self.elapsed_time.unwrap_or(0.)
    }
    pub fn clear_elapsed_time(&mut self) {
        self.elapsed_time = ::std::option::Option::None;
    }

    pub fn has_elapsed_time(&self) -> bool {
        self.elapsed_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_elapsed_time(&mut self, v: f32) {
        self.elapsed_time = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgHalloween_ServerBossEvent {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.event_counter = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.timestamp = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.boss_type = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.boss_level = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.event_type = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.players_involved = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.elapsed_time = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.event_counter {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.boss_type {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.boss_level {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.event_type {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.players_involved {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.elapsed_time {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.event_counter {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.boss_type {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.boss_level {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.event_type {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.players_involved {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.elapsed_time {
            os.write_float(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgHalloween_ServerBossEvent {
        CMsgHalloween_ServerBossEvent::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "event_counter",
                |m: &CMsgHalloween_ServerBossEvent| { &m.event_counter },
                |m: &mut CMsgHalloween_ServerBossEvent| { &mut m.event_counter },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "timestamp",
                |m: &CMsgHalloween_ServerBossEvent| { &m.timestamp },
                |m: &mut CMsgHalloween_ServerBossEvent| { &mut m.timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "boss_type",
                |m: &CMsgHalloween_ServerBossEvent| { &m.boss_type },
                |m: &mut CMsgHalloween_ServerBossEvent| { &mut m.boss_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "boss_level",
                |m: &CMsgHalloween_ServerBossEvent| { &m.boss_level },
                |m: &mut CMsgHalloween_ServerBossEvent| { &mut m.boss_level },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "event_type",
                |m: &CMsgHalloween_ServerBossEvent| { &m.event_type },
                |m: &mut CMsgHalloween_ServerBossEvent| { &mut m.event_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "players_involved",
                |m: &CMsgHalloween_ServerBossEvent| { &m.players_involved },
                |m: &mut CMsgHalloween_ServerBossEvent| { &mut m.players_involved },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "elapsed_time",
                |m: &CMsgHalloween_ServerBossEvent| { &m.elapsed_time },
                |m: &mut CMsgHalloween_ServerBossEvent| { &mut m.elapsed_time },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgHalloween_ServerBossEvent>(
                "CMsgHalloween_ServerBossEvent",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgHalloween_ServerBossEvent {
        static instance: ::protobuf::rt::LazyV2<CMsgHalloween_ServerBossEvent> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgHalloween_ServerBossEvent::new)
    }
}

impl ::protobuf::Clear for CMsgHalloween_ServerBossEvent {
    fn clear(&mut self) {
        self.event_counter = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.boss_type = ::std::option::Option::None;
        self.boss_level = ::std::option::Option::None;
        self.event_type = ::std::option::Option::None;
        self.players_involved = ::std::option::Option::None;
        self.elapsed_time = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgHalloween_ServerBossEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgHalloween_ServerBossEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgHalloween_Merasmus2012 {
    // message fields
    event_counter: ::std::option::Option<u32>,
    time_submitted: ::std::option::Option<u32>,
    is_valve_server: ::std::option::Option<bool>,
    boss_level: ::std::option::Option<u32>,
    spawned_health: ::std::option::Option<u32>,
    remaining_health: ::std::option::Option<u32>,
    life_time: ::std::option::Option<u32>,
    bomb_kills: ::std::option::Option<u32>,
    staff_kills: ::std::option::Option<u32>,
    pvp_kills: ::std::option::Option<u32>,
    prophunt_time1: ::std::option::Option<u32>,
    prophunt_time2: ::std::option::Option<u32>,
    dmg_scout: ::std::option::Option<u32>,
    dmg_sniper: ::std::option::Option<u32>,
    dmg_soldier: ::std::option::Option<u32>,
    dmg_demo: ::std::option::Option<u32>,
    dmg_medic: ::std::option::Option<u32>,
    dmg_heavy: ::std::option::Option<u32>,
    dmg_pyro: ::std::option::Option<u32>,
    dmg_spy: ::std::option::Option<u32>,
    dmg_engineer: ::std::option::Option<u32>,
    scout_count: ::std::option::Option<u32>,
    sniper_count: ::std::option::Option<u32>,
    solider_count: ::std::option::Option<u32>,
    demo_count: ::std::option::Option<u32>,
    medic_count: ::std::option::Option<u32>,
    heavy_count: ::std::option::Option<u32>,
    pyro_count: ::std::option::Option<u32>,
    spy_count: ::std::option::Option<u32>,
    engineer_count: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgHalloween_Merasmus2012 {
    fn default() -> &'a CMsgHalloween_Merasmus2012 {
        <CMsgHalloween_Merasmus2012 as ::protobuf::Message>::default_instance()
    }
}

impl CMsgHalloween_Merasmus2012 {
    pub fn new() -> CMsgHalloween_Merasmus2012 {
        ::std::default::Default::default()
    }

    // optional uint32 event_counter = 1;


    pub fn get_event_counter(&self) -> u32 {
        self.event_counter.unwrap_or(0)
    }
    pub fn clear_event_counter(&mut self) {
        self.event_counter = ::std::option::Option::None;
    }

    pub fn has_event_counter(&self) -> bool {
        self.event_counter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_counter(&mut self, v: u32) {
        self.event_counter = ::std::option::Option::Some(v);
    }

    // optional fixed32 time_submitted = 2;


    pub fn get_time_submitted(&self) -> u32 {
        self.time_submitted.unwrap_or(0)
    }
    pub fn clear_time_submitted(&mut self) {
        self.time_submitted = ::std::option::Option::None;
    }

    pub fn has_time_submitted(&self) -> bool {
        self.time_submitted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_submitted(&mut self, v: u32) {
        self.time_submitted = ::std::option::Option::Some(v);
    }

    // optional bool is_valve_server = 3;


    pub fn get_is_valve_server(&self) -> bool {
        self.is_valve_server.unwrap_or(false)
    }
    pub fn clear_is_valve_server(&mut self) {
        self.is_valve_server = ::std::option::Option::None;
    }

    pub fn has_is_valve_server(&self) -> bool {
        self.is_valve_server.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_valve_server(&mut self, v: bool) {
        self.is_valve_server = ::std::option::Option::Some(v);
    }

    // optional uint32 boss_level = 4;


    pub fn get_boss_level(&self) -> u32 {
        self.boss_level.unwrap_or(0)
    }
    pub fn clear_boss_level(&mut self) {
        self.boss_level = ::std::option::Option::None;
    }

    pub fn has_boss_level(&self) -> bool {
        self.boss_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_boss_level(&mut self, v: u32) {
        self.boss_level = ::std::option::Option::Some(v);
    }

    // optional uint32 spawned_health = 5;


    pub fn get_spawned_health(&self) -> u32 {
        self.spawned_health.unwrap_or(0)
    }
    pub fn clear_spawned_health(&mut self) {
        self.spawned_health = ::std::option::Option::None;
    }

    pub fn has_spawned_health(&self) -> bool {
        self.spawned_health.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spawned_health(&mut self, v: u32) {
        self.spawned_health = ::std::option::Option::Some(v);
    }

    // optional uint32 remaining_health = 6;


    pub fn get_remaining_health(&self) -> u32 {
        self.remaining_health.unwrap_or(0)
    }
    pub fn clear_remaining_health(&mut self) {
        self.remaining_health = ::std::option::Option::None;
    }

    pub fn has_remaining_health(&self) -> bool {
        self.remaining_health.is_some()
    }

    // Param is passed by value, moved
    pub fn set_remaining_health(&mut self, v: u32) {
        self.remaining_health = ::std::option::Option::Some(v);
    }

    // optional uint32 life_time = 7;


    pub fn get_life_time(&self) -> u32 {
        self.life_time.unwrap_or(0)
    }
    pub fn clear_life_time(&mut self) {
        self.life_time = ::std::option::Option::None;
    }

    pub fn has_life_time(&self) -> bool {
        self.life_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_life_time(&mut self, v: u32) {
        self.life_time = ::std::option::Option::Some(v);
    }

    // optional uint32 bomb_kills = 8;


    pub fn get_bomb_kills(&self) -> u32 {
        self.bomb_kills.unwrap_or(0)
    }
    pub fn clear_bomb_kills(&mut self) {
        self.bomb_kills = ::std::option::Option::None;
    }

    pub fn has_bomb_kills(&self) -> bool {
        self.bomb_kills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bomb_kills(&mut self, v: u32) {
        self.bomb_kills = ::std::option::Option::Some(v);
    }

    // optional uint32 staff_kills = 9;


    pub fn get_staff_kills(&self) -> u32 {
        self.staff_kills.unwrap_or(0)
    }
    pub fn clear_staff_kills(&mut self) {
        self.staff_kills = ::std::option::Option::None;
    }

    pub fn has_staff_kills(&self) -> bool {
        self.staff_kills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_staff_kills(&mut self, v: u32) {
        self.staff_kills = ::std::option::Option::Some(v);
    }

    // optional uint32 pvp_kills = 10;


    pub fn get_pvp_kills(&self) -> u32 {
        self.pvp_kills.unwrap_or(0)
    }
    pub fn clear_pvp_kills(&mut self) {
        self.pvp_kills = ::std::option::Option::None;
    }

    pub fn has_pvp_kills(&self) -> bool {
        self.pvp_kills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pvp_kills(&mut self, v: u32) {
        self.pvp_kills = ::std::option::Option::Some(v);
    }

    // optional uint32 prophunt_time1 = 11;


    pub fn get_prophunt_time1(&self) -> u32 {
        self.prophunt_time1.unwrap_or(0)
    }
    pub fn clear_prophunt_time1(&mut self) {
        self.prophunt_time1 = ::std::option::Option::None;
    }

    pub fn has_prophunt_time1(&self) -> bool {
        self.prophunt_time1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prophunt_time1(&mut self, v: u32) {
        self.prophunt_time1 = ::std::option::Option::Some(v);
    }

    // optional uint32 prophunt_time2 = 12;


    pub fn get_prophunt_time2(&self) -> u32 {
        self.prophunt_time2.unwrap_or(0)
    }
    pub fn clear_prophunt_time2(&mut self) {
        self.prophunt_time2 = ::std::option::Option::None;
    }

    pub fn has_prophunt_time2(&self) -> bool {
        self.prophunt_time2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prophunt_time2(&mut self, v: u32) {
        self.prophunt_time2 = ::std::option::Option::Some(v);
    }

    // optional uint32 dmg_scout = 13;


    pub fn get_dmg_scout(&self) -> u32 {
        self.dmg_scout.unwrap_or(0)
    }
    pub fn clear_dmg_scout(&mut self) {
        self.dmg_scout = ::std::option::Option::None;
    }

    pub fn has_dmg_scout(&self) -> bool {
        self.dmg_scout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dmg_scout(&mut self, v: u32) {
        self.dmg_scout = ::std::option::Option::Some(v);
    }

    // optional uint32 dmg_sniper = 14;


    pub fn get_dmg_sniper(&self) -> u32 {
        self.dmg_sniper.unwrap_or(0)
    }
    pub fn clear_dmg_sniper(&mut self) {
        self.dmg_sniper = ::std::option::Option::None;
    }

    pub fn has_dmg_sniper(&self) -> bool {
        self.dmg_sniper.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dmg_sniper(&mut self, v: u32) {
        self.dmg_sniper = ::std::option::Option::Some(v);
    }

    // optional uint32 dmg_soldier = 15;


    pub fn get_dmg_soldier(&self) -> u32 {
        self.dmg_soldier.unwrap_or(0)
    }
    pub fn clear_dmg_soldier(&mut self) {
        self.dmg_soldier = ::std::option::Option::None;
    }

    pub fn has_dmg_soldier(&self) -> bool {
        self.dmg_soldier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dmg_soldier(&mut self, v: u32) {
        self.dmg_soldier = ::std::option::Option::Some(v);
    }

    // optional uint32 dmg_demo = 16;


    pub fn get_dmg_demo(&self) -> u32 {
        self.dmg_demo.unwrap_or(0)
    }
    pub fn clear_dmg_demo(&mut self) {
        self.dmg_demo = ::std::option::Option::None;
    }

    pub fn has_dmg_demo(&self) -> bool {
        self.dmg_demo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dmg_demo(&mut self, v: u32) {
        self.dmg_demo = ::std::option::Option::Some(v);
    }

    // optional uint32 dmg_medic = 17;


    pub fn get_dmg_medic(&self) -> u32 {
        self.dmg_medic.unwrap_or(0)
    }
    pub fn clear_dmg_medic(&mut self) {
        self.dmg_medic = ::std::option::Option::None;
    }

    pub fn has_dmg_medic(&self) -> bool {
        self.dmg_medic.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dmg_medic(&mut self, v: u32) {
        self.dmg_medic = ::std::option::Option::Some(v);
    }

    // optional uint32 dmg_heavy = 18;


    pub fn get_dmg_heavy(&self) -> u32 {
        self.dmg_heavy.unwrap_or(0)
    }
    pub fn clear_dmg_heavy(&mut self) {
        self.dmg_heavy = ::std::option::Option::None;
    }

    pub fn has_dmg_heavy(&self) -> bool {
        self.dmg_heavy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dmg_heavy(&mut self, v: u32) {
        self.dmg_heavy = ::std::option::Option::Some(v);
    }

    // optional uint32 dmg_pyro = 19;


    pub fn get_dmg_pyro(&self) -> u32 {
        self.dmg_pyro.unwrap_or(0)
    }
    pub fn clear_dmg_pyro(&mut self) {
        self.dmg_pyro = ::std::option::Option::None;
    }

    pub fn has_dmg_pyro(&self) -> bool {
        self.dmg_pyro.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dmg_pyro(&mut self, v: u32) {
        self.dmg_pyro = ::std::option::Option::Some(v);
    }

    // optional uint32 dmg_spy = 20;


    pub fn get_dmg_spy(&self) -> u32 {
        self.dmg_spy.unwrap_or(0)
    }
    pub fn clear_dmg_spy(&mut self) {
        self.dmg_spy = ::std::option::Option::None;
    }

    pub fn has_dmg_spy(&self) -> bool {
        self.dmg_spy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dmg_spy(&mut self, v: u32) {
        self.dmg_spy = ::std::option::Option::Some(v);
    }

    // optional uint32 dmg_engineer = 21;


    pub fn get_dmg_engineer(&self) -> u32 {
        self.dmg_engineer.unwrap_or(0)
    }
    pub fn clear_dmg_engineer(&mut self) {
        self.dmg_engineer = ::std::option::Option::None;
    }

    pub fn has_dmg_engineer(&self) -> bool {
        self.dmg_engineer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dmg_engineer(&mut self, v: u32) {
        self.dmg_engineer = ::std::option::Option::Some(v);
    }

    // optional uint32 scout_count = 22;


    pub fn get_scout_count(&self) -> u32 {
        self.scout_count.unwrap_or(0)
    }
    pub fn clear_scout_count(&mut self) {
        self.scout_count = ::std::option::Option::None;
    }

    pub fn has_scout_count(&self) -> bool {
        self.scout_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scout_count(&mut self, v: u32) {
        self.scout_count = ::std::option::Option::Some(v);
    }

    // optional uint32 sniper_count = 23;


    pub fn get_sniper_count(&self) -> u32 {
        self.sniper_count.unwrap_or(0)
    }
    pub fn clear_sniper_count(&mut self) {
        self.sniper_count = ::std::option::Option::None;
    }

    pub fn has_sniper_count(&self) -> bool {
        self.sniper_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sniper_count(&mut self, v: u32) {
        self.sniper_count = ::std::option::Option::Some(v);
    }

    // optional uint32 solider_count = 24;


    pub fn get_solider_count(&self) -> u32 {
        self.solider_count.unwrap_or(0)
    }
    pub fn clear_solider_count(&mut self) {
        self.solider_count = ::std::option::Option::None;
    }

    pub fn has_solider_count(&self) -> bool {
        self.solider_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_solider_count(&mut self, v: u32) {
        self.solider_count = ::std::option::Option::Some(v);
    }

    // optional uint32 demo_count = 25;


    pub fn get_demo_count(&self) -> u32 {
        self.demo_count.unwrap_or(0)
    }
    pub fn clear_demo_count(&mut self) {
        self.demo_count = ::std::option::Option::None;
    }

    pub fn has_demo_count(&self) -> bool {
        self.demo_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_demo_count(&mut self, v: u32) {
        self.demo_count = ::std::option::Option::Some(v);
    }

    // optional uint32 medic_count = 26;


    pub fn get_medic_count(&self) -> u32 {
        self.medic_count.unwrap_or(0)
    }
    pub fn clear_medic_count(&mut self) {
        self.medic_count = ::std::option::Option::None;
    }

    pub fn has_medic_count(&self) -> bool {
        self.medic_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_medic_count(&mut self, v: u32) {
        self.medic_count = ::std::option::Option::Some(v);
    }

    // optional uint32 heavy_count = 27;


    pub fn get_heavy_count(&self) -> u32 {
        self.heavy_count.unwrap_or(0)
    }
    pub fn clear_heavy_count(&mut self) {
        self.heavy_count = ::std::option::Option::None;
    }

    pub fn has_heavy_count(&self) -> bool {
        self.heavy_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_heavy_count(&mut self, v: u32) {
        self.heavy_count = ::std::option::Option::Some(v);
    }

    // optional uint32 pyro_count = 28;


    pub fn get_pyro_count(&self) -> u32 {
        self.pyro_count.unwrap_or(0)
    }
    pub fn clear_pyro_count(&mut self) {
        self.pyro_count = ::std::option::Option::None;
    }

    pub fn has_pyro_count(&self) -> bool {
        self.pyro_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pyro_count(&mut self, v: u32) {
        self.pyro_count = ::std::option::Option::Some(v);
    }

    // optional uint32 spy_count = 29;


    pub fn get_spy_count(&self) -> u32 {
        self.spy_count.unwrap_or(0)
    }
    pub fn clear_spy_count(&mut self) {
        self.spy_count = ::std::option::Option::None;
    }

    pub fn has_spy_count(&self) -> bool {
        self.spy_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spy_count(&mut self, v: u32) {
        self.spy_count = ::std::option::Option::Some(v);
    }

    // optional uint32 engineer_count = 30;


    pub fn get_engineer_count(&self) -> u32 {
        self.engineer_count.unwrap_or(0)
    }
    pub fn clear_engineer_count(&mut self) {
        self.engineer_count = ::std::option::Option::None;
    }

    pub fn has_engineer_count(&self) -> bool {
        self.engineer_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_engineer_count(&mut self, v: u32) {
        self.engineer_count = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgHalloween_Merasmus2012 {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.event_counter = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.time_submitted = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_valve_server = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.boss_level = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.spawned_health = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.remaining_health = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.life_time = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.bomb_kills = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.staff_kills = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.pvp_kills = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.prophunt_time1 = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.prophunt_time2 = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.dmg_scout = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.dmg_sniper = ::std::option::Option::Some(tmp);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.dmg_soldier = ::std::option::Option::Some(tmp);
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.dmg_demo = ::std::option::Option::Some(tmp);
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.dmg_medic = ::std::option::Option::Some(tmp);
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.dmg_heavy = ::std::option::Option::Some(tmp);
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.dmg_pyro = ::std::option::Option::Some(tmp);
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.dmg_spy = ::std::option::Option::Some(tmp);
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.dmg_engineer = ::std::option::Option::Some(tmp);
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.scout_count = ::std::option::Option::Some(tmp);
                },
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.sniper_count = ::std::option::Option::Some(tmp);
                },
                24 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.solider_count = ::std::option::Option::Some(tmp);
                },
                25 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.demo_count = ::std::option::Option::Some(tmp);
                },
                26 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.medic_count = ::std::option::Option::Some(tmp);
                },
                27 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.heavy_count = ::std::option::Option::Some(tmp);
                },
                28 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.pyro_count = ::std::option::Option::Some(tmp);
                },
                29 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.spy_count = ::std::option::Option::Some(tmp);
                },
                30 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.engineer_count = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.event_counter {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.time_submitted {
            my_size += 5;
        }
        if let Some(v) = self.is_valve_server {
            my_size += 2;
        }
        if let Some(v) = self.boss_level {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.spawned_health {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.remaining_health {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.life_time {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.bomb_kills {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.staff_kills {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.pvp_kills {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.prophunt_time1 {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.prophunt_time2 {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.dmg_scout {
            my_size += ::protobuf::rt::value_size(13, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.dmg_sniper {
            my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.dmg_soldier {
            my_size += ::protobuf::rt::value_size(15, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.dmg_demo {
            my_size += ::protobuf::rt::value_size(16, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.dmg_medic {
            my_size += ::protobuf::rt::value_size(17, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.dmg_heavy {
            my_size += ::protobuf::rt::value_size(18, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.dmg_pyro {
            my_size += ::protobuf::rt::value_size(19, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.dmg_spy {
            my_size += ::protobuf::rt::value_size(20, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.dmg_engineer {
            my_size += ::protobuf::rt::value_size(21, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.scout_count {
            my_size += ::protobuf::rt::value_size(22, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.sniper_count {
            my_size += ::protobuf::rt::value_size(23, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.solider_count {
            my_size += ::protobuf::rt::value_size(24, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.demo_count {
            my_size += ::protobuf::rt::value_size(25, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.medic_count {
            my_size += ::protobuf::rt::value_size(26, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.heavy_count {
            my_size += ::protobuf::rt::value_size(27, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.pyro_count {
            my_size += ::protobuf::rt::value_size(28, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.spy_count {
            my_size += ::protobuf::rt::value_size(29, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.engineer_count {
            my_size += ::protobuf::rt::value_size(30, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.event_counter {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.time_submitted {
            os.write_fixed32(2, v)?;
        }
        if let Some(v) = self.is_valve_server {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.boss_level {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.spawned_health {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.remaining_health {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.life_time {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.bomb_kills {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.staff_kills {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.pvp_kills {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.prophunt_time1 {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.prophunt_time2 {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.dmg_scout {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.dmg_sniper {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.dmg_soldier {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.dmg_demo {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.dmg_medic {
            os.write_uint32(17, v)?;
        }
        if let Some(v) = self.dmg_heavy {
            os.write_uint32(18, v)?;
        }
        if let Some(v) = self.dmg_pyro {
            os.write_uint32(19, v)?;
        }
        if let Some(v) = self.dmg_spy {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.dmg_engineer {
            os.write_uint32(21, v)?;
        }
        if let Some(v) = self.scout_count {
            os.write_uint32(22, v)?;
        }
        if let Some(v) = self.sniper_count {
            os.write_uint32(23, v)?;
        }
        if let Some(v) = self.solider_count {
            os.write_uint32(24, v)?;
        }
        if let Some(v) = self.demo_count {
            os.write_uint32(25, v)?;
        }
        if let Some(v) = self.medic_count {
            os.write_uint32(26, v)?;
        }
        if let Some(v) = self.heavy_count {
            os.write_uint32(27, v)?;
        }
        if let Some(v) = self.pyro_count {
            os.write_uint32(28, v)?;
        }
        if let Some(v) = self.spy_count {
            os.write_uint32(29, v)?;
        }
        if let Some(v) = self.engineer_count {
            os.write_uint32(30, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgHalloween_Merasmus2012 {
        CMsgHalloween_Merasmus2012::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "event_counter",
                |m: &CMsgHalloween_Merasmus2012| { &m.event_counter },
                |m: &mut CMsgHalloween_Merasmus2012| { &mut m.event_counter },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "time_submitted",
                |m: &CMsgHalloween_Merasmus2012| { &m.time_submitted },
                |m: &mut CMsgHalloween_Merasmus2012| { &mut m.time_submitted },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_valve_server",
                |m: &CMsgHalloween_Merasmus2012| { &m.is_valve_server },
                |m: &mut CMsgHalloween_Merasmus2012| { &mut m.is_valve_server },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "boss_level",
                |m: &CMsgHalloween_Merasmus2012| { &m.boss_level },
                |m: &mut CMsgHalloween_Merasmus2012| { &mut m.boss_level },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "spawned_health",
                |m: &CMsgHalloween_Merasmus2012| { &m.spawned_health },
                |m: &mut CMsgHalloween_Merasmus2012| { &mut m.spawned_health },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "remaining_health",
                |m: &CMsgHalloween_Merasmus2012| { &m.remaining_health },
                |m: &mut CMsgHalloween_Merasmus2012| { &mut m.remaining_health },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "life_time",
                |m: &CMsgHalloween_Merasmus2012| { &m.life_time },
                |m: &mut CMsgHalloween_Merasmus2012| { &mut m.life_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "bomb_kills",
                |m: &CMsgHalloween_Merasmus2012| { &m.bomb_kills },
                |m: &mut CMsgHalloween_Merasmus2012| { &mut m.bomb_kills },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "staff_kills",
                |m: &CMsgHalloween_Merasmus2012| { &m.staff_kills },
                |m: &mut CMsgHalloween_Merasmus2012| { &mut m.staff_kills },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "pvp_kills",
                |m: &CMsgHalloween_Merasmus2012| { &m.pvp_kills },
                |m: &mut CMsgHalloween_Merasmus2012| { &mut m.pvp_kills },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "prophunt_time1",
                |m: &CMsgHalloween_Merasmus2012| { &m.prophunt_time1 },
                |m: &mut CMsgHalloween_Merasmus2012| { &mut m.prophunt_time1 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "prophunt_time2",
                |m: &CMsgHalloween_Merasmus2012| { &m.prophunt_time2 },
                |m: &mut CMsgHalloween_Merasmus2012| { &mut m.prophunt_time2 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "dmg_scout",
                |m: &CMsgHalloween_Merasmus2012| { &m.dmg_scout },
                |m: &mut CMsgHalloween_Merasmus2012| { &mut m.dmg_scout },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "dmg_sniper",
                |m: &CMsgHalloween_Merasmus2012| { &m.dmg_sniper },
                |m: &mut CMsgHalloween_Merasmus2012| { &mut m.dmg_sniper },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "dmg_soldier",
                |m: &CMsgHalloween_Merasmus2012| { &m.dmg_soldier },
                |m: &mut CMsgHalloween_Merasmus2012| { &mut m.dmg_soldier },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "dmg_demo",
                |m: &CMsgHalloween_Merasmus2012| { &m.dmg_demo },
                |m: &mut CMsgHalloween_Merasmus2012| { &mut m.dmg_demo },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "dmg_medic",
                |m: &CMsgHalloween_Merasmus2012| { &m.dmg_medic },
                |m: &mut CMsgHalloween_Merasmus2012| { &mut m.dmg_medic },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "dmg_heavy",
                |m: &CMsgHalloween_Merasmus2012| { &m.dmg_heavy },
                |m: &mut CMsgHalloween_Merasmus2012| { &mut m.dmg_heavy },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "dmg_pyro",
                |m: &CMsgHalloween_Merasmus2012| { &m.dmg_pyro },
                |m: &mut CMsgHalloween_Merasmus2012| { &mut m.dmg_pyro },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "dmg_spy",
                |m: &CMsgHalloween_Merasmus2012| { &m.dmg_spy },
                |m: &mut CMsgHalloween_Merasmus2012| { &mut m.dmg_spy },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "dmg_engineer",
                |m: &CMsgHalloween_Merasmus2012| { &m.dmg_engineer },
                |m: &mut CMsgHalloween_Merasmus2012| { &mut m.dmg_engineer },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "scout_count",
                |m: &CMsgHalloween_Merasmus2012| { &m.scout_count },
                |m: &mut CMsgHalloween_Merasmus2012| { &mut m.scout_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "sniper_count",
                |m: &CMsgHalloween_Merasmus2012| { &m.sniper_count },
                |m: &mut CMsgHalloween_Merasmus2012| { &mut m.sniper_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "solider_count",
                |m: &CMsgHalloween_Merasmus2012| { &m.solider_count },
                |m: &mut CMsgHalloween_Merasmus2012| { &mut m.solider_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "demo_count",
                |m: &CMsgHalloween_Merasmus2012| { &m.demo_count },
                |m: &mut CMsgHalloween_Merasmus2012| { &mut m.demo_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "medic_count",
                |m: &CMsgHalloween_Merasmus2012| { &m.medic_count },
                |m: &mut CMsgHalloween_Merasmus2012| { &mut m.medic_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "heavy_count",
                |m: &CMsgHalloween_Merasmus2012| { &m.heavy_count },
                |m: &mut CMsgHalloween_Merasmus2012| { &mut m.heavy_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "pyro_count",
                |m: &CMsgHalloween_Merasmus2012| { &m.pyro_count },
                |m: &mut CMsgHalloween_Merasmus2012| { &mut m.pyro_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "spy_count",
                |m: &CMsgHalloween_Merasmus2012| { &m.spy_count },
                |m: &mut CMsgHalloween_Merasmus2012| { &mut m.spy_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "engineer_count",
                |m: &CMsgHalloween_Merasmus2012| { &m.engineer_count },
                |m: &mut CMsgHalloween_Merasmus2012| { &mut m.engineer_count },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgHalloween_Merasmus2012>(
                "CMsgHalloween_Merasmus2012",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgHalloween_Merasmus2012 {
        static instance: ::protobuf::rt::LazyV2<CMsgHalloween_Merasmus2012> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgHalloween_Merasmus2012::new)
    }
}

impl ::protobuf::Clear for CMsgHalloween_Merasmus2012 {
    fn clear(&mut self) {
        self.event_counter = ::std::option::Option::None;
        self.time_submitted = ::std::option::Option::None;
        self.is_valve_server = ::std::option::Option::None;
        self.boss_level = ::std::option::Option::None;
        self.spawned_health = ::std::option::Option::None;
        self.remaining_health = ::std::option::Option::None;
        self.life_time = ::std::option::Option::None;
        self.bomb_kills = ::std::option::Option::None;
        self.staff_kills = ::std::option::Option::None;
        self.pvp_kills = ::std::option::Option::None;
        self.prophunt_time1 = ::std::option::Option::None;
        self.prophunt_time2 = ::std::option::Option::None;
        self.dmg_scout = ::std::option::Option::None;
        self.dmg_sniper = ::std::option::Option::None;
        self.dmg_soldier = ::std::option::Option::None;
        self.dmg_demo = ::std::option::Option::None;
        self.dmg_medic = ::std::option::Option::None;
        self.dmg_heavy = ::std::option::Option::None;
        self.dmg_pyro = ::std::option::Option::None;
        self.dmg_spy = ::std::option::Option::None;
        self.dmg_engineer = ::std::option::Option::None;
        self.scout_count = ::std::option::Option::None;
        self.sniper_count = ::std::option::Option::None;
        self.solider_count = ::std::option::Option::None;
        self.demo_count = ::std::option::Option::None;
        self.medic_count = ::std::option::Option::None;
        self.heavy_count = ::std::option::Option::None;
        self.pyro_count = ::std::option::Option::None;
        self.spy_count = ::std::option::Option::None;
        self.engineer_count = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgHalloween_Merasmus2012 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgHalloween_Merasmus2012 {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgUpdateHalloweenMerasmusLootLevel {
    // message fields
    pub players: ::protobuf::RepeatedField<CMsgUpdateHalloweenMerasmusLootLevel_Player>,
    merasmus_level: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgUpdateHalloweenMerasmusLootLevel {
    fn default() -> &'a CMsgUpdateHalloweenMerasmusLootLevel {
        <CMsgUpdateHalloweenMerasmusLootLevel as ::protobuf::Message>::default_instance()
    }
}

impl CMsgUpdateHalloweenMerasmusLootLevel {
    pub fn new() -> CMsgUpdateHalloweenMerasmusLootLevel {
        ::std::default::Default::default()
    }

    // repeated .CMsgUpdateHalloweenMerasmusLootLevel.Player players = 1;


    pub fn get_players(&self) -> &[CMsgUpdateHalloweenMerasmusLootLevel_Player] {
        &self.players
    }
    pub fn clear_players(&mut self) {
        self.players.clear();
    }

    // Param is passed by value, moved
    pub fn set_players(&mut self, v: ::protobuf::RepeatedField<CMsgUpdateHalloweenMerasmusLootLevel_Player>) {
        self.players = v;
    }

    // Mutable pointer to the field.
    pub fn mut_players(&mut self) -> &mut ::protobuf::RepeatedField<CMsgUpdateHalloweenMerasmusLootLevel_Player> {
        &mut self.players
    }

    // Take field
    pub fn take_players(&mut self) -> ::protobuf::RepeatedField<CMsgUpdateHalloweenMerasmusLootLevel_Player> {
        ::std::mem::replace(&mut self.players, ::protobuf::RepeatedField::new())
    }

    // optional uint32 merasmus_level = 2;


    pub fn get_merasmus_level(&self) -> u32 {
        self.merasmus_level.unwrap_or(0)
    }
    pub fn clear_merasmus_level(&mut self) {
        self.merasmus_level = ::std::option::Option::None;
    }

    pub fn has_merasmus_level(&self) -> bool {
        self.merasmus_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_merasmus_level(&mut self, v: u32) {
        self.merasmus_level = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgUpdateHalloweenMerasmusLootLevel {
    fn is_initialized(&self) -> bool {
        for v in &self.players {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.players)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.merasmus_level = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.players {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.merasmus_level {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.players {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.merasmus_level {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgUpdateHalloweenMerasmusLootLevel {
        CMsgUpdateHalloweenMerasmusLootLevel::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgUpdateHalloweenMerasmusLootLevel_Player>>(
                "players",
                |m: &CMsgUpdateHalloweenMerasmusLootLevel| { &m.players },
                |m: &mut CMsgUpdateHalloweenMerasmusLootLevel| { &mut m.players },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "merasmus_level",
                |m: &CMsgUpdateHalloweenMerasmusLootLevel| { &m.merasmus_level },
                |m: &mut CMsgUpdateHalloweenMerasmusLootLevel| { &mut m.merasmus_level },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgUpdateHalloweenMerasmusLootLevel>(
                "CMsgUpdateHalloweenMerasmusLootLevel",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgUpdateHalloweenMerasmusLootLevel {
        static instance: ::protobuf::rt::LazyV2<CMsgUpdateHalloweenMerasmusLootLevel> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgUpdateHalloweenMerasmusLootLevel::new)
    }
}

impl ::protobuf::Clear for CMsgUpdateHalloweenMerasmusLootLevel {
    fn clear(&mut self) {
        self.players.clear();
        self.merasmus_level = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgUpdateHalloweenMerasmusLootLevel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgUpdateHalloweenMerasmusLootLevel {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgUpdateHalloweenMerasmusLootLevel_Player {
    // message fields
    steam_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgUpdateHalloweenMerasmusLootLevel_Player {
    fn default() -> &'a CMsgUpdateHalloweenMerasmusLootLevel_Player {
        <CMsgUpdateHalloweenMerasmusLootLevel_Player as ::protobuf::Message>::default_instance()
    }
}

impl CMsgUpdateHalloweenMerasmusLootLevel_Player {
    pub fn new() -> CMsgUpdateHalloweenMerasmusLootLevel_Player {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id = 1;


    pub fn get_steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }
    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgUpdateHalloweenMerasmusLootLevel_Player {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steam_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steam_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgUpdateHalloweenMerasmusLootLevel_Player {
        CMsgUpdateHalloweenMerasmusLootLevel_Player::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steam_id",
                |m: &CMsgUpdateHalloweenMerasmusLootLevel_Player| { &m.steam_id },
                |m: &mut CMsgUpdateHalloweenMerasmusLootLevel_Player| { &mut m.steam_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgUpdateHalloweenMerasmusLootLevel_Player>(
                "CMsgUpdateHalloweenMerasmusLootLevel.Player",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgUpdateHalloweenMerasmusLootLevel_Player {
        static instance: ::protobuf::rt::LazyV2<CMsgUpdateHalloweenMerasmusLootLevel_Player> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgUpdateHalloweenMerasmusLootLevel_Player::new)
    }
}

impl ::protobuf::Clear for CMsgUpdateHalloweenMerasmusLootLevel_Player {
    fn clear(&mut self) {
        self.steam_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgUpdateHalloweenMerasmusLootLevel_Player {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgUpdateHalloweenMerasmusLootLevel_Player {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CAttribute_String {
    // message fields
    value: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CAttribute_String {
    fn default() -> &'a CAttribute_String {
        <CAttribute_String as ::protobuf::Message>::default_instance()
    }
}

impl CAttribute_String {
    pub fn new() -> CAttribute_String {
        ::std::default::Default::default()
    }

    // optional string value = 1;


    pub fn get_value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CAttribute_String {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.value.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CAttribute_String {
        CAttribute_String::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "value",
                |m: &CAttribute_String| { &m.value },
                |m: &mut CAttribute_String| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CAttribute_String>(
                "CAttribute_String",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CAttribute_String {
        static instance: ::protobuf::rt::LazyV2<CAttribute_String> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CAttribute_String::new)
    }
}

impl ::protobuf::Clear for CAttribute_String {
    fn clear(&mut self) {
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CAttribute_String {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CAttribute_String {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CAttribute_DynamicRecipeComponent {
    // message fields
    def_index: ::std::option::Option<u32>,
    item_quality: ::std::option::Option<u32>,
    component_flags: ::std::option::Option<u32>,
    attributes_string: ::protobuf::SingularField<::std::string::String>,
    num_required: ::std::option::Option<u32>,
    num_fulfilled: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CAttribute_DynamicRecipeComponent {
    fn default() -> &'a CAttribute_DynamicRecipeComponent {
        <CAttribute_DynamicRecipeComponent as ::protobuf::Message>::default_instance()
    }
}

impl CAttribute_DynamicRecipeComponent {
    pub fn new() -> CAttribute_DynamicRecipeComponent {
        ::std::default::Default::default()
    }

    // optional uint32 def_index = 1;


    pub fn get_def_index(&self) -> u32 {
        self.def_index.unwrap_or(0)
    }
    pub fn clear_def_index(&mut self) {
        self.def_index = ::std::option::Option::None;
    }

    pub fn has_def_index(&self) -> bool {
        self.def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_def_index(&mut self, v: u32) {
        self.def_index = ::std::option::Option::Some(v);
    }

    // optional uint32 item_quality = 2;


    pub fn get_item_quality(&self) -> u32 {
        self.item_quality.unwrap_or(0)
    }
    pub fn clear_item_quality(&mut self) {
        self.item_quality = ::std::option::Option::None;
    }

    pub fn has_item_quality(&self) -> bool {
        self.item_quality.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_quality(&mut self, v: u32) {
        self.item_quality = ::std::option::Option::Some(v);
    }

    // optional uint32 component_flags = 3;


    pub fn get_component_flags(&self) -> u32 {
        self.component_flags.unwrap_or(0)
    }
    pub fn clear_component_flags(&mut self) {
        self.component_flags = ::std::option::Option::None;
    }

    pub fn has_component_flags(&self) -> bool {
        self.component_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_component_flags(&mut self, v: u32) {
        self.component_flags = ::std::option::Option::Some(v);
    }

    // optional string attributes_string = 4;


    pub fn get_attributes_string(&self) -> &str {
        match self.attributes_string.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_attributes_string(&mut self) {
        self.attributes_string.clear();
    }

    pub fn has_attributes_string(&self) -> bool {
        self.attributes_string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attributes_string(&mut self, v: ::std::string::String) {
        self.attributes_string = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_attributes_string(&mut self) -> &mut ::std::string::String {
        if self.attributes_string.is_none() {
            self.attributes_string.set_default();
        }
        self.attributes_string.as_mut().unwrap()
    }

    // Take field
    pub fn take_attributes_string(&mut self) -> ::std::string::String {
        self.attributes_string.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 num_required = 5;


    pub fn get_num_required(&self) -> u32 {
        self.num_required.unwrap_or(0)
    }
    pub fn clear_num_required(&mut self) {
        self.num_required = ::std::option::Option::None;
    }

    pub fn has_num_required(&self) -> bool {
        self.num_required.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_required(&mut self, v: u32) {
        self.num_required = ::std::option::Option::Some(v);
    }

    // optional uint32 num_fulfilled = 6;


    pub fn get_num_fulfilled(&self) -> u32 {
        self.num_fulfilled.unwrap_or(0)
    }
    pub fn clear_num_fulfilled(&mut self) {
        self.num_fulfilled = ::std::option::Option::None;
    }

    pub fn has_num_fulfilled(&self) -> bool {
        self.num_fulfilled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_fulfilled(&mut self, v: u32) {
        self.num_fulfilled = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CAttribute_DynamicRecipeComponent {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.def_index = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.item_quality = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.component_flags = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.attributes_string)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.num_required = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.num_fulfilled = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.def_index {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.item_quality {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.component_flags {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.attributes_string.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.num_required {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.num_fulfilled {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.def_index {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.item_quality {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.component_flags {
            os.write_uint32(3, v)?;
        }
        if let Some(ref v) = self.attributes_string.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(v) = self.num_required {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.num_fulfilled {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CAttribute_DynamicRecipeComponent {
        CAttribute_DynamicRecipeComponent::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "def_index",
                |m: &CAttribute_DynamicRecipeComponent| { &m.def_index },
                |m: &mut CAttribute_DynamicRecipeComponent| { &mut m.def_index },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "item_quality",
                |m: &CAttribute_DynamicRecipeComponent| { &m.item_quality },
                |m: &mut CAttribute_DynamicRecipeComponent| { &mut m.item_quality },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "component_flags",
                |m: &CAttribute_DynamicRecipeComponent| { &m.component_flags },
                |m: &mut CAttribute_DynamicRecipeComponent| { &mut m.component_flags },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "attributes_string",
                |m: &CAttribute_DynamicRecipeComponent| { &m.attributes_string },
                |m: &mut CAttribute_DynamicRecipeComponent| { &mut m.attributes_string },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "num_required",
                |m: &CAttribute_DynamicRecipeComponent| { &m.num_required },
                |m: &mut CAttribute_DynamicRecipeComponent| { &mut m.num_required },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "num_fulfilled",
                |m: &CAttribute_DynamicRecipeComponent| { &m.num_fulfilled },
                |m: &mut CAttribute_DynamicRecipeComponent| { &mut m.num_fulfilled },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CAttribute_DynamicRecipeComponent>(
                "CAttribute_DynamicRecipeComponent",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CAttribute_DynamicRecipeComponent {
        static instance: ::protobuf::rt::LazyV2<CAttribute_DynamicRecipeComponent> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CAttribute_DynamicRecipeComponent::new)
    }
}

impl ::protobuf::Clear for CAttribute_DynamicRecipeComponent {
    fn clear(&mut self) {
        self.def_index = ::std::option::Option::None;
        self.item_quality = ::std::option::Option::None;
        self.component_flags = ::std::option::Option::None;
        self.attributes_string.clear();
        self.num_required = ::std::option::Option::None;
        self.num_fulfilled = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CAttribute_DynamicRecipeComponent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CAttribute_DynamicRecipeComponent {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT {
    // message fields
    def_index: ::std::option::Option<u32>,
    item_def: ::std::option::Option<u32>,
    item_quality: ::std::option::Option<u32>,
    component_flags: ::std::option::Option<u32>,
    item_flags: ::std::option::Option<u32>,
    attributes_string: ::protobuf::SingularField<::std::string::String>,
    num_required: ::std::option::Option<u32>,
    item_count: ::std::option::Option<u32>,
    num_fulfilled: ::std::option::Option<u32>,
    items_fulfilled: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT {
    fn default() -> &'a CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT {
        <CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT as ::protobuf::Message>::default_instance()
    }
}

impl CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT {
    pub fn new() -> CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT {
        ::std::default::Default::default()
    }

    // optional uint32 def_index = 1;


    pub fn get_def_index(&self) -> u32 {
        self.def_index.unwrap_or(0)
    }
    pub fn clear_def_index(&mut self) {
        self.def_index = ::std::option::Option::None;
    }

    pub fn has_def_index(&self) -> bool {
        self.def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_def_index(&mut self, v: u32) {
        self.def_index = ::std::option::Option::Some(v);
    }

    // optional uint32 item_def = 2;


    pub fn get_item_def(&self) -> u32 {
        self.item_def.unwrap_or(0)
    }
    pub fn clear_item_def(&mut self) {
        self.item_def = ::std::option::Option::None;
    }

    pub fn has_item_def(&self) -> bool {
        self.item_def.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_def(&mut self, v: u32) {
        self.item_def = ::std::option::Option::Some(v);
    }

    // optional uint32 item_quality = 3;


    pub fn get_item_quality(&self) -> u32 {
        self.item_quality.unwrap_or(0)
    }
    pub fn clear_item_quality(&mut self) {
        self.item_quality = ::std::option::Option::None;
    }

    pub fn has_item_quality(&self) -> bool {
        self.item_quality.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_quality(&mut self, v: u32) {
        self.item_quality = ::std::option::Option::Some(v);
    }

    // optional uint32 component_flags = 4;


    pub fn get_component_flags(&self) -> u32 {
        self.component_flags.unwrap_or(0)
    }
    pub fn clear_component_flags(&mut self) {
        self.component_flags = ::std::option::Option::None;
    }

    pub fn has_component_flags(&self) -> bool {
        self.component_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_component_flags(&mut self, v: u32) {
        self.component_flags = ::std::option::Option::Some(v);
    }

    // optional uint32 item_flags = 5;


    pub fn get_item_flags(&self) -> u32 {
        self.item_flags.unwrap_or(0)
    }
    pub fn clear_item_flags(&mut self) {
        self.item_flags = ::std::option::Option::None;
    }

    pub fn has_item_flags(&self) -> bool {
        self.item_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_flags(&mut self, v: u32) {
        self.item_flags = ::std::option::Option::Some(v);
    }

    // optional string attributes_string = 6;


    pub fn get_attributes_string(&self) -> &str {
        match self.attributes_string.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_attributes_string(&mut self) {
        self.attributes_string.clear();
    }

    pub fn has_attributes_string(&self) -> bool {
        self.attributes_string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attributes_string(&mut self, v: ::std::string::String) {
        self.attributes_string = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_attributes_string(&mut self) -> &mut ::std::string::String {
        if self.attributes_string.is_none() {
            self.attributes_string.set_default();
        }
        self.attributes_string.as_mut().unwrap()
    }

    // Take field
    pub fn take_attributes_string(&mut self) -> ::std::string::String {
        self.attributes_string.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 num_required = 7;


    pub fn get_num_required(&self) -> u32 {
        self.num_required.unwrap_or(0)
    }
    pub fn clear_num_required(&mut self) {
        self.num_required = ::std::option::Option::None;
    }

    pub fn has_num_required(&self) -> bool {
        self.num_required.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_required(&mut self, v: u32) {
        self.num_required = ::std::option::Option::Some(v);
    }

    // optional uint32 item_count = 8;


    pub fn get_item_count(&self) -> u32 {
        self.item_count.unwrap_or(0)
    }
    pub fn clear_item_count(&mut self) {
        self.item_count = ::std::option::Option::None;
    }

    pub fn has_item_count(&self) -> bool {
        self.item_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_count(&mut self, v: u32) {
        self.item_count = ::std::option::Option::Some(v);
    }

    // optional uint32 num_fulfilled = 9;


    pub fn get_num_fulfilled(&self) -> u32 {
        self.num_fulfilled.unwrap_or(0)
    }
    pub fn clear_num_fulfilled(&mut self) {
        self.num_fulfilled = ::std::option::Option::None;
    }

    pub fn has_num_fulfilled(&self) -> bool {
        self.num_fulfilled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_fulfilled(&mut self, v: u32) {
        self.num_fulfilled = ::std::option::Option::Some(v);
    }

    // optional uint32 items_fulfilled = 10;


    pub fn get_items_fulfilled(&self) -> u32 {
        self.items_fulfilled.unwrap_or(0)
    }
    pub fn clear_items_fulfilled(&mut self) {
        self.items_fulfilled = ::std::option::Option::None;
    }

    pub fn has_items_fulfilled(&self) -> bool {
        self.items_fulfilled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_items_fulfilled(&mut self, v: u32) {
        self.items_fulfilled = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.def_index = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.item_def = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.item_quality = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.component_flags = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.item_flags = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.attributes_string)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.num_required = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.item_count = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.num_fulfilled = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.items_fulfilled = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.def_index {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.item_def {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.item_quality {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.component_flags {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.item_flags {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.attributes_string.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.num_required {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.item_count {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.num_fulfilled {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.items_fulfilled {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.def_index {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.item_def {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.item_quality {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.component_flags {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.item_flags {
            os.write_uint32(5, v)?;
        }
        if let Some(ref v) = self.attributes_string.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(v) = self.num_required {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.item_count {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.num_fulfilled {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.items_fulfilled {
            os.write_uint32(10, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT {
        CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "def_index",
                |m: &CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT| { &m.def_index },
                |m: &mut CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT| { &mut m.def_index },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "item_def",
                |m: &CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT| { &m.item_def },
                |m: &mut CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT| { &mut m.item_def },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "item_quality",
                |m: &CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT| { &m.item_quality },
                |m: &mut CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT| { &mut m.item_quality },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "component_flags",
                |m: &CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT| { &m.component_flags },
                |m: &mut CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT| { &mut m.component_flags },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "item_flags",
                |m: &CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT| { &m.item_flags },
                |m: &mut CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT| { &mut m.item_flags },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "attributes_string",
                |m: &CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT| { &m.attributes_string },
                |m: &mut CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT| { &mut m.attributes_string },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "num_required",
                |m: &CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT| { &m.num_required },
                |m: &mut CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT| { &mut m.num_required },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "item_count",
                |m: &CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT| { &m.item_count },
                |m: &mut CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT| { &mut m.item_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "num_fulfilled",
                |m: &CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT| { &m.num_fulfilled },
                |m: &mut CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT| { &mut m.num_fulfilled },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "items_fulfilled",
                |m: &CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT| { &m.items_fulfilled },
                |m: &mut CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT| { &mut m.items_fulfilled },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT>(
                "CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT {
        static instance: ::protobuf::rt::LazyV2<CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT::new)
    }
}

impl ::protobuf::Clear for CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT {
    fn clear(&mut self) {
        self.def_index = ::std::option::Option::None;
        self.item_def = ::std::option::Option::None;
        self.item_quality = ::std::option::Option::None;
        self.component_flags = ::std::option::Option::None;
        self.item_flags = ::std::option::Option::None;
        self.attributes_string.clear();
        self.num_required = ::std::option::Option::None;
        self.item_count = ::std::option::Option::None;
        self.num_fulfilled = ::std::option::Option::None;
        self.items_fulfilled = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CAttribute_ItemSlotCriteria {
    // message fields
    tags: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CAttribute_ItemSlotCriteria {
    fn default() -> &'a CAttribute_ItemSlotCriteria {
        <CAttribute_ItemSlotCriteria as ::protobuf::Message>::default_instance()
    }
}

impl CAttribute_ItemSlotCriteria {
    pub fn new() -> CAttribute_ItemSlotCriteria {
        ::std::default::Default::default()
    }

    // optional string tags = 1;


    pub fn get_tags(&self) -> &str {
        match self.tags.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_tags(&mut self) {
        self.tags.clear();
    }

    pub fn has_tags(&self) -> bool {
        self.tags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tags(&mut self, v: ::std::string::String) {
        self.tags = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tags(&mut self) -> &mut ::std::string::String {
        if self.tags.is_none() {
            self.tags.set_default();
        }
        self.tags.as_mut().unwrap()
    }

    // Take field
    pub fn take_tags(&mut self) -> ::std::string::String {
        self.tags.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CAttribute_ItemSlotCriteria {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.tags)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.tags.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.tags.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CAttribute_ItemSlotCriteria {
        CAttribute_ItemSlotCriteria::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "tags",
                |m: &CAttribute_ItemSlotCriteria| { &m.tags },
                |m: &mut CAttribute_ItemSlotCriteria| { &mut m.tags },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CAttribute_ItemSlotCriteria>(
                "CAttribute_ItemSlotCriteria",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CAttribute_ItemSlotCriteria {
        static instance: ::protobuf::rt::LazyV2<CAttribute_ItemSlotCriteria> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CAttribute_ItemSlotCriteria::new)
    }
}

impl ::protobuf::Clear for CAttribute_ItemSlotCriteria {
    fn clear(&mut self) {
        self.tags.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CAttribute_ItemSlotCriteria {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CAttribute_ItemSlotCriteria {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSetItemSlotAttribute {
    // message fields
    item_id: ::std::option::Option<u64>,
    slot_item_original_id: ::std::option::Option<u64>,
    slot_index: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSetItemSlotAttribute {
    fn default() -> &'a CMsgSetItemSlotAttribute {
        <CMsgSetItemSlotAttribute as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSetItemSlotAttribute {
    pub fn new() -> CMsgSetItemSlotAttribute {
        ::std::default::Default::default()
    }

    // optional uint64 item_id = 1;


    pub fn get_item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }
    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    // optional uint64 slot_item_original_id = 2;


    pub fn get_slot_item_original_id(&self) -> u64 {
        self.slot_item_original_id.unwrap_or(0)
    }
    pub fn clear_slot_item_original_id(&mut self) {
        self.slot_item_original_id = ::std::option::Option::None;
    }

    pub fn has_slot_item_original_id(&self) -> bool {
        self.slot_item_original_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slot_item_original_id(&mut self, v: u64) {
        self.slot_item_original_id = ::std::option::Option::Some(v);
    }

    // optional uint32 slot_index = 3;


    pub fn get_slot_index(&self) -> u32 {
        self.slot_index.unwrap_or(0)
    }
    pub fn clear_slot_index(&mut self) {
        self.slot_index = ::std::option::Option::None;
    }

    pub fn has_slot_index(&self) -> bool {
        self.slot_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slot_index(&mut self, v: u32) {
        self.slot_index = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSetItemSlotAttribute {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.item_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.slot_item_original_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.slot_index = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.slot_item_original_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.slot_index {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.slot_item_original_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.slot_index {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSetItemSlotAttribute {
        CMsgSetItemSlotAttribute::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "item_id",
                |m: &CMsgSetItemSlotAttribute| { &m.item_id },
                |m: &mut CMsgSetItemSlotAttribute| { &mut m.item_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "slot_item_original_id",
                |m: &CMsgSetItemSlotAttribute| { &m.slot_item_original_id },
                |m: &mut CMsgSetItemSlotAttribute| { &mut m.slot_item_original_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "slot_index",
                |m: &CMsgSetItemSlotAttribute| { &m.slot_index },
                |m: &mut CMsgSetItemSlotAttribute| { &mut m.slot_index },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSetItemSlotAttribute>(
                "CMsgSetItemSlotAttribute",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSetItemSlotAttribute {
        static instance: ::protobuf::rt::LazyV2<CMsgSetItemSlotAttribute> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSetItemSlotAttribute::new)
    }
}

impl ::protobuf::Clear for CMsgSetItemSlotAttribute {
    fn clear(&mut self) {
        self.item_id = ::std::option::Option::None;
        self.slot_item_original_id = ::std::option::Option::None;
        self.slot_index = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSetItemSlotAttribute {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSetItemSlotAttribute {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CSOWarData {
    // message fields
    account_id: ::std::option::Option<u32>,
    war_id: ::std::option::Option<u32>,
    affiliation: ::std::option::Option<u32>,
    points_scored: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CSOWarData {
    fn default() -> &'a CSOWarData {
        <CSOWarData as ::protobuf::Message>::default_instance()
    }
}

impl CSOWarData {
    pub fn new() -> CSOWarData {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;


    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }
    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 war_id = 2;


    pub fn get_war_id(&self) -> u32 {
        self.war_id.unwrap_or(0)
    }
    pub fn clear_war_id(&mut self) {
        self.war_id = ::std::option::Option::None;
    }

    pub fn has_war_id(&self) -> bool {
        self.war_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_war_id(&mut self, v: u32) {
        self.war_id = ::std::option::Option::Some(v);
    }

    // optional uint32 affiliation = 3;


    pub fn get_affiliation(&self) -> u32 {
        self.affiliation.unwrap_or(0)
    }
    pub fn clear_affiliation(&mut self) {
        self.affiliation = ::std::option::Option::None;
    }

    pub fn has_affiliation(&self) -> bool {
        self.affiliation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_affiliation(&mut self, v: u32) {
        self.affiliation = ::std::option::Option::Some(v);
    }

    // optional uint32 points_scored = 4;


    pub fn get_points_scored(&self) -> u32 {
        self.points_scored.unwrap_or(0)
    }
    pub fn clear_points_scored(&mut self) {
        self.points_scored = ::std::option::Option::None;
    }

    pub fn has_points_scored(&self) -> bool {
        self.points_scored.is_some()
    }

    // Param is passed by value, moved
    pub fn set_points_scored(&mut self, v: u32) {
        self.points_scored = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CSOWarData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.war_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.affiliation = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.points_scored = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.war_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.affiliation {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.points_scored {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.war_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.affiliation {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.points_scored {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CSOWarData {
        CSOWarData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "account_id",
                |m: &CSOWarData| { &m.account_id },
                |m: &mut CSOWarData| { &mut m.account_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "war_id",
                |m: &CSOWarData| { &m.war_id },
                |m: &mut CSOWarData| { &mut m.war_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "affiliation",
                |m: &CSOWarData| { &m.affiliation },
                |m: &mut CSOWarData| { &mut m.affiliation },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "points_scored",
                |m: &CSOWarData| { &m.points_scored },
                |m: &mut CSOWarData| { &mut m.points_scored },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CSOWarData>(
                "CSOWarData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CSOWarData {
        static instance: ::protobuf::rt::LazyV2<CSOWarData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CSOWarData::new)
    }
}

impl ::protobuf::Clear for CSOWarData {
    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.war_id = ::std::option::Option::None;
        self.affiliation = ::std::option::Option::None;
        self.points_scored = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSOWarData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOWarData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CGCMsgGC_War_IndividualUpdate {
    // message fields
    steam_id: ::std::option::Option<u64>,
    war_id: ::std::option::Option<u32>,
    score: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CGCMsgGC_War_IndividualUpdate {
    fn default() -> &'a CGCMsgGC_War_IndividualUpdate {
        <CGCMsgGC_War_IndividualUpdate as ::protobuf::Message>::default_instance()
    }
}

impl CGCMsgGC_War_IndividualUpdate {
    pub fn new() -> CGCMsgGC_War_IndividualUpdate {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id = 1;


    pub fn get_steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }
    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }

    // optional uint32 war_id = 2;


    pub fn get_war_id(&self) -> u32 {
        self.war_id.unwrap_or(0)
    }
    pub fn clear_war_id(&mut self) {
        self.war_id = ::std::option::Option::None;
    }

    pub fn has_war_id(&self) -> bool {
        self.war_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_war_id(&mut self, v: u32) {
        self.war_id = ::std::option::Option::Some(v);
    }

    // optional uint32 score = 3;


    pub fn get_score(&self) -> u32 {
        self.score.unwrap_or(0)
    }
    pub fn clear_score(&mut self) {
        self.score = ::std::option::Option::None;
    }

    pub fn has_score(&self) -> bool {
        self.score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_score(&mut self, v: u32) {
        self.score = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CGCMsgGC_War_IndividualUpdate {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steam_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.war_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.score = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id {
            my_size += 9;
        }
        if let Some(v) = self.war_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.score {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steam_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.war_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.score {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CGCMsgGC_War_IndividualUpdate {
        CGCMsgGC_War_IndividualUpdate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steam_id",
                |m: &CGCMsgGC_War_IndividualUpdate| { &m.steam_id },
                |m: &mut CGCMsgGC_War_IndividualUpdate| { &mut m.steam_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "war_id",
                |m: &CGCMsgGC_War_IndividualUpdate| { &m.war_id },
                |m: &mut CGCMsgGC_War_IndividualUpdate| { &mut m.war_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "score",
                |m: &CGCMsgGC_War_IndividualUpdate| { &m.score },
                |m: &mut CGCMsgGC_War_IndividualUpdate| { &mut m.score },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CGCMsgGC_War_IndividualUpdate>(
                "CGCMsgGC_War_IndividualUpdate",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CGCMsgGC_War_IndividualUpdate {
        static instance: ::protobuf::rt::LazyV2<CGCMsgGC_War_IndividualUpdate> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CGCMsgGC_War_IndividualUpdate::new)
    }
}

impl ::protobuf::Clear for CGCMsgGC_War_IndividualUpdate {
    fn clear(&mut self) {
        self.steam_id = ::std::option::Option::None;
        self.war_id = ::std::option::Option::None;
        self.score = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CGCMsgGC_War_IndividualUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CGCMsgGC_War_IndividualUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CGCMsgGC_War_JoinWar {
    // message fields
    affiliation: ::std::option::Option<u32>,
    war_id: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CGCMsgGC_War_JoinWar {
    fn default() -> &'a CGCMsgGC_War_JoinWar {
        <CGCMsgGC_War_JoinWar as ::protobuf::Message>::default_instance()
    }
}

impl CGCMsgGC_War_JoinWar {
    pub fn new() -> CGCMsgGC_War_JoinWar {
        ::std::default::Default::default()
    }

    // optional uint32 affiliation = 1;


    pub fn get_affiliation(&self) -> u32 {
        self.affiliation.unwrap_or(0)
    }
    pub fn clear_affiliation(&mut self) {
        self.affiliation = ::std::option::Option::None;
    }

    pub fn has_affiliation(&self) -> bool {
        self.affiliation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_affiliation(&mut self, v: u32) {
        self.affiliation = ::std::option::Option::Some(v);
    }

    // optional uint32 war_id = 2;


    pub fn get_war_id(&self) -> u32 {
        self.war_id.unwrap_or(0)
    }
    pub fn clear_war_id(&mut self) {
        self.war_id = ::std::option::Option::None;
    }

    pub fn has_war_id(&self) -> bool {
        self.war_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_war_id(&mut self, v: u32) {
        self.war_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CGCMsgGC_War_JoinWar {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.affiliation = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.war_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.affiliation {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.war_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.affiliation {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.war_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CGCMsgGC_War_JoinWar {
        CGCMsgGC_War_JoinWar::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "affiliation",
                |m: &CGCMsgGC_War_JoinWar| { &m.affiliation },
                |m: &mut CGCMsgGC_War_JoinWar| { &mut m.affiliation },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "war_id",
                |m: &CGCMsgGC_War_JoinWar| { &m.war_id },
                |m: &mut CGCMsgGC_War_JoinWar| { &mut m.war_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CGCMsgGC_War_JoinWar>(
                "CGCMsgGC_War_JoinWar",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CGCMsgGC_War_JoinWar {
        static instance: ::protobuf::rt::LazyV2<CGCMsgGC_War_JoinWar> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CGCMsgGC_War_JoinWar::new)
    }
}

impl ::protobuf::Clear for CGCMsgGC_War_JoinWar {
    fn clear(&mut self) {
        self.affiliation = ::std::option::Option::None;
        self.war_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CGCMsgGC_War_JoinWar {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CGCMsgGC_War_JoinWar {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CGCMsgGC_War_RequestGlobalStats {
    // message fields
    war_id: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CGCMsgGC_War_RequestGlobalStats {
    fn default() -> &'a CGCMsgGC_War_RequestGlobalStats {
        <CGCMsgGC_War_RequestGlobalStats as ::protobuf::Message>::default_instance()
    }
}

impl CGCMsgGC_War_RequestGlobalStats {
    pub fn new() -> CGCMsgGC_War_RequestGlobalStats {
        ::std::default::Default::default()
    }

    // optional uint32 war_id = 1;


    pub fn get_war_id(&self) -> u32 {
        self.war_id.unwrap_or(0)
    }
    pub fn clear_war_id(&mut self) {
        self.war_id = ::std::option::Option::None;
    }

    pub fn has_war_id(&self) -> bool {
        self.war_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_war_id(&mut self, v: u32) {
        self.war_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CGCMsgGC_War_RequestGlobalStats {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.war_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.war_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.war_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CGCMsgGC_War_RequestGlobalStats {
        CGCMsgGC_War_RequestGlobalStats::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "war_id",
                |m: &CGCMsgGC_War_RequestGlobalStats| { &m.war_id },
                |m: &mut CGCMsgGC_War_RequestGlobalStats| { &mut m.war_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CGCMsgGC_War_RequestGlobalStats>(
                "CGCMsgGC_War_RequestGlobalStats",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CGCMsgGC_War_RequestGlobalStats {
        static instance: ::protobuf::rt::LazyV2<CGCMsgGC_War_RequestGlobalStats> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CGCMsgGC_War_RequestGlobalStats::new)
    }
}

impl ::protobuf::Clear for CGCMsgGC_War_RequestGlobalStats {
    fn clear(&mut self) {
        self.war_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CGCMsgGC_War_RequestGlobalStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CGCMsgGC_War_RequestGlobalStats {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CGCMsgGC_War_GlobalStatsResponse {
    // message fields
    pub side_scores: ::protobuf::RepeatedField<CGCMsgGC_War_GlobalStatsResponse_SideScore>,
    war_id: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CGCMsgGC_War_GlobalStatsResponse {
    fn default() -> &'a CGCMsgGC_War_GlobalStatsResponse {
        <CGCMsgGC_War_GlobalStatsResponse as ::protobuf::Message>::default_instance()
    }
}

impl CGCMsgGC_War_GlobalStatsResponse {
    pub fn new() -> CGCMsgGC_War_GlobalStatsResponse {
        ::std::default::Default::default()
    }

    // repeated .CGCMsgGC_War_GlobalStatsResponse.SideScore side_scores = 1;


    pub fn get_side_scores(&self) -> &[CGCMsgGC_War_GlobalStatsResponse_SideScore] {
        &self.side_scores
    }
    pub fn clear_side_scores(&mut self) {
        self.side_scores.clear();
    }

    // Param is passed by value, moved
    pub fn set_side_scores(&mut self, v: ::protobuf::RepeatedField<CGCMsgGC_War_GlobalStatsResponse_SideScore>) {
        self.side_scores = v;
    }

    // Mutable pointer to the field.
    pub fn mut_side_scores(&mut self) -> &mut ::protobuf::RepeatedField<CGCMsgGC_War_GlobalStatsResponse_SideScore> {
        &mut self.side_scores
    }

    // Take field
    pub fn take_side_scores(&mut self) -> ::protobuf::RepeatedField<CGCMsgGC_War_GlobalStatsResponse_SideScore> {
        ::std::mem::replace(&mut self.side_scores, ::protobuf::RepeatedField::new())
    }

    // optional uint32 war_id = 2;


    pub fn get_war_id(&self) -> u32 {
        self.war_id.unwrap_or(0)
    }
    pub fn clear_war_id(&mut self) {
        self.war_id = ::std::option::Option::None;
    }

    pub fn has_war_id(&self) -> bool {
        self.war_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_war_id(&mut self, v: u32) {
        self.war_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CGCMsgGC_War_GlobalStatsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.side_scores {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.side_scores)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.war_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.side_scores {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.war_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.side_scores {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.war_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CGCMsgGC_War_GlobalStatsResponse {
        CGCMsgGC_War_GlobalStatsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CGCMsgGC_War_GlobalStatsResponse_SideScore>>(
                "side_scores",
                |m: &CGCMsgGC_War_GlobalStatsResponse| { &m.side_scores },
                |m: &mut CGCMsgGC_War_GlobalStatsResponse| { &mut m.side_scores },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "war_id",
                |m: &CGCMsgGC_War_GlobalStatsResponse| { &m.war_id },
                |m: &mut CGCMsgGC_War_GlobalStatsResponse| { &mut m.war_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CGCMsgGC_War_GlobalStatsResponse>(
                "CGCMsgGC_War_GlobalStatsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CGCMsgGC_War_GlobalStatsResponse {
        static instance: ::protobuf::rt::LazyV2<CGCMsgGC_War_GlobalStatsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CGCMsgGC_War_GlobalStatsResponse::new)
    }
}

impl ::protobuf::Clear for CGCMsgGC_War_GlobalStatsResponse {
    fn clear(&mut self) {
        self.side_scores.clear();
        self.war_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CGCMsgGC_War_GlobalStatsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CGCMsgGC_War_GlobalStatsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CGCMsgGC_War_GlobalStatsResponse_SideScore {
    // message fields
    side: ::std::option::Option<u32>,
    score: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CGCMsgGC_War_GlobalStatsResponse_SideScore {
    fn default() -> &'a CGCMsgGC_War_GlobalStatsResponse_SideScore {
        <CGCMsgGC_War_GlobalStatsResponse_SideScore as ::protobuf::Message>::default_instance()
    }
}

impl CGCMsgGC_War_GlobalStatsResponse_SideScore {
    pub fn new() -> CGCMsgGC_War_GlobalStatsResponse_SideScore {
        ::std::default::Default::default()
    }

    // optional uint32 side = 1;


    pub fn get_side(&self) -> u32 {
        self.side.unwrap_or(0)
    }
    pub fn clear_side(&mut self) {
        self.side = ::std::option::Option::None;
    }

    pub fn has_side(&self) -> bool {
        self.side.is_some()
    }

    // Param is passed by value, moved
    pub fn set_side(&mut self, v: u32) {
        self.side = ::std::option::Option::Some(v);
    }

    // optional uint64 score = 2;


    pub fn get_score(&self) -> u64 {
        self.score.unwrap_or(0)
    }
    pub fn clear_score(&mut self) {
        self.score = ::std::option::Option::None;
    }

    pub fn has_score(&self) -> bool {
        self.score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_score(&mut self, v: u64) {
        self.score = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CGCMsgGC_War_GlobalStatsResponse_SideScore {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.side = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.score = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.side {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.score {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.side {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.score {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CGCMsgGC_War_GlobalStatsResponse_SideScore {
        CGCMsgGC_War_GlobalStatsResponse_SideScore::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "side",
                |m: &CGCMsgGC_War_GlobalStatsResponse_SideScore| { &m.side },
                |m: &mut CGCMsgGC_War_GlobalStatsResponse_SideScore| { &mut m.side },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "score",
                |m: &CGCMsgGC_War_GlobalStatsResponse_SideScore| { &m.score },
                |m: &mut CGCMsgGC_War_GlobalStatsResponse_SideScore| { &mut m.score },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CGCMsgGC_War_GlobalStatsResponse_SideScore>(
                "CGCMsgGC_War_GlobalStatsResponse.SideScore",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CGCMsgGC_War_GlobalStatsResponse_SideScore {
        static instance: ::protobuf::rt::LazyV2<CGCMsgGC_War_GlobalStatsResponse_SideScore> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CGCMsgGC_War_GlobalStatsResponse_SideScore::new)
    }
}

impl ::protobuf::Clear for CGCMsgGC_War_GlobalStatsResponse_SideScore {
    fn clear(&mut self) {
        self.side = ::std::option::Option::None;
        self.score = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CGCMsgGC_War_GlobalStatsResponse_SideScore {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CGCMsgGC_War_GlobalStatsResponse_SideScore {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CGCMsgGC_PlayerDuckLeaderboard_IndividualUpdate {
    // message fields
    score: ::std::option::Option<u32>,
    field_type: ::std::option::Option<u32>,
    score_id: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    score_check: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CGCMsgGC_PlayerDuckLeaderboard_IndividualUpdate {
    fn default() -> &'a CGCMsgGC_PlayerDuckLeaderboard_IndividualUpdate {
        <CGCMsgGC_PlayerDuckLeaderboard_IndividualUpdate as ::protobuf::Message>::default_instance()
    }
}

impl CGCMsgGC_PlayerDuckLeaderboard_IndividualUpdate {
    pub fn new() -> CGCMsgGC_PlayerDuckLeaderboard_IndividualUpdate {
        ::std::default::Default::default()
    }

    // optional uint32 score = 2;


    pub fn get_score(&self) -> u32 {
        self.score.unwrap_or(0)
    }
    pub fn clear_score(&mut self) {
        self.score = ::std::option::Option::None;
    }

    pub fn has_score(&self) -> bool {
        self.score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_score(&mut self, v: u32) {
        self.score = ::std::option::Option::Some(v);
    }

    // optional uint32 type = 3;


    pub fn get_field_type(&self) -> u32 {
        self.field_type.unwrap_or(0)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: u32) {
        self.field_type = ::std::option::Option::Some(v);
    }

    // optional bytes score_id = 4;


    pub fn get_score_id(&self) -> &[u8] {
        match self.score_id.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_score_id(&mut self) {
        self.score_id.clear();
    }

    pub fn has_score_id(&self) -> bool {
        self.score_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_score_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.score_id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_score_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.score_id.is_none() {
            self.score_id.set_default();
        }
        self.score_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_score_id(&mut self) -> ::std::vec::Vec<u8> {
        self.score_id.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 score_check = 5;


    pub fn get_score_check(&self) -> u32 {
        self.score_check.unwrap_or(0)
    }
    pub fn clear_score_check(&mut self) {
        self.score_check = ::std::option::Option::None;
    }

    pub fn has_score_check(&self) -> bool {
        self.score_check.is_some()
    }

    // Param is passed by value, moved
    pub fn set_score_check(&mut self, v: u32) {
        self.score_check = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CGCMsgGC_PlayerDuckLeaderboard_IndividualUpdate {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.score = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.score_id)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.score_check = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.score {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.score_id.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.score_check {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.score {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.field_type {
            os.write_uint32(3, v)?;
        }
        if let Some(ref v) = self.score_id.as_ref() {
            os.write_bytes(4, &v)?;
        }
        if let Some(v) = self.score_check {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CGCMsgGC_PlayerDuckLeaderboard_IndividualUpdate {
        CGCMsgGC_PlayerDuckLeaderboard_IndividualUpdate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "score",
                |m: &CGCMsgGC_PlayerDuckLeaderboard_IndividualUpdate| { &m.score },
                |m: &mut CGCMsgGC_PlayerDuckLeaderboard_IndividualUpdate| { &mut m.score },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "type",
                |m: &CGCMsgGC_PlayerDuckLeaderboard_IndividualUpdate| { &m.field_type },
                |m: &mut CGCMsgGC_PlayerDuckLeaderboard_IndividualUpdate| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "score_id",
                |m: &CGCMsgGC_PlayerDuckLeaderboard_IndividualUpdate| { &m.score_id },
                |m: &mut CGCMsgGC_PlayerDuckLeaderboard_IndividualUpdate| { &mut m.score_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "score_check",
                |m: &CGCMsgGC_PlayerDuckLeaderboard_IndividualUpdate| { &m.score_check },
                |m: &mut CGCMsgGC_PlayerDuckLeaderboard_IndividualUpdate| { &mut m.score_check },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CGCMsgGC_PlayerDuckLeaderboard_IndividualUpdate>(
                "CGCMsgGC_PlayerDuckLeaderboard_IndividualUpdate",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CGCMsgGC_PlayerDuckLeaderboard_IndividualUpdate {
        static instance: ::protobuf::rt::LazyV2<CGCMsgGC_PlayerDuckLeaderboard_IndividualUpdate> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CGCMsgGC_PlayerDuckLeaderboard_IndividualUpdate::new)
    }
}

impl ::protobuf::Clear for CGCMsgGC_PlayerDuckLeaderboard_IndividualUpdate {
    fn clear(&mut self) {
        self.score = ::std::option::Option::None;
        self.field_type = ::std::option::Option::None;
        self.score_id.clear();
        self.score_check = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CGCMsgGC_PlayerDuckLeaderboard_IndividualUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CGCMsgGC_PlayerDuckLeaderboard_IndividualUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CAttribute_WorldItemPlacement {
    // message fields
    original_item_id: ::std::option::Option<u64>,
    pos_x: ::std::option::Option<f32>,
    pos_y: ::std::option::Option<f32>,
    pos_z: ::std::option::Option<f32>,
    ang_x: ::std::option::Option<f32>,
    ang_y: ::std::option::Option<f32>,
    ang_z: ::std::option::Option<f32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CAttribute_WorldItemPlacement {
    fn default() -> &'a CAttribute_WorldItemPlacement {
        <CAttribute_WorldItemPlacement as ::protobuf::Message>::default_instance()
    }
}

impl CAttribute_WorldItemPlacement {
    pub fn new() -> CAttribute_WorldItemPlacement {
        ::std::default::Default::default()
    }

    // optional uint64 original_item_id = 1;


    pub fn get_original_item_id(&self) -> u64 {
        self.original_item_id.unwrap_or(0)
    }
    pub fn clear_original_item_id(&mut self) {
        self.original_item_id = ::std::option::Option::None;
    }

    pub fn has_original_item_id(&self) -> bool {
        self.original_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_original_item_id(&mut self, v: u64) {
        self.original_item_id = ::std::option::Option::Some(v);
    }

    // optional float pos_x = 2;


    pub fn get_pos_x(&self) -> f32 {
        self.pos_x.unwrap_or(0.)
    }
    pub fn clear_pos_x(&mut self) {
        self.pos_x = ::std::option::Option::None;
    }

    pub fn has_pos_x(&self) -> bool {
        self.pos_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos_x(&mut self, v: f32) {
        self.pos_x = ::std::option::Option::Some(v);
    }

    // optional float pos_y = 3;


    pub fn get_pos_y(&self) -> f32 {
        self.pos_y.unwrap_or(0.)
    }
    pub fn clear_pos_y(&mut self) {
        self.pos_y = ::std::option::Option::None;
    }

    pub fn has_pos_y(&self) -> bool {
        self.pos_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos_y(&mut self, v: f32) {
        self.pos_y = ::std::option::Option::Some(v);
    }

    // optional float pos_z = 4;


    pub fn get_pos_z(&self) -> f32 {
        self.pos_z.unwrap_or(0.)
    }
    pub fn clear_pos_z(&mut self) {
        self.pos_z = ::std::option::Option::None;
    }

    pub fn has_pos_z(&self) -> bool {
        self.pos_z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos_z(&mut self, v: f32) {
        self.pos_z = ::std::option::Option::Some(v);
    }

    // optional float ang_x = 5;


    pub fn get_ang_x(&self) -> f32 {
        self.ang_x.unwrap_or(0.)
    }
    pub fn clear_ang_x(&mut self) {
        self.ang_x = ::std::option::Option::None;
    }

    pub fn has_ang_x(&self) -> bool {
        self.ang_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ang_x(&mut self, v: f32) {
        self.ang_x = ::std::option::Option::Some(v);
    }

    // optional float ang_y = 6;


    pub fn get_ang_y(&self) -> f32 {
        self.ang_y.unwrap_or(0.)
    }
    pub fn clear_ang_y(&mut self) {
        self.ang_y = ::std::option::Option::None;
    }

    pub fn has_ang_y(&self) -> bool {
        self.ang_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ang_y(&mut self, v: f32) {
        self.ang_y = ::std::option::Option::Some(v);
    }

    // optional float ang_z = 7;


    pub fn get_ang_z(&self) -> f32 {
        self.ang_z.unwrap_or(0.)
    }
    pub fn clear_ang_z(&mut self) {
        self.ang_z = ::std::option::Option::None;
    }

    pub fn has_ang_z(&self) -> bool {
        self.ang_z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ang_z(&mut self, v: f32) {
        self.ang_z = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CAttribute_WorldItemPlacement {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.original_item_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.pos_x = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.pos_y = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.pos_z = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.ang_x = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.ang_y = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.ang_z = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.original_item_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.pos_x {
            my_size += 5;
        }
        if let Some(v) = self.pos_y {
            my_size += 5;
        }
        if let Some(v) = self.pos_z {
            my_size += 5;
        }
        if let Some(v) = self.ang_x {
            my_size += 5;
        }
        if let Some(v) = self.ang_y {
            my_size += 5;
        }
        if let Some(v) = self.ang_z {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.original_item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.pos_x {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.pos_y {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.pos_z {
            os.write_float(4, v)?;
        }
        if let Some(v) = self.ang_x {
            os.write_float(5, v)?;
        }
        if let Some(v) = self.ang_y {
            os.write_float(6, v)?;
        }
        if let Some(v) = self.ang_z {
            os.write_float(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CAttribute_WorldItemPlacement {
        CAttribute_WorldItemPlacement::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "original_item_id",
                |m: &CAttribute_WorldItemPlacement| { &m.original_item_id },
                |m: &mut CAttribute_WorldItemPlacement| { &mut m.original_item_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "pos_x",
                |m: &CAttribute_WorldItemPlacement| { &m.pos_x },
                |m: &mut CAttribute_WorldItemPlacement| { &mut m.pos_x },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "pos_y",
                |m: &CAttribute_WorldItemPlacement| { &m.pos_y },
                |m: &mut CAttribute_WorldItemPlacement| { &mut m.pos_y },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "pos_z",
                |m: &CAttribute_WorldItemPlacement| { &m.pos_z },
                |m: &mut CAttribute_WorldItemPlacement| { &mut m.pos_z },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "ang_x",
                |m: &CAttribute_WorldItemPlacement| { &m.ang_x },
                |m: &mut CAttribute_WorldItemPlacement| { &mut m.ang_x },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "ang_y",
                |m: &CAttribute_WorldItemPlacement| { &m.ang_y },
                |m: &mut CAttribute_WorldItemPlacement| { &mut m.ang_y },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "ang_z",
                |m: &CAttribute_WorldItemPlacement| { &m.ang_z },
                |m: &mut CAttribute_WorldItemPlacement| { &mut m.ang_z },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CAttribute_WorldItemPlacement>(
                "CAttribute_WorldItemPlacement",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CAttribute_WorldItemPlacement {
        static instance: ::protobuf::rt::LazyV2<CAttribute_WorldItemPlacement> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CAttribute_WorldItemPlacement::new)
    }
}

impl ::protobuf::Clear for CAttribute_WorldItemPlacement {
    fn clear(&mut self) {
        self.original_item_id = ::std::option::Option::None;
        self.pos_x = ::std::option::Option::None;
        self.pos_y = ::std::option::Option::None;
        self.pos_z = ::std::option::Option::None;
        self.ang_x = ::std::option::Option::None;
        self.ang_y = ::std::option::Option::None;
        self.ang_z = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CAttribute_WorldItemPlacement {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CAttribute_WorldItemPlacement {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CGCMsg_WorldItemPlacement_Update {
    // message fields
    original_item_id: ::std::option::Option<u64>,
    pos_x: ::std::option::Option<f32>,
    pos_y: ::std::option::Option<f32>,
    pos_z: ::std::option::Option<f32>,
    ang_x: ::std::option::Option<f32>,
    ang_y: ::std::option::Option<f32>,
    ang_z: ::std::option::Option<f32>,
    force_remove_all: ::std::option::Option<bool>,
    attrib_name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CGCMsg_WorldItemPlacement_Update {
    fn default() -> &'a CGCMsg_WorldItemPlacement_Update {
        <CGCMsg_WorldItemPlacement_Update as ::protobuf::Message>::default_instance()
    }
}

impl CGCMsg_WorldItemPlacement_Update {
    pub fn new() -> CGCMsg_WorldItemPlacement_Update {
        ::std::default::Default::default()
    }

    // optional uint64 original_item_id = 1;


    pub fn get_original_item_id(&self) -> u64 {
        self.original_item_id.unwrap_or(0)
    }
    pub fn clear_original_item_id(&mut self) {
        self.original_item_id = ::std::option::Option::None;
    }

    pub fn has_original_item_id(&self) -> bool {
        self.original_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_original_item_id(&mut self, v: u64) {
        self.original_item_id = ::std::option::Option::Some(v);
    }

    // optional float pos_x = 2;


    pub fn get_pos_x(&self) -> f32 {
        self.pos_x.unwrap_or(0.)
    }
    pub fn clear_pos_x(&mut self) {
        self.pos_x = ::std::option::Option::None;
    }

    pub fn has_pos_x(&self) -> bool {
        self.pos_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos_x(&mut self, v: f32) {
        self.pos_x = ::std::option::Option::Some(v);
    }

    // optional float pos_y = 3;


    pub fn get_pos_y(&self) -> f32 {
        self.pos_y.unwrap_or(0.)
    }
    pub fn clear_pos_y(&mut self) {
        self.pos_y = ::std::option::Option::None;
    }

    pub fn has_pos_y(&self) -> bool {
        self.pos_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos_y(&mut self, v: f32) {
        self.pos_y = ::std::option::Option::Some(v);
    }

    // optional float pos_z = 4;


    pub fn get_pos_z(&self) -> f32 {
        self.pos_z.unwrap_or(0.)
    }
    pub fn clear_pos_z(&mut self) {
        self.pos_z = ::std::option::Option::None;
    }

    pub fn has_pos_z(&self) -> bool {
        self.pos_z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos_z(&mut self, v: f32) {
        self.pos_z = ::std::option::Option::Some(v);
    }

    // optional float ang_x = 5;


    pub fn get_ang_x(&self) -> f32 {
        self.ang_x.unwrap_or(0.)
    }
    pub fn clear_ang_x(&mut self) {
        self.ang_x = ::std::option::Option::None;
    }

    pub fn has_ang_x(&self) -> bool {
        self.ang_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ang_x(&mut self, v: f32) {
        self.ang_x = ::std::option::Option::Some(v);
    }

    // optional float ang_y = 6;


    pub fn get_ang_y(&self) -> f32 {
        self.ang_y.unwrap_or(0.)
    }
    pub fn clear_ang_y(&mut self) {
        self.ang_y = ::std::option::Option::None;
    }

    pub fn has_ang_y(&self) -> bool {
        self.ang_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ang_y(&mut self, v: f32) {
        self.ang_y = ::std::option::Option::Some(v);
    }

    // optional float ang_z = 7;


    pub fn get_ang_z(&self) -> f32 {
        self.ang_z.unwrap_or(0.)
    }
    pub fn clear_ang_z(&mut self) {
        self.ang_z = ::std::option::Option::None;
    }

    pub fn has_ang_z(&self) -> bool {
        self.ang_z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ang_z(&mut self, v: f32) {
        self.ang_z = ::std::option::Option::Some(v);
    }

    // optional bool force_remove_all = 8;


    pub fn get_force_remove_all(&self) -> bool {
        self.force_remove_all.unwrap_or(false)
    }
    pub fn clear_force_remove_all(&mut self) {
        self.force_remove_all = ::std::option::Option::None;
    }

    pub fn has_force_remove_all(&self) -> bool {
        self.force_remove_all.is_some()
    }

    // Param is passed by value, moved
    pub fn set_force_remove_all(&mut self, v: bool) {
        self.force_remove_all = ::std::option::Option::Some(v);
    }

    // optional string attrib_name = 9;


    pub fn get_attrib_name(&self) -> &str {
        match self.attrib_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_attrib_name(&mut self) {
        self.attrib_name.clear();
    }

    pub fn has_attrib_name(&self) -> bool {
        self.attrib_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attrib_name(&mut self, v: ::std::string::String) {
        self.attrib_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_attrib_name(&mut self) -> &mut ::std::string::String {
        if self.attrib_name.is_none() {
            self.attrib_name.set_default();
        }
        self.attrib_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_attrib_name(&mut self) -> ::std::string::String {
        self.attrib_name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CGCMsg_WorldItemPlacement_Update {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.original_item_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.pos_x = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.pos_y = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.pos_z = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.ang_x = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.ang_y = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.ang_z = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.force_remove_all = ::std::option::Option::Some(tmp);
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.attrib_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.original_item_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.pos_x {
            my_size += 5;
        }
        if let Some(v) = self.pos_y {
            my_size += 5;
        }
        if let Some(v) = self.pos_z {
            my_size += 5;
        }
        if let Some(v) = self.ang_x {
            my_size += 5;
        }
        if let Some(v) = self.ang_y {
            my_size += 5;
        }
        if let Some(v) = self.ang_z {
            my_size += 5;
        }
        if let Some(v) = self.force_remove_all {
            my_size += 2;
        }
        if let Some(ref v) = self.attrib_name.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.original_item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.pos_x {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.pos_y {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.pos_z {
            os.write_float(4, v)?;
        }
        if let Some(v) = self.ang_x {
            os.write_float(5, v)?;
        }
        if let Some(v) = self.ang_y {
            os.write_float(6, v)?;
        }
        if let Some(v) = self.ang_z {
            os.write_float(7, v)?;
        }
        if let Some(v) = self.force_remove_all {
            os.write_bool(8, v)?;
        }
        if let Some(ref v) = self.attrib_name.as_ref() {
            os.write_string(9, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CGCMsg_WorldItemPlacement_Update {
        CGCMsg_WorldItemPlacement_Update::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "original_item_id",
                |m: &CGCMsg_WorldItemPlacement_Update| { &m.original_item_id },
                |m: &mut CGCMsg_WorldItemPlacement_Update| { &mut m.original_item_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "pos_x",
                |m: &CGCMsg_WorldItemPlacement_Update| { &m.pos_x },
                |m: &mut CGCMsg_WorldItemPlacement_Update| { &mut m.pos_x },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "pos_y",
                |m: &CGCMsg_WorldItemPlacement_Update| { &m.pos_y },
                |m: &mut CGCMsg_WorldItemPlacement_Update| { &mut m.pos_y },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "pos_z",
                |m: &CGCMsg_WorldItemPlacement_Update| { &m.pos_z },
                |m: &mut CGCMsg_WorldItemPlacement_Update| { &mut m.pos_z },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "ang_x",
                |m: &CGCMsg_WorldItemPlacement_Update| { &m.ang_x },
                |m: &mut CGCMsg_WorldItemPlacement_Update| { &mut m.ang_x },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "ang_y",
                |m: &CGCMsg_WorldItemPlacement_Update| { &m.ang_y },
                |m: &mut CGCMsg_WorldItemPlacement_Update| { &mut m.ang_y },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "ang_z",
                |m: &CGCMsg_WorldItemPlacement_Update| { &m.ang_z },
                |m: &mut CGCMsg_WorldItemPlacement_Update| { &mut m.ang_z },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "force_remove_all",
                |m: &CGCMsg_WorldItemPlacement_Update| { &m.force_remove_all },
                |m: &mut CGCMsg_WorldItemPlacement_Update| { &mut m.force_remove_all },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "attrib_name",
                |m: &CGCMsg_WorldItemPlacement_Update| { &m.attrib_name },
                |m: &mut CGCMsg_WorldItemPlacement_Update| { &mut m.attrib_name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CGCMsg_WorldItemPlacement_Update>(
                "CGCMsg_WorldItemPlacement_Update",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CGCMsg_WorldItemPlacement_Update {
        static instance: ::protobuf::rt::LazyV2<CGCMsg_WorldItemPlacement_Update> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CGCMsg_WorldItemPlacement_Update::new)
    }
}

impl ::protobuf::Clear for CGCMsg_WorldItemPlacement_Update {
    fn clear(&mut self) {
        self.original_item_id = ::std::option::Option::None;
        self.pos_x = ::std::option::Option::None;
        self.pos_y = ::std::option::Option::None;
        self.pos_z = ::std::option::Option::None;
        self.ang_x = ::std::option::Option::None;
        self.ang_y = ::std::option::Option::None;
        self.ang_z = ::std::option::Option::None;
        self.force_remove_all = ::std::option::Option::None;
        self.attrib_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CGCMsg_WorldItemPlacement_Update {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CGCMsg_WorldItemPlacement_Update {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgAcknowledgeXP {
    // message fields
    match_group: ::std::option::Option<i32>,
    predicted_experience: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgAcknowledgeXP {
    fn default() -> &'a CMsgAcknowledgeXP {
        <CMsgAcknowledgeXP as ::protobuf::Message>::default_instance()
    }
}

impl CMsgAcknowledgeXP {
    pub fn new() -> CMsgAcknowledgeXP {
        ::std::default::Default::default()
    }

    // optional int32 match_group = 1;


    pub fn get_match_group(&self) -> i32 {
        self.match_group.unwrap_or(0)
    }
    pub fn clear_match_group(&mut self) {
        self.match_group = ::std::option::Option::None;
    }

    pub fn has_match_group(&self) -> bool {
        self.match_group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_group(&mut self, v: i32) {
        self.match_group = ::std::option::Option::Some(v);
    }

    // optional uint32 predicted_experience = 2;


    pub fn get_predicted_experience(&self) -> u32 {
        self.predicted_experience.unwrap_or(0)
    }
    pub fn clear_predicted_experience(&mut self) {
        self.predicted_experience = ::std::option::Option::None;
    }

    pub fn has_predicted_experience(&self) -> bool {
        self.predicted_experience.is_some()
    }

    // Param is passed by value, moved
    pub fn set_predicted_experience(&mut self, v: u32) {
        self.predicted_experience = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgAcknowledgeXP {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.match_group = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.predicted_experience = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.match_group {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.predicted_experience {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.match_group {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.predicted_experience {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgAcknowledgeXP {
        CMsgAcknowledgeXP::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "match_group",
                |m: &CMsgAcknowledgeXP| { &m.match_group },
                |m: &mut CMsgAcknowledgeXP| { &mut m.match_group },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "predicted_experience",
                |m: &CMsgAcknowledgeXP| { &m.predicted_experience },
                |m: &mut CMsgAcknowledgeXP| { &mut m.predicted_experience },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgAcknowledgeXP>(
                "CMsgAcknowledgeXP",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgAcknowledgeXP {
        static instance: ::protobuf::rt::LazyV2<CMsgAcknowledgeXP> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgAcknowledgeXP::new)
    }
}

impl ::protobuf::Clear for CMsgAcknowledgeXP {
    fn clear(&mut self) {
        self.match_group = ::std::option::Option::None;
        self.predicted_experience = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgAcknowledgeXP {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgAcknowledgeXP {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgTFXPSource {
    // message fields
    field_type: ::std::option::Option<CMsgTFXPSource_XPSourceType>,
    amount: ::std::option::Option<i32>,
    match_group: ::std::option::Option<i32>,
    account_id: ::std::option::Option<u32>,
    match_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgTFXPSource {
    fn default() -> &'a CMsgTFXPSource {
        <CMsgTFXPSource as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTFXPSource {
    pub fn new() -> CMsgTFXPSource {
        ::std::default::Default::default()
    }

    // optional .CMsgTFXPSource.XPSourceType type = 1;


    pub fn get_field_type(&self) -> CMsgTFXPSource_XPSourceType {
        self.field_type.unwrap_or(CMsgTFXPSource_XPSourceType::SOURCE_SCORE)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: CMsgTFXPSource_XPSourceType) {
        self.field_type = ::std::option::Option::Some(v);
    }

    // optional int32 amount = 2;


    pub fn get_amount(&self) -> i32 {
        self.amount.unwrap_or(0)
    }
    pub fn clear_amount(&mut self) {
        self.amount = ::std::option::Option::None;
    }

    pub fn has_amount(&self) -> bool {
        self.amount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: i32) {
        self.amount = ::std::option::Option::Some(v);
    }

    // optional int32 match_group = 3;


    pub fn get_match_group(&self) -> i32 {
        self.match_group.unwrap_or(0)
    }
    pub fn clear_match_group(&mut self) {
        self.match_group = ::std::option::Option::None;
    }

    pub fn has_match_group(&self) -> bool {
        self.match_group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_group(&mut self, v: i32) {
        self.match_group = ::std::option::Option::Some(v);
    }

    // optional uint32 account_id = 4;


    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }
    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint64 match_id = 5;


    pub fn get_match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }
    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgTFXPSource {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.amount = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.match_group = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.match_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.amount {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.match_group {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.amount {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.match_group {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.account_id {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.match_id {
            os.write_uint64(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgTFXPSource {
        CMsgTFXPSource::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CMsgTFXPSource_XPSourceType>>(
                "type",
                |m: &CMsgTFXPSource| { &m.field_type },
                |m: &mut CMsgTFXPSource| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "amount",
                |m: &CMsgTFXPSource| { &m.amount },
                |m: &mut CMsgTFXPSource| { &mut m.amount },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "match_group",
                |m: &CMsgTFXPSource| { &m.match_group },
                |m: &mut CMsgTFXPSource| { &mut m.match_group },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "account_id",
                |m: &CMsgTFXPSource| { &m.account_id },
                |m: &mut CMsgTFXPSource| { &mut m.account_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "match_id",
                |m: &CMsgTFXPSource| { &m.match_id },
                |m: &mut CMsgTFXPSource| { &mut m.match_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgTFXPSource>(
                "CMsgTFXPSource",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgTFXPSource {
        static instance: ::protobuf::rt::LazyV2<CMsgTFXPSource> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgTFXPSource::new)
    }
}

impl ::protobuf::Clear for CMsgTFXPSource {
    fn clear(&mut self) {
        self.field_type = ::std::option::Option::None;
        self.amount = ::std::option::Option::None;
        self.match_group = ::std::option::Option::None;
        self.account_id = ::std::option::Option::None;
        self.match_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgTFXPSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTFXPSource {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgTFXPSource_XPSourceType {
    SOURCE_SCORE = 0,
    SOURCE_OBJECTIVE_BONUS = 1,
    SOURCE_COMPLETED_MATCH = 2,
    SOURCE_COMPETITIVE_ABANDON = 3,
    SOURCE_COMPETITIVE_WIN = 4,
    SOURCE_COMPETITIVE_LOSS = 5,
    SOURCE_AUTOBALANCE_BONUS = 6,
    SOURCE_PRESTIGE_BONUS = 7,
}

impl ::protobuf::ProtobufEnum for CMsgTFXPSource_XPSourceType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgTFXPSource_XPSourceType> {
        match value {
            0 => ::std::option::Option::Some(CMsgTFXPSource_XPSourceType::SOURCE_SCORE),
            1 => ::std::option::Option::Some(CMsgTFXPSource_XPSourceType::SOURCE_OBJECTIVE_BONUS),
            2 => ::std::option::Option::Some(CMsgTFXPSource_XPSourceType::SOURCE_COMPLETED_MATCH),
            3 => ::std::option::Option::Some(CMsgTFXPSource_XPSourceType::SOURCE_COMPETITIVE_ABANDON),
            4 => ::std::option::Option::Some(CMsgTFXPSource_XPSourceType::SOURCE_COMPETITIVE_WIN),
            5 => ::std::option::Option::Some(CMsgTFXPSource_XPSourceType::SOURCE_COMPETITIVE_LOSS),
            6 => ::std::option::Option::Some(CMsgTFXPSource_XPSourceType::SOURCE_AUTOBALANCE_BONUS),
            7 => ::std::option::Option::Some(CMsgTFXPSource_XPSourceType::SOURCE_PRESTIGE_BONUS),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgTFXPSource_XPSourceType] = &[
            CMsgTFXPSource_XPSourceType::SOURCE_SCORE,
            CMsgTFXPSource_XPSourceType::SOURCE_OBJECTIVE_BONUS,
            CMsgTFXPSource_XPSourceType::SOURCE_COMPLETED_MATCH,
            CMsgTFXPSource_XPSourceType::SOURCE_COMPETITIVE_ABANDON,
            CMsgTFXPSource_XPSourceType::SOURCE_COMPETITIVE_WIN,
            CMsgTFXPSource_XPSourceType::SOURCE_COMPETITIVE_LOSS,
            CMsgTFXPSource_XPSourceType::SOURCE_AUTOBALANCE_BONUS,
            CMsgTFXPSource_XPSourceType::SOURCE_PRESTIGE_BONUS,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<CMsgTFXPSource_XPSourceType>("CMsgTFXPSource.XPSourceType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for CMsgTFXPSource_XPSourceType {
}

impl ::std::default::Default for CMsgTFXPSource_XPSourceType {
    fn default() -> Self {
        CMsgTFXPSource_XPSourceType::SOURCE_SCORE
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTFXPSource_XPSourceType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgTFXPSourceBreakdown {
    // message fields
    pub sources: ::protobuf::RepeatedField<CMsgTFXPSource>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgTFXPSourceBreakdown {
    fn default() -> &'a CMsgTFXPSourceBreakdown {
        <CMsgTFXPSourceBreakdown as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTFXPSourceBreakdown {
    pub fn new() -> CMsgTFXPSourceBreakdown {
        ::std::default::Default::default()
    }

    // repeated .CMsgTFXPSource sources = 1;


    pub fn get_sources(&self) -> &[CMsgTFXPSource] {
        &self.sources
    }
    pub fn clear_sources(&mut self) {
        self.sources.clear();
    }

    // Param is passed by value, moved
    pub fn set_sources(&mut self, v: ::protobuf::RepeatedField<CMsgTFXPSource>) {
        self.sources = v;
    }

    // Mutable pointer to the field.
    pub fn mut_sources(&mut self) -> &mut ::protobuf::RepeatedField<CMsgTFXPSource> {
        &mut self.sources
    }

    // Take field
    pub fn take_sources(&mut self) -> ::protobuf::RepeatedField<CMsgTFXPSource> {
        ::std::mem::replace(&mut self.sources, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgTFXPSourceBreakdown {
    fn is_initialized(&self) -> bool {
        for v in &self.sources {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.sources)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.sources {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.sources {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgTFXPSourceBreakdown {
        CMsgTFXPSourceBreakdown::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgTFXPSource>>(
                "sources",
                |m: &CMsgTFXPSourceBreakdown| { &m.sources },
                |m: &mut CMsgTFXPSourceBreakdown| { &mut m.sources },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgTFXPSourceBreakdown>(
                "CMsgTFXPSourceBreakdown",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgTFXPSourceBreakdown {
        static instance: ::protobuf::rt::LazyV2<CMsgTFXPSourceBreakdown> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgTFXPSourceBreakdown::new)
    }
}

impl ::protobuf::Clear for CMsgTFXPSourceBreakdown {
    fn clear(&mut self) {
        self.sources.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgTFXPSourceBreakdown {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTFXPSourceBreakdown {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgTFClientInit {
    // message fields
    client_version: ::std::option::Option<u32>,
    language: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgTFClientInit {
    fn default() -> &'a CMsgTFClientInit {
        <CMsgTFClientInit as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTFClientInit {
    pub fn new() -> CMsgTFClientInit {
        ::std::default::Default::default()
    }

    // optional uint32 client_version = 1;


    pub fn get_client_version(&self) -> u32 {
        self.client_version.unwrap_or(0)
    }
    pub fn clear_client_version(&mut self) {
        self.client_version = ::std::option::Option::None;
    }

    pub fn has_client_version(&self) -> bool {
        self.client_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_version(&mut self, v: u32) {
        self.client_version = ::std::option::Option::Some(v);
    }

    // optional int32 language = 2;


    pub fn get_language(&self) -> i32 {
        self.language.unwrap_or(0)
    }
    pub fn clear_language(&mut self) {
        self.language = ::std::option::Option::None;
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: i32) {
        self.language = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgTFClientInit {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.client_version = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.language = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.client_version {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.language {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.client_version {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.language {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgTFClientInit {
        CMsgTFClientInit::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "client_version",
                |m: &CMsgTFClientInit| { &m.client_version },
                |m: &mut CMsgTFClientInit| { &mut m.client_version },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "language",
                |m: &CMsgTFClientInit| { &m.language },
                |m: &mut CMsgTFClientInit| { &mut m.language },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgTFClientInit>(
                "CMsgTFClientInit",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgTFClientInit {
        static instance: ::protobuf::rt::LazyV2<CMsgTFClientInit> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgTFClientInit::new)
    }
}

impl ::protobuf::Clear for CMsgTFClientInit {
    fn clear(&mut self) {
        self.client_version = ::std::option::Option::None;
        self.language = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgTFClientInit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTFClientInit {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCNotification {
    // message fields
    notification_id: ::std::option::Option<u64>,
    account_id: ::std::option::Option<u32>,
    expiration_time: ::std::option::Option<u32>,
    field_type: ::std::option::Option<CMsgGCNotification_NotificationType>,
    notification_string: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCNotification {
    fn default() -> &'a CMsgGCNotification {
        <CMsgGCNotification as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCNotification {
    pub fn new() -> CMsgGCNotification {
        ::std::default::Default::default()
    }

    // optional uint64 notification_id = 1;


    pub fn get_notification_id(&self) -> u64 {
        self.notification_id.unwrap_or(0)
    }
    pub fn clear_notification_id(&mut self) {
        self.notification_id = ::std::option::Option::None;
    }

    pub fn has_notification_id(&self) -> bool {
        self.notification_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_notification_id(&mut self, v: u64) {
        self.notification_id = ::std::option::Option::Some(v);
    }

    // optional uint32 account_id = 2;


    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }
    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 expiration_time = 3;


    pub fn get_expiration_time(&self) -> u32 {
        self.expiration_time.unwrap_or(0)
    }
    pub fn clear_expiration_time(&mut self) {
        self.expiration_time = ::std::option::Option::None;
    }

    pub fn has_expiration_time(&self) -> bool {
        self.expiration_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expiration_time(&mut self, v: u32) {
        self.expiration_time = ::std::option::Option::Some(v);
    }

    // optional .CMsgGCNotification.NotificationType type = 4;


    pub fn get_field_type(&self) -> CMsgGCNotification_NotificationType {
        self.field_type.unwrap_or(CMsgGCNotification_NotificationType::NOTIFICATION_CUSTOM_STRING)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: CMsgGCNotification_NotificationType) {
        self.field_type = ::std::option::Option::Some(v);
    }

    // optional string notification_string = 5;


    pub fn get_notification_string(&self) -> &str {
        match self.notification_string.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_notification_string(&mut self) {
        self.notification_string.clear();
    }

    pub fn has_notification_string(&self) -> bool {
        self.notification_string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_notification_string(&mut self, v: ::std::string::String) {
        self.notification_string = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_notification_string(&mut self) -> &mut ::std::string::String {
        if self.notification_string.is_none() {
            self.notification_string.set_default();
        }
        self.notification_string.as_mut().unwrap()
    }

    // Take field
    pub fn take_notification_string(&mut self) -> ::std::string::String {
        self.notification_string.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgGCNotification {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.notification_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.expiration_time = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 4, &mut self.unknown_fields)?
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.notification_string)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.notification_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.expiration_time {
            my_size += 5;
        }
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(4, v);
        }
        if let Some(ref v) = self.notification_string.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.notification_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.account_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.expiration_time {
            os.write_fixed32(3, v)?;
        }
        if let Some(v) = self.field_type {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.notification_string.as_ref() {
            os.write_string(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCNotification {
        CMsgGCNotification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "notification_id",
                |m: &CMsgGCNotification| { &m.notification_id },
                |m: &mut CMsgGCNotification| { &mut m.notification_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "account_id",
                |m: &CMsgGCNotification| { &m.account_id },
                |m: &mut CMsgGCNotification| { &mut m.account_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "expiration_time",
                |m: &CMsgGCNotification| { &m.expiration_time },
                |m: &mut CMsgGCNotification| { &mut m.expiration_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CMsgGCNotification_NotificationType>>(
                "type",
                |m: &CMsgGCNotification| { &m.field_type },
                |m: &mut CMsgGCNotification| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "notification_string",
                |m: &CMsgGCNotification| { &m.notification_string },
                |m: &mut CMsgGCNotification| { &mut m.notification_string },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCNotification>(
                "CMsgGCNotification",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCNotification {
        static instance: ::protobuf::rt::LazyV2<CMsgGCNotification> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCNotification::new)
    }
}

impl ::protobuf::Clear for CMsgGCNotification {
    fn clear(&mut self) {
        self.notification_id = ::std::option::Option::None;
        self.account_id = ::std::option::Option::None;
        self.expiration_time = ::std::option::Option::None;
        self.field_type = ::std::option::Option::None;
        self.notification_string.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCNotification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCNotification {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgGCNotification_NotificationType {
    NOTIFICATION_REPORTED_PLAYER_BANNED = 0,
    NOTIFICATION_CUSTOM_STRING = 1,
    NOTIFICATION_MM_BAN_DUE_TO_EXCESSIVE_REPORTS = 2,
    NOTIFICATION_REPORTED_PLAYER_WAS_BANNED = 3,
    NOTIFICATION_SUPPORT_MESSAGE = 4,
    NOTIFICATION_NUM_TYPES = 5,
}

impl ::protobuf::ProtobufEnum for CMsgGCNotification_NotificationType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgGCNotification_NotificationType> {
        match value {
            0 => ::std::option::Option::Some(CMsgGCNotification_NotificationType::NOTIFICATION_REPORTED_PLAYER_BANNED),
            1 => ::std::option::Option::Some(CMsgGCNotification_NotificationType::NOTIFICATION_CUSTOM_STRING),
            2 => ::std::option::Option::Some(CMsgGCNotification_NotificationType::NOTIFICATION_MM_BAN_DUE_TO_EXCESSIVE_REPORTS),
            3 => ::std::option::Option::Some(CMsgGCNotification_NotificationType::NOTIFICATION_REPORTED_PLAYER_WAS_BANNED),
            4 => ::std::option::Option::Some(CMsgGCNotification_NotificationType::NOTIFICATION_SUPPORT_MESSAGE),
            5 => ::std::option::Option::Some(CMsgGCNotification_NotificationType::NOTIFICATION_NUM_TYPES),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgGCNotification_NotificationType] = &[
            CMsgGCNotification_NotificationType::NOTIFICATION_REPORTED_PLAYER_BANNED,
            CMsgGCNotification_NotificationType::NOTIFICATION_CUSTOM_STRING,
            CMsgGCNotification_NotificationType::NOTIFICATION_MM_BAN_DUE_TO_EXCESSIVE_REPORTS,
            CMsgGCNotification_NotificationType::NOTIFICATION_REPORTED_PLAYER_WAS_BANNED,
            CMsgGCNotification_NotificationType::NOTIFICATION_SUPPORT_MESSAGE,
            CMsgGCNotification_NotificationType::NOTIFICATION_NUM_TYPES,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<CMsgGCNotification_NotificationType>("CMsgGCNotification.NotificationType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for CMsgGCNotification_NotificationType {
}

impl ::std::default::Default for CMsgGCNotification_NotificationType {
    fn default() -> Self {
        CMsgGCNotification_NotificationType::NOTIFICATION_REPORTED_PLAYER_BANNED
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCNotification_NotificationType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCNotificationQueue {
    // message fields
    pub notifications: ::protobuf::RepeatedField<CMsgGCNotification>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCNotificationQueue {
    fn default() -> &'a CMsgGCNotificationQueue {
        <CMsgGCNotificationQueue as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCNotificationQueue {
    pub fn new() -> CMsgGCNotificationQueue {
        ::std::default::Default::default()
    }

    // repeated .CMsgGCNotification notifications = 1;


    pub fn get_notifications(&self) -> &[CMsgGCNotification] {
        &self.notifications
    }
    pub fn clear_notifications(&mut self) {
        self.notifications.clear();
    }

    // Param is passed by value, moved
    pub fn set_notifications(&mut self, v: ::protobuf::RepeatedField<CMsgGCNotification>) {
        self.notifications = v;
    }

    // Mutable pointer to the field.
    pub fn mut_notifications(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGCNotification> {
        &mut self.notifications
    }

    // Take field
    pub fn take_notifications(&mut self) -> ::protobuf::RepeatedField<CMsgGCNotification> {
        ::std::mem::replace(&mut self.notifications, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgGCNotificationQueue {
    fn is_initialized(&self) -> bool {
        for v in &self.notifications {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.notifications)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.notifications {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.notifications {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCNotificationQueue {
        CMsgGCNotificationQueue::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCNotification>>(
                "notifications",
                |m: &CMsgGCNotificationQueue| { &m.notifications },
                |m: &mut CMsgGCNotificationQueue| { &mut m.notifications },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCNotificationQueue>(
                "CMsgGCNotificationQueue",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCNotificationQueue {
        static instance: ::protobuf::rt::LazyV2<CMsgGCNotificationQueue> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCNotificationQueue::new)
    }
}

impl ::protobuf::Clear for CMsgGCNotificationQueue {
    fn clear(&mut self) {
        self.notifications.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCNotificationQueue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCNotificationQueue {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgNotificationAcknowledge {
    // message fields
    account_id: ::std::option::Option<u32>,
    notification_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgNotificationAcknowledge {
    fn default() -> &'a CMsgNotificationAcknowledge {
        <CMsgNotificationAcknowledge as ::protobuf::Message>::default_instance()
    }
}

impl CMsgNotificationAcknowledge {
    pub fn new() -> CMsgNotificationAcknowledge {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;


    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }
    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint64 notification_id = 2;


    pub fn get_notification_id(&self) -> u64 {
        self.notification_id.unwrap_or(0)
    }
    pub fn clear_notification_id(&mut self) {
        self.notification_id = ::std::option::Option::None;
    }

    pub fn has_notification_id(&self) -> bool {
        self.notification_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_notification_id(&mut self, v: u64) {
        self.notification_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgNotificationAcknowledge {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.notification_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.notification_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.notification_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgNotificationAcknowledge {
        CMsgNotificationAcknowledge::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "account_id",
                |m: &CMsgNotificationAcknowledge| { &m.account_id },
                |m: &mut CMsgNotificationAcknowledge| { &mut m.account_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "notification_id",
                |m: &CMsgNotificationAcknowledge| { &m.notification_id },
                |m: &mut CMsgNotificationAcknowledge| { &mut m.notification_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgNotificationAcknowledge>(
                "CMsgNotificationAcknowledge",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgNotificationAcknowledge {
        static instance: ::protobuf::rt::LazyV2<CMsgNotificationAcknowledge> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgNotificationAcknowledge::new)
    }
}

impl ::protobuf::Clear for CMsgNotificationAcknowledge {
    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.notification_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgNotificationAcknowledge {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgNotificationAcknowledge {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgNotificationAcknowledgeReply {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgNotificationAcknowledgeReply {
    fn default() -> &'a CMsgNotificationAcknowledgeReply {
        <CMsgNotificationAcknowledgeReply as ::protobuf::Message>::default_instance()
    }
}

impl CMsgNotificationAcknowledgeReply {
    pub fn new() -> CMsgNotificationAcknowledgeReply {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgNotificationAcknowledgeReply {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgNotificationAcknowledgeReply {
        CMsgNotificationAcknowledgeReply::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgNotificationAcknowledgeReply>(
                "CMsgNotificationAcknowledgeReply",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgNotificationAcknowledgeReply {
        static instance: ::protobuf::rt::LazyV2<CMsgNotificationAcknowledgeReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgNotificationAcknowledgeReply::new)
    }
}

impl ::protobuf::Clear for CMsgNotificationAcknowledgeReply {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgNotificationAcknowledgeReply {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgNotificationAcknowledgeReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGC_Match_Result {
    // message fields
    match_id: ::std::option::Option<u64>,
    match_group: ::std::option::Option<i32>,
    status: ::std::option::Option<CMsgGC_Match_Result_Status>,
    duration: ::std::option::Option<u32>,
    red_score: ::std::option::Option<u32>,
    blue_score: ::std::option::Option<u32>,
    winning_team: ::std::option::Option<u32>,
    map_index: ::std::option::Option<u32>,
    game_type: ::std::option::Option<u32>,
    pub players: ::protobuf::RepeatedField<CMsgGC_Match_Result_Player>,
    win_reason: ::std::option::Option<u32>,
    flags: ::std::option::Option<u32>,
    bots: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGC_Match_Result {
    fn default() -> &'a CMsgGC_Match_Result {
        <CMsgGC_Match_Result as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_Match_Result {
    pub fn new() -> CMsgGC_Match_Result {
        ::std::default::Default::default()
    }

    // optional uint64 match_id = 1;


    pub fn get_match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }
    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional int32 match_group = 2;


    pub fn get_match_group(&self) -> i32 {
        self.match_group.unwrap_or(0)
    }
    pub fn clear_match_group(&mut self) {
        self.match_group = ::std::option::Option::None;
    }

    pub fn has_match_group(&self) -> bool {
        self.match_group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_group(&mut self, v: i32) {
        self.match_group = ::std::option::Option::Some(v);
    }

    // optional .CMsgGC_Match_Result.Status status = 3;


    pub fn get_status(&self) -> CMsgGC_Match_Result_Status {
        self.status.unwrap_or(CMsgGC_Match_Result_Status::MATCH_SUCCEEDED)
    }
    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: CMsgGC_Match_Result_Status) {
        self.status = ::std::option::Option::Some(v);
    }

    // optional uint32 duration = 4;


    pub fn get_duration(&self) -> u32 {
        self.duration.unwrap_or(0)
    }
    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: u32) {
        self.duration = ::std::option::Option::Some(v);
    }

    // optional uint32 red_score = 5;


    pub fn get_red_score(&self) -> u32 {
        self.red_score.unwrap_or(0)
    }
    pub fn clear_red_score(&mut self) {
        self.red_score = ::std::option::Option::None;
    }

    pub fn has_red_score(&self) -> bool {
        self.red_score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_red_score(&mut self, v: u32) {
        self.red_score = ::std::option::Option::Some(v);
    }

    // optional uint32 blue_score = 6;


    pub fn get_blue_score(&self) -> u32 {
        self.blue_score.unwrap_or(0)
    }
    pub fn clear_blue_score(&mut self) {
        self.blue_score = ::std::option::Option::None;
    }

    pub fn has_blue_score(&self) -> bool {
        self.blue_score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blue_score(&mut self, v: u32) {
        self.blue_score = ::std::option::Option::Some(v);
    }

    // optional uint32 winning_team = 7;


    pub fn get_winning_team(&self) -> u32 {
        self.winning_team.unwrap_or(0)
    }
    pub fn clear_winning_team(&mut self) {
        self.winning_team = ::std::option::Option::None;
    }

    pub fn has_winning_team(&self) -> bool {
        self.winning_team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_winning_team(&mut self, v: u32) {
        self.winning_team = ::std::option::Option::Some(v);
    }

    // optional uint32 map_index = 8;


    pub fn get_map_index(&self) -> u32 {
        self.map_index.unwrap_or(0)
    }
    pub fn clear_map_index(&mut self) {
        self.map_index = ::std::option::Option::None;
    }

    pub fn has_map_index(&self) -> bool {
        self.map_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map_index(&mut self, v: u32) {
        self.map_index = ::std::option::Option::Some(v);
    }

    // optional uint32 game_type = 9;


    pub fn get_game_type(&self) -> u32 {
        self.game_type.unwrap_or(0u32)
    }
    pub fn clear_game_type(&mut self) {
        self.game_type = ::std::option::Option::None;
    }

    pub fn has_game_type(&self) -> bool {
        self.game_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_type(&mut self, v: u32) {
        self.game_type = ::std::option::Option::Some(v);
    }

    // repeated .CMsgGC_Match_Result.Player players = 10;


    pub fn get_players(&self) -> &[CMsgGC_Match_Result_Player] {
        &self.players
    }
    pub fn clear_players(&mut self) {
        self.players.clear();
    }

    // Param is passed by value, moved
    pub fn set_players(&mut self, v: ::protobuf::RepeatedField<CMsgGC_Match_Result_Player>) {
        self.players = v;
    }

    // Mutable pointer to the field.
    pub fn mut_players(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGC_Match_Result_Player> {
        &mut self.players
    }

    // Take field
    pub fn take_players(&mut self) -> ::protobuf::RepeatedField<CMsgGC_Match_Result_Player> {
        ::std::mem::replace(&mut self.players, ::protobuf::RepeatedField::new())
    }

    // optional uint32 win_reason = 13;


    pub fn get_win_reason(&self) -> u32 {
        self.win_reason.unwrap_or(0)
    }
    pub fn clear_win_reason(&mut self) {
        self.win_reason = ::std::option::Option::None;
    }

    pub fn has_win_reason(&self) -> bool {
        self.win_reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_win_reason(&mut self, v: u32) {
        self.win_reason = ::std::option::Option::Some(v);
    }

    // optional uint32 flags = 14;


    pub fn get_flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }
    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional uint32 bots = 16;


    pub fn get_bots(&self) -> u32 {
        self.bots.unwrap_or(0)
    }
    pub fn clear_bots(&mut self) {
        self.bots = ::std::option::Option::None;
    }

    pub fn has_bots(&self) -> bool {
        self.bots.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bots(&mut self, v: u32) {
        self.bots = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGC_Match_Result {
    fn is_initialized(&self) -> bool {
        for v in &self.players {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.match_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.match_group = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.status, 3, &mut self.unknown_fields)?
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.duration = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.red_score = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.blue_score = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.winning_team = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.map_index = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.game_type = ::std::option::Option::Some(tmp);
                },
                10 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.players)?;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.win_reason = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.flags = ::std::option::Option::Some(tmp);
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.bots = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.match_group {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::enum_size(3, v);
        }
        if let Some(v) = self.duration {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.red_score {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.blue_score {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.winning_team {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.map_index {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.game_type {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.players {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.win_reason {
            my_size += ::protobuf::rt::value_size(13, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.bots {
            my_size += ::protobuf::rt::value_size(16, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.match_group {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.status {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.duration {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.red_score {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.blue_score {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.winning_team {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.map_index {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.game_type {
            os.write_uint32(9, v)?;
        }
        for v in &self.players {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.win_reason {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.flags {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.bots {
            os.write_uint32(16, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGC_Match_Result {
        CMsgGC_Match_Result::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "match_id",
                |m: &CMsgGC_Match_Result| { &m.match_id },
                |m: &mut CMsgGC_Match_Result| { &mut m.match_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "match_group",
                |m: &CMsgGC_Match_Result| { &m.match_group },
                |m: &mut CMsgGC_Match_Result| { &mut m.match_group },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CMsgGC_Match_Result_Status>>(
                "status",
                |m: &CMsgGC_Match_Result| { &m.status },
                |m: &mut CMsgGC_Match_Result| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "duration",
                |m: &CMsgGC_Match_Result| { &m.duration },
                |m: &mut CMsgGC_Match_Result| { &mut m.duration },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "red_score",
                |m: &CMsgGC_Match_Result| { &m.red_score },
                |m: &mut CMsgGC_Match_Result| { &mut m.red_score },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "blue_score",
                |m: &CMsgGC_Match_Result| { &m.blue_score },
                |m: &mut CMsgGC_Match_Result| { &mut m.blue_score },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "winning_team",
                |m: &CMsgGC_Match_Result| { &m.winning_team },
                |m: &mut CMsgGC_Match_Result| { &mut m.winning_team },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "map_index",
                |m: &CMsgGC_Match_Result| { &m.map_index },
                |m: &mut CMsgGC_Match_Result| { &mut m.map_index },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "game_type",
                |m: &CMsgGC_Match_Result| { &m.game_type },
                |m: &mut CMsgGC_Match_Result| { &mut m.game_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGC_Match_Result_Player>>(
                "players",
                |m: &CMsgGC_Match_Result| { &m.players },
                |m: &mut CMsgGC_Match_Result| { &mut m.players },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "win_reason",
                |m: &CMsgGC_Match_Result| { &m.win_reason },
                |m: &mut CMsgGC_Match_Result| { &mut m.win_reason },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "flags",
                |m: &CMsgGC_Match_Result| { &m.flags },
                |m: &mut CMsgGC_Match_Result| { &mut m.flags },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "bots",
                |m: &CMsgGC_Match_Result| { &m.bots },
                |m: &mut CMsgGC_Match_Result| { &mut m.bots },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGC_Match_Result>(
                "CMsgGC_Match_Result",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGC_Match_Result {
        static instance: ::protobuf::rt::LazyV2<CMsgGC_Match_Result> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGC_Match_Result::new)
    }
}

impl ::protobuf::Clear for CMsgGC_Match_Result {
    fn clear(&mut self) {
        self.match_id = ::std::option::Option::None;
        self.match_group = ::std::option::Option::None;
        self.status = ::std::option::Option::None;
        self.duration = ::std::option::Option::None;
        self.red_score = ::std::option::Option::None;
        self.blue_score = ::std::option::Option::None;
        self.winning_team = ::std::option::Option::None;
        self.map_index = ::std::option::Option::None;
        self.game_type = ::std::option::Option::None;
        self.players.clear();
        self.win_reason = ::std::option::Option::None;
        self.flags = ::std::option::Option::None;
        self.bots = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGC_Match_Result {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGC_Match_Result {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGC_Match_Result_Player {
    // message fields
    steam_id: ::std::option::Option<u64>,
    original_party_id: ::std::option::Option<u64>,
    team: ::std::option::Option<u32>,
    score: ::std::option::Option<u32>,
    ping: ::std::option::Option<u32>,
    flags: ::std::option::Option<u32>,
    rank: ::std::option::Option<u32>,
    classes_played: ::std::option::Option<u32>,
    kills: ::std::option::Option<u32>,
    deaths: ::std::option::Option<u32>,
    damage: ::std::option::Option<u32>,
    healing: ::std::option::Option<u32>,
    support: ::std::option::Option<u32>,
    score_medal: ::std::option::Option<u32>,
    kills_medal: ::std::option::Option<u32>,
    damage_medal: ::std::option::Option<u32>,
    healing_medal: ::std::option::Option<u32>,
    support_medal: ::std::option::Option<u32>,
    pub xp_breakdown: ::protobuf::RepeatedField<CMsgTFXPSource>,
    leave_time: ::std::option::Option<u32>,
    leave_reason: ::std::option::Option<TFMatchLeaveReason>,
    connect_time: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGC_Match_Result_Player {
    fn default() -> &'a CMsgGC_Match_Result_Player {
        <CMsgGC_Match_Result_Player as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_Match_Result_Player {
    pub fn new() -> CMsgGC_Match_Result_Player {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id = 1;


    pub fn get_steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }
    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }

    // optional uint64 original_party_id = 2;


    pub fn get_original_party_id(&self) -> u64 {
        self.original_party_id.unwrap_or(0)
    }
    pub fn clear_original_party_id(&mut self) {
        self.original_party_id = ::std::option::Option::None;
    }

    pub fn has_original_party_id(&self) -> bool {
        self.original_party_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_original_party_id(&mut self, v: u64) {
        self.original_party_id = ::std::option::Option::Some(v);
    }

    // optional uint32 team = 3;


    pub fn get_team(&self) -> u32 {
        self.team.unwrap_or(0)
    }
    pub fn clear_team(&mut self) {
        self.team = ::std::option::Option::None;
    }

    pub fn has_team(&self) -> bool {
        self.team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team(&mut self, v: u32) {
        self.team = ::std::option::Option::Some(v);
    }

    // optional uint32 score = 4;


    pub fn get_score(&self) -> u32 {
        self.score.unwrap_or(0)
    }
    pub fn clear_score(&mut self) {
        self.score = ::std::option::Option::None;
    }

    pub fn has_score(&self) -> bool {
        self.score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_score(&mut self, v: u32) {
        self.score = ::std::option::Option::Some(v);
    }

    // optional uint32 ping = 5;


    pub fn get_ping(&self) -> u32 {
        self.ping.unwrap_or(0)
    }
    pub fn clear_ping(&mut self) {
        self.ping = ::std::option::Option::None;
    }

    pub fn has_ping(&self) -> bool {
        self.ping.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping(&mut self, v: u32) {
        self.ping = ::std::option::Option::Some(v);
    }

    // optional uint32 flags = 6;


    pub fn get_flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }
    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional uint32 rank = 9;


    pub fn get_rank(&self) -> u32 {
        self.rank.unwrap_or(0)
    }
    pub fn clear_rank(&mut self) {
        self.rank = ::std::option::Option::None;
    }

    pub fn has_rank(&self) -> bool {
        self.rank.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rank(&mut self, v: u32) {
        self.rank = ::std::option::Option::Some(v);
    }

    // optional uint32 classes_played = 10;


    pub fn get_classes_played(&self) -> u32 {
        self.classes_played.unwrap_or(0)
    }
    pub fn clear_classes_played(&mut self) {
        self.classes_played = ::std::option::Option::None;
    }

    pub fn has_classes_played(&self) -> bool {
        self.classes_played.is_some()
    }

    // Param is passed by value, moved
    pub fn set_classes_played(&mut self, v: u32) {
        self.classes_played = ::std::option::Option::Some(v);
    }

    // optional uint32 kills = 11;


    pub fn get_kills(&self) -> u32 {
        self.kills.unwrap_or(0)
    }
    pub fn clear_kills(&mut self) {
        self.kills = ::std::option::Option::None;
    }

    pub fn has_kills(&self) -> bool {
        self.kills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kills(&mut self, v: u32) {
        self.kills = ::std::option::Option::Some(v);
    }

    // optional uint32 deaths = 12;


    pub fn get_deaths(&self) -> u32 {
        self.deaths.unwrap_or(0)
    }
    pub fn clear_deaths(&mut self) {
        self.deaths = ::std::option::Option::None;
    }

    pub fn has_deaths(&self) -> bool {
        self.deaths.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deaths(&mut self, v: u32) {
        self.deaths = ::std::option::Option::Some(v);
    }

    // optional uint32 damage = 13;


    pub fn get_damage(&self) -> u32 {
        self.damage.unwrap_or(0)
    }
    pub fn clear_damage(&mut self) {
        self.damage = ::std::option::Option::None;
    }

    pub fn has_damage(&self) -> bool {
        self.damage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_damage(&mut self, v: u32) {
        self.damage = ::std::option::Option::Some(v);
    }

    // optional uint32 healing = 14;


    pub fn get_healing(&self) -> u32 {
        self.healing.unwrap_or(0)
    }
    pub fn clear_healing(&mut self) {
        self.healing = ::std::option::Option::None;
    }

    pub fn has_healing(&self) -> bool {
        self.healing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_healing(&mut self, v: u32) {
        self.healing = ::std::option::Option::Some(v);
    }

    // optional uint32 support = 15;


    pub fn get_support(&self) -> u32 {
        self.support.unwrap_or(0)
    }
    pub fn clear_support(&mut self) {
        self.support = ::std::option::Option::None;
    }

    pub fn has_support(&self) -> bool {
        self.support.is_some()
    }

    // Param is passed by value, moved
    pub fn set_support(&mut self, v: u32) {
        self.support = ::std::option::Option::Some(v);
    }

    // optional uint32 score_medal = 16;


    pub fn get_score_medal(&self) -> u32 {
        self.score_medal.unwrap_or(0)
    }
    pub fn clear_score_medal(&mut self) {
        self.score_medal = ::std::option::Option::None;
    }

    pub fn has_score_medal(&self) -> bool {
        self.score_medal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_score_medal(&mut self, v: u32) {
        self.score_medal = ::std::option::Option::Some(v);
    }

    // optional uint32 kills_medal = 17;


    pub fn get_kills_medal(&self) -> u32 {
        self.kills_medal.unwrap_or(0)
    }
    pub fn clear_kills_medal(&mut self) {
        self.kills_medal = ::std::option::Option::None;
    }

    pub fn has_kills_medal(&self) -> bool {
        self.kills_medal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kills_medal(&mut self, v: u32) {
        self.kills_medal = ::std::option::Option::Some(v);
    }

    // optional uint32 damage_medal = 18;


    pub fn get_damage_medal(&self) -> u32 {
        self.damage_medal.unwrap_or(0)
    }
    pub fn clear_damage_medal(&mut self) {
        self.damage_medal = ::std::option::Option::None;
    }

    pub fn has_damage_medal(&self) -> bool {
        self.damage_medal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_damage_medal(&mut self, v: u32) {
        self.damage_medal = ::std::option::Option::Some(v);
    }

    // optional uint32 healing_medal = 19;


    pub fn get_healing_medal(&self) -> u32 {
        self.healing_medal.unwrap_or(0)
    }
    pub fn clear_healing_medal(&mut self) {
        self.healing_medal = ::std::option::Option::None;
    }

    pub fn has_healing_medal(&self) -> bool {
        self.healing_medal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_healing_medal(&mut self, v: u32) {
        self.healing_medal = ::std::option::Option::Some(v);
    }

    // optional uint32 support_medal = 20;


    pub fn get_support_medal(&self) -> u32 {
        self.support_medal.unwrap_or(0)
    }
    pub fn clear_support_medal(&mut self) {
        self.support_medal = ::std::option::Option::None;
    }

    pub fn has_support_medal(&self) -> bool {
        self.support_medal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_support_medal(&mut self, v: u32) {
        self.support_medal = ::std::option::Option::Some(v);
    }

    // repeated .CMsgTFXPSource xp_breakdown = 21;


    pub fn get_xp_breakdown(&self) -> &[CMsgTFXPSource] {
        &self.xp_breakdown
    }
    pub fn clear_xp_breakdown(&mut self) {
        self.xp_breakdown.clear();
    }

    // Param is passed by value, moved
    pub fn set_xp_breakdown(&mut self, v: ::protobuf::RepeatedField<CMsgTFXPSource>) {
        self.xp_breakdown = v;
    }

    // Mutable pointer to the field.
    pub fn mut_xp_breakdown(&mut self) -> &mut ::protobuf::RepeatedField<CMsgTFXPSource> {
        &mut self.xp_breakdown
    }

    // Take field
    pub fn take_xp_breakdown(&mut self) -> ::protobuf::RepeatedField<CMsgTFXPSource> {
        ::std::mem::replace(&mut self.xp_breakdown, ::protobuf::RepeatedField::new())
    }

    // optional uint32 leave_time = 22;


    pub fn get_leave_time(&self) -> u32 {
        self.leave_time.unwrap_or(0)
    }
    pub fn clear_leave_time(&mut self) {
        self.leave_time = ::std::option::Option::None;
    }

    pub fn has_leave_time(&self) -> bool {
        self.leave_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leave_time(&mut self, v: u32) {
        self.leave_time = ::std::option::Option::Some(v);
    }

    // optional .TFMatchLeaveReason leave_reason = 23;


    pub fn get_leave_reason(&self) -> TFMatchLeaveReason {
        self.leave_reason.unwrap_or(TFMatchLeaveReason::TFMatchLeaveReason_UNSPECIFIED)
    }
    pub fn clear_leave_reason(&mut self) {
        self.leave_reason = ::std::option::Option::None;
    }

    pub fn has_leave_reason(&self) -> bool {
        self.leave_reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leave_reason(&mut self, v: TFMatchLeaveReason) {
        self.leave_reason = ::std::option::Option::Some(v);
    }

    // optional uint32 connect_time = 24;


    pub fn get_connect_time(&self) -> u32 {
        self.connect_time.unwrap_or(0)
    }
    pub fn clear_connect_time(&mut self) {
        self.connect_time = ::std::option::Option::None;
    }

    pub fn has_connect_time(&self) -> bool {
        self.connect_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connect_time(&mut self, v: u32) {
        self.connect_time = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGC_Match_Result_Player {
    fn is_initialized(&self) -> bool {
        for v in &self.xp_breakdown {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steam_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.original_party_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.team = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.score = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ping = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.flags = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rank = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.classes_played = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.kills = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.deaths = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.damage = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.healing = ::std::option::Option::Some(tmp);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.support = ::std::option::Option::Some(tmp);
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.score_medal = ::std::option::Option::Some(tmp);
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.kills_medal = ::std::option::Option::Some(tmp);
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.damage_medal = ::std::option::Option::Some(tmp);
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.healing_medal = ::std::option::Option::Some(tmp);
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.support_medal = ::std::option::Option::Some(tmp);
                },
                21 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.xp_breakdown)?;
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.leave_time = ::std::option::Option::Some(tmp);
                },
                23 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.leave_reason, 23, &mut self.unknown_fields)?
                },
                24 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.connect_time = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id {
            my_size += 9;
        }
        if let Some(v) = self.original_party_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.team {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.score {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ping {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rank {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.classes_played {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.kills {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.deaths {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.damage {
            my_size += ::protobuf::rt::value_size(13, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.healing {
            my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.support {
            my_size += ::protobuf::rt::value_size(15, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.score_medal {
            my_size += ::protobuf::rt::value_size(16, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.kills_medal {
            my_size += ::protobuf::rt::value_size(17, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.damage_medal {
            my_size += ::protobuf::rt::value_size(18, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.healing_medal {
            my_size += ::protobuf::rt::value_size(19, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.support_medal {
            my_size += ::protobuf::rt::value_size(20, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.xp_breakdown {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.leave_time {
            my_size += ::protobuf::rt::value_size(22, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.leave_reason {
            my_size += ::protobuf::rt::enum_size(23, v);
        }
        if let Some(v) = self.connect_time {
            my_size += ::protobuf::rt::value_size(24, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steam_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.original_party_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.team {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.score {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.ping {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.flags {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.rank {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.classes_played {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.kills {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.deaths {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.damage {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.healing {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.support {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.score_medal {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.kills_medal {
            os.write_uint32(17, v)?;
        }
        if let Some(v) = self.damage_medal {
            os.write_uint32(18, v)?;
        }
        if let Some(v) = self.healing_medal {
            os.write_uint32(19, v)?;
        }
        if let Some(v) = self.support_medal {
            os.write_uint32(20, v)?;
        }
        for v in &self.xp_breakdown {
            os.write_tag(21, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.leave_time {
            os.write_uint32(22, v)?;
        }
        if let Some(v) = self.leave_reason {
            os.write_enum(23, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.connect_time {
            os.write_uint32(24, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGC_Match_Result_Player {
        CMsgGC_Match_Result_Player::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steam_id",
                |m: &CMsgGC_Match_Result_Player| { &m.steam_id },
                |m: &mut CMsgGC_Match_Result_Player| { &mut m.steam_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "original_party_id",
                |m: &CMsgGC_Match_Result_Player| { &m.original_party_id },
                |m: &mut CMsgGC_Match_Result_Player| { &mut m.original_party_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "team",
                |m: &CMsgGC_Match_Result_Player| { &m.team },
                |m: &mut CMsgGC_Match_Result_Player| { &mut m.team },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "score",
                |m: &CMsgGC_Match_Result_Player| { &m.score },
                |m: &mut CMsgGC_Match_Result_Player| { &mut m.score },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ping",
                |m: &CMsgGC_Match_Result_Player| { &m.ping },
                |m: &mut CMsgGC_Match_Result_Player| { &mut m.ping },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "flags",
                |m: &CMsgGC_Match_Result_Player| { &m.flags },
                |m: &mut CMsgGC_Match_Result_Player| { &mut m.flags },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "rank",
                |m: &CMsgGC_Match_Result_Player| { &m.rank },
                |m: &mut CMsgGC_Match_Result_Player| { &mut m.rank },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "classes_played",
                |m: &CMsgGC_Match_Result_Player| { &m.classes_played },
                |m: &mut CMsgGC_Match_Result_Player| { &mut m.classes_played },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "kills",
                |m: &CMsgGC_Match_Result_Player| { &m.kills },
                |m: &mut CMsgGC_Match_Result_Player| { &mut m.kills },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "deaths",
                |m: &CMsgGC_Match_Result_Player| { &m.deaths },
                |m: &mut CMsgGC_Match_Result_Player| { &mut m.deaths },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "damage",
                |m: &CMsgGC_Match_Result_Player| { &m.damage },
                |m: &mut CMsgGC_Match_Result_Player| { &mut m.damage },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "healing",
                |m: &CMsgGC_Match_Result_Player| { &m.healing },
                |m: &mut CMsgGC_Match_Result_Player| { &mut m.healing },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "support",
                |m: &CMsgGC_Match_Result_Player| { &m.support },
                |m: &mut CMsgGC_Match_Result_Player| { &mut m.support },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "score_medal",
                |m: &CMsgGC_Match_Result_Player| { &m.score_medal },
                |m: &mut CMsgGC_Match_Result_Player| { &mut m.score_medal },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "kills_medal",
                |m: &CMsgGC_Match_Result_Player| { &m.kills_medal },
                |m: &mut CMsgGC_Match_Result_Player| { &mut m.kills_medal },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "damage_medal",
                |m: &CMsgGC_Match_Result_Player| { &m.damage_medal },
                |m: &mut CMsgGC_Match_Result_Player| { &mut m.damage_medal },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "healing_medal",
                |m: &CMsgGC_Match_Result_Player| { &m.healing_medal },
                |m: &mut CMsgGC_Match_Result_Player| { &mut m.healing_medal },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "support_medal",
                |m: &CMsgGC_Match_Result_Player| { &m.support_medal },
                |m: &mut CMsgGC_Match_Result_Player| { &mut m.support_medal },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgTFXPSource>>(
                "xp_breakdown",
                |m: &CMsgGC_Match_Result_Player| { &m.xp_breakdown },
                |m: &mut CMsgGC_Match_Result_Player| { &mut m.xp_breakdown },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "leave_time",
                |m: &CMsgGC_Match_Result_Player| { &m.leave_time },
                |m: &mut CMsgGC_Match_Result_Player| { &mut m.leave_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TFMatchLeaveReason>>(
                "leave_reason",
                |m: &CMsgGC_Match_Result_Player| { &m.leave_reason },
                |m: &mut CMsgGC_Match_Result_Player| { &mut m.leave_reason },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "connect_time",
                |m: &CMsgGC_Match_Result_Player| { &m.connect_time },
                |m: &mut CMsgGC_Match_Result_Player| { &mut m.connect_time },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGC_Match_Result_Player>(
                "CMsgGC_Match_Result.Player",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGC_Match_Result_Player {
        static instance: ::protobuf::rt::LazyV2<CMsgGC_Match_Result_Player> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGC_Match_Result_Player::new)
    }
}

impl ::protobuf::Clear for CMsgGC_Match_Result_Player {
    fn clear(&mut self) {
        self.steam_id = ::std::option::Option::None;
        self.original_party_id = ::std::option::Option::None;
        self.team = ::std::option::Option::None;
        self.score = ::std::option::Option::None;
        self.ping = ::std::option::Option::None;
        self.flags = ::std::option::Option::None;
        self.rank = ::std::option::Option::None;
        self.classes_played = ::std::option::Option::None;
        self.kills = ::std::option::Option::None;
        self.deaths = ::std::option::Option::None;
        self.damage = ::std::option::Option::None;
        self.healing = ::std::option::Option::None;
        self.support = ::std::option::Option::None;
        self.score_medal = ::std::option::Option::None;
        self.kills_medal = ::std::option::Option::None;
        self.damage_medal = ::std::option::Option::None;
        self.healing_medal = ::std::option::Option::None;
        self.support_medal = ::std::option::Option::None;
        self.xp_breakdown.clear();
        self.leave_time = ::std::option::Option::None;
        self.leave_reason = ::std::option::Option::None;
        self.connect_time = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGC_Match_Result_Player {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGC_Match_Result_Player {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgGC_Match_Result_Status {
    MATCH_SUCCEEDED = 0,
    MATCH_FAILED_GC = 1,
    MATCH_FAILED_TRUSTED = 2,
    MATCH_FAILED_ABANDON = 3,
    MATCH_FAILED_UNKNOWN = 5,
    MATCH_FAILED_TIMEOUT = 6,
    MATCH_FINISHED_ABANDON = 7,
}

impl ::protobuf::ProtobufEnum for CMsgGC_Match_Result_Status {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgGC_Match_Result_Status> {
        match value {
            0 => ::std::option::Option::Some(CMsgGC_Match_Result_Status::MATCH_SUCCEEDED),
            1 => ::std::option::Option::Some(CMsgGC_Match_Result_Status::MATCH_FAILED_GC),
            2 => ::std::option::Option::Some(CMsgGC_Match_Result_Status::MATCH_FAILED_TRUSTED),
            3 => ::std::option::Option::Some(CMsgGC_Match_Result_Status::MATCH_FAILED_ABANDON),
            5 => ::std::option::Option::Some(CMsgGC_Match_Result_Status::MATCH_FAILED_UNKNOWN),
            6 => ::std::option::Option::Some(CMsgGC_Match_Result_Status::MATCH_FAILED_TIMEOUT),
            7 => ::std::option::Option::Some(CMsgGC_Match_Result_Status::MATCH_FINISHED_ABANDON),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgGC_Match_Result_Status] = &[
            CMsgGC_Match_Result_Status::MATCH_SUCCEEDED,
            CMsgGC_Match_Result_Status::MATCH_FAILED_GC,
            CMsgGC_Match_Result_Status::MATCH_FAILED_TRUSTED,
            CMsgGC_Match_Result_Status::MATCH_FAILED_ABANDON,
            CMsgGC_Match_Result_Status::MATCH_FAILED_UNKNOWN,
            CMsgGC_Match_Result_Status::MATCH_FAILED_TIMEOUT,
            CMsgGC_Match_Result_Status::MATCH_FINISHED_ABANDON,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<CMsgGC_Match_Result_Status>("CMsgGC_Match_Result.Status", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for CMsgGC_Match_Result_Status {
}

impl ::std::default::Default for CMsgGC_Match_Result_Status {
    fn default() -> Self {
        CMsgGC_Match_Result_Status::MATCH_SUCCEEDED
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGC_Match_Result_Status {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGC_Match_ResultResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGC_Match_ResultResponse {
    fn default() -> &'a CMsgGC_Match_ResultResponse {
        <CMsgGC_Match_ResultResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_Match_ResultResponse {
    pub fn new() -> CMsgGC_Match_ResultResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgGC_Match_ResultResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGC_Match_ResultResponse {
        CMsgGC_Match_ResultResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGC_Match_ResultResponse>(
                "CMsgGC_Match_ResultResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGC_Match_ResultResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgGC_Match_ResultResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGC_Match_ResultResponse::new)
    }
}

impl ::protobuf::Clear for CMsgGC_Match_ResultResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGC_Match_ResultResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGC_Match_ResultResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CEconItemPreviewDataBlock {
    // message fields
    pub econitem: ::protobuf::SingularPtrField<super::base_gcmessages::CSOEconItem>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CEconItemPreviewDataBlock {
    fn default() -> &'a CEconItemPreviewDataBlock {
        <CEconItemPreviewDataBlock as ::protobuf::Message>::default_instance()
    }
}

impl CEconItemPreviewDataBlock {
    pub fn new() -> CEconItemPreviewDataBlock {
        ::std::default::Default::default()
    }

    // optional .CSOEconItem econitem = 1;


    pub fn get_econitem(&self) -> &super::base_gcmessages::CSOEconItem {
        self.econitem.as_ref().unwrap_or_else(|| <super::base_gcmessages::CSOEconItem as ::protobuf::Message>::default_instance())
    }
    pub fn clear_econitem(&mut self) {
        self.econitem.clear();
    }

    pub fn has_econitem(&self) -> bool {
        self.econitem.is_some()
    }

    // Param is passed by value, moved
    pub fn set_econitem(&mut self, v: super::base_gcmessages::CSOEconItem) {
        self.econitem = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_econitem(&mut self) -> &mut super::base_gcmessages::CSOEconItem {
        if self.econitem.is_none() {
            self.econitem.set_default();
        }
        self.econitem.as_mut().unwrap()
    }

    // Take field
    pub fn take_econitem(&mut self) -> super::base_gcmessages::CSOEconItem {
        self.econitem.take().unwrap_or_else(|| super::base_gcmessages::CSOEconItem::new())
    }
}

impl ::protobuf::Message for CEconItemPreviewDataBlock {
    fn is_initialized(&self) -> bool {
        for v in &self.econitem {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.econitem)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.econitem.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.econitem.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CEconItemPreviewDataBlock {
        CEconItemPreviewDataBlock::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::base_gcmessages::CSOEconItem>>(
                "econitem",
                |m: &CEconItemPreviewDataBlock| { &m.econitem },
                |m: &mut CEconItemPreviewDataBlock| { &mut m.econitem },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CEconItemPreviewDataBlock>(
                "CEconItemPreviewDataBlock",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CEconItemPreviewDataBlock {
        static instance: ::protobuf::rt::LazyV2<CEconItemPreviewDataBlock> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CEconItemPreviewDataBlock::new)
    }
}

impl ::protobuf::Clear for CEconItemPreviewDataBlock {
    fn clear(&mut self) {
        self.econitem.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CEconItemPreviewDataBlock {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CEconItemPreviewDataBlock {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGC_Client2GCEconPreviewDataBlockRequest {
    // message fields
    param_s: ::std::option::Option<u64>,
    param_a: ::std::option::Option<u64>,
    param_d: ::std::option::Option<u64>,
    param_m: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGC_Client2GCEconPreviewDataBlockRequest {
    fn default() -> &'a CMsgGC_Client2GCEconPreviewDataBlockRequest {
        <CMsgGC_Client2GCEconPreviewDataBlockRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_Client2GCEconPreviewDataBlockRequest {
    pub fn new() -> CMsgGC_Client2GCEconPreviewDataBlockRequest {
        ::std::default::Default::default()
    }

    // optional uint64 param_s = 1;


    pub fn get_param_s(&self) -> u64 {
        self.param_s.unwrap_or(0)
    }
    pub fn clear_param_s(&mut self) {
        self.param_s = ::std::option::Option::None;
    }

    pub fn has_param_s(&self) -> bool {
        self.param_s.is_some()
    }

    // Param is passed by value, moved
    pub fn set_param_s(&mut self, v: u64) {
        self.param_s = ::std::option::Option::Some(v);
    }

    // optional uint64 param_a = 2;


    pub fn get_param_a(&self) -> u64 {
        self.param_a.unwrap_or(0)
    }
    pub fn clear_param_a(&mut self) {
        self.param_a = ::std::option::Option::None;
    }

    pub fn has_param_a(&self) -> bool {
        self.param_a.is_some()
    }

    // Param is passed by value, moved
    pub fn set_param_a(&mut self, v: u64) {
        self.param_a = ::std::option::Option::Some(v);
    }

    // optional uint64 param_d = 3;


    pub fn get_param_d(&self) -> u64 {
        self.param_d.unwrap_or(0)
    }
    pub fn clear_param_d(&mut self) {
        self.param_d = ::std::option::Option::None;
    }

    pub fn has_param_d(&self) -> bool {
        self.param_d.is_some()
    }

    // Param is passed by value, moved
    pub fn set_param_d(&mut self, v: u64) {
        self.param_d = ::std::option::Option::Some(v);
    }

    // optional uint64 param_m = 4;


    pub fn get_param_m(&self) -> u64 {
        self.param_m.unwrap_or(0)
    }
    pub fn clear_param_m(&mut self) {
        self.param_m = ::std::option::Option::None;
    }

    pub fn has_param_m(&self) -> bool {
        self.param_m.is_some()
    }

    // Param is passed by value, moved
    pub fn set_param_m(&mut self, v: u64) {
        self.param_m = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGC_Client2GCEconPreviewDataBlockRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.param_s = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.param_a = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.param_d = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.param_m = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.param_s {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.param_a {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.param_d {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.param_m {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.param_s {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.param_a {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.param_d {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.param_m {
            os.write_uint64(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGC_Client2GCEconPreviewDataBlockRequest {
        CMsgGC_Client2GCEconPreviewDataBlockRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "param_s",
                |m: &CMsgGC_Client2GCEconPreviewDataBlockRequest| { &m.param_s },
                |m: &mut CMsgGC_Client2GCEconPreviewDataBlockRequest| { &mut m.param_s },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "param_a",
                |m: &CMsgGC_Client2GCEconPreviewDataBlockRequest| { &m.param_a },
                |m: &mut CMsgGC_Client2GCEconPreviewDataBlockRequest| { &mut m.param_a },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "param_d",
                |m: &CMsgGC_Client2GCEconPreviewDataBlockRequest| { &m.param_d },
                |m: &mut CMsgGC_Client2GCEconPreviewDataBlockRequest| { &mut m.param_d },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "param_m",
                |m: &CMsgGC_Client2GCEconPreviewDataBlockRequest| { &m.param_m },
                |m: &mut CMsgGC_Client2GCEconPreviewDataBlockRequest| { &mut m.param_m },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGC_Client2GCEconPreviewDataBlockRequest>(
                "CMsgGC_Client2GCEconPreviewDataBlockRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGC_Client2GCEconPreviewDataBlockRequest {
        static instance: ::protobuf::rt::LazyV2<CMsgGC_Client2GCEconPreviewDataBlockRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGC_Client2GCEconPreviewDataBlockRequest::new)
    }
}

impl ::protobuf::Clear for CMsgGC_Client2GCEconPreviewDataBlockRequest {
    fn clear(&mut self) {
        self.param_s = ::std::option::Option::None;
        self.param_a = ::std::option::Option::None;
        self.param_d = ::std::option::Option::None;
        self.param_m = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGC_Client2GCEconPreviewDataBlockRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGC_Client2GCEconPreviewDataBlockRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGC_Client2GCEconPreviewDataBlockResponse {
    // message fields
    pub iteminfo: ::protobuf::SingularPtrField<CEconItemPreviewDataBlock>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGC_Client2GCEconPreviewDataBlockResponse {
    fn default() -> &'a CMsgGC_Client2GCEconPreviewDataBlockResponse {
        <CMsgGC_Client2GCEconPreviewDataBlockResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_Client2GCEconPreviewDataBlockResponse {
    pub fn new() -> CMsgGC_Client2GCEconPreviewDataBlockResponse {
        ::std::default::Default::default()
    }

    // optional .CEconItemPreviewDataBlock iteminfo = 1;


    pub fn get_iteminfo(&self) -> &CEconItemPreviewDataBlock {
        self.iteminfo.as_ref().unwrap_or_else(|| <CEconItemPreviewDataBlock as ::protobuf::Message>::default_instance())
    }
    pub fn clear_iteminfo(&mut self) {
        self.iteminfo.clear();
    }

    pub fn has_iteminfo(&self) -> bool {
        self.iteminfo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_iteminfo(&mut self, v: CEconItemPreviewDataBlock) {
        self.iteminfo = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_iteminfo(&mut self) -> &mut CEconItemPreviewDataBlock {
        if self.iteminfo.is_none() {
            self.iteminfo.set_default();
        }
        self.iteminfo.as_mut().unwrap()
    }

    // Take field
    pub fn take_iteminfo(&mut self) -> CEconItemPreviewDataBlock {
        self.iteminfo.take().unwrap_or_else(|| CEconItemPreviewDataBlock::new())
    }
}

impl ::protobuf::Message for CMsgGC_Client2GCEconPreviewDataBlockResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.iteminfo {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.iteminfo)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.iteminfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.iteminfo.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGC_Client2GCEconPreviewDataBlockResponse {
        CMsgGC_Client2GCEconPreviewDataBlockResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CEconItemPreviewDataBlock>>(
                "iteminfo",
                |m: &CMsgGC_Client2GCEconPreviewDataBlockResponse| { &m.iteminfo },
                |m: &mut CMsgGC_Client2GCEconPreviewDataBlockResponse| { &mut m.iteminfo },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGC_Client2GCEconPreviewDataBlockResponse>(
                "CMsgGC_Client2GCEconPreviewDataBlockResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGC_Client2GCEconPreviewDataBlockResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgGC_Client2GCEconPreviewDataBlockResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGC_Client2GCEconPreviewDataBlockResponse::new)
    }
}

impl ::protobuf::Clear for CMsgGC_Client2GCEconPreviewDataBlockResponse {
    fn clear(&mut self) {
        self.iteminfo.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGC_Client2GCEconPreviewDataBlockResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGC_Client2GCEconPreviewDataBlockResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CSOTFLadderPlayerStats {
    // message fields
    account_id: ::std::option::Option<u32>,
    match_group: ::std::option::Option<i32>,
    season_id: ::std::option::Option<u32>,
    games: ::std::option::Option<u32>,
    score: ::std::option::Option<u32>,
    kills: ::std::option::Option<u32>,
    deaths: ::std::option::Option<u32>,
    damage: ::std::option::Option<u32>,
    healing: ::std::option::Option<u32>,
    support: ::std::option::Option<u32>,
    score_bronze: ::std::option::Option<u32>,
    score_silver: ::std::option::Option<u32>,
    score_gold: ::std::option::Option<u32>,
    kills_bronze: ::std::option::Option<u32>,
    kills_silver: ::std::option::Option<u32>,
    kills_gold: ::std::option::Option<u32>,
    damage_bronze: ::std::option::Option<u32>,
    damage_silver: ::std::option::Option<u32>,
    damage_gold: ::std::option::Option<u32>,
    healing_bronze: ::std::option::Option<u32>,
    healing_silver: ::std::option::Option<u32>,
    healing_gold: ::std::option::Option<u32>,
    support_bronze: ::std::option::Option<u32>,
    support_silver: ::std::option::Option<u32>,
    support_gold: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CSOTFLadderPlayerStats {
    fn default() -> &'a CSOTFLadderPlayerStats {
        <CSOTFLadderPlayerStats as ::protobuf::Message>::default_instance()
    }
}

impl CSOTFLadderPlayerStats {
    pub fn new() -> CSOTFLadderPlayerStats {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;


    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }
    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional int32 match_group = 2;


    pub fn get_match_group(&self) -> i32 {
        self.match_group.unwrap_or(0)
    }
    pub fn clear_match_group(&mut self) {
        self.match_group = ::std::option::Option::None;
    }

    pub fn has_match_group(&self) -> bool {
        self.match_group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_group(&mut self, v: i32) {
        self.match_group = ::std::option::Option::Some(v);
    }

    // optional uint32 season_id = 3;


    pub fn get_season_id(&self) -> u32 {
        self.season_id.unwrap_or(0)
    }
    pub fn clear_season_id(&mut self) {
        self.season_id = ::std::option::Option::None;
    }

    pub fn has_season_id(&self) -> bool {
        self.season_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_season_id(&mut self, v: u32) {
        self.season_id = ::std::option::Option::Some(v);
    }

    // optional uint32 games = 9;


    pub fn get_games(&self) -> u32 {
        self.games.unwrap_or(0)
    }
    pub fn clear_games(&mut self) {
        self.games = ::std::option::Option::None;
    }

    pub fn has_games(&self) -> bool {
        self.games.is_some()
    }

    // Param is passed by value, moved
    pub fn set_games(&mut self, v: u32) {
        self.games = ::std::option::Option::Some(v);
    }

    // optional uint32 score = 10;


    pub fn get_score(&self) -> u32 {
        self.score.unwrap_or(0)
    }
    pub fn clear_score(&mut self) {
        self.score = ::std::option::Option::None;
    }

    pub fn has_score(&self) -> bool {
        self.score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_score(&mut self, v: u32) {
        self.score = ::std::option::Option::Some(v);
    }

    // optional uint32 kills = 11;


    pub fn get_kills(&self) -> u32 {
        self.kills.unwrap_or(0)
    }
    pub fn clear_kills(&mut self) {
        self.kills = ::std::option::Option::None;
    }

    pub fn has_kills(&self) -> bool {
        self.kills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kills(&mut self, v: u32) {
        self.kills = ::std::option::Option::Some(v);
    }

    // optional uint32 deaths = 12;


    pub fn get_deaths(&self) -> u32 {
        self.deaths.unwrap_or(0)
    }
    pub fn clear_deaths(&mut self) {
        self.deaths = ::std::option::Option::None;
    }

    pub fn has_deaths(&self) -> bool {
        self.deaths.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deaths(&mut self, v: u32) {
        self.deaths = ::std::option::Option::Some(v);
    }

    // optional uint32 damage = 13;


    pub fn get_damage(&self) -> u32 {
        self.damage.unwrap_or(0)
    }
    pub fn clear_damage(&mut self) {
        self.damage = ::std::option::Option::None;
    }

    pub fn has_damage(&self) -> bool {
        self.damage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_damage(&mut self, v: u32) {
        self.damage = ::std::option::Option::Some(v);
    }

    // optional uint32 healing = 14;


    pub fn get_healing(&self) -> u32 {
        self.healing.unwrap_or(0)
    }
    pub fn clear_healing(&mut self) {
        self.healing = ::std::option::Option::None;
    }

    pub fn has_healing(&self) -> bool {
        self.healing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_healing(&mut self, v: u32) {
        self.healing = ::std::option::Option::Some(v);
    }

    // optional uint32 support = 15;


    pub fn get_support(&self) -> u32 {
        self.support.unwrap_or(0)
    }
    pub fn clear_support(&mut self) {
        self.support = ::std::option::Option::None;
    }

    pub fn has_support(&self) -> bool {
        self.support.is_some()
    }

    // Param is passed by value, moved
    pub fn set_support(&mut self, v: u32) {
        self.support = ::std::option::Option::Some(v);
    }

    // optional uint32 score_bronze = 16;


    pub fn get_score_bronze(&self) -> u32 {
        self.score_bronze.unwrap_or(0)
    }
    pub fn clear_score_bronze(&mut self) {
        self.score_bronze = ::std::option::Option::None;
    }

    pub fn has_score_bronze(&self) -> bool {
        self.score_bronze.is_some()
    }

    // Param is passed by value, moved
    pub fn set_score_bronze(&mut self, v: u32) {
        self.score_bronze = ::std::option::Option::Some(v);
    }

    // optional uint32 score_silver = 17;


    pub fn get_score_silver(&self) -> u32 {
        self.score_silver.unwrap_or(0)
    }
    pub fn clear_score_silver(&mut self) {
        self.score_silver = ::std::option::Option::None;
    }

    pub fn has_score_silver(&self) -> bool {
        self.score_silver.is_some()
    }

    // Param is passed by value, moved
    pub fn set_score_silver(&mut self, v: u32) {
        self.score_silver = ::std::option::Option::Some(v);
    }

    // optional uint32 score_gold = 18;


    pub fn get_score_gold(&self) -> u32 {
        self.score_gold.unwrap_or(0)
    }
    pub fn clear_score_gold(&mut self) {
        self.score_gold = ::std::option::Option::None;
    }

    pub fn has_score_gold(&self) -> bool {
        self.score_gold.is_some()
    }

    // Param is passed by value, moved
    pub fn set_score_gold(&mut self, v: u32) {
        self.score_gold = ::std::option::Option::Some(v);
    }

    // optional uint32 kills_bronze = 19;


    pub fn get_kills_bronze(&self) -> u32 {
        self.kills_bronze.unwrap_or(0)
    }
    pub fn clear_kills_bronze(&mut self) {
        self.kills_bronze = ::std::option::Option::None;
    }

    pub fn has_kills_bronze(&self) -> bool {
        self.kills_bronze.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kills_bronze(&mut self, v: u32) {
        self.kills_bronze = ::std::option::Option::Some(v);
    }

    // optional uint32 kills_silver = 20;


    pub fn get_kills_silver(&self) -> u32 {
        self.kills_silver.unwrap_or(0)
    }
    pub fn clear_kills_silver(&mut self) {
        self.kills_silver = ::std::option::Option::None;
    }

    pub fn has_kills_silver(&self) -> bool {
        self.kills_silver.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kills_silver(&mut self, v: u32) {
        self.kills_silver = ::std::option::Option::Some(v);
    }

    // optional uint32 kills_gold = 21;


    pub fn get_kills_gold(&self) -> u32 {
        self.kills_gold.unwrap_or(0)
    }
    pub fn clear_kills_gold(&mut self) {
        self.kills_gold = ::std::option::Option::None;
    }

    pub fn has_kills_gold(&self) -> bool {
        self.kills_gold.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kills_gold(&mut self, v: u32) {
        self.kills_gold = ::std::option::Option::Some(v);
    }

    // optional uint32 damage_bronze = 22;


    pub fn get_damage_bronze(&self) -> u32 {
        self.damage_bronze.unwrap_or(0)
    }
    pub fn clear_damage_bronze(&mut self) {
        self.damage_bronze = ::std::option::Option::None;
    }

    pub fn has_damage_bronze(&self) -> bool {
        self.damage_bronze.is_some()
    }

    // Param is passed by value, moved
    pub fn set_damage_bronze(&mut self, v: u32) {
        self.damage_bronze = ::std::option::Option::Some(v);
    }

    // optional uint32 damage_silver = 23;


    pub fn get_damage_silver(&self) -> u32 {
        self.damage_silver.unwrap_or(0)
    }
    pub fn clear_damage_silver(&mut self) {
        self.damage_silver = ::std::option::Option::None;
    }

    pub fn has_damage_silver(&self) -> bool {
        self.damage_silver.is_some()
    }

    // Param is passed by value, moved
    pub fn set_damage_silver(&mut self, v: u32) {
        self.damage_silver = ::std::option::Option::Some(v);
    }

    // optional uint32 damage_gold = 24;


    pub fn get_damage_gold(&self) -> u32 {
        self.damage_gold.unwrap_or(0)
    }
    pub fn clear_damage_gold(&mut self) {
        self.damage_gold = ::std::option::Option::None;
    }

    pub fn has_damage_gold(&self) -> bool {
        self.damage_gold.is_some()
    }

    // Param is passed by value, moved
    pub fn set_damage_gold(&mut self, v: u32) {
        self.damage_gold = ::std::option::Option::Some(v);
    }

    // optional uint32 healing_bronze = 25;


    pub fn get_healing_bronze(&self) -> u32 {
        self.healing_bronze.unwrap_or(0)
    }
    pub fn clear_healing_bronze(&mut self) {
        self.healing_bronze = ::std::option::Option::None;
    }

    pub fn has_healing_bronze(&self) -> bool {
        self.healing_bronze.is_some()
    }

    // Param is passed by value, moved
    pub fn set_healing_bronze(&mut self, v: u32) {
        self.healing_bronze = ::std::option::Option::Some(v);
    }

    // optional uint32 healing_silver = 26;


    pub fn get_healing_silver(&self) -> u32 {
        self.healing_silver.unwrap_or(0)
    }
    pub fn clear_healing_silver(&mut self) {
        self.healing_silver = ::std::option::Option::None;
    }

    pub fn has_healing_silver(&self) -> bool {
        self.healing_silver.is_some()
    }

    // Param is passed by value, moved
    pub fn set_healing_silver(&mut self, v: u32) {
        self.healing_silver = ::std::option::Option::Some(v);
    }

    // optional uint32 healing_gold = 27;


    pub fn get_healing_gold(&self) -> u32 {
        self.healing_gold.unwrap_or(0)
    }
    pub fn clear_healing_gold(&mut self) {
        self.healing_gold = ::std::option::Option::None;
    }

    pub fn has_healing_gold(&self) -> bool {
        self.healing_gold.is_some()
    }

    // Param is passed by value, moved
    pub fn set_healing_gold(&mut self, v: u32) {
        self.healing_gold = ::std::option::Option::Some(v);
    }

    // optional uint32 support_bronze = 28;


    pub fn get_support_bronze(&self) -> u32 {
        self.support_bronze.unwrap_or(0)
    }
    pub fn clear_support_bronze(&mut self) {
        self.support_bronze = ::std::option::Option::None;
    }

    pub fn has_support_bronze(&self) -> bool {
        self.support_bronze.is_some()
    }

    // Param is passed by value, moved
    pub fn set_support_bronze(&mut self, v: u32) {
        self.support_bronze = ::std::option::Option::Some(v);
    }

    // optional uint32 support_silver = 29;


    pub fn get_support_silver(&self) -> u32 {
        self.support_silver.unwrap_or(0)
    }
    pub fn clear_support_silver(&mut self) {
        self.support_silver = ::std::option::Option::None;
    }

    pub fn has_support_silver(&self) -> bool {
        self.support_silver.is_some()
    }

    // Param is passed by value, moved
    pub fn set_support_silver(&mut self, v: u32) {
        self.support_silver = ::std::option::Option::Some(v);
    }

    // optional uint32 support_gold = 30;


    pub fn get_support_gold(&self) -> u32 {
        self.support_gold.unwrap_or(0)
    }
    pub fn clear_support_gold(&mut self) {
        self.support_gold = ::std::option::Option::None;
    }

    pub fn has_support_gold(&self) -> bool {
        self.support_gold.is_some()
    }

    // Param is passed by value, moved
    pub fn set_support_gold(&mut self, v: u32) {
        self.support_gold = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CSOTFLadderPlayerStats {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.match_group = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.season_id = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.games = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.score = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.kills = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.deaths = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.damage = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.healing = ::std::option::Option::Some(tmp);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.support = ::std::option::Option::Some(tmp);
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.score_bronze = ::std::option::Option::Some(tmp);
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.score_silver = ::std::option::Option::Some(tmp);
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.score_gold = ::std::option::Option::Some(tmp);
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.kills_bronze = ::std::option::Option::Some(tmp);
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.kills_silver = ::std::option::Option::Some(tmp);
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.kills_gold = ::std::option::Option::Some(tmp);
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.damage_bronze = ::std::option::Option::Some(tmp);
                },
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.damage_silver = ::std::option::Option::Some(tmp);
                },
                24 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.damage_gold = ::std::option::Option::Some(tmp);
                },
                25 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.healing_bronze = ::std::option::Option::Some(tmp);
                },
                26 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.healing_silver = ::std::option::Option::Some(tmp);
                },
                27 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.healing_gold = ::std::option::Option::Some(tmp);
                },
                28 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.support_bronze = ::std::option::Option::Some(tmp);
                },
                29 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.support_silver = ::std::option::Option::Some(tmp);
                },
                30 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.support_gold = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.match_group {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.season_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.games {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.score {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.kills {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.deaths {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.damage {
            my_size += ::protobuf::rt::value_size(13, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.healing {
            my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.support {
            my_size += ::protobuf::rt::value_size(15, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.score_bronze {
            my_size += ::protobuf::rt::value_size(16, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.score_silver {
            my_size += ::protobuf::rt::value_size(17, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.score_gold {
            my_size += ::protobuf::rt::value_size(18, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.kills_bronze {
            my_size += ::protobuf::rt::value_size(19, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.kills_silver {
            my_size += ::protobuf::rt::value_size(20, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.kills_gold {
            my_size += ::protobuf::rt::value_size(21, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.damage_bronze {
            my_size += ::protobuf::rt::value_size(22, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.damage_silver {
            my_size += ::protobuf::rt::value_size(23, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.damage_gold {
            my_size += ::protobuf::rt::value_size(24, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.healing_bronze {
            my_size += ::protobuf::rt::value_size(25, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.healing_silver {
            my_size += ::protobuf::rt::value_size(26, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.healing_gold {
            my_size += ::protobuf::rt::value_size(27, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.support_bronze {
            my_size += ::protobuf::rt::value_size(28, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.support_silver {
            my_size += ::protobuf::rt::value_size(29, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.support_gold {
            my_size += ::protobuf::rt::value_size(30, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.match_group {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.season_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.games {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.score {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.kills {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.deaths {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.damage {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.healing {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.support {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.score_bronze {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.score_silver {
            os.write_uint32(17, v)?;
        }
        if let Some(v) = self.score_gold {
            os.write_uint32(18, v)?;
        }
        if let Some(v) = self.kills_bronze {
            os.write_uint32(19, v)?;
        }
        if let Some(v) = self.kills_silver {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.kills_gold {
            os.write_uint32(21, v)?;
        }
        if let Some(v) = self.damage_bronze {
            os.write_uint32(22, v)?;
        }
        if let Some(v) = self.damage_silver {
            os.write_uint32(23, v)?;
        }
        if let Some(v) = self.damage_gold {
            os.write_uint32(24, v)?;
        }
        if let Some(v) = self.healing_bronze {
            os.write_uint32(25, v)?;
        }
        if let Some(v) = self.healing_silver {
            os.write_uint32(26, v)?;
        }
        if let Some(v) = self.healing_gold {
            os.write_uint32(27, v)?;
        }
        if let Some(v) = self.support_bronze {
            os.write_uint32(28, v)?;
        }
        if let Some(v) = self.support_silver {
            os.write_uint32(29, v)?;
        }
        if let Some(v) = self.support_gold {
            os.write_uint32(30, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CSOTFLadderPlayerStats {
        CSOTFLadderPlayerStats::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "account_id",
                |m: &CSOTFLadderPlayerStats| { &m.account_id },
                |m: &mut CSOTFLadderPlayerStats| { &mut m.account_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "match_group",
                |m: &CSOTFLadderPlayerStats| { &m.match_group },
                |m: &mut CSOTFLadderPlayerStats| { &mut m.match_group },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "season_id",
                |m: &CSOTFLadderPlayerStats| { &m.season_id },
                |m: &mut CSOTFLadderPlayerStats| { &mut m.season_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "games",
                |m: &CSOTFLadderPlayerStats| { &m.games },
                |m: &mut CSOTFLadderPlayerStats| { &mut m.games },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "score",
                |m: &CSOTFLadderPlayerStats| { &m.score },
                |m: &mut CSOTFLadderPlayerStats| { &mut m.score },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "kills",
                |m: &CSOTFLadderPlayerStats| { &m.kills },
                |m: &mut CSOTFLadderPlayerStats| { &mut m.kills },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "deaths",
                |m: &CSOTFLadderPlayerStats| { &m.deaths },
                |m: &mut CSOTFLadderPlayerStats| { &mut m.deaths },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "damage",
                |m: &CSOTFLadderPlayerStats| { &m.damage },
                |m: &mut CSOTFLadderPlayerStats| { &mut m.damage },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "healing",
                |m: &CSOTFLadderPlayerStats| { &m.healing },
                |m: &mut CSOTFLadderPlayerStats| { &mut m.healing },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "support",
                |m: &CSOTFLadderPlayerStats| { &m.support },
                |m: &mut CSOTFLadderPlayerStats| { &mut m.support },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "score_bronze",
                |m: &CSOTFLadderPlayerStats| { &m.score_bronze },
                |m: &mut CSOTFLadderPlayerStats| { &mut m.score_bronze },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "score_silver",
                |m: &CSOTFLadderPlayerStats| { &m.score_silver },
                |m: &mut CSOTFLadderPlayerStats| { &mut m.score_silver },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "score_gold",
                |m: &CSOTFLadderPlayerStats| { &m.score_gold },
                |m: &mut CSOTFLadderPlayerStats| { &mut m.score_gold },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "kills_bronze",
                |m: &CSOTFLadderPlayerStats| { &m.kills_bronze },
                |m: &mut CSOTFLadderPlayerStats| { &mut m.kills_bronze },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "kills_silver",
                |m: &CSOTFLadderPlayerStats| { &m.kills_silver },
                |m: &mut CSOTFLadderPlayerStats| { &mut m.kills_silver },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "kills_gold",
                |m: &CSOTFLadderPlayerStats| { &m.kills_gold },
                |m: &mut CSOTFLadderPlayerStats| { &mut m.kills_gold },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "damage_bronze",
                |m: &CSOTFLadderPlayerStats| { &m.damage_bronze },
                |m: &mut CSOTFLadderPlayerStats| { &mut m.damage_bronze },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "damage_silver",
                |m: &CSOTFLadderPlayerStats| { &m.damage_silver },
                |m: &mut CSOTFLadderPlayerStats| { &mut m.damage_silver },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "damage_gold",
                |m: &CSOTFLadderPlayerStats| { &m.damage_gold },
                |m: &mut CSOTFLadderPlayerStats| { &mut m.damage_gold },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "healing_bronze",
                |m: &CSOTFLadderPlayerStats| { &m.healing_bronze },
                |m: &mut CSOTFLadderPlayerStats| { &mut m.healing_bronze },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "healing_silver",
                |m: &CSOTFLadderPlayerStats| { &m.healing_silver },
                |m: &mut CSOTFLadderPlayerStats| { &mut m.healing_silver },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "healing_gold",
                |m: &CSOTFLadderPlayerStats| { &m.healing_gold },
                |m: &mut CSOTFLadderPlayerStats| { &mut m.healing_gold },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "support_bronze",
                |m: &CSOTFLadderPlayerStats| { &m.support_bronze },
                |m: &mut CSOTFLadderPlayerStats| { &mut m.support_bronze },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "support_silver",
                |m: &CSOTFLadderPlayerStats| { &m.support_silver },
                |m: &mut CSOTFLadderPlayerStats| { &mut m.support_silver },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "support_gold",
                |m: &CSOTFLadderPlayerStats| { &m.support_gold },
                |m: &mut CSOTFLadderPlayerStats| { &mut m.support_gold },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CSOTFLadderPlayerStats>(
                "CSOTFLadderPlayerStats",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CSOTFLadderPlayerStats {
        static instance: ::protobuf::rt::LazyV2<CSOTFLadderPlayerStats> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CSOTFLadderPlayerStats::new)
    }
}

impl ::protobuf::Clear for CSOTFLadderPlayerStats {
    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.match_group = ::std::option::Option::None;
        self.season_id = ::std::option::Option::None;
        self.games = ::std::option::Option::None;
        self.score = ::std::option::Option::None;
        self.kills = ::std::option::Option::None;
        self.deaths = ::std::option::Option::None;
        self.damage = ::std::option::Option::None;
        self.healing = ::std::option::Option::None;
        self.support = ::std::option::Option::None;
        self.score_bronze = ::std::option::Option::None;
        self.score_silver = ::std::option::Option::None;
        self.score_gold = ::std::option::Option::None;
        self.kills_bronze = ::std::option::Option::None;
        self.kills_silver = ::std::option::Option::None;
        self.kills_gold = ::std::option::Option::None;
        self.damage_bronze = ::std::option::Option::None;
        self.damage_silver = ::std::option::Option::None;
        self.damage_gold = ::std::option::Option::None;
        self.healing_bronze = ::std::option::Option::None;
        self.healing_silver = ::std::option::Option::None;
        self.healing_gold = ::std::option::Option::None;
        self.support_bronze = ::std::option::Option::None;
        self.support_silver = ::std::option::Option::None;
        self.support_gold = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSOTFLadderPlayerStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOTFLadderPlayerStats {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CSOTFRatingData {
    // message fields
    account_id: ::std::option::Option<u32>,
    rating_type: ::std::option::Option<i32>,
    rating_primary: ::std::option::Option<u32>,
    rating_secondary: ::std::option::Option<u32>,
    rating_tertiary: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CSOTFRatingData {
    fn default() -> &'a CSOTFRatingData {
        <CSOTFRatingData as ::protobuf::Message>::default_instance()
    }
}

impl CSOTFRatingData {
    pub fn new() -> CSOTFRatingData {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;


    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }
    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional int32 rating_type = 2;


    pub fn get_rating_type(&self) -> i32 {
        self.rating_type.unwrap_or(0)
    }
    pub fn clear_rating_type(&mut self) {
        self.rating_type = ::std::option::Option::None;
    }

    pub fn has_rating_type(&self) -> bool {
        self.rating_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rating_type(&mut self, v: i32) {
        self.rating_type = ::std::option::Option::Some(v);
    }

    // optional uint32 rating_primary = 3;


    pub fn get_rating_primary(&self) -> u32 {
        self.rating_primary.unwrap_or(0)
    }
    pub fn clear_rating_primary(&mut self) {
        self.rating_primary = ::std::option::Option::None;
    }

    pub fn has_rating_primary(&self) -> bool {
        self.rating_primary.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rating_primary(&mut self, v: u32) {
        self.rating_primary = ::std::option::Option::Some(v);
    }

    // optional uint32 rating_secondary = 4;


    pub fn get_rating_secondary(&self) -> u32 {
        self.rating_secondary.unwrap_or(0)
    }
    pub fn clear_rating_secondary(&mut self) {
        self.rating_secondary = ::std::option::Option::None;
    }

    pub fn has_rating_secondary(&self) -> bool {
        self.rating_secondary.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rating_secondary(&mut self, v: u32) {
        self.rating_secondary = ::std::option::Option::Some(v);
    }

    // optional uint32 rating_tertiary = 5;


    pub fn get_rating_tertiary(&self) -> u32 {
        self.rating_tertiary.unwrap_or(0)
    }
    pub fn clear_rating_tertiary(&mut self) {
        self.rating_tertiary = ::std::option::Option::None;
    }

    pub fn has_rating_tertiary(&self) -> bool {
        self.rating_tertiary.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rating_tertiary(&mut self, v: u32) {
        self.rating_tertiary = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CSOTFRatingData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.rating_type = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rating_primary = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rating_secondary = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rating_tertiary = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rating_type {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rating_primary {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rating_secondary {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rating_tertiary {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.rating_type {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.rating_primary {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.rating_secondary {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.rating_tertiary {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CSOTFRatingData {
        CSOTFRatingData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "account_id",
                |m: &CSOTFRatingData| { &m.account_id },
                |m: &mut CSOTFRatingData| { &mut m.account_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "rating_type",
                |m: &CSOTFRatingData| { &m.rating_type },
                |m: &mut CSOTFRatingData| { &mut m.rating_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "rating_primary",
                |m: &CSOTFRatingData| { &m.rating_primary },
                |m: &mut CSOTFRatingData| { &mut m.rating_primary },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "rating_secondary",
                |m: &CSOTFRatingData| { &m.rating_secondary },
                |m: &mut CSOTFRatingData| { &mut m.rating_secondary },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "rating_tertiary",
                |m: &CSOTFRatingData| { &m.rating_tertiary },
                |m: &mut CSOTFRatingData| { &mut m.rating_tertiary },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CSOTFRatingData>(
                "CSOTFRatingData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CSOTFRatingData {
        static instance: ::protobuf::rt::LazyV2<CSOTFRatingData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CSOTFRatingData::new)
    }
}

impl ::protobuf::Clear for CSOTFRatingData {
    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.rating_type = ::std::option::Option::None;
        self.rating_primary = ::std::option::Option::None;
        self.rating_secondary = ::std::option::Option::None;
        self.rating_tertiary = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSOTFRatingData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOTFRatingData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGC_TFVoteKickPlayerRequest {
    // message fields
    target_id: ::std::option::Option<u64>,
    voter_id: ::std::option::Option<u64>,
    reason: ::std::option::Option<TFVoteKickReason>,
    match_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGC_TFVoteKickPlayerRequest {
    fn default() -> &'a CMsgGC_TFVoteKickPlayerRequest {
        <CMsgGC_TFVoteKickPlayerRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_TFVoteKickPlayerRequest {
    pub fn new() -> CMsgGC_TFVoteKickPlayerRequest {
        ::std::default::Default::default()
    }

    // optional uint64 target_id = 2;


    pub fn get_target_id(&self) -> u64 {
        self.target_id.unwrap_or(0)
    }
    pub fn clear_target_id(&mut self) {
        self.target_id = ::std::option::Option::None;
    }

    pub fn has_target_id(&self) -> bool {
        self.target_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_id(&mut self, v: u64) {
        self.target_id = ::std::option::Option::Some(v);
    }

    // optional uint64 voter_id = 3;


    pub fn get_voter_id(&self) -> u64 {
        self.voter_id.unwrap_or(0)
    }
    pub fn clear_voter_id(&mut self) {
        self.voter_id = ::std::option::Option::None;
    }

    pub fn has_voter_id(&self) -> bool {
        self.voter_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_voter_id(&mut self, v: u64) {
        self.voter_id = ::std::option::Option::Some(v);
    }

    // optional .TFVoteKickReason reason = 4;


    pub fn get_reason(&self) -> TFVoteKickReason {
        self.reason.unwrap_or(TFVoteKickReason::TFVoteKickReason_Other)
    }
    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: TFVoteKickReason) {
        self.reason = ::std::option::Option::Some(v);
    }

    // optional uint64 match_id = 5;


    pub fn get_match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }
    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGC_TFVoteKickPlayerRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.target_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.voter_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.reason, 4, &mut self.unknown_fields)?
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.match_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.target_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.voter_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.reason {
            my_size += ::protobuf::rt::enum_size(4, v);
        }
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.target_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.voter_id {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.reason {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.match_id {
            os.write_uint64(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGC_TFVoteKickPlayerRequest {
        CMsgGC_TFVoteKickPlayerRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "target_id",
                |m: &CMsgGC_TFVoteKickPlayerRequest| { &m.target_id },
                |m: &mut CMsgGC_TFVoteKickPlayerRequest| { &mut m.target_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "voter_id",
                |m: &CMsgGC_TFVoteKickPlayerRequest| { &m.voter_id },
                |m: &mut CMsgGC_TFVoteKickPlayerRequest| { &mut m.voter_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TFVoteKickReason>>(
                "reason",
                |m: &CMsgGC_TFVoteKickPlayerRequest| { &m.reason },
                |m: &mut CMsgGC_TFVoteKickPlayerRequest| { &mut m.reason },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "match_id",
                |m: &CMsgGC_TFVoteKickPlayerRequest| { &m.match_id },
                |m: &mut CMsgGC_TFVoteKickPlayerRequest| { &mut m.match_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGC_TFVoteKickPlayerRequest>(
                "CMsgGC_TFVoteKickPlayerRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGC_TFVoteKickPlayerRequest {
        static instance: ::protobuf::rt::LazyV2<CMsgGC_TFVoteKickPlayerRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGC_TFVoteKickPlayerRequest::new)
    }
}

impl ::protobuf::Clear for CMsgGC_TFVoteKickPlayerRequest {
    fn clear(&mut self) {
        self.target_id = ::std::option::Option::None;
        self.voter_id = ::std::option::Option::None;
        self.reason = ::std::option::Option::None;
        self.match_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGC_TFVoteKickPlayerRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGC_TFVoteKickPlayerRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGC_VoteKickPlayerRequestResponse {
    // message fields
    allowed: ::std::option::Option<bool>,
    voter_inhibit: ::std::option::Option<bool>,
    target_inhibit: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGC_VoteKickPlayerRequestResponse {
    fn default() -> &'a CMsgGC_VoteKickPlayerRequestResponse {
        <CMsgGC_VoteKickPlayerRequestResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_VoteKickPlayerRequestResponse {
    pub fn new() -> CMsgGC_VoteKickPlayerRequestResponse {
        ::std::default::Default::default()
    }

    // optional bool allowed = 1;


    pub fn get_allowed(&self) -> bool {
        self.allowed.unwrap_or(false)
    }
    pub fn clear_allowed(&mut self) {
        self.allowed = ::std::option::Option::None;
    }

    pub fn has_allowed(&self) -> bool {
        self.allowed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allowed(&mut self, v: bool) {
        self.allowed = ::std::option::Option::Some(v);
    }

    // optional bool voter_inhibit = 3;


    pub fn get_voter_inhibit(&self) -> bool {
        self.voter_inhibit.unwrap_or(false)
    }
    pub fn clear_voter_inhibit(&mut self) {
        self.voter_inhibit = ::std::option::Option::None;
    }

    pub fn has_voter_inhibit(&self) -> bool {
        self.voter_inhibit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_voter_inhibit(&mut self, v: bool) {
        self.voter_inhibit = ::std::option::Option::Some(v);
    }

    // optional bool target_inhibit = 4;


    pub fn get_target_inhibit(&self) -> bool {
        self.target_inhibit.unwrap_or(false)
    }
    pub fn clear_target_inhibit(&mut self) {
        self.target_inhibit = ::std::option::Option::None;
    }

    pub fn has_target_inhibit(&self) -> bool {
        self.target_inhibit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_inhibit(&mut self, v: bool) {
        self.target_inhibit = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGC_VoteKickPlayerRequestResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.allowed = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.voter_inhibit = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.target_inhibit = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.allowed {
            my_size += 2;
        }
        if let Some(v) = self.voter_inhibit {
            my_size += 2;
        }
        if let Some(v) = self.target_inhibit {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.allowed {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.voter_inhibit {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.target_inhibit {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGC_VoteKickPlayerRequestResponse {
        CMsgGC_VoteKickPlayerRequestResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "allowed",
                |m: &CMsgGC_VoteKickPlayerRequestResponse| { &m.allowed },
                |m: &mut CMsgGC_VoteKickPlayerRequestResponse| { &mut m.allowed },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "voter_inhibit",
                |m: &CMsgGC_VoteKickPlayerRequestResponse| { &m.voter_inhibit },
                |m: &mut CMsgGC_VoteKickPlayerRequestResponse| { &mut m.voter_inhibit },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "target_inhibit",
                |m: &CMsgGC_VoteKickPlayerRequestResponse| { &m.target_inhibit },
                |m: &mut CMsgGC_VoteKickPlayerRequestResponse| { &mut m.target_inhibit },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGC_VoteKickPlayerRequestResponse>(
                "CMsgGC_VoteKickPlayerRequestResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGC_VoteKickPlayerRequestResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgGC_VoteKickPlayerRequestResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGC_VoteKickPlayerRequestResponse::new)
    }
}

impl ::protobuf::Clear for CMsgGC_VoteKickPlayerRequestResponse {
    fn clear(&mut self) {
        self.allowed = ::std::option::Option::None;
        self.voter_inhibit = ::std::option::Option::None;
        self.target_inhibit = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGC_VoteKickPlayerRequestResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGC_VoteKickPlayerRequestResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGC_DailyCompetitiveStatsRollup {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGC_DailyCompetitiveStatsRollup {
    fn default() -> &'a CMsgGC_DailyCompetitiveStatsRollup {
        <CMsgGC_DailyCompetitiveStatsRollup as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_DailyCompetitiveStatsRollup {
    pub fn new() -> CMsgGC_DailyCompetitiveStatsRollup {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgGC_DailyCompetitiveStatsRollup {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGC_DailyCompetitiveStatsRollup {
        CMsgGC_DailyCompetitiveStatsRollup::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGC_DailyCompetitiveStatsRollup>(
                "CMsgGC_DailyCompetitiveStatsRollup",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGC_DailyCompetitiveStatsRollup {
        static instance: ::protobuf::rt::LazyV2<CMsgGC_DailyCompetitiveStatsRollup> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGC_DailyCompetitiveStatsRollup::new)
    }
}

impl ::protobuf::Clear for CMsgGC_DailyCompetitiveStatsRollup {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGC_DailyCompetitiveStatsRollup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGC_DailyCompetitiveStatsRollup {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGC_DailyCompetitiveStatsRollup_Response {
    // message fields
    pub rankdata: ::protobuf::RepeatedField<CMsgGC_DailyCompetitiveStatsRollup_Response_RankBucketEntry>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGC_DailyCompetitiveStatsRollup_Response {
    fn default() -> &'a CMsgGC_DailyCompetitiveStatsRollup_Response {
        <CMsgGC_DailyCompetitiveStatsRollup_Response as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_DailyCompetitiveStatsRollup_Response {
    pub fn new() -> CMsgGC_DailyCompetitiveStatsRollup_Response {
        ::std::default::Default::default()
    }

    // repeated .CMsgGC_DailyCompetitiveStatsRollup_Response.RankBucketEntry rankdata = 1;


    pub fn get_rankdata(&self) -> &[CMsgGC_DailyCompetitiveStatsRollup_Response_RankBucketEntry] {
        &self.rankdata
    }
    pub fn clear_rankdata(&mut self) {
        self.rankdata.clear();
    }

    // Param is passed by value, moved
    pub fn set_rankdata(&mut self, v: ::protobuf::RepeatedField<CMsgGC_DailyCompetitiveStatsRollup_Response_RankBucketEntry>) {
        self.rankdata = v;
    }

    // Mutable pointer to the field.
    pub fn mut_rankdata(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGC_DailyCompetitiveStatsRollup_Response_RankBucketEntry> {
        &mut self.rankdata
    }

    // Take field
    pub fn take_rankdata(&mut self) -> ::protobuf::RepeatedField<CMsgGC_DailyCompetitiveStatsRollup_Response_RankBucketEntry> {
        ::std::mem::replace(&mut self.rankdata, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgGC_DailyCompetitiveStatsRollup_Response {
    fn is_initialized(&self) -> bool {
        for v in &self.rankdata {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.rankdata)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.rankdata {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.rankdata {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGC_DailyCompetitiveStatsRollup_Response {
        CMsgGC_DailyCompetitiveStatsRollup_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGC_DailyCompetitiveStatsRollup_Response_RankBucketEntry>>(
                "rankdata",
                |m: &CMsgGC_DailyCompetitiveStatsRollup_Response| { &m.rankdata },
                |m: &mut CMsgGC_DailyCompetitiveStatsRollup_Response| { &mut m.rankdata },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGC_DailyCompetitiveStatsRollup_Response>(
                "CMsgGC_DailyCompetitiveStatsRollup_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGC_DailyCompetitiveStatsRollup_Response {
        static instance: ::protobuf::rt::LazyV2<CMsgGC_DailyCompetitiveStatsRollup_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGC_DailyCompetitiveStatsRollup_Response::new)
    }
}

impl ::protobuf::Clear for CMsgGC_DailyCompetitiveStatsRollup_Response {
    fn clear(&mut self) {
        self.rankdata.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGC_DailyCompetitiveStatsRollup_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGC_DailyCompetitiveStatsRollup_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGC_DailyCompetitiveStatsRollup_Response_RankBucketEntry {
    // message fields
    rank: ::std::option::Option<u32>,
    records: ::std::option::Option<u32>,
    avg_score: ::std::option::Option<u32>,
    stdev_score: ::std::option::Option<u32>,
    avg_kills: ::std::option::Option<u32>,
    stdev_kills: ::std::option::Option<u32>,
    avg_damage: ::std::option::Option<u32>,
    stdev_damage: ::std::option::Option<u32>,
    avg_healing: ::std::option::Option<u32>,
    stdev_healing: ::std::option::Option<u32>,
    avg_support: ::std::option::Option<u32>,
    stdev_support: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGC_DailyCompetitiveStatsRollup_Response_RankBucketEntry {
    fn default() -> &'a CMsgGC_DailyCompetitiveStatsRollup_Response_RankBucketEntry {
        <CMsgGC_DailyCompetitiveStatsRollup_Response_RankBucketEntry as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_DailyCompetitiveStatsRollup_Response_RankBucketEntry {
    pub fn new() -> CMsgGC_DailyCompetitiveStatsRollup_Response_RankBucketEntry {
        ::std::default::Default::default()
    }

    // optional uint32 rank = 1;


    pub fn get_rank(&self) -> u32 {
        self.rank.unwrap_or(0)
    }
    pub fn clear_rank(&mut self) {
        self.rank = ::std::option::Option::None;
    }

    pub fn has_rank(&self) -> bool {
        self.rank.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rank(&mut self, v: u32) {
        self.rank = ::std::option::Option::Some(v);
    }

    // optional uint32 records = 2;


    pub fn get_records(&self) -> u32 {
        self.records.unwrap_or(0)
    }
    pub fn clear_records(&mut self) {
        self.records = ::std::option::Option::None;
    }

    pub fn has_records(&self) -> bool {
        self.records.is_some()
    }

    // Param is passed by value, moved
    pub fn set_records(&mut self, v: u32) {
        self.records = ::std::option::Option::Some(v);
    }

    // optional uint32 avg_score = 3;


    pub fn get_avg_score(&self) -> u32 {
        self.avg_score.unwrap_or(0)
    }
    pub fn clear_avg_score(&mut self) {
        self.avg_score = ::std::option::Option::None;
    }

    pub fn has_avg_score(&self) -> bool {
        self.avg_score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avg_score(&mut self, v: u32) {
        self.avg_score = ::std::option::Option::Some(v);
    }

    // optional uint32 stdev_score = 4;


    pub fn get_stdev_score(&self) -> u32 {
        self.stdev_score.unwrap_or(0)
    }
    pub fn clear_stdev_score(&mut self) {
        self.stdev_score = ::std::option::Option::None;
    }

    pub fn has_stdev_score(&self) -> bool {
        self.stdev_score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stdev_score(&mut self, v: u32) {
        self.stdev_score = ::std::option::Option::Some(v);
    }

    // optional uint32 avg_kills = 5;


    pub fn get_avg_kills(&self) -> u32 {
        self.avg_kills.unwrap_or(0)
    }
    pub fn clear_avg_kills(&mut self) {
        self.avg_kills = ::std::option::Option::None;
    }

    pub fn has_avg_kills(&self) -> bool {
        self.avg_kills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avg_kills(&mut self, v: u32) {
        self.avg_kills = ::std::option::Option::Some(v);
    }

    // optional uint32 stdev_kills = 6;


    pub fn get_stdev_kills(&self) -> u32 {
        self.stdev_kills.unwrap_or(0)
    }
    pub fn clear_stdev_kills(&mut self) {
        self.stdev_kills = ::std::option::Option::None;
    }

    pub fn has_stdev_kills(&self) -> bool {
        self.stdev_kills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stdev_kills(&mut self, v: u32) {
        self.stdev_kills = ::std::option::Option::Some(v);
    }

    // optional uint32 avg_damage = 7;


    pub fn get_avg_damage(&self) -> u32 {
        self.avg_damage.unwrap_or(0)
    }
    pub fn clear_avg_damage(&mut self) {
        self.avg_damage = ::std::option::Option::None;
    }

    pub fn has_avg_damage(&self) -> bool {
        self.avg_damage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avg_damage(&mut self, v: u32) {
        self.avg_damage = ::std::option::Option::Some(v);
    }

    // optional uint32 stdev_damage = 8;


    pub fn get_stdev_damage(&self) -> u32 {
        self.stdev_damage.unwrap_or(0)
    }
    pub fn clear_stdev_damage(&mut self) {
        self.stdev_damage = ::std::option::Option::None;
    }

    pub fn has_stdev_damage(&self) -> bool {
        self.stdev_damage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stdev_damage(&mut self, v: u32) {
        self.stdev_damage = ::std::option::Option::Some(v);
    }

    // optional uint32 avg_healing = 9;


    pub fn get_avg_healing(&self) -> u32 {
        self.avg_healing.unwrap_or(0)
    }
    pub fn clear_avg_healing(&mut self) {
        self.avg_healing = ::std::option::Option::None;
    }

    pub fn has_avg_healing(&self) -> bool {
        self.avg_healing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avg_healing(&mut self, v: u32) {
        self.avg_healing = ::std::option::Option::Some(v);
    }

    // optional uint32 stdev_healing = 10;


    pub fn get_stdev_healing(&self) -> u32 {
        self.stdev_healing.unwrap_or(0)
    }
    pub fn clear_stdev_healing(&mut self) {
        self.stdev_healing = ::std::option::Option::None;
    }

    pub fn has_stdev_healing(&self) -> bool {
        self.stdev_healing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stdev_healing(&mut self, v: u32) {
        self.stdev_healing = ::std::option::Option::Some(v);
    }

    // optional uint32 avg_support = 11;


    pub fn get_avg_support(&self) -> u32 {
        self.avg_support.unwrap_or(0)
    }
    pub fn clear_avg_support(&mut self) {
        self.avg_support = ::std::option::Option::None;
    }

    pub fn has_avg_support(&self) -> bool {
        self.avg_support.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avg_support(&mut self, v: u32) {
        self.avg_support = ::std::option::Option::Some(v);
    }

    // optional uint32 stdev_support = 12;


    pub fn get_stdev_support(&self) -> u32 {
        self.stdev_support.unwrap_or(0)
    }
    pub fn clear_stdev_support(&mut self) {
        self.stdev_support = ::std::option::Option::None;
    }

    pub fn has_stdev_support(&self) -> bool {
        self.stdev_support.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stdev_support(&mut self, v: u32) {
        self.stdev_support = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGC_DailyCompetitiveStatsRollup_Response_RankBucketEntry {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rank = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.records = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.avg_score = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.stdev_score = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.avg_kills = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.stdev_kills = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.avg_damage = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.stdev_damage = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.avg_healing = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.stdev_healing = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.avg_support = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.stdev_support = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.rank {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.records {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.avg_score {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.stdev_score {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.avg_kills {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.stdev_kills {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.avg_damage {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.stdev_damage {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.avg_healing {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.stdev_healing {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.avg_support {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.stdev_support {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.rank {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.records {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.avg_score {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.stdev_score {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.avg_kills {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.stdev_kills {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.avg_damage {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.stdev_damage {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.avg_healing {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.stdev_healing {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.avg_support {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.stdev_support {
            os.write_uint32(12, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGC_DailyCompetitiveStatsRollup_Response_RankBucketEntry {
        CMsgGC_DailyCompetitiveStatsRollup_Response_RankBucketEntry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "rank",
                |m: &CMsgGC_DailyCompetitiveStatsRollup_Response_RankBucketEntry| { &m.rank },
                |m: &mut CMsgGC_DailyCompetitiveStatsRollup_Response_RankBucketEntry| { &mut m.rank },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "records",
                |m: &CMsgGC_DailyCompetitiveStatsRollup_Response_RankBucketEntry| { &m.records },
                |m: &mut CMsgGC_DailyCompetitiveStatsRollup_Response_RankBucketEntry| { &mut m.records },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "avg_score",
                |m: &CMsgGC_DailyCompetitiveStatsRollup_Response_RankBucketEntry| { &m.avg_score },
                |m: &mut CMsgGC_DailyCompetitiveStatsRollup_Response_RankBucketEntry| { &mut m.avg_score },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "stdev_score",
                |m: &CMsgGC_DailyCompetitiveStatsRollup_Response_RankBucketEntry| { &m.stdev_score },
                |m: &mut CMsgGC_DailyCompetitiveStatsRollup_Response_RankBucketEntry| { &mut m.stdev_score },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "avg_kills",
                |m: &CMsgGC_DailyCompetitiveStatsRollup_Response_RankBucketEntry| { &m.avg_kills },
                |m: &mut CMsgGC_DailyCompetitiveStatsRollup_Response_RankBucketEntry| { &mut m.avg_kills },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "stdev_kills",
                |m: &CMsgGC_DailyCompetitiveStatsRollup_Response_RankBucketEntry| { &m.stdev_kills },
                |m: &mut CMsgGC_DailyCompetitiveStatsRollup_Response_RankBucketEntry| { &mut m.stdev_kills },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "avg_damage",
                |m: &CMsgGC_DailyCompetitiveStatsRollup_Response_RankBucketEntry| { &m.avg_damage },
                |m: &mut CMsgGC_DailyCompetitiveStatsRollup_Response_RankBucketEntry| { &mut m.avg_damage },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "stdev_damage",
                |m: &CMsgGC_DailyCompetitiveStatsRollup_Response_RankBucketEntry| { &m.stdev_damage },
                |m: &mut CMsgGC_DailyCompetitiveStatsRollup_Response_RankBucketEntry| { &mut m.stdev_damage },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "avg_healing",
                |m: &CMsgGC_DailyCompetitiveStatsRollup_Response_RankBucketEntry| { &m.avg_healing },
                |m: &mut CMsgGC_DailyCompetitiveStatsRollup_Response_RankBucketEntry| { &mut m.avg_healing },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "stdev_healing",
                |m: &CMsgGC_DailyCompetitiveStatsRollup_Response_RankBucketEntry| { &m.stdev_healing },
                |m: &mut CMsgGC_DailyCompetitiveStatsRollup_Response_RankBucketEntry| { &mut m.stdev_healing },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "avg_support",
                |m: &CMsgGC_DailyCompetitiveStatsRollup_Response_RankBucketEntry| { &m.avg_support },
                |m: &mut CMsgGC_DailyCompetitiveStatsRollup_Response_RankBucketEntry| { &mut m.avg_support },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "stdev_support",
                |m: &CMsgGC_DailyCompetitiveStatsRollup_Response_RankBucketEntry| { &m.stdev_support },
                |m: &mut CMsgGC_DailyCompetitiveStatsRollup_Response_RankBucketEntry| { &mut m.stdev_support },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGC_DailyCompetitiveStatsRollup_Response_RankBucketEntry>(
                "CMsgGC_DailyCompetitiveStatsRollup_Response.RankBucketEntry",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGC_DailyCompetitiveStatsRollup_Response_RankBucketEntry {
        static instance: ::protobuf::rt::LazyV2<CMsgGC_DailyCompetitiveStatsRollup_Response_RankBucketEntry> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGC_DailyCompetitiveStatsRollup_Response_RankBucketEntry::new)
    }
}

impl ::protobuf::Clear for CMsgGC_DailyCompetitiveStatsRollup_Response_RankBucketEntry {
    fn clear(&mut self) {
        self.rank = ::std::option::Option::None;
        self.records = ::std::option::Option::None;
        self.avg_score = ::std::option::Option::None;
        self.stdev_score = ::std::option::Option::None;
        self.avg_kills = ::std::option::Option::None;
        self.stdev_kills = ::std::option::Option::None;
        self.avg_damage = ::std::option::Option::None;
        self.stdev_damage = ::std::option::Option::None;
        self.avg_healing = ::std::option::Option::None;
        self.stdev_healing = ::std::option::Option::None;
        self.avg_support = ::std::option::Option::None;
        self.stdev_support = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGC_DailyCompetitiveStatsRollup_Response_RankBucketEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGC_DailyCompetitiveStatsRollup_Response_RankBucketEntry {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGC_ReportPlayer {
    // message fields
    account_id_target: ::std::option::Option<u32>,
    reason: ::std::option::Option<CMsgGC_ReportPlayer_EReason>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGC_ReportPlayer {
    fn default() -> &'a CMsgGC_ReportPlayer {
        <CMsgGC_ReportPlayer as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_ReportPlayer {
    pub fn new() -> CMsgGC_ReportPlayer {
        ::std::default::Default::default()
    }

    // optional uint32 account_id_target = 1;


    pub fn get_account_id_target(&self) -> u32 {
        self.account_id_target.unwrap_or(0)
    }
    pub fn clear_account_id_target(&mut self) {
        self.account_id_target = ::std::option::Option::None;
    }

    pub fn has_account_id_target(&self) -> bool {
        self.account_id_target.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id_target(&mut self, v: u32) {
        self.account_id_target = ::std::option::Option::Some(v);
    }

    // optional .CMsgGC_ReportPlayer.EReason reason = 2;


    pub fn get_reason(&self) -> CMsgGC_ReportPlayer_EReason {
        self.reason.unwrap_or(CMsgGC_ReportPlayer_EReason::kReason_INVALID)
    }
    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: CMsgGC_ReportPlayer_EReason) {
        self.reason = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGC_ReportPlayer {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id_target = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.reason, 2, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id_target {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.reason {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id_target {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.reason {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGC_ReportPlayer {
        CMsgGC_ReportPlayer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "account_id_target",
                |m: &CMsgGC_ReportPlayer| { &m.account_id_target },
                |m: &mut CMsgGC_ReportPlayer| { &mut m.account_id_target },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CMsgGC_ReportPlayer_EReason>>(
                "reason",
                |m: &CMsgGC_ReportPlayer| { &m.reason },
                |m: &mut CMsgGC_ReportPlayer| { &mut m.reason },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGC_ReportPlayer>(
                "CMsgGC_ReportPlayer",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGC_ReportPlayer {
        static instance: ::protobuf::rt::LazyV2<CMsgGC_ReportPlayer> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGC_ReportPlayer::new)
    }
}

impl ::protobuf::Clear for CMsgGC_ReportPlayer {
    fn clear(&mut self) {
        self.account_id_target = ::std::option::Option::None;
        self.reason = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGC_ReportPlayer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGC_ReportPlayer {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgGC_ReportPlayer_EReason {
    kReason_INVALID = 0,
    kReason_CHEATING = 1,
    kReason_IDLE = 2,
    kReason_HARASSMENT = 3,
    kReason_GRIEFING = 4,
    kReason_COUNT = 5,
}

impl ::protobuf::ProtobufEnum for CMsgGC_ReportPlayer_EReason {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgGC_ReportPlayer_EReason> {
        match value {
            0 => ::std::option::Option::Some(CMsgGC_ReportPlayer_EReason::kReason_INVALID),
            1 => ::std::option::Option::Some(CMsgGC_ReportPlayer_EReason::kReason_CHEATING),
            2 => ::std::option::Option::Some(CMsgGC_ReportPlayer_EReason::kReason_IDLE),
            3 => ::std::option::Option::Some(CMsgGC_ReportPlayer_EReason::kReason_HARASSMENT),
            4 => ::std::option::Option::Some(CMsgGC_ReportPlayer_EReason::kReason_GRIEFING),
            5 => ::std::option::Option::Some(CMsgGC_ReportPlayer_EReason::kReason_COUNT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgGC_ReportPlayer_EReason] = &[
            CMsgGC_ReportPlayer_EReason::kReason_INVALID,
            CMsgGC_ReportPlayer_EReason::kReason_CHEATING,
            CMsgGC_ReportPlayer_EReason::kReason_IDLE,
            CMsgGC_ReportPlayer_EReason::kReason_HARASSMENT,
            CMsgGC_ReportPlayer_EReason::kReason_GRIEFING,
            CMsgGC_ReportPlayer_EReason::kReason_COUNT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<CMsgGC_ReportPlayer_EReason>("CMsgGC_ReportPlayer.EReason", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for CMsgGC_ReportPlayer_EReason {
}

impl ::std::default::Default for CMsgGC_ReportPlayer_EReason {
    fn default() -> Self {
        CMsgGC_ReportPlayer_EReason::kReason_INVALID
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGC_ReportPlayer_EReason {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CSOTFMatchResultPlayerStats {
    // message fields
    match_id: ::std::option::Option<u64>,
    account_id: ::std::option::Option<u32>,
    match_group: ::std::option::Option<i32>,
    endtime: ::std::option::Option<u32>,
    season_id: ::std::option::Option<u32>,
    status: ::std::option::Option<u32>,
    original_party_id: ::std::option::Option<u32>,
    team: ::std::option::Option<u32>,
    score: ::std::option::Option<u32>,
    ping: ::std::option::Option<u32>,
    flags: ::std::option::Option<u32>,
    display_rating: ::std::option::Option<u32>,
    display_rating_change: ::std::option::Option<i32>,
    rank: ::std::option::Option<u32>,
    classes_played: ::std::option::Option<u32>,
    kills: ::std::option::Option<u32>,
    deaths: ::std::option::Option<u32>,
    damage: ::std::option::Option<u32>,
    healing: ::std::option::Option<u32>,
    support: ::std::option::Option<u32>,
    score_medal: ::std::option::Option<u32>,
    kills_medal: ::std::option::Option<u32>,
    damage_medal: ::std::option::Option<u32>,
    healing_medal: ::std::option::Option<u32>,
    support_medal: ::std::option::Option<u32>,
    map_index: ::std::option::Option<u32>,
    winning_team: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CSOTFMatchResultPlayerStats {
    fn default() -> &'a CSOTFMatchResultPlayerStats {
        <CSOTFMatchResultPlayerStats as ::protobuf::Message>::default_instance()
    }
}

impl CSOTFMatchResultPlayerStats {
    pub fn new() -> CSOTFMatchResultPlayerStats {
        ::std::default::Default::default()
    }

    // optional uint64 match_id = 1;


    pub fn get_match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }
    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional uint32 account_id = 2;


    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }
    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional int32 match_group = 3;


    pub fn get_match_group(&self) -> i32 {
        self.match_group.unwrap_or(0)
    }
    pub fn clear_match_group(&mut self) {
        self.match_group = ::std::option::Option::None;
    }

    pub fn has_match_group(&self) -> bool {
        self.match_group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_group(&mut self, v: i32) {
        self.match_group = ::std::option::Option::Some(v);
    }

    // optional uint32 endtime = 4;


    pub fn get_endtime(&self) -> u32 {
        self.endtime.unwrap_or(0)
    }
    pub fn clear_endtime(&mut self) {
        self.endtime = ::std::option::Option::None;
    }

    pub fn has_endtime(&self) -> bool {
        self.endtime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_endtime(&mut self, v: u32) {
        self.endtime = ::std::option::Option::Some(v);
    }

    // optional uint32 season_id = 5;


    pub fn get_season_id(&self) -> u32 {
        self.season_id.unwrap_or(0)
    }
    pub fn clear_season_id(&mut self) {
        self.season_id = ::std::option::Option::None;
    }

    pub fn has_season_id(&self) -> bool {
        self.season_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_season_id(&mut self, v: u32) {
        self.season_id = ::std::option::Option::Some(v);
    }

    // optional uint32 status = 6;


    pub fn get_status(&self) -> u32 {
        self.status.unwrap_or(0)
    }
    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: u32) {
        self.status = ::std::option::Option::Some(v);
    }

    // optional uint32 original_party_id = 7;


    pub fn get_original_party_id(&self) -> u32 {
        self.original_party_id.unwrap_or(0)
    }
    pub fn clear_original_party_id(&mut self) {
        self.original_party_id = ::std::option::Option::None;
    }

    pub fn has_original_party_id(&self) -> bool {
        self.original_party_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_original_party_id(&mut self, v: u32) {
        self.original_party_id = ::std::option::Option::Some(v);
    }

    // optional uint32 team = 8;


    pub fn get_team(&self) -> u32 {
        self.team.unwrap_or(0)
    }
    pub fn clear_team(&mut self) {
        self.team = ::std::option::Option::None;
    }

    pub fn has_team(&self) -> bool {
        self.team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team(&mut self, v: u32) {
        self.team = ::std::option::Option::Some(v);
    }

    // optional uint32 score = 9;


    pub fn get_score(&self) -> u32 {
        self.score.unwrap_or(0)
    }
    pub fn clear_score(&mut self) {
        self.score = ::std::option::Option::None;
    }

    pub fn has_score(&self) -> bool {
        self.score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_score(&mut self, v: u32) {
        self.score = ::std::option::Option::Some(v);
    }

    // optional uint32 ping = 10;


    pub fn get_ping(&self) -> u32 {
        self.ping.unwrap_or(0)
    }
    pub fn clear_ping(&mut self) {
        self.ping = ::std::option::Option::None;
    }

    pub fn has_ping(&self) -> bool {
        self.ping.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping(&mut self, v: u32) {
        self.ping = ::std::option::Option::Some(v);
    }

    // optional uint32 flags = 11;


    pub fn get_flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }
    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional uint32 display_rating = 12;


    pub fn get_display_rating(&self) -> u32 {
        self.display_rating.unwrap_or(0)
    }
    pub fn clear_display_rating(&mut self) {
        self.display_rating = ::std::option::Option::None;
    }

    pub fn has_display_rating(&self) -> bool {
        self.display_rating.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_rating(&mut self, v: u32) {
        self.display_rating = ::std::option::Option::Some(v);
    }

    // optional int32 display_rating_change = 13;


    pub fn get_display_rating_change(&self) -> i32 {
        self.display_rating_change.unwrap_or(0)
    }
    pub fn clear_display_rating_change(&mut self) {
        self.display_rating_change = ::std::option::Option::None;
    }

    pub fn has_display_rating_change(&self) -> bool {
        self.display_rating_change.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_rating_change(&mut self, v: i32) {
        self.display_rating_change = ::std::option::Option::Some(v);
    }

    // optional uint32 rank = 14;


    pub fn get_rank(&self) -> u32 {
        self.rank.unwrap_or(0)
    }
    pub fn clear_rank(&mut self) {
        self.rank = ::std::option::Option::None;
    }

    pub fn has_rank(&self) -> bool {
        self.rank.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rank(&mut self, v: u32) {
        self.rank = ::std::option::Option::Some(v);
    }

    // optional uint32 classes_played = 15;


    pub fn get_classes_played(&self) -> u32 {
        self.classes_played.unwrap_or(0)
    }
    pub fn clear_classes_played(&mut self) {
        self.classes_played = ::std::option::Option::None;
    }

    pub fn has_classes_played(&self) -> bool {
        self.classes_played.is_some()
    }

    // Param is passed by value, moved
    pub fn set_classes_played(&mut self, v: u32) {
        self.classes_played = ::std::option::Option::Some(v);
    }

    // optional uint32 kills = 16;


    pub fn get_kills(&self) -> u32 {
        self.kills.unwrap_or(0)
    }
    pub fn clear_kills(&mut self) {
        self.kills = ::std::option::Option::None;
    }

    pub fn has_kills(&self) -> bool {
        self.kills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kills(&mut self, v: u32) {
        self.kills = ::std::option::Option::Some(v);
    }

    // optional uint32 deaths = 17;


    pub fn get_deaths(&self) -> u32 {
        self.deaths.unwrap_or(0)
    }
    pub fn clear_deaths(&mut self) {
        self.deaths = ::std::option::Option::None;
    }

    pub fn has_deaths(&self) -> bool {
        self.deaths.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deaths(&mut self, v: u32) {
        self.deaths = ::std::option::Option::Some(v);
    }

    // optional uint32 damage = 18;


    pub fn get_damage(&self) -> u32 {
        self.damage.unwrap_or(0)
    }
    pub fn clear_damage(&mut self) {
        self.damage = ::std::option::Option::None;
    }

    pub fn has_damage(&self) -> bool {
        self.damage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_damage(&mut self, v: u32) {
        self.damage = ::std::option::Option::Some(v);
    }

    // optional uint32 healing = 19;


    pub fn get_healing(&self) -> u32 {
        self.healing.unwrap_or(0)
    }
    pub fn clear_healing(&mut self) {
        self.healing = ::std::option::Option::None;
    }

    pub fn has_healing(&self) -> bool {
        self.healing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_healing(&mut self, v: u32) {
        self.healing = ::std::option::Option::Some(v);
    }

    // optional uint32 support = 20;


    pub fn get_support(&self) -> u32 {
        self.support.unwrap_or(0)
    }
    pub fn clear_support(&mut self) {
        self.support = ::std::option::Option::None;
    }

    pub fn has_support(&self) -> bool {
        self.support.is_some()
    }

    // Param is passed by value, moved
    pub fn set_support(&mut self, v: u32) {
        self.support = ::std::option::Option::Some(v);
    }

    // optional uint32 score_medal = 21;


    pub fn get_score_medal(&self) -> u32 {
        self.score_medal.unwrap_or(0)
    }
    pub fn clear_score_medal(&mut self) {
        self.score_medal = ::std::option::Option::None;
    }

    pub fn has_score_medal(&self) -> bool {
        self.score_medal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_score_medal(&mut self, v: u32) {
        self.score_medal = ::std::option::Option::Some(v);
    }

    // optional uint32 kills_medal = 22;


    pub fn get_kills_medal(&self) -> u32 {
        self.kills_medal.unwrap_or(0)
    }
    pub fn clear_kills_medal(&mut self) {
        self.kills_medal = ::std::option::Option::None;
    }

    pub fn has_kills_medal(&self) -> bool {
        self.kills_medal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kills_medal(&mut self, v: u32) {
        self.kills_medal = ::std::option::Option::Some(v);
    }

    // optional uint32 damage_medal = 23;


    pub fn get_damage_medal(&self) -> u32 {
        self.damage_medal.unwrap_or(0)
    }
    pub fn clear_damage_medal(&mut self) {
        self.damage_medal = ::std::option::Option::None;
    }

    pub fn has_damage_medal(&self) -> bool {
        self.damage_medal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_damage_medal(&mut self, v: u32) {
        self.damage_medal = ::std::option::Option::Some(v);
    }

    // optional uint32 healing_medal = 24;


    pub fn get_healing_medal(&self) -> u32 {
        self.healing_medal.unwrap_or(0)
    }
    pub fn clear_healing_medal(&mut self) {
        self.healing_medal = ::std::option::Option::None;
    }

    pub fn has_healing_medal(&self) -> bool {
        self.healing_medal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_healing_medal(&mut self, v: u32) {
        self.healing_medal = ::std::option::Option::Some(v);
    }

    // optional uint32 support_medal = 25;


    pub fn get_support_medal(&self) -> u32 {
        self.support_medal.unwrap_or(0)
    }
    pub fn clear_support_medal(&mut self) {
        self.support_medal = ::std::option::Option::None;
    }

    pub fn has_support_medal(&self) -> bool {
        self.support_medal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_support_medal(&mut self, v: u32) {
        self.support_medal = ::std::option::Option::Some(v);
    }

    // optional uint32 map_index = 26;


    pub fn get_map_index(&self) -> u32 {
        self.map_index.unwrap_or(0)
    }
    pub fn clear_map_index(&mut self) {
        self.map_index = ::std::option::Option::None;
    }

    pub fn has_map_index(&self) -> bool {
        self.map_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map_index(&mut self, v: u32) {
        self.map_index = ::std::option::Option::Some(v);
    }

    // optional uint32 winning_team = 27;


    pub fn get_winning_team(&self) -> u32 {
        self.winning_team.unwrap_or(0)
    }
    pub fn clear_winning_team(&mut self) {
        self.winning_team = ::std::option::Option::None;
    }

    pub fn has_winning_team(&self) -> bool {
        self.winning_team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_winning_team(&mut self, v: u32) {
        self.winning_team = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CSOTFMatchResultPlayerStats {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.match_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.match_group = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.endtime = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.season_id = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.status = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.original_party_id = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.team = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.score = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ping = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.flags = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.display_rating = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.display_rating_change = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rank = ::std::option::Option::Some(tmp);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.classes_played = ::std::option::Option::Some(tmp);
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.kills = ::std::option::Option::Some(tmp);
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.deaths = ::std::option::Option::Some(tmp);
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.damage = ::std::option::Option::Some(tmp);
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.healing = ::std::option::Option::Some(tmp);
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.support = ::std::option::Option::Some(tmp);
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.score_medal = ::std::option::Option::Some(tmp);
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.kills_medal = ::std::option::Option::Some(tmp);
                },
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.damage_medal = ::std::option::Option::Some(tmp);
                },
                24 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.healing_medal = ::std::option::Option::Some(tmp);
                },
                25 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.support_medal = ::std::option::Option::Some(tmp);
                },
                26 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.map_index = ::std::option::Option::Some(tmp);
                },
                27 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.winning_team = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.match_group {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.endtime {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.season_id {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.original_party_id {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.team {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.score {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ping {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.display_rating {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.display_rating_change {
            my_size += ::protobuf::rt::value_size(13, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rank {
            my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.classes_played {
            my_size += ::protobuf::rt::value_size(15, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.kills {
            my_size += ::protobuf::rt::value_size(16, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.deaths {
            my_size += ::protobuf::rt::value_size(17, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.damage {
            my_size += ::protobuf::rt::value_size(18, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.healing {
            my_size += ::protobuf::rt::value_size(19, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.support {
            my_size += ::protobuf::rt::value_size(20, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.score_medal {
            my_size += ::protobuf::rt::value_size(21, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.kills_medal {
            my_size += ::protobuf::rt::value_size(22, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.damage_medal {
            my_size += ::protobuf::rt::value_size(23, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.healing_medal {
            my_size += ::protobuf::rt::value_size(24, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.support_medal {
            my_size += ::protobuf::rt::value_size(25, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.map_index {
            my_size += ::protobuf::rt::value_size(26, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.winning_team {
            my_size += ::protobuf::rt::value_size(27, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.account_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.match_group {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.endtime {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.season_id {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.status {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.original_party_id {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.team {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.score {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.ping {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.flags {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.display_rating {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.display_rating_change {
            os.write_int32(13, v)?;
        }
        if let Some(v) = self.rank {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.classes_played {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.kills {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.deaths {
            os.write_uint32(17, v)?;
        }
        if let Some(v) = self.damage {
            os.write_uint32(18, v)?;
        }
        if let Some(v) = self.healing {
            os.write_uint32(19, v)?;
        }
        if let Some(v) = self.support {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.score_medal {
            os.write_uint32(21, v)?;
        }
        if let Some(v) = self.kills_medal {
            os.write_uint32(22, v)?;
        }
        if let Some(v) = self.damage_medal {
            os.write_uint32(23, v)?;
        }
        if let Some(v) = self.healing_medal {
            os.write_uint32(24, v)?;
        }
        if let Some(v) = self.support_medal {
            os.write_uint32(25, v)?;
        }
        if let Some(v) = self.map_index {
            os.write_uint32(26, v)?;
        }
        if let Some(v) = self.winning_team {
            os.write_uint32(27, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CSOTFMatchResultPlayerStats {
        CSOTFMatchResultPlayerStats::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "match_id",
                |m: &CSOTFMatchResultPlayerStats| { &m.match_id },
                |m: &mut CSOTFMatchResultPlayerStats| { &mut m.match_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "account_id",
                |m: &CSOTFMatchResultPlayerStats| { &m.account_id },
                |m: &mut CSOTFMatchResultPlayerStats| { &mut m.account_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "match_group",
                |m: &CSOTFMatchResultPlayerStats| { &m.match_group },
                |m: &mut CSOTFMatchResultPlayerStats| { &mut m.match_group },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "endtime",
                |m: &CSOTFMatchResultPlayerStats| { &m.endtime },
                |m: &mut CSOTFMatchResultPlayerStats| { &mut m.endtime },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "season_id",
                |m: &CSOTFMatchResultPlayerStats| { &m.season_id },
                |m: &mut CSOTFMatchResultPlayerStats| { &mut m.season_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "status",
                |m: &CSOTFMatchResultPlayerStats| { &m.status },
                |m: &mut CSOTFMatchResultPlayerStats| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "original_party_id",
                |m: &CSOTFMatchResultPlayerStats| { &m.original_party_id },
                |m: &mut CSOTFMatchResultPlayerStats| { &mut m.original_party_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "team",
                |m: &CSOTFMatchResultPlayerStats| { &m.team },
                |m: &mut CSOTFMatchResultPlayerStats| { &mut m.team },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "score",
                |m: &CSOTFMatchResultPlayerStats| { &m.score },
                |m: &mut CSOTFMatchResultPlayerStats| { &mut m.score },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ping",
                |m: &CSOTFMatchResultPlayerStats| { &m.ping },
                |m: &mut CSOTFMatchResultPlayerStats| { &mut m.ping },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "flags",
                |m: &CSOTFMatchResultPlayerStats| { &m.flags },
                |m: &mut CSOTFMatchResultPlayerStats| { &mut m.flags },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "display_rating",
                |m: &CSOTFMatchResultPlayerStats| { &m.display_rating },
                |m: &mut CSOTFMatchResultPlayerStats| { &mut m.display_rating },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "display_rating_change",
                |m: &CSOTFMatchResultPlayerStats| { &m.display_rating_change },
                |m: &mut CSOTFMatchResultPlayerStats| { &mut m.display_rating_change },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "rank",
                |m: &CSOTFMatchResultPlayerStats| { &m.rank },
                |m: &mut CSOTFMatchResultPlayerStats| { &mut m.rank },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "classes_played",
                |m: &CSOTFMatchResultPlayerStats| { &m.classes_played },
                |m: &mut CSOTFMatchResultPlayerStats| { &mut m.classes_played },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "kills",
                |m: &CSOTFMatchResultPlayerStats| { &m.kills },
                |m: &mut CSOTFMatchResultPlayerStats| { &mut m.kills },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "deaths",
                |m: &CSOTFMatchResultPlayerStats| { &m.deaths },
                |m: &mut CSOTFMatchResultPlayerStats| { &mut m.deaths },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "damage",
                |m: &CSOTFMatchResultPlayerStats| { &m.damage },
                |m: &mut CSOTFMatchResultPlayerStats| { &mut m.damage },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "healing",
                |m: &CSOTFMatchResultPlayerStats| { &m.healing },
                |m: &mut CSOTFMatchResultPlayerStats| { &mut m.healing },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "support",
                |m: &CSOTFMatchResultPlayerStats| { &m.support },
                |m: &mut CSOTFMatchResultPlayerStats| { &mut m.support },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "score_medal",
                |m: &CSOTFMatchResultPlayerStats| { &m.score_medal },
                |m: &mut CSOTFMatchResultPlayerStats| { &mut m.score_medal },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "kills_medal",
                |m: &CSOTFMatchResultPlayerStats| { &m.kills_medal },
                |m: &mut CSOTFMatchResultPlayerStats| { &mut m.kills_medal },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "damage_medal",
                |m: &CSOTFMatchResultPlayerStats| { &m.damage_medal },
                |m: &mut CSOTFMatchResultPlayerStats| { &mut m.damage_medal },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "healing_medal",
                |m: &CSOTFMatchResultPlayerStats| { &m.healing_medal },
                |m: &mut CSOTFMatchResultPlayerStats| { &mut m.healing_medal },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "support_medal",
                |m: &CSOTFMatchResultPlayerStats| { &m.support_medal },
                |m: &mut CSOTFMatchResultPlayerStats| { &mut m.support_medal },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "map_index",
                |m: &CSOTFMatchResultPlayerStats| { &m.map_index },
                |m: &mut CSOTFMatchResultPlayerStats| { &mut m.map_index },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "winning_team",
                |m: &CSOTFMatchResultPlayerStats| { &m.winning_team },
                |m: &mut CSOTFMatchResultPlayerStats| { &mut m.winning_team },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CSOTFMatchResultPlayerStats>(
                "CSOTFMatchResultPlayerStats",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CSOTFMatchResultPlayerStats {
        static instance: ::protobuf::rt::LazyV2<CSOTFMatchResultPlayerStats> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CSOTFMatchResultPlayerStats::new)
    }
}

impl ::protobuf::Clear for CSOTFMatchResultPlayerStats {
    fn clear(&mut self) {
        self.match_id = ::std::option::Option::None;
        self.account_id = ::std::option::Option::None;
        self.match_group = ::std::option::Option::None;
        self.endtime = ::std::option::Option::None;
        self.season_id = ::std::option::Option::None;
        self.status = ::std::option::Option::None;
        self.original_party_id = ::std::option::Option::None;
        self.team = ::std::option::Option::None;
        self.score = ::std::option::Option::None;
        self.ping = ::std::option::Option::None;
        self.flags = ::std::option::Option::None;
        self.display_rating = ::std::option::Option::None;
        self.display_rating_change = ::std::option::Option::None;
        self.rank = ::std::option::Option::None;
        self.classes_played = ::std::option::Option::None;
        self.kills = ::std::option::Option::None;
        self.deaths = ::std::option::Option::None;
        self.damage = ::std::option::Option::None;
        self.healing = ::std::option::Option::None;
        self.support = ::std::option::Option::None;
        self.score_medal = ::std::option::Option::None;
        self.kills_medal = ::std::option::Option::None;
        self.damage_medal = ::std::option::Option::None;
        self.healing_medal = ::std::option::Option::None;
        self.support_medal = ::std::option::Option::None;
        self.map_index = ::std::option::Option::None;
        self.winning_team = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSOTFMatchResultPlayerStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOTFMatchResultPlayerStats {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCRequestMatchMakerStats {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCRequestMatchMakerStats {
    fn default() -> &'a CMsgGCRequestMatchMakerStats {
        <CMsgGCRequestMatchMakerStats as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCRequestMatchMakerStats {
    pub fn new() -> CMsgGCRequestMatchMakerStats {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgGCRequestMatchMakerStats {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCRequestMatchMakerStats {
        CMsgGCRequestMatchMakerStats::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCRequestMatchMakerStats>(
                "CMsgGCRequestMatchMakerStats",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCRequestMatchMakerStats {
        static instance: ::protobuf::rt::LazyV2<CMsgGCRequestMatchMakerStats> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCRequestMatchMakerStats::new)
    }
}

impl ::protobuf::Clear for CMsgGCRequestMatchMakerStats {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCRequestMatchMakerStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCRequestMatchMakerStats {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCDataCenterPopulation {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    health_ratio: ::std::option::Option<f32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCDataCenterPopulation {
    fn default() -> &'a CMsgGCDataCenterPopulation {
        <CMsgGCDataCenterPopulation as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCDataCenterPopulation {
    pub fn new() -> CMsgGCDataCenterPopulation {
        ::std::default::Default::default()
    }

    // optional string name = 1;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional float health_ratio = 2;


    pub fn get_health_ratio(&self) -> f32 {
        self.health_ratio.unwrap_or(0.)
    }
    pub fn clear_health_ratio(&mut self) {
        self.health_ratio = ::std::option::Option::None;
    }

    pub fn has_health_ratio(&self) -> bool {
        self.health_ratio.is_some()
    }

    // Param is passed by value, moved
    pub fn set_health_ratio(&mut self, v: f32) {
        self.health_ratio = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCDataCenterPopulation {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.health_ratio = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.health_ratio {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.health_ratio {
            os.write_float(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCDataCenterPopulation {
        CMsgGCDataCenterPopulation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &CMsgGCDataCenterPopulation| { &m.name },
                |m: &mut CMsgGCDataCenterPopulation| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "health_ratio",
                |m: &CMsgGCDataCenterPopulation| { &m.health_ratio },
                |m: &mut CMsgGCDataCenterPopulation| { &mut m.health_ratio },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCDataCenterPopulation>(
                "CMsgGCDataCenterPopulation",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCDataCenterPopulation {
        static instance: ::protobuf::rt::LazyV2<CMsgGCDataCenterPopulation> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCDataCenterPopulation::new)
    }
}

impl ::protobuf::Clear for CMsgGCDataCenterPopulation {
    fn clear(&mut self) {
        self.name.clear();
        self.health_ratio = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCDataCenterPopulation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCDataCenterPopulation {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCMatchGroupDataCenterPopulation {
    // message fields
    pub data_center_population: ::protobuf::RepeatedField<CMsgGCDataCenterPopulation>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCMatchGroupDataCenterPopulation {
    fn default() -> &'a CMsgGCMatchGroupDataCenterPopulation {
        <CMsgGCMatchGroupDataCenterPopulation as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCMatchGroupDataCenterPopulation {
    pub fn new() -> CMsgGCMatchGroupDataCenterPopulation {
        ::std::default::Default::default()
    }

    // repeated .CMsgGCDataCenterPopulation data_center_population = 1;


    pub fn get_data_center_population(&self) -> &[CMsgGCDataCenterPopulation] {
        &self.data_center_population
    }
    pub fn clear_data_center_population(&mut self) {
        self.data_center_population.clear();
    }

    // Param is passed by value, moved
    pub fn set_data_center_population(&mut self, v: ::protobuf::RepeatedField<CMsgGCDataCenterPopulation>) {
        self.data_center_population = v;
    }

    // Mutable pointer to the field.
    pub fn mut_data_center_population(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGCDataCenterPopulation> {
        &mut self.data_center_population
    }

    // Take field
    pub fn take_data_center_population(&mut self) -> ::protobuf::RepeatedField<CMsgGCDataCenterPopulation> {
        ::std::mem::replace(&mut self.data_center_population, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgGCMatchGroupDataCenterPopulation {
    fn is_initialized(&self) -> bool {
        for v in &self.data_center_population {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.data_center_population)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.data_center_population {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.data_center_population {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCMatchGroupDataCenterPopulation {
        CMsgGCMatchGroupDataCenterPopulation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCDataCenterPopulation>>(
                "data_center_population",
                |m: &CMsgGCMatchGroupDataCenterPopulation| { &m.data_center_population },
                |m: &mut CMsgGCMatchGroupDataCenterPopulation| { &mut m.data_center_population },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCMatchGroupDataCenterPopulation>(
                "CMsgGCMatchGroupDataCenterPopulation",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCMatchGroupDataCenterPopulation {
        static instance: ::protobuf::rt::LazyV2<CMsgGCMatchGroupDataCenterPopulation> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCMatchGroupDataCenterPopulation::new)
    }
}

impl ::protobuf::Clear for CMsgGCMatchGroupDataCenterPopulation {
    fn clear(&mut self) {
        self.data_center_population.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCMatchGroupDataCenterPopulation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCMatchGroupDataCenterPopulation {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCMatchMakerStatsResponse {
    // message fields
    pub map_count: ::std::vec::Vec<u32>,
    pub matchgroup_data_center_population: ::protobuf::RepeatedField<CMsgGCMatchGroupDataCenterPopulation>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCMatchMakerStatsResponse {
    fn default() -> &'a CMsgGCMatchMakerStatsResponse {
        <CMsgGCMatchMakerStatsResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCMatchMakerStatsResponse {
    pub fn new() -> CMsgGCMatchMakerStatsResponse {
        ::std::default::Default::default()
    }

    // repeated uint32 map_count = 1;


    pub fn get_map_count(&self) -> &[u32] {
        &self.map_count
    }
    pub fn clear_map_count(&mut self) {
        self.map_count.clear();
    }

    // Param is passed by value, moved
    pub fn set_map_count(&mut self, v: ::std::vec::Vec<u32>) {
        self.map_count = v;
    }

    // Mutable pointer to the field.
    pub fn mut_map_count(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.map_count
    }

    // Take field
    pub fn take_map_count(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.map_count, ::std::vec::Vec::new())
    }

    // repeated .CMsgGCMatchGroupDataCenterPopulation matchgroup_data_center_population = 2;


    pub fn get_matchgroup_data_center_population(&self) -> &[CMsgGCMatchGroupDataCenterPopulation] {
        &self.matchgroup_data_center_population
    }
    pub fn clear_matchgroup_data_center_population(&mut self) {
        self.matchgroup_data_center_population.clear();
    }

    // Param is passed by value, moved
    pub fn set_matchgroup_data_center_population(&mut self, v: ::protobuf::RepeatedField<CMsgGCMatchGroupDataCenterPopulation>) {
        self.matchgroup_data_center_population = v;
    }

    // Mutable pointer to the field.
    pub fn mut_matchgroup_data_center_population(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGCMatchGroupDataCenterPopulation> {
        &mut self.matchgroup_data_center_population
    }

    // Take field
    pub fn take_matchgroup_data_center_population(&mut self) -> ::protobuf::RepeatedField<CMsgGCMatchGroupDataCenterPopulation> {
        ::std::mem::replace(&mut self.matchgroup_data_center_population, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgGCMatchMakerStatsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.matchgroup_data_center_population {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.map_count)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.matchgroup_data_center_population)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.map_count {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.matchgroup_data_center_population {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.map_count {
            os.write_uint32(1, *v)?;
        };
        for v in &self.matchgroup_data_center_population {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCMatchMakerStatsResponse {
        CMsgGCMatchMakerStatsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "map_count",
                |m: &CMsgGCMatchMakerStatsResponse| { &m.map_count },
                |m: &mut CMsgGCMatchMakerStatsResponse| { &mut m.map_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCMatchGroupDataCenterPopulation>>(
                "matchgroup_data_center_population",
                |m: &CMsgGCMatchMakerStatsResponse| { &m.matchgroup_data_center_population },
                |m: &mut CMsgGCMatchMakerStatsResponse| { &mut m.matchgroup_data_center_population },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCMatchMakerStatsResponse>(
                "CMsgGCMatchMakerStatsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCMatchMakerStatsResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgGCMatchMakerStatsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCMatchMakerStatsResponse::new)
    }
}

impl ::protobuf::Clear for CMsgGCMatchMakerStatsResponse {
    fn clear(&mut self) {
        self.map_count.clear();
        self.matchgroup_data_center_population.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCMatchMakerStatsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCMatchMakerStatsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCMatchHistoryLoad {
    // message fields
    match_group: ::std::option::Option<ETFMatchGroup>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCMatchHistoryLoad {
    fn default() -> &'a CMsgGCMatchHistoryLoad {
        <CMsgGCMatchHistoryLoad as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCMatchHistoryLoad {
    pub fn new() -> CMsgGCMatchHistoryLoad {
        ::std::default::Default::default()
    }

    // optional .ETFMatchGroup match_group = 1;


    pub fn get_match_group(&self) -> ETFMatchGroup {
        self.match_group.unwrap_or(ETFMatchGroup::k_eTFMatchGroup_Invalid)
    }
    pub fn clear_match_group(&mut self) {
        self.match_group = ::std::option::Option::None;
    }

    pub fn has_match_group(&self) -> bool {
        self.match_group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_group(&mut self, v: ETFMatchGroup) {
        self.match_group = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCMatchHistoryLoad {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.match_group, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.match_group {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.match_group {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCMatchHistoryLoad {
        CMsgGCMatchHistoryLoad::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ETFMatchGroup>>(
                "match_group",
                |m: &CMsgGCMatchHistoryLoad| { &m.match_group },
                |m: &mut CMsgGCMatchHistoryLoad| { &mut m.match_group },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCMatchHistoryLoad>(
                "CMsgGCMatchHistoryLoad",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCMatchHistoryLoad {
        static instance: ::protobuf::rt::LazyV2<CMsgGCMatchHistoryLoad> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCMatchHistoryLoad::new)
    }
}

impl ::protobuf::Clear for CMsgGCMatchHistoryLoad {
    fn clear(&mut self) {
        self.match_group = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCMatchHistoryLoad {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCMatchHistoryLoad {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCDataCenterPing_Update {
    // message fields
    pub pingdata: ::protobuf::RepeatedField<CMsgGCDataCenterPing_Update_PingEntry>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCDataCenterPing_Update {
    fn default() -> &'a CMsgGCDataCenterPing_Update {
        <CMsgGCDataCenterPing_Update as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCDataCenterPing_Update {
    pub fn new() -> CMsgGCDataCenterPing_Update {
        ::std::default::Default::default()
    }

    // repeated .CMsgGCDataCenterPing_Update.PingEntry pingdata = 1;


    pub fn get_pingdata(&self) -> &[CMsgGCDataCenterPing_Update_PingEntry] {
        &self.pingdata
    }
    pub fn clear_pingdata(&mut self) {
        self.pingdata.clear();
    }

    // Param is passed by value, moved
    pub fn set_pingdata(&mut self, v: ::protobuf::RepeatedField<CMsgGCDataCenterPing_Update_PingEntry>) {
        self.pingdata = v;
    }

    // Mutable pointer to the field.
    pub fn mut_pingdata(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGCDataCenterPing_Update_PingEntry> {
        &mut self.pingdata
    }

    // Take field
    pub fn take_pingdata(&mut self) -> ::protobuf::RepeatedField<CMsgGCDataCenterPing_Update_PingEntry> {
        ::std::mem::replace(&mut self.pingdata, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgGCDataCenterPing_Update {
    fn is_initialized(&self) -> bool {
        for v in &self.pingdata {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.pingdata)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.pingdata {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.pingdata {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCDataCenterPing_Update {
        CMsgGCDataCenterPing_Update::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCDataCenterPing_Update_PingEntry>>(
                "pingdata",
                |m: &CMsgGCDataCenterPing_Update| { &m.pingdata },
                |m: &mut CMsgGCDataCenterPing_Update| { &mut m.pingdata },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCDataCenterPing_Update>(
                "CMsgGCDataCenterPing_Update",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCDataCenterPing_Update {
        static instance: ::protobuf::rt::LazyV2<CMsgGCDataCenterPing_Update> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCDataCenterPing_Update::new)
    }
}

impl ::protobuf::Clear for CMsgGCDataCenterPing_Update {
    fn clear(&mut self) {
        self.pingdata.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCDataCenterPing_Update {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCDataCenterPing_Update {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCDataCenterPing_Update_PingEntry {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    ping: ::std::option::Option<u32>,
    ping_status: ::std::option::Option<CMsgGCDataCenterPing_Update_Status>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCDataCenterPing_Update_PingEntry {
    fn default() -> &'a CMsgGCDataCenterPing_Update_PingEntry {
        <CMsgGCDataCenterPing_Update_PingEntry as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCDataCenterPing_Update_PingEntry {
    pub fn new() -> CMsgGCDataCenterPing_Update_PingEntry {
        ::std::default::Default::default()
    }

    // optional string name = 1;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 ping = 2;


    pub fn get_ping(&self) -> u32 {
        self.ping.unwrap_or(0)
    }
    pub fn clear_ping(&mut self) {
        self.ping = ::std::option::Option::None;
    }

    pub fn has_ping(&self) -> bool {
        self.ping.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping(&mut self, v: u32) {
        self.ping = ::std::option::Option::Some(v);
    }

    // optional .CMsgGCDataCenterPing_Update.Status ping_status = 3;


    pub fn get_ping_status(&self) -> CMsgGCDataCenterPing_Update_Status {
        self.ping_status.unwrap_or(CMsgGCDataCenterPing_Update_Status::Normal)
    }
    pub fn clear_ping_status(&mut self) {
        self.ping_status = ::std::option::Option::None;
    }

    pub fn has_ping_status(&self) -> bool {
        self.ping_status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping_status(&mut self, v: CMsgGCDataCenterPing_Update_Status) {
        self.ping_status = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCDataCenterPing_Update_PingEntry {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ping = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.ping_status, 3, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.ping {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ping_status {
            my_size += ::protobuf::rt::enum_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.ping {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.ping_status {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCDataCenterPing_Update_PingEntry {
        CMsgGCDataCenterPing_Update_PingEntry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &CMsgGCDataCenterPing_Update_PingEntry| { &m.name },
                |m: &mut CMsgGCDataCenterPing_Update_PingEntry| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ping",
                |m: &CMsgGCDataCenterPing_Update_PingEntry| { &m.ping },
                |m: &mut CMsgGCDataCenterPing_Update_PingEntry| { &mut m.ping },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CMsgGCDataCenterPing_Update_Status>>(
                "ping_status",
                |m: &CMsgGCDataCenterPing_Update_PingEntry| { &m.ping_status },
                |m: &mut CMsgGCDataCenterPing_Update_PingEntry| { &mut m.ping_status },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCDataCenterPing_Update_PingEntry>(
                "CMsgGCDataCenterPing_Update.PingEntry",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCDataCenterPing_Update_PingEntry {
        static instance: ::protobuf::rt::LazyV2<CMsgGCDataCenterPing_Update_PingEntry> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCDataCenterPing_Update_PingEntry::new)
    }
}

impl ::protobuf::Clear for CMsgGCDataCenterPing_Update_PingEntry {
    fn clear(&mut self) {
        self.name.clear();
        self.ping = ::std::option::Option::None;
        self.ping_status = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCDataCenterPing_Update_PingEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCDataCenterPing_Update_PingEntry {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgGCDataCenterPing_Update_Status {
    Invalid = 0,
    Normal = 1,
    Unreachable = 2,
    FallbackToDCPing = 3,
}

impl ::protobuf::ProtobufEnum for CMsgGCDataCenterPing_Update_Status {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgGCDataCenterPing_Update_Status> {
        match value {
            0 => ::std::option::Option::Some(CMsgGCDataCenterPing_Update_Status::Invalid),
            1 => ::std::option::Option::Some(CMsgGCDataCenterPing_Update_Status::Normal),
            2 => ::std::option::Option::Some(CMsgGCDataCenterPing_Update_Status::Unreachable),
            3 => ::std::option::Option::Some(CMsgGCDataCenterPing_Update_Status::FallbackToDCPing),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgGCDataCenterPing_Update_Status] = &[
            CMsgGCDataCenterPing_Update_Status::Invalid,
            CMsgGCDataCenterPing_Update_Status::Normal,
            CMsgGCDataCenterPing_Update_Status::Unreachable,
            CMsgGCDataCenterPing_Update_Status::FallbackToDCPing,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<CMsgGCDataCenterPing_Update_Status>("CMsgGCDataCenterPing_Update.Status", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for CMsgGCDataCenterPing_Update_Status {
}

impl ::std::default::Default for CMsgGCDataCenterPing_Update_Status {
    fn default() -> Self {
        CMsgGCDataCenterPing_Update_Status::Invalid
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCDataCenterPing_Update_Status {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGC_KickPlayerFromLobby {
    // message fields
    targetID: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGC_KickPlayerFromLobby {
    fn default() -> &'a CMsgGC_KickPlayerFromLobby {
        <CMsgGC_KickPlayerFromLobby as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_KickPlayerFromLobby {
    pub fn new() -> CMsgGC_KickPlayerFromLobby {
        ::std::default::Default::default()
    }

    // optional uint64 targetID = 1;


    pub fn get_targetID(&self) -> u64 {
        self.targetID.unwrap_or(0)
    }
    pub fn clear_targetID(&mut self) {
        self.targetID = ::std::option::Option::None;
    }

    pub fn has_targetID(&self) -> bool {
        self.targetID.is_some()
    }

    // Param is passed by value, moved
    pub fn set_targetID(&mut self, v: u64) {
        self.targetID = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGC_KickPlayerFromLobby {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.targetID = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.targetID {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.targetID {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGC_KickPlayerFromLobby {
        CMsgGC_KickPlayerFromLobby::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "targetID",
                |m: &CMsgGC_KickPlayerFromLobby| { &m.targetID },
                |m: &mut CMsgGC_KickPlayerFromLobby| { &mut m.targetID },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGC_KickPlayerFromLobby>(
                "CMsgGC_KickPlayerFromLobby",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGC_KickPlayerFromLobby {
        static instance: ::protobuf::rt::LazyV2<CMsgGC_KickPlayerFromLobby> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGC_KickPlayerFromLobby::new)
    }
}

impl ::protobuf::Clear for CMsgGC_KickPlayerFromLobby {
    fn clear(&mut self) {
        self.targetID = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGC_KickPlayerFromLobby {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGC_KickPlayerFromLobby {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCSurveyRequest {
    // message fields
    question_type: ::std::option::Option<SurveyQuestionType>,
    match_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCSurveyRequest {
    fn default() -> &'a CMsgGCSurveyRequest {
        <CMsgGCSurveyRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCSurveyRequest {
    pub fn new() -> CMsgGCSurveyRequest {
        ::std::default::Default::default()
    }

    // optional .SurveyQuestionType question_type = 1;


    pub fn get_question_type(&self) -> SurveyQuestionType {
        self.question_type.unwrap_or(SurveyQuestionType::QUESTION_MATCH_QUALITY)
    }
    pub fn clear_question_type(&mut self) {
        self.question_type = ::std::option::Option::None;
    }

    pub fn has_question_type(&self) -> bool {
        self.question_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_question_type(&mut self, v: SurveyQuestionType) {
        self.question_type = ::std::option::Option::Some(v);
    }

    // optional uint64 match_id = 2;


    pub fn get_match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }
    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCSurveyRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.question_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.match_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.question_type {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.question_type {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.match_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCSurveyRequest {
        CMsgGCSurveyRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<SurveyQuestionType>>(
                "question_type",
                |m: &CMsgGCSurveyRequest| { &m.question_type },
                |m: &mut CMsgGCSurveyRequest| { &mut m.question_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "match_id",
                |m: &CMsgGCSurveyRequest| { &m.match_id },
                |m: &mut CMsgGCSurveyRequest| { &mut m.match_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCSurveyRequest>(
                "CMsgGCSurveyRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCSurveyRequest {
        static instance: ::protobuf::rt::LazyV2<CMsgGCSurveyRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCSurveyRequest::new)
    }
}

impl ::protobuf::Clear for CMsgGCSurveyRequest {
    fn clear(&mut self) {
        self.question_type = ::std::option::Option::None;
        self.match_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCSurveyRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCSurveyRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCSurveyResponse {
    // message fields
    question_type: ::std::option::Option<SurveyQuestionType>,
    match_id: ::std::option::Option<u64>,
    response: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCSurveyResponse {
    fn default() -> &'a CMsgGCSurveyResponse {
        <CMsgGCSurveyResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCSurveyResponse {
    pub fn new() -> CMsgGCSurveyResponse {
        ::std::default::Default::default()
    }

    // optional .SurveyQuestionType question_type = 1;


    pub fn get_question_type(&self) -> SurveyQuestionType {
        self.question_type.unwrap_or(SurveyQuestionType::QUESTION_MATCH_QUALITY)
    }
    pub fn clear_question_type(&mut self) {
        self.question_type = ::std::option::Option::None;
    }

    pub fn has_question_type(&self) -> bool {
        self.question_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_question_type(&mut self, v: SurveyQuestionType) {
        self.question_type = ::std::option::Option::Some(v);
    }

    // optional uint64 match_id = 2;


    pub fn get_match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }
    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional int32 response = 3;


    pub fn get_response(&self) -> i32 {
        self.response.unwrap_or(0)
    }
    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: i32) {
        self.response = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCSurveyResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.question_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.match_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.response = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.question_type {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.response {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.question_type {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.match_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.response {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCSurveyResponse {
        CMsgGCSurveyResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<SurveyQuestionType>>(
                "question_type",
                |m: &CMsgGCSurveyResponse| { &m.question_type },
                |m: &mut CMsgGCSurveyResponse| { &mut m.question_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "match_id",
                |m: &CMsgGCSurveyResponse| { &m.match_id },
                |m: &mut CMsgGCSurveyResponse| { &mut m.match_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "response",
                |m: &CMsgGCSurveyResponse| { &m.response },
                |m: &mut CMsgGCSurveyResponse| { &mut m.response },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCSurveyResponse>(
                "CMsgGCSurveyResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCSurveyResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgGCSurveyResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCSurveyResponse::new)
    }
}

impl ::protobuf::Clear for CMsgGCSurveyResponse {
    fn clear(&mut self) {
        self.question_type = ::std::option::Option::None;
        self.match_id = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCSurveyResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCSurveyResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CSOQuestMapNode {
    // message fields
    account_id: ::std::option::Option<u32>,
    defindex: ::std::option::Option<u32>,
    node_id: ::std::option::Option<u32>,
    star_0_earned: ::std::option::Option<bool>,
    star_1_earned: ::std::option::Option<bool>,
    star_2_earned: ::std::option::Option<bool>,
    loot_claimed: ::std::option::Option<bool>,
    selected_quest_def: ::std::option::Option<u32>,
    map_cycle: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CSOQuestMapNode {
    fn default() -> &'a CSOQuestMapNode {
        <CSOQuestMapNode as ::protobuf::Message>::default_instance()
    }
}

impl CSOQuestMapNode {
    pub fn new() -> CSOQuestMapNode {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;


    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }
    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 defindex = 3;


    pub fn get_defindex(&self) -> u32 {
        self.defindex.unwrap_or(0)
    }
    pub fn clear_defindex(&mut self) {
        self.defindex = ::std::option::Option::None;
    }

    pub fn has_defindex(&self) -> bool {
        self.defindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_defindex(&mut self, v: u32) {
        self.defindex = ::std::option::Option::Some(v);
    }

    // optional uint32 node_id = 4;


    pub fn get_node_id(&self) -> u32 {
        self.node_id.unwrap_or(0)
    }
    pub fn clear_node_id(&mut self) {
        self.node_id = ::std::option::Option::None;
    }

    pub fn has_node_id(&self) -> bool {
        self.node_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_node_id(&mut self, v: u32) {
        self.node_id = ::std::option::Option::Some(v);
    }

    // optional bool star_0_earned = 6;


    pub fn get_star_0_earned(&self) -> bool {
        self.star_0_earned.unwrap_or(false)
    }
    pub fn clear_star_0_earned(&mut self) {
        self.star_0_earned = ::std::option::Option::None;
    }

    pub fn has_star_0_earned(&self) -> bool {
        self.star_0_earned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_star_0_earned(&mut self, v: bool) {
        self.star_0_earned = ::std::option::Option::Some(v);
    }

    // optional bool star_1_earned = 7;


    pub fn get_star_1_earned(&self) -> bool {
        self.star_1_earned.unwrap_or(false)
    }
    pub fn clear_star_1_earned(&mut self) {
        self.star_1_earned = ::std::option::Option::None;
    }

    pub fn has_star_1_earned(&self) -> bool {
        self.star_1_earned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_star_1_earned(&mut self, v: bool) {
        self.star_1_earned = ::std::option::Option::Some(v);
    }

    // optional bool star_2_earned = 8;


    pub fn get_star_2_earned(&self) -> bool {
        self.star_2_earned.unwrap_or(false)
    }
    pub fn clear_star_2_earned(&mut self) {
        self.star_2_earned = ::std::option::Option::None;
    }

    pub fn has_star_2_earned(&self) -> bool {
        self.star_2_earned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_star_2_earned(&mut self, v: bool) {
        self.star_2_earned = ::std::option::Option::Some(v);
    }

    // optional bool loot_claimed = 9;


    pub fn get_loot_claimed(&self) -> bool {
        self.loot_claimed.unwrap_or(false)
    }
    pub fn clear_loot_claimed(&mut self) {
        self.loot_claimed = ::std::option::Option::None;
    }

    pub fn has_loot_claimed(&self) -> bool {
        self.loot_claimed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_loot_claimed(&mut self, v: bool) {
        self.loot_claimed = ::std::option::Option::Some(v);
    }

    // optional uint32 selected_quest_def = 10;


    pub fn get_selected_quest_def(&self) -> u32 {
        self.selected_quest_def.unwrap_or(0u32)
    }
    pub fn clear_selected_quest_def(&mut self) {
        self.selected_quest_def = ::std::option::Option::None;
    }

    pub fn has_selected_quest_def(&self) -> bool {
        self.selected_quest_def.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selected_quest_def(&mut self, v: u32) {
        self.selected_quest_def = ::std::option::Option::Some(v);
    }

    // optional uint32 map_cycle = 11;


    pub fn get_map_cycle(&self) -> u32 {
        self.map_cycle.unwrap_or(0)
    }
    pub fn clear_map_cycle(&mut self) {
        self.map_cycle = ::std::option::Option::None;
    }

    pub fn has_map_cycle(&self) -> bool {
        self.map_cycle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map_cycle(&mut self, v: u32) {
        self.map_cycle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CSOQuestMapNode {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.defindex = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.node_id = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.star_0_earned = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.star_1_earned = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.star_2_earned = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.loot_claimed = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.selected_quest_def = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.map_cycle = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.defindex {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.node_id {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.star_0_earned {
            my_size += 2;
        }
        if let Some(v) = self.star_1_earned {
            my_size += 2;
        }
        if let Some(v) = self.star_2_earned {
            my_size += 2;
        }
        if let Some(v) = self.loot_claimed {
            my_size += 2;
        }
        if let Some(v) = self.selected_quest_def {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.map_cycle {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.defindex {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.node_id {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.star_0_earned {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.star_1_earned {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.star_2_earned {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.loot_claimed {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.selected_quest_def {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.map_cycle {
            os.write_uint32(11, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CSOQuestMapNode {
        CSOQuestMapNode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "account_id",
                |m: &CSOQuestMapNode| { &m.account_id },
                |m: &mut CSOQuestMapNode| { &mut m.account_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "defindex",
                |m: &CSOQuestMapNode| { &m.defindex },
                |m: &mut CSOQuestMapNode| { &mut m.defindex },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "node_id",
                |m: &CSOQuestMapNode| { &m.node_id },
                |m: &mut CSOQuestMapNode| { &mut m.node_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "star_0_earned",
                |m: &CSOQuestMapNode| { &m.star_0_earned },
                |m: &mut CSOQuestMapNode| { &mut m.star_0_earned },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "star_1_earned",
                |m: &CSOQuestMapNode| { &m.star_1_earned },
                |m: &mut CSOQuestMapNode| { &mut m.star_1_earned },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "star_2_earned",
                |m: &CSOQuestMapNode| { &m.star_2_earned },
                |m: &mut CSOQuestMapNode| { &mut m.star_2_earned },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "loot_claimed",
                |m: &CSOQuestMapNode| { &m.loot_claimed },
                |m: &mut CSOQuestMapNode| { &mut m.loot_claimed },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "selected_quest_def",
                |m: &CSOQuestMapNode| { &m.selected_quest_def },
                |m: &mut CSOQuestMapNode| { &mut m.selected_quest_def },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "map_cycle",
                |m: &CSOQuestMapNode| { &m.map_cycle },
                |m: &mut CSOQuestMapNode| { &mut m.map_cycle },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CSOQuestMapNode>(
                "CSOQuestMapNode",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CSOQuestMapNode {
        static instance: ::protobuf::rt::LazyV2<CSOQuestMapNode> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CSOQuestMapNode::new)
    }
}

impl ::protobuf::Clear for CSOQuestMapNode {
    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.defindex = ::std::option::Option::None;
        self.node_id = ::std::option::Option::None;
        self.star_0_earned = ::std::option::Option::None;
        self.star_1_earned = ::std::option::Option::None;
        self.star_2_earned = ::std::option::Option::None;
        self.loot_claimed = ::std::option::Option::None;
        self.selected_quest_def = ::std::option::Option::None;
        self.map_cycle = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSOQuestMapNode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOQuestMapNode {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CSOQuest {
    // message fields
    account_id: ::std::option::Option<u32>,
    quest_id: ::std::option::Option<u64>,
    defindex: ::std::option::Option<u32>,
    active: ::std::option::Option<bool>,
    points_0: ::std::option::Option<u32>,
    points_1: ::std::option::Option<u32>,
    points_2: ::std::option::Option<u32>,
    quest_map_node_source_id: ::std::option::Option<u32>,
    map_cycle: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CSOQuest {
    fn default() -> &'a CSOQuest {
        <CSOQuest as ::protobuf::Message>::default_instance()
    }
}

impl CSOQuest {
    pub fn new() -> CSOQuest {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;


    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }
    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint64 quest_id = 2;


    pub fn get_quest_id(&self) -> u64 {
        self.quest_id.unwrap_or(0)
    }
    pub fn clear_quest_id(&mut self) {
        self.quest_id = ::std::option::Option::None;
    }

    pub fn has_quest_id(&self) -> bool {
        self.quest_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quest_id(&mut self, v: u64) {
        self.quest_id = ::std::option::Option::Some(v);
    }

    // optional uint32 defindex = 3;


    pub fn get_defindex(&self) -> u32 {
        self.defindex.unwrap_or(0)
    }
    pub fn clear_defindex(&mut self) {
        self.defindex = ::std::option::Option::None;
    }

    pub fn has_defindex(&self) -> bool {
        self.defindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_defindex(&mut self, v: u32) {
        self.defindex = ::std::option::Option::Some(v);
    }

    // optional bool active = 4;


    pub fn get_active(&self) -> bool {
        self.active.unwrap_or(false)
    }
    pub fn clear_active(&mut self) {
        self.active = ::std::option::Option::None;
    }

    pub fn has_active(&self) -> bool {
        self.active.is_some()
    }

    // Param is passed by value, moved
    pub fn set_active(&mut self, v: bool) {
        self.active = ::std::option::Option::Some(v);
    }

    // optional uint32 points_0 = 5;


    pub fn get_points_0(&self) -> u32 {
        self.points_0.unwrap_or(0)
    }
    pub fn clear_points_0(&mut self) {
        self.points_0 = ::std::option::Option::None;
    }

    pub fn has_points_0(&self) -> bool {
        self.points_0.is_some()
    }

    // Param is passed by value, moved
    pub fn set_points_0(&mut self, v: u32) {
        self.points_0 = ::std::option::Option::Some(v);
    }

    // optional uint32 points_1 = 6;


    pub fn get_points_1(&self) -> u32 {
        self.points_1.unwrap_or(0)
    }
    pub fn clear_points_1(&mut self) {
        self.points_1 = ::std::option::Option::None;
    }

    pub fn has_points_1(&self) -> bool {
        self.points_1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_points_1(&mut self, v: u32) {
        self.points_1 = ::std::option::Option::Some(v);
    }

    // optional uint32 points_2 = 7;


    pub fn get_points_2(&self) -> u32 {
        self.points_2.unwrap_or(0)
    }
    pub fn clear_points_2(&mut self) {
        self.points_2 = ::std::option::Option::None;
    }

    pub fn has_points_2(&self) -> bool {
        self.points_2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_points_2(&mut self, v: u32) {
        self.points_2 = ::std::option::Option::Some(v);
    }

    // optional uint32 quest_map_node_source_id = 8;


    pub fn get_quest_map_node_source_id(&self) -> u32 {
        self.quest_map_node_source_id.unwrap_or(0)
    }
    pub fn clear_quest_map_node_source_id(&mut self) {
        self.quest_map_node_source_id = ::std::option::Option::None;
    }

    pub fn has_quest_map_node_source_id(&self) -> bool {
        self.quest_map_node_source_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quest_map_node_source_id(&mut self, v: u32) {
        self.quest_map_node_source_id = ::std::option::Option::Some(v);
    }

    // optional uint32 map_cycle = 9;


    pub fn get_map_cycle(&self) -> u32 {
        self.map_cycle.unwrap_or(0)
    }
    pub fn clear_map_cycle(&mut self) {
        self.map_cycle = ::std::option::Option::None;
    }

    pub fn has_map_cycle(&self) -> bool {
        self.map_cycle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map_cycle(&mut self, v: u32) {
        self.map_cycle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CSOQuest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.quest_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.defindex = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.active = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.points_0 = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.points_1 = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.points_2 = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.quest_map_node_source_id = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.map_cycle = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.quest_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.defindex {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.active {
            my_size += 2;
        }
        if let Some(v) = self.points_0 {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.points_1 {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.points_2 {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.quest_map_node_source_id {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.map_cycle {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.quest_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.defindex {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.active {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.points_0 {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.points_1 {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.points_2 {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.quest_map_node_source_id {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.map_cycle {
            os.write_uint32(9, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CSOQuest {
        CSOQuest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "account_id",
                |m: &CSOQuest| { &m.account_id },
                |m: &mut CSOQuest| { &mut m.account_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "quest_id",
                |m: &CSOQuest| { &m.quest_id },
                |m: &mut CSOQuest| { &mut m.quest_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "defindex",
                |m: &CSOQuest| { &m.defindex },
                |m: &mut CSOQuest| { &mut m.defindex },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "active",
                |m: &CSOQuest| { &m.active },
                |m: &mut CSOQuest| { &mut m.active },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "points_0",
                |m: &CSOQuest| { &m.points_0 },
                |m: &mut CSOQuest| { &mut m.points_0 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "points_1",
                |m: &CSOQuest| { &m.points_1 },
                |m: &mut CSOQuest| { &mut m.points_1 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "points_2",
                |m: &CSOQuest| { &m.points_2 },
                |m: &mut CSOQuest| { &mut m.points_2 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "quest_map_node_source_id",
                |m: &CSOQuest| { &m.quest_map_node_source_id },
                |m: &mut CSOQuest| { &mut m.quest_map_node_source_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "map_cycle",
                |m: &CSOQuest| { &m.map_cycle },
                |m: &mut CSOQuest| { &mut m.map_cycle },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CSOQuest>(
                "CSOQuest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CSOQuest {
        static instance: ::protobuf::rt::LazyV2<CSOQuest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CSOQuest::new)
    }
}

impl ::protobuf::Clear for CSOQuest {
    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.quest_id = ::std::option::Option::None;
        self.defindex = ::std::option::Option::None;
        self.active = ::std::option::Option::None;
        self.points_0 = ::std::option::Option::None;
        self.points_1 = ::std::option::Option::None;
        self.points_2 = ::std::option::Option::None;
        self.quest_map_node_source_id = ::std::option::Option::None;
        self.map_cycle = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSOQuest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOQuest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CSOQuestMapRewardPurchase {
    // message fields
    account_id: ::std::option::Option<u32>,
    defindex: ::std::option::Option<u32>,
    count: ::std::option::Option<u32>,
    map_cycle: ::std::option::Option<u32>,
    purchase_id: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CSOQuestMapRewardPurchase {
    fn default() -> &'a CSOQuestMapRewardPurchase {
        <CSOQuestMapRewardPurchase as ::protobuf::Message>::default_instance()
    }
}

impl CSOQuestMapRewardPurchase {
    pub fn new() -> CSOQuestMapRewardPurchase {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;


    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }
    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 defindex = 2;


    pub fn get_defindex(&self) -> u32 {
        self.defindex.unwrap_or(0)
    }
    pub fn clear_defindex(&mut self) {
        self.defindex = ::std::option::Option::None;
    }

    pub fn has_defindex(&self) -> bool {
        self.defindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_defindex(&mut self, v: u32) {
        self.defindex = ::std::option::Option::Some(v);
    }

    // optional uint32 count = 3;


    pub fn get_count(&self) -> u32 {
        self.count.unwrap_or(0)
    }
    pub fn clear_count(&mut self) {
        self.count = ::std::option::Option::None;
    }

    pub fn has_count(&self) -> bool {
        self.count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: u32) {
        self.count = ::std::option::Option::Some(v);
    }

    // optional uint32 map_cycle = 4;


    pub fn get_map_cycle(&self) -> u32 {
        self.map_cycle.unwrap_or(0)
    }
    pub fn clear_map_cycle(&mut self) {
        self.map_cycle = ::std::option::Option::None;
    }

    pub fn has_map_cycle(&self) -> bool {
        self.map_cycle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map_cycle(&mut self, v: u32) {
        self.map_cycle = ::std::option::Option::Some(v);
    }

    // optional uint32 purchase_id = 5;


    pub fn get_purchase_id(&self) -> u32 {
        self.purchase_id.unwrap_or(0)
    }
    pub fn clear_purchase_id(&mut self) {
        self.purchase_id = ::std::option::Option::None;
    }

    pub fn has_purchase_id(&self) -> bool {
        self.purchase_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_purchase_id(&mut self, v: u32) {
        self.purchase_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CSOQuestMapRewardPurchase {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.defindex = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.count = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.map_cycle = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.purchase_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.defindex {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.count {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.map_cycle {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.purchase_id {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.defindex {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.count {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.map_cycle {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.purchase_id {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CSOQuestMapRewardPurchase {
        CSOQuestMapRewardPurchase::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "account_id",
                |m: &CSOQuestMapRewardPurchase| { &m.account_id },
                |m: &mut CSOQuestMapRewardPurchase| { &mut m.account_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "defindex",
                |m: &CSOQuestMapRewardPurchase| { &m.defindex },
                |m: &mut CSOQuestMapRewardPurchase| { &mut m.defindex },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "count",
                |m: &CSOQuestMapRewardPurchase| { &m.count },
                |m: &mut CSOQuestMapRewardPurchase| { &mut m.count },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "map_cycle",
                |m: &CSOQuestMapRewardPurchase| { &m.map_cycle },
                |m: &mut CSOQuestMapRewardPurchase| { &mut m.map_cycle },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "purchase_id",
                |m: &CSOQuestMapRewardPurchase| { &m.purchase_id },
                |m: &mut CSOQuestMapRewardPurchase| { &mut m.purchase_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CSOQuestMapRewardPurchase>(
                "CSOQuestMapRewardPurchase",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CSOQuestMapRewardPurchase {
        static instance: ::protobuf::rt::LazyV2<CSOQuestMapRewardPurchase> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CSOQuestMapRewardPurchase::new)
    }
}

impl ::protobuf::Clear for CSOQuestMapRewardPurchase {
    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.defindex = ::std::option::Option::None;
        self.count = ::std::option::Option::None;
        self.map_cycle = ::std::option::Option::None;
        self.purchase_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSOQuestMapRewardPurchase {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOQuestMapRewardPurchase {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCQuestIdentify {
    // message fields
    quest_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCQuestIdentify {
    fn default() -> &'a CMsgGCQuestIdentify {
        <CMsgGCQuestIdentify as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCQuestIdentify {
    pub fn new() -> CMsgGCQuestIdentify {
        ::std::default::Default::default()
    }

    // optional uint64 quest_id = 1;


    pub fn get_quest_id(&self) -> u64 {
        self.quest_id.unwrap_or(0)
    }
    pub fn clear_quest_id(&mut self) {
        self.quest_id = ::std::option::Option::None;
    }

    pub fn has_quest_id(&self) -> bool {
        self.quest_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quest_id(&mut self, v: u64) {
        self.quest_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCQuestIdentify {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.quest_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.quest_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.quest_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCQuestIdentify {
        CMsgGCQuestIdentify::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "quest_id",
                |m: &CMsgGCQuestIdentify| { &m.quest_id },
                |m: &mut CMsgGCQuestIdentify| { &mut m.quest_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCQuestIdentify>(
                "CMsgGCQuestIdentify",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCQuestIdentify {
        static instance: ::protobuf::rt::LazyV2<CMsgGCQuestIdentify> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCQuestIdentify::new)
    }
}

impl ::protobuf::Clear for CMsgGCQuestIdentify {
    fn clear(&mut self) {
        self.quest_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCQuestIdentify {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCQuestIdentify {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCQuestDevGive {
    // message fields
    quest_def_index: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCQuestDevGive {
    fn default() -> &'a CMsgGCQuestDevGive {
        <CMsgGCQuestDevGive as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCQuestDevGive {
    pub fn new() -> CMsgGCQuestDevGive {
        ::std::default::Default::default()
    }

    // optional uint32 quest_def_index = 1;


    pub fn get_quest_def_index(&self) -> u32 {
        self.quest_def_index.unwrap_or(0)
    }
    pub fn clear_quest_def_index(&mut self) {
        self.quest_def_index = ::std::option::Option::None;
    }

    pub fn has_quest_def_index(&self) -> bool {
        self.quest_def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quest_def_index(&mut self, v: u32) {
        self.quest_def_index = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCQuestDevGive {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.quest_def_index = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.quest_def_index {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.quest_def_index {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCQuestDevGive {
        CMsgGCQuestDevGive::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "quest_def_index",
                |m: &CMsgGCQuestDevGive| { &m.quest_def_index },
                |m: &mut CMsgGCQuestDevGive| { &mut m.quest_def_index },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCQuestDevGive>(
                "CMsgGCQuestDevGive",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCQuestDevGive {
        static instance: ::protobuf::rt::LazyV2<CMsgGCQuestDevGive> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCQuestDevGive::new)
    }
}

impl ::protobuf::Clear for CMsgGCQuestDevGive {
    fn clear(&mut self) {
        self.quest_def_index = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCQuestDevGive {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCQuestDevGive {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCQuestNodeTurnIn {
    // message fields
    node_defindex: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCQuestNodeTurnIn {
    fn default() -> &'a CMsgGCQuestNodeTurnIn {
        <CMsgGCQuestNodeTurnIn as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCQuestNodeTurnIn {
    pub fn new() -> CMsgGCQuestNodeTurnIn {
        ::std::default::Default::default()
    }

    // optional uint32 node_defindex = 1;


    pub fn get_node_defindex(&self) -> u32 {
        self.node_defindex.unwrap_or(0)
    }
    pub fn clear_node_defindex(&mut self) {
        self.node_defindex = ::std::option::Option::None;
    }

    pub fn has_node_defindex(&self) -> bool {
        self.node_defindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_node_defindex(&mut self, v: u32) {
        self.node_defindex = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCQuestNodeTurnIn {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.node_defindex = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.node_defindex {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.node_defindex {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCQuestNodeTurnIn {
        CMsgGCQuestNodeTurnIn::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "node_defindex",
                |m: &CMsgGCQuestNodeTurnIn| { &m.node_defindex },
                |m: &mut CMsgGCQuestNodeTurnIn| { &mut m.node_defindex },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCQuestNodeTurnIn>(
                "CMsgGCQuestNodeTurnIn",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCQuestNodeTurnIn {
        static instance: ::protobuf::rt::LazyV2<CMsgGCQuestNodeTurnIn> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCQuestNodeTurnIn::new)
    }
}

impl ::protobuf::Clear for CMsgGCQuestNodeTurnIn {
    fn clear(&mut self) {
        self.node_defindex = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCQuestNodeTurnIn {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCQuestNodeTurnIn {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCQuestMapUnlockNode {
    // message fields
    node_defindex: ::std::option::Option<u32>,
    quest_defindex: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCQuestMapUnlockNode {
    fn default() -> &'a CMsgGCQuestMapUnlockNode {
        <CMsgGCQuestMapUnlockNode as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCQuestMapUnlockNode {
    pub fn new() -> CMsgGCQuestMapUnlockNode {
        ::std::default::Default::default()
    }

    // optional uint32 node_defindex = 1;


    pub fn get_node_defindex(&self) -> u32 {
        self.node_defindex.unwrap_or(0)
    }
    pub fn clear_node_defindex(&mut self) {
        self.node_defindex = ::std::option::Option::None;
    }

    pub fn has_node_defindex(&self) -> bool {
        self.node_defindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_node_defindex(&mut self, v: u32) {
        self.node_defindex = ::std::option::Option::Some(v);
    }

    // optional uint32 quest_defindex = 2;


    pub fn get_quest_defindex(&self) -> u32 {
        self.quest_defindex.unwrap_or(0)
    }
    pub fn clear_quest_defindex(&mut self) {
        self.quest_defindex = ::std::option::Option::None;
    }

    pub fn has_quest_defindex(&self) -> bool {
        self.quest_defindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quest_defindex(&mut self, v: u32) {
        self.quest_defindex = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCQuestMapUnlockNode {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.node_defindex = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.quest_defindex = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.node_defindex {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.quest_defindex {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.node_defindex {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.quest_defindex {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCQuestMapUnlockNode {
        CMsgGCQuestMapUnlockNode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "node_defindex",
                |m: &CMsgGCQuestMapUnlockNode| { &m.node_defindex },
                |m: &mut CMsgGCQuestMapUnlockNode| { &mut m.node_defindex },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "quest_defindex",
                |m: &CMsgGCQuestMapUnlockNode| { &m.quest_defindex },
                |m: &mut CMsgGCQuestMapUnlockNode| { &mut m.quest_defindex },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCQuestMapUnlockNode>(
                "CMsgGCQuestMapUnlockNode",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCQuestMapUnlockNode {
        static instance: ::protobuf::rt::LazyV2<CMsgGCQuestMapUnlockNode> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCQuestMapUnlockNode::new)
    }
}

impl ::protobuf::Clear for CMsgGCQuestMapUnlockNode {
    fn clear(&mut self) {
        self.node_defindex = ::std::option::Option::None;
        self.quest_defindex = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCQuestMapUnlockNode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCQuestMapUnlockNode {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCNewMatchForLobbyRequest {
    // message fields
    current_match_id: ::std::option::Option<u64>,
    next_map_id: ::std::option::Option<u32>,
    lobby_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCNewMatchForLobbyRequest {
    fn default() -> &'a CMsgGCNewMatchForLobbyRequest {
        <CMsgGCNewMatchForLobbyRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCNewMatchForLobbyRequest {
    pub fn new() -> CMsgGCNewMatchForLobbyRequest {
        ::std::default::Default::default()
    }

    // optional uint64 current_match_id = 1;


    pub fn get_current_match_id(&self) -> u64 {
        self.current_match_id.unwrap_or(0)
    }
    pub fn clear_current_match_id(&mut self) {
        self.current_match_id = ::std::option::Option::None;
    }

    pub fn has_current_match_id(&self) -> bool {
        self.current_match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_current_match_id(&mut self, v: u64) {
        self.current_match_id = ::std::option::Option::Some(v);
    }

    // optional uint32 next_map_id = 2;


    pub fn get_next_map_id(&self) -> u32 {
        self.next_map_id.unwrap_or(0)
    }
    pub fn clear_next_map_id(&mut self) {
        self.next_map_id = ::std::option::Option::None;
    }

    pub fn has_next_map_id(&self) -> bool {
        self.next_map_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_next_map_id(&mut self, v: u32) {
        self.next_map_id = ::std::option::Option::Some(v);
    }

    // optional uint64 lobby_id = 3;


    pub fn get_lobby_id(&self) -> u64 {
        self.lobby_id.unwrap_or(0)
    }
    pub fn clear_lobby_id(&mut self) {
        self.lobby_id = ::std::option::Option::None;
    }

    pub fn has_lobby_id(&self) -> bool {
        self.lobby_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_id(&mut self, v: u64) {
        self.lobby_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCNewMatchForLobbyRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.current_match_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.next_map_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.lobby_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.current_match_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.next_map_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.lobby_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.current_match_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.next_map_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.lobby_id {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCNewMatchForLobbyRequest {
        CMsgGCNewMatchForLobbyRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "current_match_id",
                |m: &CMsgGCNewMatchForLobbyRequest| { &m.current_match_id },
                |m: &mut CMsgGCNewMatchForLobbyRequest| { &mut m.current_match_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "next_map_id",
                |m: &CMsgGCNewMatchForLobbyRequest| { &m.next_map_id },
                |m: &mut CMsgGCNewMatchForLobbyRequest| { &mut m.next_map_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "lobby_id",
                |m: &CMsgGCNewMatchForLobbyRequest| { &m.lobby_id },
                |m: &mut CMsgGCNewMatchForLobbyRequest| { &mut m.lobby_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCNewMatchForLobbyRequest>(
                "CMsgGCNewMatchForLobbyRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCNewMatchForLobbyRequest {
        static instance: ::protobuf::rt::LazyV2<CMsgGCNewMatchForLobbyRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCNewMatchForLobbyRequest::new)
    }
}

impl ::protobuf::Clear for CMsgGCNewMatchForLobbyRequest {
    fn clear(&mut self) {
        self.current_match_id = ::std::option::Option::None;
        self.next_map_id = ::std::option::Option::None;
        self.lobby_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCNewMatchForLobbyRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCNewMatchForLobbyRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCNewMatchForLobbyResponse {
    // message fields
    success: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCNewMatchForLobbyResponse {
    fn default() -> &'a CMsgGCNewMatchForLobbyResponse {
        <CMsgGCNewMatchForLobbyResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCNewMatchForLobbyResponse {
    pub fn new() -> CMsgGCNewMatchForLobbyResponse {
        ::std::default::Default::default()
    }

    // optional bool success = 1;


    pub fn get_success(&self) -> bool {
        self.success.unwrap_or(false)
    }
    pub fn clear_success(&mut self) {
        self.success = ::std::option::Option::None;
    }

    pub fn has_success(&self) -> bool {
        self.success.is_some()
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCNewMatchForLobbyResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.success = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.success {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.success {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCNewMatchForLobbyResponse {
        CMsgGCNewMatchForLobbyResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "success",
                |m: &CMsgGCNewMatchForLobbyResponse| { &m.success },
                |m: &mut CMsgGCNewMatchForLobbyResponse| { &mut m.success },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCNewMatchForLobbyResponse>(
                "CMsgGCNewMatchForLobbyResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCNewMatchForLobbyResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgGCNewMatchForLobbyResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCNewMatchForLobbyResponse::new)
    }
}

impl ::protobuf::Clear for CMsgGCNewMatchForLobbyResponse {
    fn clear(&mut self) {
        self.success = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCNewMatchForLobbyResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCNewMatchForLobbyResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCChangeMatchPlayerTeamsRequest {
    // message fields
    match_id: ::std::option::Option<u64>,
    lobby_id: ::std::option::Option<u64>,
    pub member: ::protobuf::RepeatedField<CMsgGCChangeMatchPlayerTeamsRequest_Member>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCChangeMatchPlayerTeamsRequest {
    fn default() -> &'a CMsgGCChangeMatchPlayerTeamsRequest {
        <CMsgGCChangeMatchPlayerTeamsRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCChangeMatchPlayerTeamsRequest {
    pub fn new() -> CMsgGCChangeMatchPlayerTeamsRequest {
        ::std::default::Default::default()
    }

    // optional uint64 match_id = 1;


    pub fn get_match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }
    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional uint64 lobby_id = 2;


    pub fn get_lobby_id(&self) -> u64 {
        self.lobby_id.unwrap_or(0)
    }
    pub fn clear_lobby_id(&mut self) {
        self.lobby_id = ::std::option::Option::None;
    }

    pub fn has_lobby_id(&self) -> bool {
        self.lobby_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_id(&mut self, v: u64) {
        self.lobby_id = ::std::option::Option::Some(v);
    }

    // repeated .CMsgGCChangeMatchPlayerTeamsRequest.Member member = 3;


    pub fn get_member(&self) -> &[CMsgGCChangeMatchPlayerTeamsRequest_Member] {
        &self.member
    }
    pub fn clear_member(&mut self) {
        self.member.clear();
    }

    // Param is passed by value, moved
    pub fn set_member(&mut self, v: ::protobuf::RepeatedField<CMsgGCChangeMatchPlayerTeamsRequest_Member>) {
        self.member = v;
    }

    // Mutable pointer to the field.
    pub fn mut_member(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGCChangeMatchPlayerTeamsRequest_Member> {
        &mut self.member
    }

    // Take field
    pub fn take_member(&mut self) -> ::protobuf::RepeatedField<CMsgGCChangeMatchPlayerTeamsRequest_Member> {
        ::std::mem::replace(&mut self.member, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgGCChangeMatchPlayerTeamsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.member {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.match_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.lobby_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.member)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.lobby_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.member {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.lobby_id {
            os.write_uint64(2, v)?;
        }
        for v in &self.member {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCChangeMatchPlayerTeamsRequest {
        CMsgGCChangeMatchPlayerTeamsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "match_id",
                |m: &CMsgGCChangeMatchPlayerTeamsRequest| { &m.match_id },
                |m: &mut CMsgGCChangeMatchPlayerTeamsRequest| { &mut m.match_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "lobby_id",
                |m: &CMsgGCChangeMatchPlayerTeamsRequest| { &m.lobby_id },
                |m: &mut CMsgGCChangeMatchPlayerTeamsRequest| { &mut m.lobby_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCChangeMatchPlayerTeamsRequest_Member>>(
                "member",
                |m: &CMsgGCChangeMatchPlayerTeamsRequest| { &m.member },
                |m: &mut CMsgGCChangeMatchPlayerTeamsRequest| { &mut m.member },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCChangeMatchPlayerTeamsRequest>(
                "CMsgGCChangeMatchPlayerTeamsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCChangeMatchPlayerTeamsRequest {
        static instance: ::protobuf::rt::LazyV2<CMsgGCChangeMatchPlayerTeamsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCChangeMatchPlayerTeamsRequest::new)
    }
}

impl ::protobuf::Clear for CMsgGCChangeMatchPlayerTeamsRequest {
    fn clear(&mut self) {
        self.match_id = ::std::option::Option::None;
        self.lobby_id = ::std::option::Option::None;
        self.member.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCChangeMatchPlayerTeamsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCChangeMatchPlayerTeamsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCChangeMatchPlayerTeamsRequest_Member {
    // message fields
    member_id: ::std::option::Option<u64>,
    new_team: ::std::option::Option<TF_GC_TEAM>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCChangeMatchPlayerTeamsRequest_Member {
    fn default() -> &'a CMsgGCChangeMatchPlayerTeamsRequest_Member {
        <CMsgGCChangeMatchPlayerTeamsRequest_Member as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCChangeMatchPlayerTeamsRequest_Member {
    pub fn new() -> CMsgGCChangeMatchPlayerTeamsRequest_Member {
        ::std::default::Default::default()
    }

    // optional uint64 member_id = 1;


    pub fn get_member_id(&self) -> u64 {
        self.member_id.unwrap_or(0)
    }
    pub fn clear_member_id(&mut self) {
        self.member_id = ::std::option::Option::None;
    }

    pub fn has_member_id(&self) -> bool {
        self.member_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_member_id(&mut self, v: u64) {
        self.member_id = ::std::option::Option::Some(v);
    }

    // optional .TF_GC_TEAM new_team = 2;


    pub fn get_new_team(&self) -> TF_GC_TEAM {
        self.new_team.unwrap_or(TF_GC_TEAM::TF_GC_TEAM_NOTEAM)
    }
    pub fn clear_new_team(&mut self) {
        self.new_team = ::std::option::Option::None;
    }

    pub fn has_new_team(&self) -> bool {
        self.new_team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_new_team(&mut self, v: TF_GC_TEAM) {
        self.new_team = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCChangeMatchPlayerTeamsRequest_Member {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.member_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.new_team, 2, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.member_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.new_team {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.member_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.new_team {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCChangeMatchPlayerTeamsRequest_Member {
        CMsgGCChangeMatchPlayerTeamsRequest_Member::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "member_id",
                |m: &CMsgGCChangeMatchPlayerTeamsRequest_Member| { &m.member_id },
                |m: &mut CMsgGCChangeMatchPlayerTeamsRequest_Member| { &mut m.member_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TF_GC_TEAM>>(
                "new_team",
                |m: &CMsgGCChangeMatchPlayerTeamsRequest_Member| { &m.new_team },
                |m: &mut CMsgGCChangeMatchPlayerTeamsRequest_Member| { &mut m.new_team },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCChangeMatchPlayerTeamsRequest_Member>(
                "CMsgGCChangeMatchPlayerTeamsRequest.Member",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCChangeMatchPlayerTeamsRequest_Member {
        static instance: ::protobuf::rt::LazyV2<CMsgGCChangeMatchPlayerTeamsRequest_Member> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCChangeMatchPlayerTeamsRequest_Member::new)
    }
}

impl ::protobuf::Clear for CMsgGCChangeMatchPlayerTeamsRequest_Member {
    fn clear(&mut self) {
        self.member_id = ::std::option::Option::None;
        self.new_team = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCChangeMatchPlayerTeamsRequest_Member {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCChangeMatchPlayerTeamsRequest_Member {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCChangeMatchPlayerTeamsResponse {
    // message fields
    success: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCChangeMatchPlayerTeamsResponse {
    fn default() -> &'a CMsgGCChangeMatchPlayerTeamsResponse {
        <CMsgGCChangeMatchPlayerTeamsResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCChangeMatchPlayerTeamsResponse {
    pub fn new() -> CMsgGCChangeMatchPlayerTeamsResponse {
        ::std::default::Default::default()
    }

    // optional bool success = 1;


    pub fn get_success(&self) -> bool {
        self.success.unwrap_or(false)
    }
    pub fn clear_success(&mut self) {
        self.success = ::std::option::Option::None;
    }

    pub fn has_success(&self) -> bool {
        self.success.is_some()
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCChangeMatchPlayerTeamsResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.success = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.success {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.success {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCChangeMatchPlayerTeamsResponse {
        CMsgGCChangeMatchPlayerTeamsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "success",
                |m: &CMsgGCChangeMatchPlayerTeamsResponse| { &m.success },
                |m: &mut CMsgGCChangeMatchPlayerTeamsResponse| { &mut m.success },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCChangeMatchPlayerTeamsResponse>(
                "CMsgGCChangeMatchPlayerTeamsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCChangeMatchPlayerTeamsResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgGCChangeMatchPlayerTeamsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCChangeMatchPlayerTeamsResponse::new)
    }
}

impl ::protobuf::Clear for CMsgGCChangeMatchPlayerTeamsResponse {
    fn clear(&mut self) {
        self.success = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCChangeMatchPlayerTeamsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCChangeMatchPlayerTeamsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCQuestComplete_Debug {
    // message fields
    quest_id: ::std::option::Option<u64>,
    points_type: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCQuestComplete_Debug {
    fn default() -> &'a CMsgGCQuestComplete_Debug {
        <CMsgGCQuestComplete_Debug as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCQuestComplete_Debug {
    pub fn new() -> CMsgGCQuestComplete_Debug {
        ::std::default::Default::default()
    }

    // optional uint64 quest_id = 1;


    pub fn get_quest_id(&self) -> u64 {
        self.quest_id.unwrap_or(0)
    }
    pub fn clear_quest_id(&mut self) {
        self.quest_id = ::std::option::Option::None;
    }

    pub fn has_quest_id(&self) -> bool {
        self.quest_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quest_id(&mut self, v: u64) {
        self.quest_id = ::std::option::Option::Some(v);
    }

    // optional uint32 points_type = 2;


    pub fn get_points_type(&self) -> u32 {
        self.points_type.unwrap_or(0)
    }
    pub fn clear_points_type(&mut self) {
        self.points_type = ::std::option::Option::None;
    }

    pub fn has_points_type(&self) -> bool {
        self.points_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_points_type(&mut self, v: u32) {
        self.points_type = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCQuestComplete_Debug {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.quest_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.points_type = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.quest_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.points_type {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.quest_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.points_type {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCQuestComplete_Debug {
        CMsgGCQuestComplete_Debug::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "quest_id",
                |m: &CMsgGCQuestComplete_Debug| { &m.quest_id },
                |m: &mut CMsgGCQuestComplete_Debug| { &mut m.quest_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "points_type",
                |m: &CMsgGCQuestComplete_Debug| { &m.points_type },
                |m: &mut CMsgGCQuestComplete_Debug| { &mut m.points_type },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCQuestComplete_Debug>(
                "CMsgGCQuestComplete_Debug",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCQuestComplete_Debug {
        static instance: ::protobuf::rt::LazyV2<CMsgGCQuestComplete_Debug> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCQuestComplete_Debug::new)
    }
}

impl ::protobuf::Clear for CMsgGCQuestComplete_Debug {
    fn clear(&mut self) {
        self.quest_id = ::std::option::Option::None;
        self.points_type = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCQuestComplete_Debug {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCQuestComplete_Debug {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCQuestMap_Debug {
    // message fields
    reset_operation: ::std::option::Option<u32>,
    give_credit: ::std::option::Option<u32>,
    pub unlock_node: ::protobuf::SingularPtrField<CMsgGCQuestMapUnlockNode>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCQuestMap_Debug {
    fn default() -> &'a CMsgGCQuestMap_Debug {
        <CMsgGCQuestMap_Debug as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCQuestMap_Debug {
    pub fn new() -> CMsgGCQuestMap_Debug {
        ::std::default::Default::default()
    }

    // optional uint32 reset_operation = 1;


    pub fn get_reset_operation(&self) -> u32 {
        self.reset_operation.unwrap_or(0)
    }
    pub fn clear_reset_operation(&mut self) {
        self.reset_operation = ::std::option::Option::None;
    }

    pub fn has_reset_operation(&self) -> bool {
        self.reset_operation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reset_operation(&mut self, v: u32) {
        self.reset_operation = ::std::option::Option::Some(v);
    }

    // optional uint32 give_credit = 2;


    pub fn get_give_credit(&self) -> u32 {
        self.give_credit.unwrap_or(0)
    }
    pub fn clear_give_credit(&mut self) {
        self.give_credit = ::std::option::Option::None;
    }

    pub fn has_give_credit(&self) -> bool {
        self.give_credit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_give_credit(&mut self, v: u32) {
        self.give_credit = ::std::option::Option::Some(v);
    }

    // optional .CMsgGCQuestMapUnlockNode unlock_node = 3;


    pub fn get_unlock_node(&self) -> &CMsgGCQuestMapUnlockNode {
        self.unlock_node.as_ref().unwrap_or_else(|| <CMsgGCQuestMapUnlockNode as ::protobuf::Message>::default_instance())
    }
    pub fn clear_unlock_node(&mut self) {
        self.unlock_node.clear();
    }

    pub fn has_unlock_node(&self) -> bool {
        self.unlock_node.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unlock_node(&mut self, v: CMsgGCQuestMapUnlockNode) {
        self.unlock_node = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unlock_node(&mut self) -> &mut CMsgGCQuestMapUnlockNode {
        if self.unlock_node.is_none() {
            self.unlock_node.set_default();
        }
        self.unlock_node.as_mut().unwrap()
    }

    // Take field
    pub fn take_unlock_node(&mut self) -> CMsgGCQuestMapUnlockNode {
        self.unlock_node.take().unwrap_or_else(|| CMsgGCQuestMapUnlockNode::new())
    }
}

impl ::protobuf::Message for CMsgGCQuestMap_Debug {
    fn is_initialized(&self) -> bool {
        for v in &self.unlock_node {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.reset_operation = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.give_credit = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.unlock_node)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.reset_operation {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.give_credit {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.unlock_node.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.reset_operation {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.give_credit {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.unlock_node.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCQuestMap_Debug {
        CMsgGCQuestMap_Debug::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "reset_operation",
                |m: &CMsgGCQuestMap_Debug| { &m.reset_operation },
                |m: &mut CMsgGCQuestMap_Debug| { &mut m.reset_operation },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "give_credit",
                |m: &CMsgGCQuestMap_Debug| { &m.give_credit },
                |m: &mut CMsgGCQuestMap_Debug| { &mut m.give_credit },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCQuestMapUnlockNode>>(
                "unlock_node",
                |m: &CMsgGCQuestMap_Debug| { &m.unlock_node },
                |m: &mut CMsgGCQuestMap_Debug| { &mut m.unlock_node },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCQuestMap_Debug>(
                "CMsgGCQuestMap_Debug",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCQuestMap_Debug {
        static instance: ::protobuf::rt::LazyV2<CMsgGCQuestMap_Debug> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCQuestMap_Debug::new)
    }
}

impl ::protobuf::Clear for CMsgGCQuestMap_Debug {
    fn clear(&mut self) {
        self.reset_operation = ::std::option::Option::None;
        self.give_credit = ::std::option::Option::None;
        self.unlock_node.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCQuestMap_Debug {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCQuestMap_Debug {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCQuestMapPurchaseReward {
    // message fields
    store_item_defindex: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCQuestMapPurchaseReward {
    fn default() -> &'a CMsgGCQuestMapPurchaseReward {
        <CMsgGCQuestMapPurchaseReward as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCQuestMapPurchaseReward {
    pub fn new() -> CMsgGCQuestMapPurchaseReward {
        ::std::default::Default::default()
    }

    // optional uint32 store_item_defindex = 1;


    pub fn get_store_item_defindex(&self) -> u32 {
        self.store_item_defindex.unwrap_or(0)
    }
    pub fn clear_store_item_defindex(&mut self) {
        self.store_item_defindex = ::std::option::Option::None;
    }

    pub fn has_store_item_defindex(&self) -> bool {
        self.store_item_defindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_store_item_defindex(&mut self, v: u32) {
        self.store_item_defindex = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCQuestMapPurchaseReward {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.store_item_defindex = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.store_item_defindex {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.store_item_defindex {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCQuestMapPurchaseReward {
        CMsgGCQuestMapPurchaseReward::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "store_item_defindex",
                |m: &CMsgGCQuestMapPurchaseReward| { &m.store_item_defindex },
                |m: &mut CMsgGCQuestMapPurchaseReward| { &mut m.store_item_defindex },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCQuestMapPurchaseReward>(
                "CMsgGCQuestMapPurchaseReward",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCQuestMapPurchaseReward {
        static instance: ::protobuf::rt::LazyV2<CMsgGCQuestMapPurchaseReward> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCQuestMapPurchaseReward::new)
    }
}

impl ::protobuf::Clear for CMsgGCQuestMapPurchaseReward {
    fn clear(&mut self) {
        self.store_item_defindex = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCQuestMapPurchaseReward {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCQuestMapPurchaseReward {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCQuestResponse {
    // message fields
    success: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCQuestResponse {
    fn default() -> &'a CMsgGCQuestResponse {
        <CMsgGCQuestResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCQuestResponse {
    pub fn new() -> CMsgGCQuestResponse {
        ::std::default::Default::default()
    }

    // optional bool success = 1;


    pub fn get_success(&self) -> bool {
        self.success.unwrap_or(false)
    }
    pub fn clear_success(&mut self) {
        self.success = ::std::option::Option::None;
    }

    pub fn has_success(&self) -> bool {
        self.success.is_some()
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCQuestResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.success = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.success {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.success {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCQuestResponse {
        CMsgGCQuestResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "success",
                |m: &CMsgGCQuestResponse| { &m.success },
                |m: &mut CMsgGCQuestResponse| { &mut m.success },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCQuestResponse>(
                "CMsgGCQuestResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCQuestResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgGCQuestResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCQuestResponse::new)
    }
}

impl ::protobuf::Clear for CMsgGCQuestResponse {
    fn clear(&mut self) {
        self.success = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCQuestResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCQuestResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCSetDisablePartyQuestProgress {
    // message fields
    state: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCSetDisablePartyQuestProgress {
    fn default() -> &'a CMsgGCSetDisablePartyQuestProgress {
        <CMsgGCSetDisablePartyQuestProgress as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCSetDisablePartyQuestProgress {
    pub fn new() -> CMsgGCSetDisablePartyQuestProgress {
        ::std::default::Default::default()
    }

    // optional bool state = 1;


    pub fn get_state(&self) -> bool {
        self.state.unwrap_or(false)
    }
    pub fn clear_state(&mut self) {
        self.state = ::std::option::Option::None;
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: bool) {
        self.state = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCSetDisablePartyQuestProgress {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.state = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.state {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.state {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCSetDisablePartyQuestProgress {
        CMsgGCSetDisablePartyQuestProgress::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "state",
                |m: &CMsgGCSetDisablePartyQuestProgress| { &m.state },
                |m: &mut CMsgGCSetDisablePartyQuestProgress| { &mut m.state },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCSetDisablePartyQuestProgress>(
                "CMsgGCSetDisablePartyQuestProgress",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCSetDisablePartyQuestProgress {
        static instance: ::protobuf::rt::LazyV2<CMsgGCSetDisablePartyQuestProgress> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCSetDisablePartyQuestProgress::new)
    }
}

impl ::protobuf::Clear for CMsgGCSetDisablePartyQuestProgress {
    fn clear(&mut self) {
        self.state = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCSetDisablePartyQuestProgress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCSetDisablePartyQuestProgress {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgQuestProgressReport {
    // message fields
    quest_id: ::std::option::Option<u64>,
    star_0_earned: ::std::option::Option<bool>,
    star_1_earned: ::std::option::Option<bool>,
    star_2_earned: ::std::option::Option<bool>,
    pub items_earned: ::std::vec::Vec<u64>,
    reward_credits_earned: ::std::option::Option<u32>,
    contract_completed: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgQuestProgressReport {
    fn default() -> &'a CMsgQuestProgressReport {
        <CMsgQuestProgressReport as ::protobuf::Message>::default_instance()
    }
}

impl CMsgQuestProgressReport {
    pub fn new() -> CMsgQuestProgressReport {
        ::std::default::Default::default()
    }

    // optional uint64 quest_id = 1;


    pub fn get_quest_id(&self) -> u64 {
        self.quest_id.unwrap_or(0)
    }
    pub fn clear_quest_id(&mut self) {
        self.quest_id = ::std::option::Option::None;
    }

    pub fn has_quest_id(&self) -> bool {
        self.quest_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quest_id(&mut self, v: u64) {
        self.quest_id = ::std::option::Option::Some(v);
    }

    // optional bool star_0_earned = 2;


    pub fn get_star_0_earned(&self) -> bool {
        self.star_0_earned.unwrap_or(false)
    }
    pub fn clear_star_0_earned(&mut self) {
        self.star_0_earned = ::std::option::Option::None;
    }

    pub fn has_star_0_earned(&self) -> bool {
        self.star_0_earned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_star_0_earned(&mut self, v: bool) {
        self.star_0_earned = ::std::option::Option::Some(v);
    }

    // optional bool star_1_earned = 3;


    pub fn get_star_1_earned(&self) -> bool {
        self.star_1_earned.unwrap_or(false)
    }
    pub fn clear_star_1_earned(&mut self) {
        self.star_1_earned = ::std::option::Option::None;
    }

    pub fn has_star_1_earned(&self) -> bool {
        self.star_1_earned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_star_1_earned(&mut self, v: bool) {
        self.star_1_earned = ::std::option::Option::Some(v);
    }

    // optional bool star_2_earned = 4;


    pub fn get_star_2_earned(&self) -> bool {
        self.star_2_earned.unwrap_or(false)
    }
    pub fn clear_star_2_earned(&mut self) {
        self.star_2_earned = ::std::option::Option::None;
    }

    pub fn has_star_2_earned(&self) -> bool {
        self.star_2_earned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_star_2_earned(&mut self, v: bool) {
        self.star_2_earned = ::std::option::Option::Some(v);
    }

    // repeated uint64 items_earned = 5;


    pub fn get_items_earned(&self) -> &[u64] {
        &self.items_earned
    }
    pub fn clear_items_earned(&mut self) {
        self.items_earned.clear();
    }

    // Param is passed by value, moved
    pub fn set_items_earned(&mut self, v: ::std::vec::Vec<u64>) {
        self.items_earned = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items_earned(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.items_earned
    }

    // Take field
    pub fn take_items_earned(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.items_earned, ::std::vec::Vec::new())
    }

    // optional uint32 reward_credits_earned = 6;


    pub fn get_reward_credits_earned(&self) -> u32 {
        self.reward_credits_earned.unwrap_or(0)
    }
    pub fn clear_reward_credits_earned(&mut self) {
        self.reward_credits_earned = ::std::option::Option::None;
    }

    pub fn has_reward_credits_earned(&self) -> bool {
        self.reward_credits_earned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reward_credits_earned(&mut self, v: u32) {
        self.reward_credits_earned = ::std::option::Option::Some(v);
    }

    // optional bool contract_completed = 7;


    pub fn get_contract_completed(&self) -> bool {
        self.contract_completed.unwrap_or(false)
    }
    pub fn clear_contract_completed(&mut self) {
        self.contract_completed = ::std::option::Option::None;
    }

    pub fn has_contract_completed(&self) -> bool {
        self.contract_completed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_contract_completed(&mut self, v: bool) {
        self.contract_completed = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgQuestProgressReport {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.quest_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.star_0_earned = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.star_1_earned = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.star_2_earned = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.items_earned)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.reward_credits_earned = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.contract_completed = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.quest_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.star_0_earned {
            my_size += 2;
        }
        if let Some(v) = self.star_1_earned {
            my_size += 2;
        }
        if let Some(v) = self.star_2_earned {
            my_size += 2;
        }
        for value in &self.items_earned {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.reward_credits_earned {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.contract_completed {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.quest_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.star_0_earned {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.star_1_earned {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.star_2_earned {
            os.write_bool(4, v)?;
        }
        for v in &self.items_earned {
            os.write_uint64(5, *v)?;
        };
        if let Some(v) = self.reward_credits_earned {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.contract_completed {
            os.write_bool(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgQuestProgressReport {
        CMsgQuestProgressReport::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "quest_id",
                |m: &CMsgQuestProgressReport| { &m.quest_id },
                |m: &mut CMsgQuestProgressReport| { &mut m.quest_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "star_0_earned",
                |m: &CMsgQuestProgressReport| { &m.star_0_earned },
                |m: &mut CMsgQuestProgressReport| { &mut m.star_0_earned },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "star_1_earned",
                |m: &CMsgQuestProgressReport| { &m.star_1_earned },
                |m: &mut CMsgQuestProgressReport| { &mut m.star_1_earned },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "star_2_earned",
                |m: &CMsgQuestProgressReport| { &m.star_2_earned },
                |m: &mut CMsgQuestProgressReport| { &mut m.star_2_earned },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "items_earned",
                |m: &CMsgQuestProgressReport| { &m.items_earned },
                |m: &mut CMsgQuestProgressReport| { &mut m.items_earned },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "reward_credits_earned",
                |m: &CMsgQuestProgressReport| { &m.reward_credits_earned },
                |m: &mut CMsgQuestProgressReport| { &mut m.reward_credits_earned },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "contract_completed",
                |m: &CMsgQuestProgressReport| { &m.contract_completed },
                |m: &mut CMsgQuestProgressReport| { &mut m.contract_completed },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgQuestProgressReport>(
                "CMsgQuestProgressReport",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgQuestProgressReport {
        static instance: ::protobuf::rt::LazyV2<CMsgQuestProgressReport> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgQuestProgressReport::new)
    }
}

impl ::protobuf::Clear for CMsgQuestProgressReport {
    fn clear(&mut self) {
        self.quest_id = ::std::option::Option::None;
        self.star_0_earned = ::std::option::Option::None;
        self.star_1_earned = ::std::option::Option::None;
        self.star_2_earned = ::std::option::Option::None;
        self.items_earned.clear();
        self.reward_credits_earned = ::std::option::Option::None;
        self.contract_completed = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgQuestProgressReport {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgQuestProgressReport {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgConsumePaintkit {
    // message fields
    source_id: ::std::option::Option<u64>,
    target_defindex: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgConsumePaintkit {
    fn default() -> &'a CMsgConsumePaintkit {
        <CMsgConsumePaintkit as ::protobuf::Message>::default_instance()
    }
}

impl CMsgConsumePaintkit {
    pub fn new() -> CMsgConsumePaintkit {
        ::std::default::Default::default()
    }

    // optional fixed64 source_id = 1;


    pub fn get_source_id(&self) -> u64 {
        self.source_id.unwrap_or(0)
    }
    pub fn clear_source_id(&mut self) {
        self.source_id = ::std::option::Option::None;
    }

    pub fn has_source_id(&self) -> bool {
        self.source_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source_id(&mut self, v: u64) {
        self.source_id = ::std::option::Option::Some(v);
    }

    // optional uint32 target_defindex = 2;


    pub fn get_target_defindex(&self) -> u32 {
        self.target_defindex.unwrap_or(0)
    }
    pub fn clear_target_defindex(&mut self) {
        self.target_defindex = ::std::option::Option::None;
    }

    pub fn has_target_defindex(&self) -> bool {
        self.target_defindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_defindex(&mut self, v: u32) {
        self.target_defindex = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgConsumePaintkit {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.source_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.target_defindex = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.source_id {
            my_size += 9;
        }
        if let Some(v) = self.target_defindex {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.source_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.target_defindex {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgConsumePaintkit {
        CMsgConsumePaintkit::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "source_id",
                |m: &CMsgConsumePaintkit| { &m.source_id },
                |m: &mut CMsgConsumePaintkit| { &mut m.source_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "target_defindex",
                |m: &CMsgConsumePaintkit| { &m.target_defindex },
                |m: &mut CMsgConsumePaintkit| { &mut m.target_defindex },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgConsumePaintkit>(
                "CMsgConsumePaintkit",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgConsumePaintkit {
        static instance: ::protobuf::rt::LazyV2<CMsgConsumePaintkit> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgConsumePaintkit::new)
    }
}

impl ::protobuf::Clear for CMsgConsumePaintkit {
    fn clear(&mut self) {
        self.source_id = ::std::option::Option::None;
        self.target_defindex = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgConsumePaintkit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgConsumePaintkit {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgPainkitDevGrant {
    // message fields
    paintkit_defindex: ::std::option::Option<u32>,
    wear: ::std::option::Option<f32>,
    item_defindex: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgPainkitDevGrant {
    fn default() -> &'a CMsgPainkitDevGrant {
        <CMsgPainkitDevGrant as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPainkitDevGrant {
    pub fn new() -> CMsgPainkitDevGrant {
        ::std::default::Default::default()
    }

    // optional uint32 paintkit_defindex = 1;


    pub fn get_paintkit_defindex(&self) -> u32 {
        self.paintkit_defindex.unwrap_or(0)
    }
    pub fn clear_paintkit_defindex(&mut self) {
        self.paintkit_defindex = ::std::option::Option::None;
    }

    pub fn has_paintkit_defindex(&self) -> bool {
        self.paintkit_defindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_paintkit_defindex(&mut self, v: u32) {
        self.paintkit_defindex = ::std::option::Option::Some(v);
    }

    // optional float wear = 2;


    pub fn get_wear(&self) -> f32 {
        self.wear.unwrap_or(0.)
    }
    pub fn clear_wear(&mut self) {
        self.wear = ::std::option::Option::None;
    }

    pub fn has_wear(&self) -> bool {
        self.wear.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wear(&mut self, v: f32) {
        self.wear = ::std::option::Option::Some(v);
    }

    // optional uint32 item_defindex = 3;


    pub fn get_item_defindex(&self) -> u32 {
        self.item_defindex.unwrap_or(0)
    }
    pub fn clear_item_defindex(&mut self) {
        self.item_defindex = ::std::option::Option::None;
    }

    pub fn has_item_defindex(&self) -> bool {
        self.item_defindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_defindex(&mut self, v: u32) {
        self.item_defindex = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgPainkitDevGrant {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.paintkit_defindex = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.wear = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.item_defindex = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.paintkit_defindex {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.wear {
            my_size += 5;
        }
        if let Some(v) = self.item_defindex {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.paintkit_defindex {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.wear {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.item_defindex {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgPainkitDevGrant {
        CMsgPainkitDevGrant::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "paintkit_defindex",
                |m: &CMsgPainkitDevGrant| { &m.paintkit_defindex },
                |m: &mut CMsgPainkitDevGrant| { &mut m.paintkit_defindex },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "wear",
                |m: &CMsgPainkitDevGrant| { &m.wear },
                |m: &mut CMsgPainkitDevGrant| { &mut m.wear },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "item_defindex",
                |m: &CMsgPainkitDevGrant| { &m.item_defindex },
                |m: &mut CMsgPainkitDevGrant| { &mut m.item_defindex },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgPainkitDevGrant>(
                "CMsgPainkitDevGrant",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgPainkitDevGrant {
        static instance: ::protobuf::rt::LazyV2<CMsgPainkitDevGrant> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgPainkitDevGrant::new)
    }
}

impl ::protobuf::Clear for CMsgPainkitDevGrant {
    fn clear(&mut self) {
        self.paintkit_defindex = ::std::option::Option::None;
        self.wear = ::std::option::Option::None;
        self.item_defindex = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgPainkitDevGrant {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPainkitDevGrant {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GCQuestStrangeEvent {
    // message fields
    owner_account_id: ::std::option::Option<u32>,
    scorer_account_id: ::std::option::Option<u32>,
    quest_id: ::std::option::Option<u64>,
    strange_event_id: ::std::option::Option<u32>,
    score: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GCQuestStrangeEvent {
    fn default() -> &'a GCQuestStrangeEvent {
        <GCQuestStrangeEvent as ::protobuf::Message>::default_instance()
    }
}

impl GCQuestStrangeEvent {
    pub fn new() -> GCQuestStrangeEvent {
        ::std::default::Default::default()
    }

    // optional uint32 owner_account_id = 1;


    pub fn get_owner_account_id(&self) -> u32 {
        self.owner_account_id.unwrap_or(0)
    }
    pub fn clear_owner_account_id(&mut self) {
        self.owner_account_id = ::std::option::Option::None;
    }

    pub fn has_owner_account_id(&self) -> bool {
        self.owner_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner_account_id(&mut self, v: u32) {
        self.owner_account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 scorer_account_id = 2;


    pub fn get_scorer_account_id(&self) -> u32 {
        self.scorer_account_id.unwrap_or(0)
    }
    pub fn clear_scorer_account_id(&mut self) {
        self.scorer_account_id = ::std::option::Option::None;
    }

    pub fn has_scorer_account_id(&self) -> bool {
        self.scorer_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scorer_account_id(&mut self, v: u32) {
        self.scorer_account_id = ::std::option::Option::Some(v);
    }

    // optional uint64 quest_id = 3;


    pub fn get_quest_id(&self) -> u64 {
        self.quest_id.unwrap_or(0)
    }
    pub fn clear_quest_id(&mut self) {
        self.quest_id = ::std::option::Option::None;
    }

    pub fn has_quest_id(&self) -> bool {
        self.quest_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quest_id(&mut self, v: u64) {
        self.quest_id = ::std::option::Option::Some(v);
    }

    // optional uint32 strange_event_id = 4;


    pub fn get_strange_event_id(&self) -> u32 {
        self.strange_event_id.unwrap_or(0)
    }
    pub fn clear_strange_event_id(&mut self) {
        self.strange_event_id = ::std::option::Option::None;
    }

    pub fn has_strange_event_id(&self) -> bool {
        self.strange_event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_strange_event_id(&mut self, v: u32) {
        self.strange_event_id = ::std::option::Option::Some(v);
    }

    // optional uint32 score = 5;


    pub fn get_score(&self) -> u32 {
        self.score.unwrap_or(0)
    }
    pub fn clear_score(&mut self) {
        self.score = ::std::option::Option::None;
    }

    pub fn has_score(&self) -> bool {
        self.score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_score(&mut self, v: u32) {
        self.score = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for GCQuestStrangeEvent {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.owner_account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.scorer_account_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.quest_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.strange_event_id = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.score = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.owner_account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.scorer_account_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.quest_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.strange_event_id {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.score {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.owner_account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.scorer_account_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.quest_id {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.strange_event_id {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.score {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GCQuestStrangeEvent {
        GCQuestStrangeEvent::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "owner_account_id",
                |m: &GCQuestStrangeEvent| { &m.owner_account_id },
                |m: &mut GCQuestStrangeEvent| { &mut m.owner_account_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "scorer_account_id",
                |m: &GCQuestStrangeEvent| { &m.scorer_account_id },
                |m: &mut GCQuestStrangeEvent| { &mut m.scorer_account_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "quest_id",
                |m: &GCQuestStrangeEvent| { &m.quest_id },
                |m: &mut GCQuestStrangeEvent| { &mut m.quest_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "strange_event_id",
                |m: &GCQuestStrangeEvent| { &m.strange_event_id },
                |m: &mut GCQuestStrangeEvent| { &mut m.strange_event_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "score",
                |m: &GCQuestStrangeEvent| { &m.score },
                |m: &mut GCQuestStrangeEvent| { &mut m.score },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GCQuestStrangeEvent>(
                "GCQuestStrangeEvent",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GCQuestStrangeEvent {
        static instance: ::protobuf::rt::LazyV2<GCQuestStrangeEvent> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GCQuestStrangeEvent::new)
    }
}

impl ::protobuf::Clear for GCQuestStrangeEvent {
    fn clear(&mut self) {
        self.owner_account_id = ::std::option::Option::None;
        self.scorer_account_id = ::std::option::Option::None;
        self.quest_id = ::std::option::Option::None;
        self.strange_event_id = ::std::option::Option::None;
        self.score = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GCQuestStrangeEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GCQuestStrangeEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSDRTicket {
    // message fields
    serialized_ticket: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSDRTicket {
    fn default() -> &'a CMsgSDRTicket {
        <CMsgSDRTicket as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSDRTicket {
    pub fn new() -> CMsgSDRTicket {
        ::std::default::Default::default()
    }

    // optional bytes serialized_ticket = 1;


    pub fn get_serialized_ticket(&self) -> &[u8] {
        match self.serialized_ticket.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_serialized_ticket(&mut self) {
        self.serialized_ticket.clear();
    }

    pub fn has_serialized_ticket(&self) -> bool {
        self.serialized_ticket.is_some()
    }

    // Param is passed by value, moved
    pub fn set_serialized_ticket(&mut self, v: ::std::vec::Vec<u8>) {
        self.serialized_ticket = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_serialized_ticket(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.serialized_ticket.is_none() {
            self.serialized_ticket.set_default();
        }
        self.serialized_ticket.as_mut().unwrap()
    }

    // Take field
    pub fn take_serialized_ticket(&mut self) -> ::std::vec::Vec<u8> {
        self.serialized_ticket.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgSDRTicket {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.serialized_ticket)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.serialized_ticket.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.serialized_ticket.as_ref() {
            os.write_bytes(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSDRTicket {
        CMsgSDRTicket::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "serialized_ticket",
                |m: &CMsgSDRTicket| { &m.serialized_ticket },
                |m: &mut CMsgSDRTicket| { &mut m.serialized_ticket },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSDRTicket>(
                "CMsgSDRTicket",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSDRTicket {
        static instance: ::protobuf::rt::LazyV2<CMsgSDRTicket> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSDRTicket::new)
    }
}

impl ::protobuf::Clear for CMsgSDRTicket {
    fn clear(&mut self) {
        self.serialized_ticket.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSDRTicket {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSDRTicket {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ETFGCMsg {
    k_EMsgGCReportWarKill = 5001,
    k_EMsgGCKickPlayer_DEPRECATED = 5020,
    k_EMsgGCStartedTraining_DEPRECATED = 5021,
    k_EMsgGCFreeTrial_ChooseMostHelpfulFriend = 5022,
    k_EMsgGCRequestTF2Friends = 5023,
    k_EMsgGCRequestTF2FriendsResponse = 5024,
    k_EMsgGCReplay_SubmitContestEntry = 5026,
    k_EMsgGCReplay_SubmitContestEntryResponse = 5027,
    k_EMsgGCSaxxy_Awarded = 5029,
    k_EMsgGCFreeTrial_ThankedBySomeone = 5028,
    k_EMsgGCFreeTrial_ThankedSomeone = 5030,
    k_EMsgGCFreeTrial_ConvertedToPremium = 5031,
    k_EMsgGCMeetThePyroSilliness_BananaCraft_DEPRECATED = 5032,
    k_EMsgGCMVMARG_HighFiveSuccessResponse_DEPRECATED = 5033,
    k_EMsgGCMVMARG_HighFiveOnClient_DEPRECATED = 5034,
    k_EMsgGCCoaching_AddToCoaches = 5200,
    k_EMsgGCCoaching_AddToCoachesResponse = 5201,
    k_EMsgGCCoaching_RemoveFromCoaches = 5202,
    k_EMsgGCCoaching_RemoveFromCoachesResponse = 5203,
    k_EMsgGCCoaching_FindCoach = 5204,
    k_EMsgGCCoaching_FindCoachResponse = 5205,
    k_EMsgGCCoaching_AskCoach = 5206,
    k_EMsgGCCoaching_AskCoachResponse = 5207,
    k_EMsgGCCoaching_CoachJoinGame = 5208,
    k_EMsgGCCoaching_CoachJoining = 5209,
    k_EMsgGCCoaching_CoachJoined = 5210,
    k_EMsgGCCoaching_LikeCurrentCoach = 5211,
    k_EMsgGCCoaching_RemoveCurrentCoach = 5212,
    k_EMsgGCCoaching_AlreadyRatedCoach = 5213,
    k_EMsgGC_Duel_Request = 5500,
    k_EMsgGC_Duel_Response = 5501,
    k_EMsgGC_Duel_Results = 5502,
    k_EMsgGC_Duel_Status = 5503,
    k_EMsgGC_Halloween_ReservedItem_DEPRECATED = 5600,
    k_EMsgGC_Halloween_GrantItem_DEPRECATED = 5601,
    k_EMsgGC_Halloween_GrantItemResponse_DEPRECATED = 5604,
    k_EMsgGC_Halloween_Cheat_QueryResponse_DEPRECATED = 5605,
    k_EMsgGC_Halloween_ItemClaimed_DEPRECATED = 5606,
    k_EMsgGC_Halloween_ReservedItem = 5607,
    k_EMsgGC_Halloween_GrantItem = 5608,
    k_EMsgGC_Halloween_GrantItemResponse = 5609,
    k_EMsgGC_Halloween_Cheat_QueryResponse_DEPRECATED_2 = 5610,
    k_EMsgGC_Halloween_ItemClaimed_DEPRECATED_2 = 5611,
    k_EMsgGC_Halloween_ServerBossEvent = 5612,
    k_EMsgGC_Halloween_Merasmus2012 = 5613,
    k_EMsgGC_Halloween_UpdateMerasmusLootLevel = 5614,
    k_EMsgGC_GameServer_LevelInfo = 5700,
    k_EMsgGC_GameServer_AuthChallenge = 5701,
    k_EMsgGC_GameServer_AuthChallengeResponse = 5702,
    k_EMsgGC_GameServer_CreateIdentity = 5703,
    k_EMsgGC_GameServer_CreateIdentityResponse = 5704,
    k_EMsgGC_GameServer_List = 5705,
    k_EMsgGC_GameServer_ListResponse = 5706,
    k_EMsgGC_GameServer_AuthResult = 5707,
    k_EMsgGC_GameServer_ResetIdentity = 5708,
    k_EMsgGC_GameServer_ResetIdentityResponse = 5709,
    k_EMsgGC_Client_UseServerModificationItem = 5710,
    k_EMsgGC_Client_UseServerModificationItem_Response = 5711,
    k_EMsgGC_GameServer_UseServerModificationItem = 5712,
    k_EMsgGC_GameServer_UseServerModificationItem_Response = 5713,
    k_EMsgGC_GameServer_ServerModificationItemExpired = 5714,
    k_EMsgGC_GameServer_ModificationItemState = 5715,
    k_EMsgGC_GameServer_AckPolicy = 5716,
    k_EMsgGC_GameServer_AckPolicyResponse = 5717,
    k_EMsgGC_QP_ScoreServers = 5800,
    k_EMsgGC_QP_ScoreServersResponse = 5801,
    k_EMsgGC_QP_PlayerJoining = 5802,
    k_EMsgGC_PickupItemEligibility_Query_DEPRECATED = 6000,
    k_EMsgGC_PickupItemEligibility_Query_DEPRECATED_2 = 6001,
    k_EMsgGC_IncrementKillCountAttribute_DEPRECATED = 6100,
    k_EMsgGC_IncrementKillCountResponse_DEPRECATED = 6101,
    k_EMsgGCAbandonCurrentGame = 6235,
    k_EMsgForceSOCacheResend = 6237,
    k_EMsgGCRequestChatChannelList = 6260,
    k_EMsgGCRequestChatChannelListResponse = 6261,
    k_EMsgGCReadyUp = 6270,
    k_EMsgGCKickedFromMatchmakingQueue = 6271,
    k_EMsgGCLeaverDetected = 6272,
    k_EMsgGCLeaverDetectedResponse = 6287,
    k_EMsgGCExitMatchmaking = 6289,
    k_EMsgGCMatchmakingProgress = 6293,
    k_EMsgGCMvMVictoryInfo = 6294,
    k_EMsgGCGameServerMatchmakingStatus = 6295,
    k_EMsgGCMvMVictory = 6297,
    k_EMsgGCMvMVictoryReply = 6298,
    k_EMsgGCGameServerKickingLobby = 6299,
    k_EMsgGCLeaveGameAndPrepareToJoinParty = 6300,
    k_EMsgGC_UpdatePeriodicEvent = 6400,
    k_EMsgGC_DuckLeaderboard_IndividualUpdate = 6401,
    k_EMsgGC_Client2GCEconPreviewDataBlockRequest = 6402,
    k_EMsgGC_Client2GCEconPreviewDataBlockResponse = 6403,
    k_EMsgGC_ClientVerificationChallenge = 6500,
    k_EMsgGC_ClientVerificationChallengeResponse = 6501,
    k_EMsgGC_ClientVerificationVerboseResponse = 6502,
    k_EMsgGC_ClientSetItemSlotAttribute = 6503,
    k_EMsgGC_War_IndividualUpdate = 6505,
    k_EMsgGC_War_JoinWar = 6506,
    k_EMsgGC_War_RequestGlobalStats = 6507,
    k_EMsgGC_War_GlobalStatsResponse = 6508,
    k_EMsgGC_WorldItemPlacement_Attribute = 6510,
    k_EMsgGC_WorldItemPlacement_Update = 6511,
    k_EMsgGC_Match_Result = 6512,
    k_EMsgGCVoteKickPlayerRequest = 6513,
    k_EMsgGCVoteKickPlayerRequestResponse = 6514,
    k_EMsgGC_DailyCompetitiveStatsRollup = 6516,
    k_EMsgGC_DailyCompetitiveStatsRollup_Response = 6517,
    k_EMsgGC_WorldStatusBroadcast = 6518,
    k_EMsgGC_ReportPlayer = 6519,
    k_EMsgGC_Match_ResultResponse = 6520,
    k_EMsgGCGameServerKickingLobbyResponse = 6521,
    k_EMsgGCPlayerLeftMatch = 6522,
    k_EMsgGCPlayerLeftMatchResponse = 6523,
    k_EMsgGCRequestMatchMakerStats = 6524,
    k_EMsgGCMatchMakerStatsResponse = 6525,
    k_EMsgGCMatchHistoryLoad = 6526,
    k_EMsgGC_AcknowledgeXP = 6527,
    k_EMsgGCDataCenterPing_Update = 6528,
    k_EMsgGC_NotificationAcknowledge = 6529,
    k_EMsgGC_NotificationAcknowledgeReply = 6530,
    k_EMsgGC_KickPlayerFromLobby = 6531,
    k_EMsgGC_SurveyQuestionRequest = 6534,
    k_EMsgGC_SurveyQuestionResponse = 6535,
    k_EMsgGC_TFClientInit = 6536,
    k_EMsgGC_NewMatchForLobbyRequest = 6537,
    k_EMsgGC_NewMatchForLobbyResponse = 6538,
    k_EMsgGC_ChangeMatchPlayerTeamsRequest = 6539,
    k_EMsgGC_ChangeMatchPlayerTeamsResponse = 6540,
    k_EMsgGC_QuestIdentify = 6541,
    k_EMsgGC_QuestDevGive = 6542,
    k_EMsgGCQuestComplete_Debug = 6544,
    k_EMsgGC_QuestMapDebug = 6545,
    k_EMsgGC_QuestMapUnlockNode = 6547,
    k_EMsgGC_QuestMapPurchaseReward = 6549,
    k_EMsgGC_SetDisablePartyQuestProgress = 6550,
    k_EMsgGCQuestProgressReport = 6553,
    k_EMsgGCParty_SetOptions = 6554,
    k_EMsgGCParty_SetOptionsResponse = 6555,
    k_EMsgGCParty_QueueForMatch = 6556,
    k_EMsgGCParty_QueueForMatchResponse = 6557,
    k_EMsgGCParty_RemoveFromQueue = 6558,
    k_EMsgGCParty_RemoveFromQueueResponse = 6559,
    k_EMsgGCParty_InvitePlayer = 6560,
    k_EMsgGCParty_RequestJoinPlayer = 6561,
    k_EMsgGCParty_SendChat = 6562,
    k_EMsgGCParty_ChatMsg = 6563,
    k_EMsgGCQuestNodeTurnIn = 6564,
    k_EMsgGCConsumePaintKit = 6565,
    k_EMsgGC_Painkit_DevGrant = 6566,
    k_EMsgGCParty_QueueForStandby = 6567,
    k_EMsgGCParty_QueueForStandbyResponse = 6568,
    k_EMsgGCParty_RemoveFromStandbyQueue = 6569,
    k_EMsgGCParty_RemoveFromStandbyQueueResponse = 6570,
    k_EMsgGCParty_ClearPendingPlayer = 6571,
    k_EMsgGCParty_ClearPendingPlayerResponse = 6572,
    k_EMsgGCParty_ClearOtherPartyRequest = 6573,
    k_EMsgGCParty_ClearOtherPartyRequestResponse = 6574,
    k_EMsgGCParty_PromoteToLeader = 6575,
    k_EMsgGCParty_KickMember = 6576,
    k_EMsgGCQuestStrangeEvent = 6577,
    k_EMsgGC_AcceptLobbyInvite = 6578,
    k_EMsgGC_AcceptLobbyInviteReply = 6579,
    k_EMsgGC_SDRTicket = 6580,
    k_EMsgGC_ProcessMatchVoteKick = 6581,
    k_EMsgGC_ProcessMatchVoteKickResponse = 6582,
    k_EMsgGCDev_GrantWarKill = 10001,
}

impl ::protobuf::ProtobufEnum for ETFGCMsg {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ETFGCMsg> {
        match value {
            5001 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCReportWarKill),
            5020 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCKickPlayer_DEPRECATED),
            5021 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCStartedTraining_DEPRECATED),
            5022 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCFreeTrial_ChooseMostHelpfulFriend),
            5023 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCRequestTF2Friends),
            5024 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCRequestTF2FriendsResponse),
            5026 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCReplay_SubmitContestEntry),
            5027 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCReplay_SubmitContestEntryResponse),
            5029 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCSaxxy_Awarded),
            5028 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCFreeTrial_ThankedBySomeone),
            5030 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCFreeTrial_ThankedSomeone),
            5031 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCFreeTrial_ConvertedToPremium),
            5032 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCMeetThePyroSilliness_BananaCraft_DEPRECATED),
            5033 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCMVMARG_HighFiveSuccessResponse_DEPRECATED),
            5034 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCMVMARG_HighFiveOnClient_DEPRECATED),
            5200 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCCoaching_AddToCoaches),
            5201 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCCoaching_AddToCoachesResponse),
            5202 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCCoaching_RemoveFromCoaches),
            5203 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCCoaching_RemoveFromCoachesResponse),
            5204 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCCoaching_FindCoach),
            5205 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCCoaching_FindCoachResponse),
            5206 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCCoaching_AskCoach),
            5207 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCCoaching_AskCoachResponse),
            5208 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCCoaching_CoachJoinGame),
            5209 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCCoaching_CoachJoining),
            5210 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCCoaching_CoachJoined),
            5211 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCCoaching_LikeCurrentCoach),
            5212 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCCoaching_RemoveCurrentCoach),
            5213 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCCoaching_AlreadyRatedCoach),
            5500 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Duel_Request),
            5501 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Duel_Response),
            5502 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Duel_Results),
            5503 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Duel_Status),
            5600 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Halloween_ReservedItem_DEPRECATED),
            5601 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Halloween_GrantItem_DEPRECATED),
            5604 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Halloween_GrantItemResponse_DEPRECATED),
            5605 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Halloween_Cheat_QueryResponse_DEPRECATED),
            5606 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Halloween_ItemClaimed_DEPRECATED),
            5607 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Halloween_ReservedItem),
            5608 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Halloween_GrantItem),
            5609 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Halloween_GrantItemResponse),
            5610 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Halloween_Cheat_QueryResponse_DEPRECATED_2),
            5611 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Halloween_ItemClaimed_DEPRECATED_2),
            5612 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Halloween_ServerBossEvent),
            5613 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Halloween_Merasmus2012),
            5614 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Halloween_UpdateMerasmusLootLevel),
            5700 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_GameServer_LevelInfo),
            5701 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_GameServer_AuthChallenge),
            5702 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_GameServer_AuthChallengeResponse),
            5703 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_GameServer_CreateIdentity),
            5704 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_GameServer_CreateIdentityResponse),
            5705 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_GameServer_List),
            5706 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_GameServer_ListResponse),
            5707 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_GameServer_AuthResult),
            5708 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_GameServer_ResetIdentity),
            5709 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_GameServer_ResetIdentityResponse),
            5710 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Client_UseServerModificationItem),
            5711 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Client_UseServerModificationItem_Response),
            5712 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_GameServer_UseServerModificationItem),
            5713 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_GameServer_UseServerModificationItem_Response),
            5714 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_GameServer_ServerModificationItemExpired),
            5715 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_GameServer_ModificationItemState),
            5716 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_GameServer_AckPolicy),
            5717 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_GameServer_AckPolicyResponse),
            5800 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_QP_ScoreServers),
            5801 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_QP_ScoreServersResponse),
            5802 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_QP_PlayerJoining),
            6000 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_PickupItemEligibility_Query_DEPRECATED),
            6001 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_PickupItemEligibility_Query_DEPRECATED_2),
            6100 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_IncrementKillCountAttribute_DEPRECATED),
            6101 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_IncrementKillCountResponse_DEPRECATED),
            6235 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCAbandonCurrentGame),
            6237 => ::std::option::Option::Some(ETFGCMsg::k_EMsgForceSOCacheResend),
            6260 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCRequestChatChannelList),
            6261 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCRequestChatChannelListResponse),
            6270 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCReadyUp),
            6271 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCKickedFromMatchmakingQueue),
            6272 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCLeaverDetected),
            6287 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCLeaverDetectedResponse),
            6289 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCExitMatchmaking),
            6293 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCMatchmakingProgress),
            6294 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCMvMVictoryInfo),
            6295 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCGameServerMatchmakingStatus),
            6297 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCMvMVictory),
            6298 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCMvMVictoryReply),
            6299 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCGameServerKickingLobby),
            6300 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCLeaveGameAndPrepareToJoinParty),
            6400 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_UpdatePeriodicEvent),
            6401 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_DuckLeaderboard_IndividualUpdate),
            6402 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Client2GCEconPreviewDataBlockRequest),
            6403 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Client2GCEconPreviewDataBlockResponse),
            6500 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_ClientVerificationChallenge),
            6501 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_ClientVerificationChallengeResponse),
            6502 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_ClientVerificationVerboseResponse),
            6503 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_ClientSetItemSlotAttribute),
            6505 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_War_IndividualUpdate),
            6506 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_War_JoinWar),
            6507 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_War_RequestGlobalStats),
            6508 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_War_GlobalStatsResponse),
            6510 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_WorldItemPlacement_Attribute),
            6511 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_WorldItemPlacement_Update),
            6512 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Match_Result),
            6513 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCVoteKickPlayerRequest),
            6514 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCVoteKickPlayerRequestResponse),
            6516 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_DailyCompetitiveStatsRollup),
            6517 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_DailyCompetitiveStatsRollup_Response),
            6518 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_WorldStatusBroadcast),
            6519 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_ReportPlayer),
            6520 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Match_ResultResponse),
            6521 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCGameServerKickingLobbyResponse),
            6522 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCPlayerLeftMatch),
            6523 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCPlayerLeftMatchResponse),
            6524 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCRequestMatchMakerStats),
            6525 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCMatchMakerStatsResponse),
            6526 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCMatchHistoryLoad),
            6527 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_AcknowledgeXP),
            6528 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCDataCenterPing_Update),
            6529 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_NotificationAcknowledge),
            6530 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_NotificationAcknowledgeReply),
            6531 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_KickPlayerFromLobby),
            6534 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_SurveyQuestionRequest),
            6535 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_SurveyQuestionResponse),
            6536 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_TFClientInit),
            6537 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_NewMatchForLobbyRequest),
            6538 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_NewMatchForLobbyResponse),
            6539 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_ChangeMatchPlayerTeamsRequest),
            6540 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_ChangeMatchPlayerTeamsResponse),
            6541 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_QuestIdentify),
            6542 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_QuestDevGive),
            6544 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCQuestComplete_Debug),
            6545 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_QuestMapDebug),
            6547 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_QuestMapUnlockNode),
            6549 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_QuestMapPurchaseReward),
            6550 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_SetDisablePartyQuestProgress),
            6553 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCQuestProgressReport),
            6554 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_SetOptions),
            6555 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_SetOptionsResponse),
            6556 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_QueueForMatch),
            6557 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_QueueForMatchResponse),
            6558 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_RemoveFromQueue),
            6559 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_RemoveFromQueueResponse),
            6560 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_InvitePlayer),
            6561 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_RequestJoinPlayer),
            6562 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_SendChat),
            6563 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_ChatMsg),
            6564 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCQuestNodeTurnIn),
            6565 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCConsumePaintKit),
            6566 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Painkit_DevGrant),
            6567 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_QueueForStandby),
            6568 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_QueueForStandbyResponse),
            6569 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_RemoveFromStandbyQueue),
            6570 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_RemoveFromStandbyQueueResponse),
            6571 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_ClearPendingPlayer),
            6572 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_ClearPendingPlayerResponse),
            6573 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_ClearOtherPartyRequest),
            6574 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_ClearOtherPartyRequestResponse),
            6575 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_PromoteToLeader),
            6576 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_KickMember),
            6577 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCQuestStrangeEvent),
            6578 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_AcceptLobbyInvite),
            6579 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_AcceptLobbyInviteReply),
            6580 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_SDRTicket),
            6581 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_ProcessMatchVoteKick),
            6582 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_ProcessMatchVoteKickResponse),
            10001 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCDev_GrantWarKill),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ETFGCMsg] = &[
            ETFGCMsg::k_EMsgGCReportWarKill,
            ETFGCMsg::k_EMsgGCKickPlayer_DEPRECATED,
            ETFGCMsg::k_EMsgGCStartedTraining_DEPRECATED,
            ETFGCMsg::k_EMsgGCFreeTrial_ChooseMostHelpfulFriend,
            ETFGCMsg::k_EMsgGCRequestTF2Friends,
            ETFGCMsg::k_EMsgGCRequestTF2FriendsResponse,
            ETFGCMsg::k_EMsgGCReplay_SubmitContestEntry,
            ETFGCMsg::k_EMsgGCReplay_SubmitContestEntryResponse,
            ETFGCMsg::k_EMsgGCSaxxy_Awarded,
            ETFGCMsg::k_EMsgGCFreeTrial_ThankedBySomeone,
            ETFGCMsg::k_EMsgGCFreeTrial_ThankedSomeone,
            ETFGCMsg::k_EMsgGCFreeTrial_ConvertedToPremium,
            ETFGCMsg::k_EMsgGCMeetThePyroSilliness_BananaCraft_DEPRECATED,
            ETFGCMsg::k_EMsgGCMVMARG_HighFiveSuccessResponse_DEPRECATED,
            ETFGCMsg::k_EMsgGCMVMARG_HighFiveOnClient_DEPRECATED,
            ETFGCMsg::k_EMsgGCCoaching_AddToCoaches,
            ETFGCMsg::k_EMsgGCCoaching_AddToCoachesResponse,
            ETFGCMsg::k_EMsgGCCoaching_RemoveFromCoaches,
            ETFGCMsg::k_EMsgGCCoaching_RemoveFromCoachesResponse,
            ETFGCMsg::k_EMsgGCCoaching_FindCoach,
            ETFGCMsg::k_EMsgGCCoaching_FindCoachResponse,
            ETFGCMsg::k_EMsgGCCoaching_AskCoach,
            ETFGCMsg::k_EMsgGCCoaching_AskCoachResponse,
            ETFGCMsg::k_EMsgGCCoaching_CoachJoinGame,
            ETFGCMsg::k_EMsgGCCoaching_CoachJoining,
            ETFGCMsg::k_EMsgGCCoaching_CoachJoined,
            ETFGCMsg::k_EMsgGCCoaching_LikeCurrentCoach,
            ETFGCMsg::k_EMsgGCCoaching_RemoveCurrentCoach,
            ETFGCMsg::k_EMsgGCCoaching_AlreadyRatedCoach,
            ETFGCMsg::k_EMsgGC_Duel_Request,
            ETFGCMsg::k_EMsgGC_Duel_Response,
            ETFGCMsg::k_EMsgGC_Duel_Results,
            ETFGCMsg::k_EMsgGC_Duel_Status,
            ETFGCMsg::k_EMsgGC_Halloween_ReservedItem_DEPRECATED,
            ETFGCMsg::k_EMsgGC_Halloween_GrantItem_DEPRECATED,
            ETFGCMsg::k_EMsgGC_Halloween_GrantItemResponse_DEPRECATED,
            ETFGCMsg::k_EMsgGC_Halloween_Cheat_QueryResponse_DEPRECATED,
            ETFGCMsg::k_EMsgGC_Halloween_ItemClaimed_DEPRECATED,
            ETFGCMsg::k_EMsgGC_Halloween_ReservedItem,
            ETFGCMsg::k_EMsgGC_Halloween_GrantItem,
            ETFGCMsg::k_EMsgGC_Halloween_GrantItemResponse,
            ETFGCMsg::k_EMsgGC_Halloween_Cheat_QueryResponse_DEPRECATED_2,
            ETFGCMsg::k_EMsgGC_Halloween_ItemClaimed_DEPRECATED_2,
            ETFGCMsg::k_EMsgGC_Halloween_ServerBossEvent,
            ETFGCMsg::k_EMsgGC_Halloween_Merasmus2012,
            ETFGCMsg::k_EMsgGC_Halloween_UpdateMerasmusLootLevel,
            ETFGCMsg::k_EMsgGC_GameServer_LevelInfo,
            ETFGCMsg::k_EMsgGC_GameServer_AuthChallenge,
            ETFGCMsg::k_EMsgGC_GameServer_AuthChallengeResponse,
            ETFGCMsg::k_EMsgGC_GameServer_CreateIdentity,
            ETFGCMsg::k_EMsgGC_GameServer_CreateIdentityResponse,
            ETFGCMsg::k_EMsgGC_GameServer_List,
            ETFGCMsg::k_EMsgGC_GameServer_ListResponse,
            ETFGCMsg::k_EMsgGC_GameServer_AuthResult,
            ETFGCMsg::k_EMsgGC_GameServer_ResetIdentity,
            ETFGCMsg::k_EMsgGC_GameServer_ResetIdentityResponse,
            ETFGCMsg::k_EMsgGC_Client_UseServerModificationItem,
            ETFGCMsg::k_EMsgGC_Client_UseServerModificationItem_Response,
            ETFGCMsg::k_EMsgGC_GameServer_UseServerModificationItem,
            ETFGCMsg::k_EMsgGC_GameServer_UseServerModificationItem_Response,
            ETFGCMsg::k_EMsgGC_GameServer_ServerModificationItemExpired,
            ETFGCMsg::k_EMsgGC_GameServer_ModificationItemState,
            ETFGCMsg::k_EMsgGC_GameServer_AckPolicy,
            ETFGCMsg::k_EMsgGC_GameServer_AckPolicyResponse,
            ETFGCMsg::k_EMsgGC_QP_ScoreServers,
            ETFGCMsg::k_EMsgGC_QP_ScoreServersResponse,
            ETFGCMsg::k_EMsgGC_QP_PlayerJoining,
            ETFGCMsg::k_EMsgGC_PickupItemEligibility_Query_DEPRECATED,
            ETFGCMsg::k_EMsgGC_PickupItemEligibility_Query_DEPRECATED_2,
            ETFGCMsg::k_EMsgGC_IncrementKillCountAttribute_DEPRECATED,
            ETFGCMsg::k_EMsgGC_IncrementKillCountResponse_DEPRECATED,
            ETFGCMsg::k_EMsgGCAbandonCurrentGame,
            ETFGCMsg::k_EMsgForceSOCacheResend,
            ETFGCMsg::k_EMsgGCRequestChatChannelList,
            ETFGCMsg::k_EMsgGCRequestChatChannelListResponse,
            ETFGCMsg::k_EMsgGCReadyUp,
            ETFGCMsg::k_EMsgGCKickedFromMatchmakingQueue,
            ETFGCMsg::k_EMsgGCLeaverDetected,
            ETFGCMsg::k_EMsgGCLeaverDetectedResponse,
            ETFGCMsg::k_EMsgGCExitMatchmaking,
            ETFGCMsg::k_EMsgGCMatchmakingProgress,
            ETFGCMsg::k_EMsgGCMvMVictoryInfo,
            ETFGCMsg::k_EMsgGCGameServerMatchmakingStatus,
            ETFGCMsg::k_EMsgGCMvMVictory,
            ETFGCMsg::k_EMsgGCMvMVictoryReply,
            ETFGCMsg::k_EMsgGCGameServerKickingLobby,
            ETFGCMsg::k_EMsgGCLeaveGameAndPrepareToJoinParty,
            ETFGCMsg::k_EMsgGC_UpdatePeriodicEvent,
            ETFGCMsg::k_EMsgGC_DuckLeaderboard_IndividualUpdate,
            ETFGCMsg::k_EMsgGC_Client2GCEconPreviewDataBlockRequest,
            ETFGCMsg::k_EMsgGC_Client2GCEconPreviewDataBlockResponse,
            ETFGCMsg::k_EMsgGC_ClientVerificationChallenge,
            ETFGCMsg::k_EMsgGC_ClientVerificationChallengeResponse,
            ETFGCMsg::k_EMsgGC_ClientVerificationVerboseResponse,
            ETFGCMsg::k_EMsgGC_ClientSetItemSlotAttribute,
            ETFGCMsg::k_EMsgGC_War_IndividualUpdate,
            ETFGCMsg::k_EMsgGC_War_JoinWar,
            ETFGCMsg::k_EMsgGC_War_RequestGlobalStats,
            ETFGCMsg::k_EMsgGC_War_GlobalStatsResponse,
            ETFGCMsg::k_EMsgGC_WorldItemPlacement_Attribute,
            ETFGCMsg::k_EMsgGC_WorldItemPlacement_Update,
            ETFGCMsg::k_EMsgGC_Match_Result,
            ETFGCMsg::k_EMsgGCVoteKickPlayerRequest,
            ETFGCMsg::k_EMsgGCVoteKickPlayerRequestResponse,
            ETFGCMsg::k_EMsgGC_DailyCompetitiveStatsRollup,
            ETFGCMsg::k_EMsgGC_DailyCompetitiveStatsRollup_Response,
            ETFGCMsg::k_EMsgGC_WorldStatusBroadcast,
            ETFGCMsg::k_EMsgGC_ReportPlayer,
            ETFGCMsg::k_EMsgGC_Match_ResultResponse,
            ETFGCMsg::k_EMsgGCGameServerKickingLobbyResponse,
            ETFGCMsg::k_EMsgGCPlayerLeftMatch,
            ETFGCMsg::k_EMsgGCPlayerLeftMatchResponse,
            ETFGCMsg::k_EMsgGCRequestMatchMakerStats,
            ETFGCMsg::k_EMsgGCMatchMakerStatsResponse,
            ETFGCMsg::k_EMsgGCMatchHistoryLoad,
            ETFGCMsg::k_EMsgGC_AcknowledgeXP,
            ETFGCMsg::k_EMsgGCDataCenterPing_Update,
            ETFGCMsg::k_EMsgGC_NotificationAcknowledge,
            ETFGCMsg::k_EMsgGC_NotificationAcknowledgeReply,
            ETFGCMsg::k_EMsgGC_KickPlayerFromLobby,
            ETFGCMsg::k_EMsgGC_SurveyQuestionRequest,
            ETFGCMsg::k_EMsgGC_SurveyQuestionResponse,
            ETFGCMsg::k_EMsgGC_TFClientInit,
            ETFGCMsg::k_EMsgGC_NewMatchForLobbyRequest,
            ETFGCMsg::k_EMsgGC_NewMatchForLobbyResponse,
            ETFGCMsg::k_EMsgGC_ChangeMatchPlayerTeamsRequest,
            ETFGCMsg::k_EMsgGC_ChangeMatchPlayerTeamsResponse,
            ETFGCMsg::k_EMsgGC_QuestIdentify,
            ETFGCMsg::k_EMsgGC_QuestDevGive,
            ETFGCMsg::k_EMsgGCQuestComplete_Debug,
            ETFGCMsg::k_EMsgGC_QuestMapDebug,
            ETFGCMsg::k_EMsgGC_QuestMapUnlockNode,
            ETFGCMsg::k_EMsgGC_QuestMapPurchaseReward,
            ETFGCMsg::k_EMsgGC_SetDisablePartyQuestProgress,
            ETFGCMsg::k_EMsgGCQuestProgressReport,
            ETFGCMsg::k_EMsgGCParty_SetOptions,
            ETFGCMsg::k_EMsgGCParty_SetOptionsResponse,
            ETFGCMsg::k_EMsgGCParty_QueueForMatch,
            ETFGCMsg::k_EMsgGCParty_QueueForMatchResponse,
            ETFGCMsg::k_EMsgGCParty_RemoveFromQueue,
            ETFGCMsg::k_EMsgGCParty_RemoveFromQueueResponse,
            ETFGCMsg::k_EMsgGCParty_InvitePlayer,
            ETFGCMsg::k_EMsgGCParty_RequestJoinPlayer,
            ETFGCMsg::k_EMsgGCParty_SendChat,
            ETFGCMsg::k_EMsgGCParty_ChatMsg,
            ETFGCMsg::k_EMsgGCQuestNodeTurnIn,
            ETFGCMsg::k_EMsgGCConsumePaintKit,
            ETFGCMsg::k_EMsgGC_Painkit_DevGrant,
            ETFGCMsg::k_EMsgGCParty_QueueForStandby,
            ETFGCMsg::k_EMsgGCParty_QueueForStandbyResponse,
            ETFGCMsg::k_EMsgGCParty_RemoveFromStandbyQueue,
            ETFGCMsg::k_EMsgGCParty_RemoveFromStandbyQueueResponse,
            ETFGCMsg::k_EMsgGCParty_ClearPendingPlayer,
            ETFGCMsg::k_EMsgGCParty_ClearPendingPlayerResponse,
            ETFGCMsg::k_EMsgGCParty_ClearOtherPartyRequest,
            ETFGCMsg::k_EMsgGCParty_ClearOtherPartyRequestResponse,
            ETFGCMsg::k_EMsgGCParty_PromoteToLeader,
            ETFGCMsg::k_EMsgGCParty_KickMember,
            ETFGCMsg::k_EMsgGCQuestStrangeEvent,
            ETFGCMsg::k_EMsgGC_AcceptLobbyInvite,
            ETFGCMsg::k_EMsgGC_AcceptLobbyInviteReply,
            ETFGCMsg::k_EMsgGC_SDRTicket,
            ETFGCMsg::k_EMsgGC_ProcessMatchVoteKick,
            ETFGCMsg::k_EMsgGC_ProcessMatchVoteKickResponse,
            ETFGCMsg::k_EMsgGCDev_GrantWarKill,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ETFGCMsg>("ETFGCMsg", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ETFGCMsg {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for ETFGCMsg {
    fn default() -> Self {
        ETFGCMsg::k_EMsgGCReportWarKill
    }
}

impl ::protobuf::reflect::ProtobufValue for ETFGCMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EServerModificationItemType {
    kGameServerModificationItem_Halloween = 1,
}

impl ::protobuf::ProtobufEnum for EServerModificationItemType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EServerModificationItemType> {
        match value {
            1 => ::std::option::Option::Some(EServerModificationItemType::kGameServerModificationItem_Halloween),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EServerModificationItemType] = &[
            EServerModificationItemType::kGameServerModificationItem_Halloween,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<EServerModificationItemType>("EServerModificationItemType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for EServerModificationItemType {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EServerModificationItemType {
    fn default() -> Self {
        EServerModificationItemType::kGameServerModificationItem_Halloween
    }
}

impl ::protobuf::reflect::ProtobufValue for EServerModificationItemType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ETFSyncedMMMenuStep {
    k_eTFSyncedMMMenuStep_Invalid = -1,
    k_eTFSyncedMMMenuStep_None = 0,
    k_eTFSyncedMMMenuStep_Configuring_Mode = 1,
    k_eTFSyncedMMMenuStep_MvM_Selecting_Mode = 2,
    k_eTFSyncedMMMenuStep_MvM_Selecting_Tour = 3,
    k_eTFSyncedMMMenuStep_MvM_Selecting_Missions = 4,
}

impl ::protobuf::ProtobufEnum for ETFSyncedMMMenuStep {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ETFSyncedMMMenuStep> {
        match value {
            -1 => ::std::option::Option::Some(ETFSyncedMMMenuStep::k_eTFSyncedMMMenuStep_Invalid),
            0 => ::std::option::Option::Some(ETFSyncedMMMenuStep::k_eTFSyncedMMMenuStep_None),
            1 => ::std::option::Option::Some(ETFSyncedMMMenuStep::k_eTFSyncedMMMenuStep_Configuring_Mode),
            2 => ::std::option::Option::Some(ETFSyncedMMMenuStep::k_eTFSyncedMMMenuStep_MvM_Selecting_Mode),
            3 => ::std::option::Option::Some(ETFSyncedMMMenuStep::k_eTFSyncedMMMenuStep_MvM_Selecting_Tour),
            4 => ::std::option::Option::Some(ETFSyncedMMMenuStep::k_eTFSyncedMMMenuStep_MvM_Selecting_Missions),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ETFSyncedMMMenuStep] = &[
            ETFSyncedMMMenuStep::k_eTFSyncedMMMenuStep_Invalid,
            ETFSyncedMMMenuStep::k_eTFSyncedMMMenuStep_None,
            ETFSyncedMMMenuStep::k_eTFSyncedMMMenuStep_Configuring_Mode,
            ETFSyncedMMMenuStep::k_eTFSyncedMMMenuStep_MvM_Selecting_Mode,
            ETFSyncedMMMenuStep::k_eTFSyncedMMMenuStep_MvM_Selecting_Tour,
            ETFSyncedMMMenuStep::k_eTFSyncedMMMenuStep_MvM_Selecting_Missions,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ETFSyncedMMMenuStep>("ETFSyncedMMMenuStep", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ETFSyncedMMMenuStep {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for ETFSyncedMMMenuStep {
    fn default() -> Self {
        ETFSyncedMMMenuStep::k_eTFSyncedMMMenuStep_Invalid
    }
}

impl ::protobuf::reflect::ProtobufValue for ETFSyncedMMMenuStep {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

// Note: you cannot use pattern matching for enums with allow_alias option
#[derive(Clone,Eq,Debug)]
pub enum ETFMatchGroup {
    k_eTFMatchGroup_Invalid, // -1
    k_eTFMatchGroup_MvM_Practice, // 0
    k_eTFMatchGroup_MvM_MannUp, // 1
    k_eTFMatchGroup_First, // 0
    k_eTFMatchGroup_MvM_Default, // 0
    k_eTFMatchGroup_MvM_First, // 0
    k_eTFMatchGroup_MvM_Last, // 1
    k_eTFMatchGroup_Ladder_6v6, // 2
    k_eTFMatchGroup_Ladder_9v9, // 3
    k_eTFMatchGroup_Ladder_12v12, // 4
    k_eTFMatchGroup_Ladder_Default, // 2
    k_eTFMatchGroup_Ladder_First, // 2
    k_eTFMatchGroup_Ladder_Last, // 4
    k_eTFMatchGroup_Casual_6v6, // 5
    k_eTFMatchGroup_Casual_9v9, // 6
    k_eTFMatchGroup_Casual_12v12, // 7
    k_eTFMatchGroup_Casual_Default, // 7
    k_eTFMatchGroup_Casual_First, // 5
    k_eTFMatchGroup_Casual_Last, // 7
    k_eTFMatchGroup_Event_Placeholder, // 8
    k_eTFMatchGroup_Event_Default, // 8
    k_eTFMatchGroup_Event_First, // 8
    k_eTFMatchGroup_Event_Last, // 8
}

impl ::std::cmp::PartialEq for ETFMatchGroup {
    fn eq(&self, other: &Self) -> bool {
        ::protobuf::ProtobufEnum::value(self) == ::protobuf::ProtobufEnum::value(other)
    }
}

impl ::std::hash::Hash for ETFMatchGroup {
    fn hash<H : ::std::hash::Hasher>(&self, state: &mut H) {
        state.write_i32(::protobuf::ProtobufEnum::value(self))
    }
}

impl ::protobuf::ProtobufEnum for ETFMatchGroup {
    fn value(&self) -> i32 {
        match *self {
            ETFMatchGroup::k_eTFMatchGroup_Invalid => -1,
            ETFMatchGroup::k_eTFMatchGroup_MvM_Practice => 0,
            ETFMatchGroup::k_eTFMatchGroup_MvM_MannUp => 1,
            ETFMatchGroup::k_eTFMatchGroup_First => 0,
            ETFMatchGroup::k_eTFMatchGroup_MvM_Default => 0,
            ETFMatchGroup::k_eTFMatchGroup_MvM_First => 0,
            ETFMatchGroup::k_eTFMatchGroup_MvM_Last => 1,
            ETFMatchGroup::k_eTFMatchGroup_Ladder_6v6 => 2,
            ETFMatchGroup::k_eTFMatchGroup_Ladder_9v9 => 3,
            ETFMatchGroup::k_eTFMatchGroup_Ladder_12v12 => 4,
            ETFMatchGroup::k_eTFMatchGroup_Ladder_Default => 2,
            ETFMatchGroup::k_eTFMatchGroup_Ladder_First => 2,
            ETFMatchGroup::k_eTFMatchGroup_Ladder_Last => 4,
            ETFMatchGroup::k_eTFMatchGroup_Casual_6v6 => 5,
            ETFMatchGroup::k_eTFMatchGroup_Casual_9v9 => 6,
            ETFMatchGroup::k_eTFMatchGroup_Casual_12v12 => 7,
            ETFMatchGroup::k_eTFMatchGroup_Casual_Default => 7,
            ETFMatchGroup::k_eTFMatchGroup_Casual_First => 5,
            ETFMatchGroup::k_eTFMatchGroup_Casual_Last => 7,
            ETFMatchGroup::k_eTFMatchGroup_Event_Placeholder => 8,
            ETFMatchGroup::k_eTFMatchGroup_Event_Default => 8,
            ETFMatchGroup::k_eTFMatchGroup_Event_First => 8,
            ETFMatchGroup::k_eTFMatchGroup_Event_Last => 8,
        }
    }

    fn from_i32(value: i32) -> ::std::option::Option<ETFMatchGroup> {
        match value {
            -1 => ::std::option::Option::Some(ETFMatchGroup::k_eTFMatchGroup_Invalid),
            0 => ::std::option::Option::Some(ETFMatchGroup::k_eTFMatchGroup_MvM_Practice),
            1 => ::std::option::Option::Some(ETFMatchGroup::k_eTFMatchGroup_MvM_MannUp),
            2 => ::std::option::Option::Some(ETFMatchGroup::k_eTFMatchGroup_Ladder_6v6),
            3 => ::std::option::Option::Some(ETFMatchGroup::k_eTFMatchGroup_Ladder_9v9),
            4 => ::std::option::Option::Some(ETFMatchGroup::k_eTFMatchGroup_Ladder_12v12),
            5 => ::std::option::Option::Some(ETFMatchGroup::k_eTFMatchGroup_Casual_6v6),
            6 => ::std::option::Option::Some(ETFMatchGroup::k_eTFMatchGroup_Casual_9v9),
            7 => ::std::option::Option::Some(ETFMatchGroup::k_eTFMatchGroup_Casual_12v12),
            8 => ::std::option::Option::Some(ETFMatchGroup::k_eTFMatchGroup_Event_Placeholder),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ETFMatchGroup] = &[
            ETFMatchGroup::k_eTFMatchGroup_Invalid,
            ETFMatchGroup::k_eTFMatchGroup_MvM_Practice,
            ETFMatchGroup::k_eTFMatchGroup_MvM_MannUp,
            ETFMatchGroup::k_eTFMatchGroup_First,
            ETFMatchGroup::k_eTFMatchGroup_MvM_Default,
            ETFMatchGroup::k_eTFMatchGroup_MvM_First,
            ETFMatchGroup::k_eTFMatchGroup_MvM_Last,
            ETFMatchGroup::k_eTFMatchGroup_Ladder_6v6,
            ETFMatchGroup::k_eTFMatchGroup_Ladder_9v9,
            ETFMatchGroup::k_eTFMatchGroup_Ladder_12v12,
            ETFMatchGroup::k_eTFMatchGroup_Ladder_Default,
            ETFMatchGroup::k_eTFMatchGroup_Ladder_First,
            ETFMatchGroup::k_eTFMatchGroup_Ladder_Last,
            ETFMatchGroup::k_eTFMatchGroup_Casual_6v6,
            ETFMatchGroup::k_eTFMatchGroup_Casual_9v9,
            ETFMatchGroup::k_eTFMatchGroup_Casual_12v12,
            ETFMatchGroup::k_eTFMatchGroup_Casual_Default,
            ETFMatchGroup::k_eTFMatchGroup_Casual_First,
            ETFMatchGroup::k_eTFMatchGroup_Casual_Last,
            ETFMatchGroup::k_eTFMatchGroup_Event_Placeholder,
            ETFMatchGroup::k_eTFMatchGroup_Event_Default,
            ETFMatchGroup::k_eTFMatchGroup_Event_First,
            ETFMatchGroup::k_eTFMatchGroup_Event_Last,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ETFMatchGroup>("ETFMatchGroup", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ETFMatchGroup {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for ETFMatchGroup {
    fn default() -> Self {
        ETFMatchGroup::k_eTFMatchGroup_Invalid
    }
}

impl ::protobuf::reflect::ProtobufValue for ETFMatchGroup {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ETFPartyChatType {
    k_eTFPartyChatType_Invalid = 0,
    k_eTFPartyChatType_MemberChat = 1,
    k_eTFPartyChatType_Synthetic_MemberJoin = 1000,
    k_eTFPartyChatType_Synthetic_MemberLeave = 1001,
    k_eTFPartyChatType_Synthetic_SendFailed = 1002,
    k_eTFPartyChatType_Synthetic_MemberOnline = 1003,
    k_eTFPartyChatType_Synthetic_MemberOffline = 1004,
}

impl ::protobuf::ProtobufEnum for ETFPartyChatType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ETFPartyChatType> {
        match value {
            0 => ::std::option::Option::Some(ETFPartyChatType::k_eTFPartyChatType_Invalid),
            1 => ::std::option::Option::Some(ETFPartyChatType::k_eTFPartyChatType_MemberChat),
            1000 => ::std::option::Option::Some(ETFPartyChatType::k_eTFPartyChatType_Synthetic_MemberJoin),
            1001 => ::std::option::Option::Some(ETFPartyChatType::k_eTFPartyChatType_Synthetic_MemberLeave),
            1002 => ::std::option::Option::Some(ETFPartyChatType::k_eTFPartyChatType_Synthetic_SendFailed),
            1003 => ::std::option::Option::Some(ETFPartyChatType::k_eTFPartyChatType_Synthetic_MemberOnline),
            1004 => ::std::option::Option::Some(ETFPartyChatType::k_eTFPartyChatType_Synthetic_MemberOffline),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ETFPartyChatType] = &[
            ETFPartyChatType::k_eTFPartyChatType_Invalid,
            ETFPartyChatType::k_eTFPartyChatType_MemberChat,
            ETFPartyChatType::k_eTFPartyChatType_Synthetic_MemberJoin,
            ETFPartyChatType::k_eTFPartyChatType_Synthetic_MemberLeave,
            ETFPartyChatType::k_eTFPartyChatType_Synthetic_SendFailed,
            ETFPartyChatType::k_eTFPartyChatType_Synthetic_MemberOnline,
            ETFPartyChatType::k_eTFPartyChatType_Synthetic_MemberOffline,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ETFPartyChatType>("ETFPartyChatType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ETFPartyChatType {
}

impl ::std::default::Default for ETFPartyChatType {
    fn default() -> Self {
        ETFPartyChatType::k_eTFPartyChatType_Invalid
    }
}

impl ::protobuf::reflect::ProtobufValue for ETFPartyChatType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum TF_GC_GameState {
    TF_GC_GAMESTATE_STATE_INIT = 0,
    TF_GC_GAMESTATE_WAIT_FOR_PLAYERS_TO_LOAD = 1,
    TF_GC_GAMESTATE_STRATEGY_TIME = 3,
    TF_GC_GAMESTATE_GAME_IN_PROGRESS = 5,
    TF_GC_GAMESTATE_POST_GAME = 6,
    TF_GC_GAMESTATE_DISCONNECT = 7,
    TF_GC_GAMESTATE_LAST = 8,
}

impl ::protobuf::ProtobufEnum for TF_GC_GameState {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TF_GC_GameState> {
        match value {
            0 => ::std::option::Option::Some(TF_GC_GameState::TF_GC_GAMESTATE_STATE_INIT),
            1 => ::std::option::Option::Some(TF_GC_GameState::TF_GC_GAMESTATE_WAIT_FOR_PLAYERS_TO_LOAD),
            3 => ::std::option::Option::Some(TF_GC_GameState::TF_GC_GAMESTATE_STRATEGY_TIME),
            5 => ::std::option::Option::Some(TF_GC_GameState::TF_GC_GAMESTATE_GAME_IN_PROGRESS),
            6 => ::std::option::Option::Some(TF_GC_GameState::TF_GC_GAMESTATE_POST_GAME),
            7 => ::std::option::Option::Some(TF_GC_GameState::TF_GC_GAMESTATE_DISCONNECT),
            8 => ::std::option::Option::Some(TF_GC_GameState::TF_GC_GAMESTATE_LAST),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [TF_GC_GameState] = &[
            TF_GC_GameState::TF_GC_GAMESTATE_STATE_INIT,
            TF_GC_GameState::TF_GC_GAMESTATE_WAIT_FOR_PLAYERS_TO_LOAD,
            TF_GC_GameState::TF_GC_GAMESTATE_STRATEGY_TIME,
            TF_GC_GameState::TF_GC_GAMESTATE_GAME_IN_PROGRESS,
            TF_GC_GameState::TF_GC_GAMESTATE_POST_GAME,
            TF_GC_GameState::TF_GC_GAMESTATE_DISCONNECT,
            TF_GC_GameState::TF_GC_GAMESTATE_LAST,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<TF_GC_GameState>("TF_GC_GameState", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for TF_GC_GameState {
}

impl ::std::default::Default for TF_GC_GameState {
    fn default() -> Self {
        TF_GC_GameState::TF_GC_GAMESTATE_STATE_INIT
    }
}

impl ::protobuf::reflect::ProtobufValue for TF_GC_GameState {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum TF_GC_TEAM {
    TF_GC_TEAM_DEFENDERS = 0,
    TF_GC_TEAM_INVADERS = 1,
    TF_GC_TEAM_BROADCASTER = 2,
    TF_GC_TEAM_SPECTATOR = 3,
    TF_GC_TEAM_PLAYER_POOL = 4,
    TF_GC_TEAM_NOTEAM = 5,
}

impl ::protobuf::ProtobufEnum for TF_GC_TEAM {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TF_GC_TEAM> {
        match value {
            0 => ::std::option::Option::Some(TF_GC_TEAM::TF_GC_TEAM_DEFENDERS),
            1 => ::std::option::Option::Some(TF_GC_TEAM::TF_GC_TEAM_INVADERS),
            2 => ::std::option::Option::Some(TF_GC_TEAM::TF_GC_TEAM_BROADCASTER),
            3 => ::std::option::Option::Some(TF_GC_TEAM::TF_GC_TEAM_SPECTATOR),
            4 => ::std::option::Option::Some(TF_GC_TEAM::TF_GC_TEAM_PLAYER_POOL),
            5 => ::std::option::Option::Some(TF_GC_TEAM::TF_GC_TEAM_NOTEAM),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [TF_GC_TEAM] = &[
            TF_GC_TEAM::TF_GC_TEAM_DEFENDERS,
            TF_GC_TEAM::TF_GC_TEAM_INVADERS,
            TF_GC_TEAM::TF_GC_TEAM_BROADCASTER,
            TF_GC_TEAM::TF_GC_TEAM_SPECTATOR,
            TF_GC_TEAM::TF_GC_TEAM_PLAYER_POOL,
            TF_GC_TEAM::TF_GC_TEAM_NOTEAM,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<TF_GC_TEAM>("TF_GC_TEAM", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for TF_GC_TEAM {
}

impl ::std::default::Default for TF_GC_TEAM {
    fn default() -> Self {
        TF_GC_TEAM::TF_GC_TEAM_DEFENDERS
    }
}

impl ::protobuf::reflect::ProtobufValue for TF_GC_TEAM {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum TFMatchLeaveReason {
    TFMatchLeaveReason_UNSPECIFIED = 0,
    TFMatchLeaveReason_VOTE_KICK = 1,
    TFMatchLeaveReason_IDLE = 2,
    TFMatchLeaveReason_ADMIN_KICK = 3,
    TFMatchLeaveReason_AWOL = 4,
    TFMatchLeaveReason_NO_SHOW = 5,
    TFMatchLeaveReason_GC_REMOVED = 6,
}

impl ::protobuf::ProtobufEnum for TFMatchLeaveReason {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TFMatchLeaveReason> {
        match value {
            0 => ::std::option::Option::Some(TFMatchLeaveReason::TFMatchLeaveReason_UNSPECIFIED),
            1 => ::std::option::Option::Some(TFMatchLeaveReason::TFMatchLeaveReason_VOTE_KICK),
            2 => ::std::option::Option::Some(TFMatchLeaveReason::TFMatchLeaveReason_IDLE),
            3 => ::std::option::Option::Some(TFMatchLeaveReason::TFMatchLeaveReason_ADMIN_KICK),
            4 => ::std::option::Option::Some(TFMatchLeaveReason::TFMatchLeaveReason_AWOL),
            5 => ::std::option::Option::Some(TFMatchLeaveReason::TFMatchLeaveReason_NO_SHOW),
            6 => ::std::option::Option::Some(TFMatchLeaveReason::TFMatchLeaveReason_GC_REMOVED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [TFMatchLeaveReason] = &[
            TFMatchLeaveReason::TFMatchLeaveReason_UNSPECIFIED,
            TFMatchLeaveReason::TFMatchLeaveReason_VOTE_KICK,
            TFMatchLeaveReason::TFMatchLeaveReason_IDLE,
            TFMatchLeaveReason::TFMatchLeaveReason_ADMIN_KICK,
            TFMatchLeaveReason::TFMatchLeaveReason_AWOL,
            TFMatchLeaveReason::TFMatchLeaveReason_NO_SHOW,
            TFMatchLeaveReason::TFMatchLeaveReason_GC_REMOVED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<TFMatchLeaveReason>("TFMatchLeaveReason", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for TFMatchLeaveReason {
}

impl ::std::default::Default for TFMatchLeaveReason {
    fn default() -> Self {
        TFMatchLeaveReason::TFMatchLeaveReason_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for TFMatchLeaveReason {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum TFVoteKickReason {
    TFVoteKickReason_Other = 0,
    TFVoteKickReason_Cheating = 1,
    TFVoteKickReason_Idle = 2,
    TFVoteKickReason_Scamming = 3,
}

impl ::protobuf::ProtobufEnum for TFVoteKickReason {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TFVoteKickReason> {
        match value {
            0 => ::std::option::Option::Some(TFVoteKickReason::TFVoteKickReason_Other),
            1 => ::std::option::Option::Some(TFVoteKickReason::TFVoteKickReason_Cheating),
            2 => ::std::option::Option::Some(TFVoteKickReason::TFVoteKickReason_Idle),
            3 => ::std::option::Option::Some(TFVoteKickReason::TFVoteKickReason_Scamming),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [TFVoteKickReason] = &[
            TFVoteKickReason::TFVoteKickReason_Other,
            TFVoteKickReason::TFVoteKickReason_Cheating,
            TFVoteKickReason::TFVoteKickReason_Idle,
            TFVoteKickReason::TFVoteKickReason_Scamming,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<TFVoteKickReason>("TFVoteKickReason", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for TFVoteKickReason {
}

impl ::std::default::Default for TFVoteKickReason {
    fn default() -> Self {
        TFVoteKickReason::TFVoteKickReason_Other
    }
}

impl ::protobuf::reflect::ProtobufValue for TFVoteKickReason {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ServerMatchmakingState {
    ServerMatchmakingState_INVALID = 0,
    ServerMatchmakingState_NOT_PARTICIPATING = 1,
    ServerMatchmakingState_EMPTY = 2,
    ServerMatchmakingState_ACTIVE_MATCH_REQUESTING_LATE_JOIN = 3,
    ServerMatchmakingState_ACTIVE_MATCH = 4,
}

impl ::protobuf::ProtobufEnum for ServerMatchmakingState {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ServerMatchmakingState> {
        match value {
            0 => ::std::option::Option::Some(ServerMatchmakingState::ServerMatchmakingState_INVALID),
            1 => ::std::option::Option::Some(ServerMatchmakingState::ServerMatchmakingState_NOT_PARTICIPATING),
            2 => ::std::option::Option::Some(ServerMatchmakingState::ServerMatchmakingState_EMPTY),
            3 => ::std::option::Option::Some(ServerMatchmakingState::ServerMatchmakingState_ACTIVE_MATCH_REQUESTING_LATE_JOIN),
            4 => ::std::option::Option::Some(ServerMatchmakingState::ServerMatchmakingState_ACTIVE_MATCH),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ServerMatchmakingState] = &[
            ServerMatchmakingState::ServerMatchmakingState_INVALID,
            ServerMatchmakingState::ServerMatchmakingState_NOT_PARTICIPATING,
            ServerMatchmakingState::ServerMatchmakingState_EMPTY,
            ServerMatchmakingState::ServerMatchmakingState_ACTIVE_MATCH_REQUESTING_LATE_JOIN,
            ServerMatchmakingState::ServerMatchmakingState_ACTIVE_MATCH,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ServerMatchmakingState>("ServerMatchmakingState", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ServerMatchmakingState {
}

impl ::std::default::Default for ServerMatchmakingState {
    fn default() -> Self {
        ServerMatchmakingState::ServerMatchmakingState_INVALID
    }
}

impl ::protobuf::reflect::ProtobufValue for ServerMatchmakingState {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum SurveyQuestionType {
    QUESTION_MATCH_QUALITY = 0,
    QUESTION_MAP_QUALITY = 1,
    QUESTION_COMP_INQUIRY = 2,
    QUESTION_CASUAL_INQUIRY = 3,
    QUESTION_RANDOM_CRIT = 4,
}

impl ::protobuf::ProtobufEnum for SurveyQuestionType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SurveyQuestionType> {
        match value {
            0 => ::std::option::Option::Some(SurveyQuestionType::QUESTION_MATCH_QUALITY),
            1 => ::std::option::Option::Some(SurveyQuestionType::QUESTION_MAP_QUALITY),
            2 => ::std::option::Option::Some(SurveyQuestionType::QUESTION_COMP_INQUIRY),
            3 => ::std::option::Option::Some(SurveyQuestionType::QUESTION_CASUAL_INQUIRY),
            4 => ::std::option::Option::Some(SurveyQuestionType::QUESTION_RANDOM_CRIT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [SurveyQuestionType] = &[
            SurveyQuestionType::QUESTION_MATCH_QUALITY,
            SurveyQuestionType::QUESTION_MAP_QUALITY,
            SurveyQuestionType::QUESTION_COMP_INQUIRY,
            SurveyQuestionType::QUESTION_CASUAL_INQUIRY,
            SurveyQuestionType::QUESTION_RANDOM_CRIT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<SurveyQuestionType>("SurveyQuestionType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for SurveyQuestionType {
}

impl ::std::default::Default for SurveyQuestionType {
    fn default() -> Self {
        SurveyQuestionType::QUESTION_MATCH_QUALITY
    }
}

impl ::protobuf::reflect::ProtobufValue for SurveyQuestionType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x13tf_gcmessages.proto\x1a\x13steammessages.proto\x1a\x15base_gcmessa\
    ges.proto\"y\n\x1bCMsgTFGoldenWrenchBroadcast\x12#\n\rwrench_number\x18\
    \x01\x20\x01(\x05R\x0cwrenchNumber\x12\x18\n\x07deleted\x18\x02\x20\x01(\
    \x08R\x07deleted\x12\x1b\n\tuser_name\x18\x03\x20\x01(\tR\x08userName\"\
    \\\n\x14CMsgTFSaxxyBroadcast\x12'\n\x0fcategory_number\x18\x01\x20\x01(\
    \x05R\x0ecategoryNumber\x12\x1b\n\tuser_name\x18\x02\x20\x01(\tR\x08user\
    Name\"\x8b\x01\n\x1dCMsgGCTFSpecificItemBroadcast\x12$\n\x0eitem_def_ind\
    ex\x18\x01\x20\x01(\rR\x0citemDefIndex\x12'\n\x0fwas_destruction\x18\x02\
    \x20\x01(\x08R\x0ewasDestruction\x12\x1b\n\tuser_name\x18\x03\x20\x01(\t\
    R\x08userName\"\xd8\x02\n\x11CMsgTFWorldStatus\x12G\n\x1dbeta_stress_tes\
    t_event_active\x18\x01\x20\x01(\x08:\x05falseR\x19betaStressTestEventAct\
    ive\x12S\n\x11event_match_group\x18\x02\x20\x01(\x0e2\x0e.ETFMatchGroup:\
    \x17k_eTFMatchGroup_InvalidR\x0feventMatchGroup\x12-\n\x11event_expire_t\
    ime\x18\x03\x20\x01(\x07:\x010R\x0feventExpireTime\x122\n\x15active_clie\
    nt_version\x18\x04\x20\x01(\rR\x13activeClientVersion\x12B\n\x15disabled\
    _match_groups\x18\x05\x20\x03(\x0e2\x0e.ETFMatchGroupR\x13disabledMatchG\
    roups\"\x80\x02\n\x10CSOTFDuelSummary\x12#\n\naccount_id\x18\x01\x20\x01\
    (\rR\taccountIdB\x04\x80\xa6\x1d\x01\x12\x1b\n\tduel_wins\x18\x02\x20\
    \x01(\rR\x08duelWins\x12\x1f\n\x0bduel_losses\x18\x03\x20\x01(\rR\nduelL\
    osses\x12/\n\x14last_duel_account_id\x18\x04\x20\x01(\rR\x11lastDuelAcco\
    untId\x12.\n\x13last_duel_timestamp\x18\x05\x20\x01(\rR\x11lastDuelTimes\
    tamp\x12(\n\x10last_duel_status\x18\x06\x20\x01(\rR\x0elastDuelStatus\"\
    \x8d\x01\n\x14CSOTFMapContribution\x12#\n\naccount_id\x18\x01\x20\x01(\r\
    R\taccountIdB\x04\x80\xa6\x1d\x01\x12!\n\tdef_index\x18\x02\x20\x01(\rR\
    \x08defIndexB\x04\x80\xa6\x1d\x01\x12-\n\x12contribution_level\x18\x03\
    \x20\x01(\rR\x11contributionLevel\"T\n&CMsgTFFreeTrialChooseMostHelpfulF\
    riend\x12*\n\x11account_id_friend\x18\x01\x20\x01(\rR\x0faccountIdFriend\
    \":\n\x17CMsgTFRequestTF2Friends\x12\x1f\n\x0baccount_ids\x18\x01\x20\
    \x03(\rR\naccountIds\"B\n\x1fCMsgTFRequestTF2FriendsResponse\x12\x1f\n\
    \x0baccount_ids\x18\x01\x20\x03(\rR\naccountIds\"B\n\x0fCSOTFPlayerInfo\
    \x12/\n\x14num_new_users_helped\x18\x01\x20\x01(\rR\x11numNewUsersHelped\
    \"B\n\x16CMsgTFThankedBySomeone\x12(\n\x10thanker_steam_id\x18\x01\x20\
    \x01(\x04R\x0ethankerSteamId\"\x16\n\x14CMsgTFThankedSomeone\"#\n!CMsgTF\
    FreeTrialConvertedToPremium\"Q\n\x10CMsgSaxxyAwarded\x12\x1a\n\x08catego\
    ry\x18\x01\x20\x01(\rR\x08category\x12!\n\x0cwinner_names\x18\x02\x20\
    \x03(\tR\x0bwinnerNames\"[\n\x1cCMsgReplaySubmitContestEntry\x12\x1f\n\
    \x0byoutube_url\x18\x01\x20\x01(\tR\nyoutubeUrl\x12\x1a\n\x08category\
    \x18\x02\x20\x01(\rR\x08category\"@\n$CMsgReplaySubmitContestEntryRespon\
    se\x12\x18\n\x07success\x18\x01\x20\x01(\x08R\x07success\"\xba\x01\n\x18\
    CReplayCachedContestData\x12\x1c\n\ttimestamp\x18\x01\x20\x01(\x07R\ttim\
    estamp\x12+\n\x12num_votes_last_day\x18\x02\x20\x01(\rR\x0fnumVotesLastD\
    ay\x12&\n\x0fvideo_entry_ids\x18\x03\x20\x03(\rR\rvideoEntryIds\x12+\n\
    \x12num_flags_last_day\x18\x04\x20\x01(\rR\x0fnumFlagsLastDay\"\x1d\n\
    \x1bCMsgTFCoaching_AddToCoaches\"\"\n\x20CMsgTFCoaching_RemoveFromCoache\
    s\"V\n\x18CMsgTFCoaching_FindCoach\x12:\n\x1aaccount_id_friend_as_coach\
    \x18\x01\x20\x01(\rR\x16accountIdFriendAsCoach\"\x7f\n\x20CMsgTFCoaching\
    _FindCoachResponse\x12\x1f\n\x0bfound_coach\x18\x01\x20\x01(\x08R\nfound\
    Coach\x12\x1b\n\tnum_likes\x18\x02\x20\x01(\rR\x08numLikes\x12\x1d\n\nco\
    ach_name\x18\x03\x20\x01(\tR\tcoachName\"s\n\x17CMsgTFCoaching_AskCoach\
    \x12,\n\x12account_id_student\x18\x01\x20\x01(\rR\x10accountIdStudent\
    \x12*\n\x11student_is_friend\x18\x02\x20\x01(\x08R\x0fstudentIsFriend\"_\
    \n\x1fCMsgTFCoaching_AskCoachResponse\x12<\n\x1aaccept_coaching_assignme\
    nt\x18\x01\x20\x01(\x08R\x18acceptCoachingAssignment\"\xb1\x01\n\x1cCMsg\
    TFCoaching_CoachJoinGame\x12\x1b\n\tjoin_game\x18\x01\x20\x01(\x08R\x08j\
    oinGame\x12%\n\x0eserver_address\x18\x02\x20\x01(\rR\rserverAddress\x12\
    \x1f\n\x0bserver_port\x18\x03\x20\x01(\rR\nserverPort\x12,\n\x12account_\
    id_student\x18\x04\x20\x01(\rR\x10accountIdStudent\"u\n\x1bCMsgTFCoachin\
    g_CoachJoining\x12(\n\x10account_id_coach\x18\x01\x20\x01(\rR\x0eaccount\
    IdCoach\x12,\n\x12account_id_student\x18\x02\x20\x01(\rR\x10accountIdStu\
    dent\"F\n\x1aCMsgTFCoaching_CoachJoined\x12(\n\x10account_id_coach\x18\
    \x01\x20\x01(\rR\x0eaccountIdCoach\"@\n\x1fCMsgTFCoaching_LikeCurrentCoa\
    ch\x12\x1d\n\nlike_coach\x18\x01\x20\x01(\x08R\tlikeCoach\"M\n!CMsgTFCoa\
    ching_RemoveCurrentCoach\x12(\n\x10account_id_coach\x18\x01\x20\x01(\rR\
    \x0eaccountIdCoach\"\xad\x02\n\x1cCMsgTFQuickplay_ScoreServers\x12B\n\
    \x07servers\x18\x01\x20\x03(\x0b2(.CMsgTFQuickplay_ScoreServers.ServerIn\
    foR\x07servers\x1a\xc8\x01\n\nServerInfo\x12%\n\x0eserver_address\x18\
    \x01\x20\x01(\rR\rserverAddress\x12\x1f\n\x0bserver_port\x18\x02\x20\x01\
    (\rR\nserverPort\x12\x1b\n\tnum_users\x18\x03\x20\x01(\rR\x08numUsers\
    \x12\x19\n\x08steam_id\x18\x04\x20\x01(\x04R\x07steamId\x12\x1b\n\tmax_u\
    sers\x18\x05\x20\x01(\rR\x08maxUsers\x12\x1d\n\nuser_score\x18\x06\x20\
    \x01(\x02R\tuserScore\"\xaa\x02\n$CMsgTFQuickplay_ScoreServersResponse\
    \x12J\n\x07servers\x18\x01\x20\x03(\x0b20.CMsgTFQuickplay_ScoreServersRe\
    sponse.ServerInfoR\x07servers\x1a\xb5\x01\n\nServerInfo\x12%\n\x0eserver\
    _address\x18\x01\x20\x01(\rR\rserverAddress\x12\x1f\n\x0bserver_port\x18\
    \x02\x20\x01(\rR\nserverPort\x12\x1f\n\x0btotal_score\x18\x03\x20\x01(\
    \x02R\ntotalScore\x12\x19\n\x08steam_id\x18\x04\x20\x01(\x04R\x07steamId\
    \x12#\n\roptions_score\x18\x05\x20\x01(\rR\x0coptionsScore\">\n\x1dCMsgT\
    FQuickplay_PlayerJoining\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\tacco\
    untId\"_\n\x1bCMsgGC_GameServer_LevelInfo\x12!\n\x0clevel_loaded\x18\x01\
    \x20\x01(\x08R\x0blevelLoaded\x12\x1d\n\nlevel_name\x18\x02\x20\x01(\tR\
    \tlevelName\"L\n\x1fCMsgGC_GameServer_AuthChallenge\x12)\n\x10challenge_\
    string\x18\x01\x20\x01(\tR\x0fchallengeString\"\xf5\x01\n\x1cCMsgGC_Game\
    Server_AuthResult\x12$\n\rauthenticated\x18\x01\x20\x01(\x08R\rauthentic\
    ated\x120\n\x14game_server_standing\x18\x02\x20\x01(\x05R\x12gameServerS\
    tanding\x12;\n\x1agame_server_standing_trend\x18\x03\x20\x01(\x05R\x17ga\
    meServerStandingTrend\x12&\n\x0fis_valve_server\x18\x04\x20\x01(\x08R\ri\
    sValveServer\x12\x18\n\x07message\x18\x05\x20\x01(\tR\x07message\"\x96\
    \x01\n'CMsgGC_GameServer_AuthChallengeResponse\x123\n\x16game_server_acc\
    ount_id\x18\x01\x20\x01(\rR\x13gameServerAccountId\x126\n\x17hashed_chal\
    lenge_string\x18\x02\x20\x01(\x0cR\x15hashedChallengeString\"A\n\x20CMsg\
    GC_GameServer_CreateIdentity\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\t\
    accountId\"\xa0\x03\n(CMsgGC_GameServer_CreateIdentityResponse\x12'\n\
    \x0faccount_created\x18\x01\x20\x01(\x08R\x0eaccountCreated\x123\n\x16ga\
    me_server_account_id\x18\x02\x20\x01(\rR\x13gameServerAccountId\x12;\n\
    \x1agame_server_identity_token\x18\x03\x20\x01(\tR\x17gameServerIdentity\
    Token\x12a\n\x06status\x18\x04\x20\x01(\x0e21.CMsgGC_GameServer_CreateId\
    entityResponse.EStatus:\x16kStatus_GenericFailureR\x06status\"v\n\x07ESt\
    atus\x12\x1a\n\x16kStatus_GenericFailure\x10\0\x12\x1c\n\x0fkStatus_TooM\
    any\x10\xff\xff\xff\xff\xff\xff\xff\xff\xff\x01\x12\x1c\n\x0fkStatus_NoP\
    rivs\x10\xfe\xff\xff\xff\xff\xff\xff\xff\xff\x01\x12\x13\n\x0fkStatus_Cr\
    eated\x10\x01\"7\n\x16CMsgGC_GameServer_List\x12\x1d\n\naccount_id\x18\
    \x01\x20\x01(\rR\taccountId\"\xfa\x02\n\x1eCMsgGC_GameServer_ListRespons\
    e\x12`\n\x12owned_game_servers\x18\x01\x20\x03(\x0b22.CMsgGC_GameServer_\
    ListResponse.GameServerIdentityR\x10ownedGameServers\x1a\xf5\x01\n\x12Ga\
    meServerIdentity\x123\n\x16game_server_account_id\x18\x01\x20\x01(\rR\
    \x13gameServerAccountId\x12;\n\x1agame_server_identity_token\x18\x02\x20\
    \x01(\tR\x17gameServerIdentityToken\x120\n\x14game_server_standing\x18\
    \x03\x20\x01(\x05R\x12gameServerStanding\x12;\n\x1agame_server_standing_\
    trend\x18\x04\x20\x01(\x05R\x17gameServerStandingTrend\"V\n\x1fCMsgGC_Ga\
    meServer_ResetIdentity\x123\n\x16game_server_account_id\x18\x01\x20\x01(\
    \rR\x13gameServerAccountId\"\xe3\x01\n'CMsgGC_GameServer_ResetIdentityRe\
    sponse\x12F\n\x20game_server_identity_token_reset\x18\x01\x20\x01(\x08R\
    \x1cgameServerIdentityTokenReset\x123\n\x16game_server_account_id\x18\
    \x02\x20\x01(\rR\x13gameServerAccountId\x12;\n\x1agame_server_identity_t\
    oken\x18\x03\x20\x01(\tR\x17gameServerIdentityToken\"\x1d\n\x1bCMsgGC_Ga\
    meServer_AckPolicy\"W\n#CMsgGC_GameServer_AckPolicyResponse\x12\x16\n\
    \x06result\x18\x01\x20\x01(\rR\x06result\x12\x18\n\x07message\x18\x02\
    \x20\x01(\tR\x07message\"B\n'CMsgGC_Client_UseServerModificationItem\x12\
    \x17\n\x07item_id\x18\x01\x20\x01(\x04R\x06itemId\"\x8a\x04\n0CMsgGC_Cli\
    ent_UseServerModificationItem_Response\x12\xa4\x01\n\rresponse_code\x18\
    \x01\x20\x01(\x0e2Q.CMsgGC_Client_UseServerModificationItem_Response.ESe\
    rverModificationItemResponse:,kServerModificationItemResponse_AlreadyInU\
    seR\x0cresponseCode\"\xae\x02\n\x1fEServerModificationItemResponse\x120\
    \n,kServerModificationItemResponse_AlreadyInUse\x10\x01\x12<\n8kServerMo\
    dificationItemResponse_NotOnAuthenticatedServer\x10\x02\x120\n,kServerMo\
    dificationItemResponse_ServerReject\x10\x03\x121\n-kServerModificationIt\
    emResponse_InternalError\x10\x04\x126\n2kServerModificationItemResponse_\
    EventAlreadyActive\x10\x05\"\x9f\x01\n+CMsgGC_GameServer_UseServerModifi\
    cationItem\x12p\n\x11modification_type\x18\x01\x20\x01(\x0e2\x1c.EServer\
    ModificationItemType:%kGameServerModificationItem_HalloweenR\x10modifica\
    tionType\"\xb4\x04\n4CMsgGC_GameServer_UseServerModificationItem_Respons\
    e\x12p\n\x11modification_type\x18\x01\x20\x01(\x0e2\x1c.EServerModificat\
    ionItemType:%kGameServerModificationItem_HalloweenR\x10modificationType\
    \x12\xbd\x01\n\x14server_response_code\x18\x02\x20\x01(\x0e2[.CMsgGC_Gam\
    eServer_UseServerModificationItem_Response.EServerModificationItemServer\
    Response:.kServerModificationItemServerResponse_AcceptedR\x12serverRespo\
    nseCode\"\xc9\x01\n%EServerModificationItemServerResponse\x122\n.kServer\
    ModificationItemServerResponse_Accepted\x10\x01\x126\n2kServerModificati\
    onItemServerResponse_NoVoteCalled\x10\x02\x124\n0kServerModificationItem\
    ServerResponse_VoteFailed\x10\x03\"\xa3\x01\n/CMsgGC_GameServer_ServerMo\
    dificationItemExpired\x12p\n\x11modification_type\x18\x01\x20\x01(\x0e2\
    \x1c.EServerModificationItemType:%kGameServerModificationItem_HalloweenR\
    \x10modificationType\"\xb4\x01\n(CMsgGC_GameServer_ServerModificationIte\
    m\x12p\n\x11modification_type\x18\x01\x20\x01(\x0e2\x1c.EServerModificat\
    ionItemType:%kGameServerModificationItem_HalloweenR\x10modificationType\
    \x12\x16\n\x06active\x18\x02\x20\x01(\x08R\x06active\"q\n\x1dCMsgGC_Hall\
    oween_ReservedItem\x12\x0c\n\x01x\x18\x01\x20\x03(\x02R\x01x\x12\x0c\n\
    \x01y\x18\x02\x20\x03(\x02R\x01y\x12\x0c\n\x01z\x18\x03\x20\x03(\x02R\
    \x01z\x12&\n\x0fspawn_meta_info\x18\x07\x20\x01(\rR\rspawnMetaInfo\"\x83\
    \x01\n\x1aCMsgGC_Halloween_GrantItem\x120\n\x14recipient_account_id\x18\
    \x01\x20\x01(\rR\x12recipientAccountId\x12\x19\n\x08level_id\x18\x02\x20\
    \x01(\rR\x07levelId\x12\x18\n\x07flagged\x18\x03\x20\x01(\x08R\x07flagge\
    d\"V\n\"CMsgGC_Halloween_GrantItemResponse\x120\n\x14recipient_account_i\
    d\x18\x01\x20\x01(\rR\x12recipientAccountId\"\x1e\n\x1cCMsgGC_Halloween_\
    ItemClaimed\"d\n\"CMsgGC_PickupItemEligibility_Query\x12\x1d\n\naccount_\
    id\x18\x01\x20\x01(\rR\taccountId\x12\x1f\n\x0bseconds_ago\x18\x02\x20\
    \x01(\rR\nsecondsAgo\"\x89\x01\n*CMsgGC_PickupItemEligibility_QueryRespo\
    nse\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\x12!\n\x0cwas_e\
    ligible\x18\x02\x20\x01(\x08R\x0bwasEligible\x12\x19\n\x08level_id\x18\
    \x03\x20\x01(\rR\x07levelId\"\x8e\x06\n\x10CSOTFPartyMember\x12\x1f\n\
    \x0bowns_ticket\x18\x02\x20\x01(\x08R\nownsTicket\x12-\n\x12completed_mi\
    ssions\x18\x03\x20\x01(\rR\x11completedMissions\x12\x1f\n\x0bbadge_level\
    \x18\x04\x20\x01(\rR\nbadgeLevel\x12-\n\x12competitive_access\x18\t\x20\
    \x01(\x08R\x11competitiveAccess\x12\x1e\n\nexperience\x18\x0e\x20\x01(\r\
    R\nexperience\x12H\n\x0fplayer_criteria\x18\x10\x20\x01(\x0b2\x1f.CTFPer\
    PlayerMatchCriteriaProtoR\x0eplayerCriteria\x126\n\x08activity\x18\x11\
    \x20\x01(\x0b2\x1a.CSOTFPartyMember.ActivityR\x08activity\x12#\n\rcasual\
    _banned\x18\x12\x20\x01(\x08R\x0ccasualBanned\x12#\n\rranked_banned\x18\
    \x13\x20\x01(\x08R\x0crankedBanned\x12.\n\x13casual_low_priority\x18\x14\
    \x20\x01(\x08R\x11casualLowPriority\x12.\n\x13ranked_low_priority\x18\
    \x15\x20\x01(\x08R\x11rankedLowPriority\x12#\n\rlobby_standby\x18\x16\
    \x20\x01(\x08R\x0clobbyStandby\x1a\xe8\x01\n\x08Activity\x12\x19\n\x08lo\
    bby_id\x18\x01\x20\x01(\x06R\x07lobbyId\x12S\n\x11lobby_match_group\x18\
    \x02\x20\x01(\x0e2\x0e.ETFMatchGroup:\x17k_eTFMatchGroup_InvalidR\x0flob\
    byMatchGroup\x12-\n\x12multiqueue_blocked\x18\x03\x20\x01(\x08R\x11multi\
    queueBlocked\x12\x16\n\x06online\x18\x04\x20\x01(\x08R\x06online\x12%\n\
    \x0eclient_version\x18\x05\x20\x01(\rR\rclientVersion\"\xaf\x01\n\x14TFP\
    endingPartyMember\x12\x18\n\x07steamid\x18\x01\x20\x01(\x06R\x07steamid\
    \x128\n\x04type\x18\x02\x20\x01(\x0e2\x1b.TFPendingPartyMember.EType:\
    \x07InvitedR\x04type\x12\x18\n\x07inviter\x18\x03\x20\x01(\x06R\x07invit\
    er\")\n\x05EType\x12\x0b\n\x07Invited\x10\0\x12\x13\n\x0fRequestedToJoin\
    \x10\x01\"\xac\x01\n\x11TFSyncedMMUIState\x12M\n\tmenu_step\x18\x01\x20\
    \x01(\x0e2\x14.ETFSyncedMMMenuStep:\x1ak_eTFSyncedMMMenuStep_NoneR\x08me\
    nuStep\x12H\n\x0bmatch_group\x18\x02\x20\x01(\x0e2\x0e.ETFMatchGroup:\
    \x17k_eTFMatchGroup_InvalidR\nmatchGroup\"\xc3\x02\n\x1aCTFGroupMatchCri\
    teriaProto\x12\x20\n\x0clate_join_ok\x18\x05\x20\x01(\x08R\nlateJoinOk\
    \x125\n\x15custom_ping_tolerance\x18\r\x20\x01(\r:\x010R\x13customPingTo\
    lerance\x12&\n\x0fmvm_mannup_tour\x18\n\x20\x01(\tR\rmvmMannupTour\x12.\
    \n\x13mvm_mannup_missions\x18\x0f\x20\x03(\tR\x11mvmMannupMissions\x122\
    \n\x15mvm_bootcamp_missions\x18\x10\x20\x03(\tR\x13mvmBootcampMissions\
    \x12@\n\x0fcasual_criteria\x18\x0c\x20\x01(\x0b2\x17.CTFCasualMatchCrite\
    riaR\x0ecasualCriteria\"F\n\x16CTFCasualMatchCriteria\x12,\n\x12selected\
    _maps_bits\x18\x03\x20\x03(\x07R\x10selectedMapsBits\"L\n\x1eCTFPerPlaye\
    rMatchCriteriaProto\x12*\n\x11mvm_squad_surplus\x18\x01\x20\x01(\x08R\
    \x0fmvmSquadSurplus\"\x89\x02\n\x0fCTFPartyOptions\x12-\n\x12overwrite_e\
    xisting\x18\x01\x20\x01(\x08R\x11overwriteExisting\x12B\n\x0egroup_crite\
    ria\x18\x02\x20\x01(\x0b2\x1b.CTFGroupMatchCriteriaProtoR\rgroupCriteria\
    \x12H\n\x0fplayer_criteria\x18\x03\x20\x01(\x0b2\x1f.CTFPerPlayerMatchCr\
    iteriaProtoR\x0eplayerCriteria\x129\n\x0eplayer_uistate\x18\x05\x20\x01(\
    \x0b2\x12.TFSyncedMMUIStateR\rplayerUistate\"\\\n\x13CMsgPartySetOptions\
    \x12\x19\n\x08party_id\x18\x01\x20\x01(\x06R\x07partyId\x12*\n\x07option\
    s\x18\x02\x20\x01(\x0b2\x10.CTFPartyOptionsR\x07options\"\x1d\n\x1bCMsgP\
    artySetOptionsResponse\"\xb4\x01\n\x16CMsgPartyQueueForMatch\x12\x19\n\
    \x08party_id\x18\x01\x20\x01(\x06R\x07partyId\x125\n\rfinal_options\x18\
    \x02\x20\x01(\x0b2\x10.CTFPartyOptionsR\x0cfinalOptions\x12H\n\x0bmatch_\
    group\x18\x03\x20\x01(\x0e2\x0e.ETFMatchGroup:\x17k_eTFMatchGroup_Invali\
    dR\nmatchGroup\"\x20\n\x1eCMsgPartyQueueForMatchResponse\"[\n\x18CMsgPar\
    tyQueueForStandby\x12\x19\n\x08party_id\x18\x01\x20\x01(\x06R\x07partyId\
    \x12$\n\x0eparty_lobby_id\x18\x02\x20\x01(\x06R\x0cpartyLobbyId\"\"\n\
    \x20CMsgPartyQueueForStandbyResponse\"\x7f\n\x18CMsgPartyRemoveFromQueue\
    \x12\x19\n\x08party_id\x18\x01\x20\x01(\x06R\x07partyId\x12H\n\x0bmatch_\
    group\x18\x02\x20\x01(\x0e2\x0e.ETFMatchGroup:\x17k_eTFMatchGroup_Invali\
    dR\nmatchGroup\"\"\n\x20CMsgPartyRemoveFromQueueResponse\"<\n\x1fCMsgPar\
    tyRemoveFromStandbyQueue\x12\x19\n\x08party_id\x18\x01\x20\x01(\x06R\x07\
    partyId\")\n'CMsgPartyRemoveFromStandbyQueueResponse\"\x8a\x01\n\x15CMsg\
    PartyInvitePlayer\x12\x19\n\x08party_id\x18\x01\x20\x01(\x06R\x07partyId\
    \x12\x1b\n\tplayer_id\x18\x02\x20\x01(\x06R\x08playerId\x129\n\x19expect\
    ing_request_to_join\x18\x03\x20\x01(\x08R\x16expectingRequestToJoin\"\
    \xbb\x01\n\x1aCMsgPartyRequestJoinPlayer\x12(\n\x10current_party_id\x18\
    \x01\x20\x01(\x06R\x0ecurrentPartyId\x12$\n\x0ejoin_player_id\x18\x02\
    \x20\x01(\x06R\x0cjoinPlayerId\x12\"\n\rjoin_party_id\x18\x03\x20\x01(\
    \x06R\x0bjoinPartyId\x12)\n\x10expecting_invite\x18\x04\x20\x01(\x08R\
    \x0fexpectingInvite\"d\n\x1bCMsgPartyClearPendingPlayer\x12\x19\n\x08par\
    ty_id\x18\x01\x20\x01(\x06R\x07partyId\x12*\n\x11pending_player_id\x18\
    \x02\x20\x01(\x06R\x0fpendingPlayerId\"%\n#CMsgPartyClearPendingPlayerRe\
    sponse\"G\n\x1fCMsgPartyClearOtherPartyRequest\x12$\n\x0eother_party_id\
    \x18\x01\x20\x01(\x06R\x0cotherPartyId\")\n'CMsgPartyClearOtherPartyRequ\
    estResponse\"Y\n\x18CMsgPartyPromoteToLeader\x12\x19\n\x08party_id\x18\
    \x01\x20\x01(\x06R\x07partyId\x12\"\n\rnew_leader_id\x18\x02\x20\x01(\
    \x06R\x0bnewLeaderId\"M\n\x13CMsgPartyKickMember\x12\x19\n\x08party_id\
    \x18\x01\x20\x01(\x06R\x07partyId\x12\x1b\n\ttarget_id\x18\x02\x20\x01(\
    \x06R\x08targetId\"@\n\x11CMsgPartySendChat\x12\x19\n\x08party_id\x18\
    \x01\x20\x01(\x06R\x07partyId\x12\x10\n\x03msg\x18\x02\x20\x01(\tR\x03ms\
    g\"\x82\x01\n\x10CMsgPartyChatMsg\x12A\n\x04type\x18\x01\x20\x01(\x0e2\
    \x11.ETFPartyChatType:\x1ak_eTFPartyChatType_InvalidR\x04type\x12\x19\n\
    \x08actor_id\x18\x02\x20\x01(\x06R\x07actorId\x12\x10\n\x03msg\x18\x03\
    \x20\x01(\tR\x03msg\"\xfe\x06\n\nCSOTFParty\x12\x1f\n\x08party_id\x18\
    \x01\x20\x01(\x04R\x07partyIdB\x04\x80\xa6\x1d\x01\x12\x1b\n\tleader_id\
    \x18\x02\x20\x01(\x06R\x08leaderId\x12\x1d\n\nmember_ids\x18\x03\x20\x03\
    (\x06R\tmemberIds\x12+\n\x07members\x18\r\x20\x03(\x0b2\x11.CSOTFPartyMe\
    mberR\x07members\x12.\n\x13associated_lobby_id\x18#\x20\x01(\x04R\x11ass\
    ociatedLobbyId\x12h\n\x1cassociated_lobby_match_group\x18(\x20\x01(\x0e2\
    \x0e.ETFMatchGroup:\x17k_eTFMatchGroup_InvalidR\x19associatedLobbyMatchG\
    roup\x12E\n\x12matchmaking_queues\x18+\x20\x03(\x0b2\x16.CSOTFParty.Queu\
    eEntryR\x11matchmakingQueues\x12B\n\x0egroup_criteria\x18%\x20\x01(\x0b2\
    \x1b.CTFGroupMatchCriteriaProtoR\rgroupCriteria\x12,\n\x12casual_banned_\
    time\x18\x12\x20\x01(\rR\x10casualBannedTime\x127\n\x18casual_low_priori\
    ty_time\x18\x14\x20\x01(\rR\x15casualLowPriorityTime\x12,\n\x12ranked_ba\
    nned_time\x18)\x20\x01(\rR\x10rankedBannedTime\x127\n\x18ranked_low_prio\
    rity_time\x18*\x20\x01(\rR\x15rankedLowPriorityTime\x12:\n\x0fleader_ui_\
    state\x18,\x20\x01(\x0b2\x12.TFSyncedMMUIStateR\rleaderUiState\x12>\n\
    \x0fpending_members\x18'\x20\x03(\x0b2\x15.TFPendingPartyMemberR\x0epend\
    ingMembers\x1aw\n\nQueueEntry\x12H\n\x0bmatch_group\x18\x01\x20\x01(\x0e\
    2\x0e.ETFMatchGroup:\x17k_eTFMatchGroup_InvalidR\nmatchGroup\x12\x1f\n\
    \x0bqueued_time\x18\x02\x20\x01(\x07R\nqueuedTime\"\xa1\x02\n\x10CSOTFPa\
    rtyInvite\x12\x1f\n\x08group_id\x18\x01\x20\x01(\x04R\x07groupIdB\x04\
    \x80\xa6\x1d\x01\x12\x18\n\x07inviter\x18\x02\x20\x01(\x06R\x07inviter\
    \x127\n\x07members\x18\x04\x20\x03(\x0b2\x1d.CSOTFPartyInvite.PartyMembe\
    rR\x07members\x12:\n\x04type\x18\x05\x20\x01(\x0e2\x16.CSOTFPartyInvite.\
    Type:\x0ePENDING_INVITER\x04type\x1a'\n\x0bPartyMember\x12\x18\n\x07stea\
    mid\x18\x02\x20\x01(\x06R\x07steamid\"4\n\x04Type\x12\x12\n\x0ePENDING_I\
    NVITE\x10\x01\x12\x18\n\x14PENDING_JOIN_REQUEST\x10\x02\"\x82\x06\n\x13C\
    TFLobbyPlayerProto\x12\x14\n\x02id\x18\x01\x20\x01(\x06R\x02idB\x04\x80\
    \xa6\x1d\x01\x125\n\x04team\x18\x03\x20\x01(\x0e2\x0b.TF_GC_TEAM:\x14TF_\
    GC_TEAM_DEFENDERSR\x04team\x12O\n\rconnect_state\x18\r\x20\x01(\x0e2!.CT\
    FLobbyPlayerProto.ConnectState:\x07INVALIDR\x0cconnectState\x12\x12\n\
    \x04name\x18\x06\x20\x01(\tR\x04name\x12*\n\x11original_party_id\x18\x0c\
    \x20\x01(\x04R\x0foriginalPartyId\x12#\n\rsquad_surplus\x18\x0e\x20\x01(\
    \x08R\x0csquadSurplus\x12\x1f\n\x0bbadge_level\x18\x0f\x20\x01(\rR\nbadg\
    eLevel\x12*\n\x11last_connect_time\x18\x11\x20\x01(\rR\x0flastConnectTim\
    e\x12=\n\x04type\x18\x13\x20\x01(\x0e2\x19.CTFLobbyPlayerProto.Type:\x0e\
    INVALID_PLAYERR\x04type\x12+\n\x11normalized_rating\x18\x14\x20\x01(\x01\
    R\x10normalizedRating\x125\n\x16normalized_uncertainty\x18\x16\x20\x01(\
    \x01R\x15normalizedUncertainty\x12\x12\n\x04rank\x18\x15\x20\x01(\rR\x04\
    rank\x12'\n\x0fchat_suspension\x18\x17\x20\x01(\x08R\x0echatSuspension\"\
    c\n\x0cConnectState\x12\x0b\n\x07INVALID\x10\0\x12\x17\n\x13RESERVATION_\
    PENDING\x10\x01\x12\x0c\n\x08RESERVED\x10\x02\x12\r\n\tCONNECTED\x10\x03\
    \x12\x10\n\x0cDISCONNECTED\x10\x05\"V\n\x04Type\x12\x12\n\x0eINVALID_PLA\
    YER\x10\0\x12\x10\n\x0cMATCH_PLAYER\x10\x01\x12\x12\n\x0eSTANDBY_PLAYER\
    \x10\x02\x12\x14\n\x10OBSERVING_PLAYER\x10\x03\"\x80\x01\n\x13CTFLobbyIn\
    viteProto\x12\x1f\n\x08lobby_id\x18\x01\x20\x01(\x06R\x07lobbyIdB\x04\
    \x80\xa6\x1d\x01\x12H\n\x0bmatch_group\x18\x02\x20\x01(\x0e2\x0e.ETFMatc\
    hGroup:\x17k_eTFMatchGroup_InvalidR\nmatchGroup\"\xee\x07\n\x14CSOTFGame\
    ServerLobby\x12\x1f\n\x08lobby_id\x18\x01\x20\x01(\x04R\x07lobbyIdB\x04\
    \x80\xa6\x1d\x01\x12.\n\x07members\x18\x02\x20\x03(\x0b2\x14.CTFLobbyPla\
    yerProtoR\x07members\x12\x1e\n\tserver_id\x18\x06\x20\x01(\x06:\x010R\
    \x08serverId\x12:\n\x05state\x18\x04\x20\x01(\x0e2\x1b.CSOTFGameServerLo\
    bby.State:\x07UNKNOWNR\x05state\x12\x18\n\x07connect\x18\x05\x20\x01(\tR\
    \x07connect\x12K\n\ngame_state\x18\x16\x20\x01(\x0e2\x10.TF_GC_GameState\
    :\x1aTF_GC_GAMESTATE_STATE_INITR\tgameState\x129\n\x19initial_average_mm\
    _rating\x18\x20\x20\x01(\x01R\x16initialAverageMmRating\x12(\n\x10mannup\
    _tour_name\x18*\x20\x01(\tR\x0emannupTourName\x12\x19\n\x08map_name\x18&\
    \x20\x01(\tR\x07mapName\x12!\n\x0cmission_name\x18'\x20\x01(\tR\x0bmissi\
    onName\x12\x1f\n\x0bmatch_group\x18)\x20\x01(\rR\nmatchGroup\x12\x1c\n\
    \x08match_id\x18\x1e\x20\x01(\x04:\x010R\x07matchId\x12\x1f\n\x0bformed_\
    time\x18$\x20\x01(\rR\nformedTime\x12\x14\n\x05flags\x18+\x20\x01(\rR\
    \x05flags\x12,\n\x12late_join_eligible\x18,\x20\x01(\x08R\x10lateJoinEli\
    gible\x12(\n\x10fixed_match_size\x18-\x20\x01(\rR\x0efixedMatchSize\x12F\
    \n\x0cis_war_match\x18.\x20\x01(\x0e2\x1e.CSOTFGameServerLobby.WarMatch:\
    \x04NOPER\nisWarMatch\x12+\n\x12next_maps_for_vote\x18/\x20\x03(\rR\x0fn\
    extMapsForVote\x12(\n\x10lobby_mm_version\x180\x20\x01(\rR\x0elobbyMmVer\
    sion\x12=\n\x0fpending_members\x181\x20\x03(\x0b2\x14.CTFLobbyPlayerProt\
    oR\x0ependingMembers\".\n\x05State\x12\x0b\n\x07UNKNOWN\x10\0\x12\x0f\n\
    \x0bSERVERSETUP\x10\x01\x12\x07\n\x03RUN\x10\x02\"C\n\x08WarMatch\x12\
    \x08\n\x04NOPE\x10\0\x12\x15\n\x11INVADERS_ARE_PYRO\x10\x01\x12\x16\n\
    \x12INVADERS_ARE_HEAVY\x10\x02\"v\n\x13CMsgExitMatchmaking\x12)\n\x10exp\
    licit_abandon\x18\x01\x20\x01(\x08R\x0fexplicitAbandon\x12\x19\n\x08part\
    y_id\x18\x02\x20\x01(\x04R\x07partyId\x12\x19\n\x08lobby_id\x18\x03\x20\
    \x01(\x04R\x07lobbyId\"\xb0\x01\n\x15CMsgAcceptLobbyInvite\x12(\n\x10inv\
    ited_lobby_id\x18\x01\x20\x01(\x04R\x0einvitedLobbyId\x12.\n\x13abandoni\
    ng_match_id\x18\x02\x20\x01(\x04R\x11abandoningMatchId\x12=\n\x1babandon\
    ing_invite_lobby_ids\x18\x03\x20\x03(\x04R\x18abandoningInviteLobbyIds\"\
    \x1c\n\x1aCMsgAcceptLobbyInviteReply\"#\n!CMsgMatchmakingSearchCountRequ\
    est\"a\n\"CMsgMatchmakingSearchCountResponse\x12;\n\x1asearching_players\
    _by_group\x18\x01\x20\x03(\rR\x17searchingPlayersByGroup\"\x20\n\x1eCMsg\
    KickedFromMatchmakingQueue\"\xe0\t\n\x1fCMsgGameServerMatchmakingStatus\
    \x12+\n\x0eserver_version\x18\x10\x20\x01(\r:\x041225R\rserverVersion\
    \x12d\n\x11matchmaking_state\x18\x01\x20\x01(\x0e2\x17.ServerMatchmaking\
    State:\x1eServerMatchmakingState_INVALIDR\x10matchmakingState\x12\x10\n\
    \x03map\x18\x03\x20\x01(\tR\x03map\x12\x12\n\x04tags\x18\x04\x20\x01(\tR\
    \x04tags\x12\x1b\n\tbot_count\x18\x05\x20\x01(\rR\x08botCount\x12%\n\x0e\
    num_spectators\x18\x06\x20\x01(\rR\rnumSpectators\x12\x1f\n\x0bmax_playe\
    rs\x18\x07\x20\x01(\rR\nmaxPlayers\x12\x1d\n\nslots_free\x18\x08\x20\x01\
    (\rR\tslotsFree\x12#\n\rserver_region\x18\t\x20\x01(\rR\x0cserverRegion\
    \x12%\n\x0eserver_loadavg\x18\n\x20\x01(\x02R\rserverLoadavg\x12%\n\x0es\
    erver_trusted\x18\x0b\x20\x01(\x08R\rserverTrusted\x12)\n\x10server_dedi\
    cated\x18\x0c\x20\x01(\x08R\x0fserverDedicated\x12\x16\n\x06strict\x18\
    \x11\x20\x01(\rR\x06strict\x12\x17\n\x07fake_ip\x18\x19\x20\x01(\tR\x06f\
    akeIp\x12A\n\x07players\x18\r\x20\x03(\x0b2'.CMsgGameServerMatchmakingSt\
    atus.PlayerR\x07players\x12K\n\ngame_state\x18\x0e\x20\x01(\x0e2\x10.TF_\
    GC_GameState:\x1aTF_GC_GAMESTATE_STATE_INITR\tgameState\x12B\n\x05event\
    \x18\x0f\x20\x01(\x0e2&.CMsgGameServerMatchmakingStatus.Event:\x04NoneR\
    \x05event\x12\x19\n\x08mvm_wave\x18\x12\x20\x01(\rR\x07mvmWave\x120\n\
    \x14mvm_credits_acquired\x18\x13\x20\x01(\rR\x12mvmCreditsAcquired\x12.\
    \n\x13mvm_credits_dropped\x18\x14\x20\x01(\rR\x11mvmCreditsDropped\x12#\
    \n\x0bmatch_group\x18\x17\x20\x01(\x11:\x02-1R\nmatchGroup\x12(\n\x10lob\
    by_mm_version\x18\x18\x20\x01(\rR\x0elobbyMmVersion\x1a\x86\x01\n\x06Pla\
    yer\x12\x19\n\x08steam_id\x18\x01\x20\x01(\x06R\x07steamId\x12a\n\rconne\
    ct_state\x18\x02\x20\x01(\x0e23.CMsgGameServerMatchmakingStatus.PlayerCo\
    nnectState:\x07INVALIDR\x0cconnectState\">\n\x12PlayerConnectState\x12\
    \x0b\n\x07INVALID\x10\0\x12\r\n\tCONNECTED\x10\x01\x12\x0c\n\x08RESERVED\
    \x10\x02\"H\n\x05Event\x12\x08\n\x04None\x10\0\x12\x0e\n\nMvMVictory\x10\
    \x01\x12\r\n\tMvMDefeat\x10\x02\x12\x16\n\x12AcknowledgePlayers\x10\x03\
    \"\xbf\x08\n\x17CMsgMatchmakingProgress\x12)\n\x11avg_wait_time_new\x18\
    \x04\x20\x01(\rR\x0eavgWaitTimeNew\x124\n\x17avg_wait_time_join_late\x18\
    \x05\x20\x01(\rR\x13avgWaitTimeJoinLate\x12$\n\x0eyour_wait_time\x18\x06\
    \x20\x01(\rR\x0cyourWaitTime\x12O\n$matching_worldwide_searching_players\
    \x18\x08\x20\x01(\rR!matchingWorldwideSearchingPlayers\x12L\n#matching_n\
    ear_you_searching_players\x18\t\x20\x01(\rR\x1fmatchingNearYouSearchingP\
    layers\x12I\n!total_worldwide_searching_players\x18\r\x20\x01(\rR\x1etot\
    alWorldwideSearchingPlayers\x12F\n\x20total_near_you_searching_players\
    \x18\x0e\x20\x01(\rR\x1ctotalNearYouSearchingPlayers\x12I\n!matching_wor\
    ldwide_active_players\x18\x0f\x20\x01(\rR\x1ematchingWorldwideActivePlay\
    ers\x12F\n\x20matching_near_you_active_players\x18\x10\x20\x01(\rR\x1cma\
    tchingNearYouActivePlayers\x12C\n\x1etotal_worldwide_active_players\x18\
    \x11\x20\x01(\rR\x1btotalWorldwideActivePlayers\x12@\n\x1dtotal_near_you\
    _active_players\x18\x12\x20\x01(\rR\x19totalNearYouActivePlayers\x12O\n$\
    matching_worldwide_empty_gameservers\x18\x13\x20\x01(\rR!matchingWorldwi\
    deEmptyGameservers\x12L\n#matching_near_you_empty_gameservers\x18\x14\
    \x20\x01(\rR\x1fmatchingNearYouEmptyGameservers\x12I\n!total_worldwide_e\
    mpty_gameservers\x18\x15\x20\x01(\rR\x1etotalWorldwideEmptyGameservers\
    \x12F\n\x20total_near_you_empty_gameservers\x18\x16\x20\x01(\rR\x1ctotal\
    NearYouEmptyGameservers\x12\x1f\n\x0burgency_pct\x18\x01\x20\x01(\rR\nur\
    gencyPct\"\x94\x06\n\x12CMsgMvMVictoryInfo\x124\n\x07players\x18\x01\x20\
    \x03(\x0b2\x1a.CMsgMvMVictoryInfo.PlayerR\x07players\x12\x1b\n\ttour_nam\
    e\x18\x02\x20\x01(\tR\x08tourName\x12!\n\x0cmission_name\x18\x03\x20\x01\
    (\tR\x0bmissionName\x1a\xb4\x01\n\x04Item\x12K\n\x0cgrant_reason\x18\x01\
    \x20\x01(\x0e2\x1f.CMsgMvMVictoryInfo.GrantReason:\x07INVALIDR\x0bgrantR\
    eason\x12\x1b\n\titem_data\x18\x02\x20\x01(\x0cR\x08itemData\x12B\n\x1es\
    quad_surplus_claimer_steam_id\x18\x03\x20\x01(\x06R\x1asquadSurplusClaim\
    erSteamId\x1a\xf0\x02\n\x06Player\x12\x19\n\x08steam_id\x18\x01\x20\x01(\
    \x06R\x07steamId\x12#\n\rbadge_granted\x18\x03\x20\x01(\x08R\x0cbadgeGra\
    nted\x124\n\x16badge_progress_updated\x18\x04\x20\x01(\x08R\x14badgeProg\
    ressUpdated\x12#\n\rbadge_leveled\x18\x05\x20\x01(\x08R\x0cbadgeLeveled\
    \x12\x1f\n\x0bbadge_level\x18\x06\x20\x01(\rR\nbadgeLevel\x12.\n\x13badg\
    e_progress_bits\x18\x07\x20\x01(\rR\x11badgeProgressBits\x12.\n\x05items\
    \x18\x08\x20\x03(\x0b2\x18.CMsgMvMVictoryInfo.ItemR\x05items\x12'\n\x0fv\
    oucher_missing\x18\t\x20\x01(\x08R\x0evoucherMissing\x12!\n\x0cbadge_poi\
    nts\x18\n\x20\x01(\rR\x0bbadgePoints\"^\n\x0bGrantReason\x12\x0b\n\x07IN\
    VALID\x10\0\x12\x11\n\rBADGE_LEVELED\x10\x01\x12\x11\n\rSQUAD_SURPLUS\
    \x10\x02\x12\x0b\n\x07MANN_UP\x10\x03\x12\x0f\n\x0bHELP_A_NOOB\x10\x04\"\
    \x90\x01\n\x15CGCMsgTFHelloResponse\x12#\n\rversion_check\x18\x01\x20\
    \x01(\rR\x0cversionCheck\x12)\n\x10version_checksum\x18\x02\x20\x03(\x04\
    R\x0fversionChecksum\x12'\n\x0fversion_verbose\x18\x03\x20\x01(\rR\x0eve\
    rsionVerbose\"\xe4\x01\n\x0cCGCMsgTFSync\x12)\n\x10version_checksum\x18\
    \x01\x20\x01(\x0cR\x0fversionChecksum\x12#\n\rversion_check\x18\x02\x20\
    \x01(\rR\x0cversionCheck\x12(\n\x10version_check_ex\x18\x03\x20\x01(\rR\
    \x0eversionCheckEx\x12*\n\x11version_check_ex2\x18\x04\x20\x01(\rR\x0fve\
    rsionCheckEx2\x12.\n\x13version_checksum_ex\x18\x05\x20\x01(\x0cR\x11ver\
    sionChecksumEx\"\x90\x01\n\x0eCGCMsgTFSyncEx\x12)\n\x10version_checksum\
    \x18\x01\x20\x01(\tR\x0fversionChecksum\x12.\n\x13version_checksum_ex\
    \x18\x02\x20\x01(\x0cR\x11versionChecksumEx\x12#\n\rversion_check\x18\
    \x03\x20\x01(\rR\x0cversionCheck\"\xc5\x02\n\x0eCMsgMvMVictory\x120\n\
    \x14legacy_mission_index\x18\x01\x20\x01(\rR\x12legacyMissionIndex\x12(\
    \n\x10tour_name_mannup\x18\x05\x20\x01(\tR\x0etourNameMannup\x12!\n\x0cm\
    ission_name\x18\x06\x20\x01(\tR\x0bmissionName\x120\n\x07players\x18\x02\
    \x20\x03(\x0b2\x16.CMsgMvMVictory.PlayerR\x07players\x12\x19\n\x08lobby_\
    id\x18\x03\x20\x01(\x04R\x07lobbyId\x12\x1d\n\nevent_time\x18\x04\x20\
    \x01(\x07R\teventTime\x1aH\n\x06Player\x12\x19\n\x08steam_id\x18\x01\x20\
    \x01(\x06R\x07steamId\x12#\n\rsquad_surplus\x18\x02\x20\x01(\x08R\x0csqu\
    adSurplus\"\x1b\n\x19CMsgMvMMannUpVictoryReply\"R\n\x1aCMsgGameServerKic\
    kingLobby\x12\x19\n\x08lobby_id\x18\x03\x20\x01(\x04R\x07lobbyId\x12\x19\
    \n\x08match_id\x18\x04\x20\x01(\x04R\x07matchId\"$\n\"CMsgGameServerKick\
    ingLobbyResponse\"?\n\"CMsgLeaveGameAndPrepareToJoinParty\x12\x19\n\x08p\
    arty_id\x18\x01\x20\x01(\x06R\x07partyId\"\x93\x02\n\x13CMsgPlayerLeftMa\
    tch\x12\x19\n\x08steam_id\x18\x01\x20\x01(\x06R\x07steamId\x12V\n\x0clea\
    ve_reason\x18\x02\x20\x01(\x0e2\x13.TFMatchLeaveReason:\x1eTFMatchLeaveR\
    eason_UNSPECIFIEDR\x0bleaveReason\x12\x1f\n\x0bwas_abandon\x18\x03\x20\
    \x01(\x08R\nwasAbandon\x12\x19\n\x08lobby_id\x18\x04\x20\x01(\x04R\x07lo\
    bbyId\x12\x19\n\x08match_id\x18\x05\x20\x01(\x04R\x07matchId\x122\n\x0cx\
    p_breakdown\x18\x06\x20\x03(\x0b2\x0f.CMsgTFXPSourceR\x0bxpBreakdown\"\
    \x1d\n\x1bCMsgPlayerLeftMatchResponse\"\xe5\x02\n\x18CMsgProcessMatchVot\
    eKick\x12\x19\n\x08match_id\x18\x01\x20\x01(\x06R\x07matchId\x12,\n\x12i\
    nitiator_steam_id\x18\x02\x20\x01(\x06R\x10initiatorSteamId\x12&\n\x0fta\
    rget_steam_id\x18\x03\x20\x01(\x06R\rtargetSteamId\x12A\n\x06reason\x18\
    \x04\x20\x01(\x0e2\x11.TFVoteKickReason:\x16TFVoteKickReason_OtherR\x06r\
    eason\x124\n\x05votes\x18\x05\x20\x03(\x0b2\x1e.CMsgProcessMatchVoteKick\
    .VoteR\x05votes\x12!\n\x0cdefault_pass\x18\x06\x20\x01(\x08R\x0bdefaultP\
    ass\x1a<\n\x04Vote\x12\x19\n\x08steam_id\x18\x01\x20\x01(\x06R\x07steamI\
    d\x12\x19\n\x08vote_yay\x18\x02\x20\x01(\x08R\x07voteYay\"4\n\x20CMsgPro\
    cessMatchVoteKickResponse\x12\x10\n\x03rip\x18\x01\x20\x01(\x08R\x03rip\
    \"/\n-CMsgPlayerVoteKickedAfterLeavingMatchResponse\"\x8b\x02\n\x1dCMsgH\
    alloween_ServerBossEvent\x12#\n\revent_counter\x18\x01\x20\x01(\rR\x0cev\
    entCounter\x12\x1c\n\ttimestamp\x18\x02\x20\x01(\rR\ttimestamp\x12\x1b\n\
    \tboss_type\x18\x03\x20\x01(\rR\x08bossType\x12\x1d\n\nboss_level\x18\
    \x04\x20\x01(\rR\tbossLevel\x12\x1d\n\nevent_type\x18\x05\x20\x01(\rR\te\
    ventType\x12)\n\x10players_involved\x18\x06\x20\x01(\rR\x0fplayersInvolv\
    ed\x12!\n\x0celapsed_time\x18\x07\x20\x01(\x02R\x0belapsedTime\"\xff\x07\
    \n\x1aCMsgHalloween_Merasmus2012\x12#\n\revent_counter\x18\x01\x20\x01(\
    \rR\x0ceventCounter\x12%\n\x0etime_submitted\x18\x02\x20\x01(\x07R\rtime\
    Submitted\x12&\n\x0fis_valve_server\x18\x03\x20\x01(\x08R\risValveServer\
    \x12\x1d\n\nboss_level\x18\x04\x20\x01(\rR\tbossLevel\x12%\n\x0espawned_\
    health\x18\x05\x20\x01(\rR\rspawnedHealth\x12)\n\x10remaining_health\x18\
    \x06\x20\x01(\rR\x0fremainingHealth\x12\x1b\n\tlife_time\x18\x07\x20\x01\
    (\rR\x08lifeTime\x12\x1d\n\nbomb_kills\x18\x08\x20\x01(\rR\tbombKills\
    \x12\x1f\n\x0bstaff_kills\x18\t\x20\x01(\rR\nstaffKills\x12\x1b\n\tpvp_k\
    ills\x18\n\x20\x01(\rR\x08pvpKills\x12%\n\x0eprophunt_time1\x18\x0b\x20\
    \x01(\rR\rprophuntTime1\x12%\n\x0eprophunt_time2\x18\x0c\x20\x01(\rR\rpr\
    ophuntTime2\x12\x1b\n\tdmg_scout\x18\r\x20\x01(\rR\x08dmgScout\x12\x1d\n\
    \ndmg_sniper\x18\x0e\x20\x01(\rR\tdmgSniper\x12\x1f\n\x0bdmg_soldier\x18\
    \x0f\x20\x01(\rR\ndmgSoldier\x12\x19\n\x08dmg_demo\x18\x10\x20\x01(\rR\
    \x07dmgDemo\x12\x1b\n\tdmg_medic\x18\x11\x20\x01(\rR\x08dmgMedic\x12\x1b\
    \n\tdmg_heavy\x18\x12\x20\x01(\rR\x08dmgHeavy\x12\x19\n\x08dmg_pyro\x18\
    \x13\x20\x01(\rR\x07dmgPyro\x12\x17\n\x07dmg_spy\x18\x14\x20\x01(\rR\x06\
    dmgSpy\x12!\n\x0cdmg_engineer\x18\x15\x20\x01(\rR\x0bdmgEngineer\x12\x1f\
    \n\x0bscout_count\x18\x16\x20\x01(\rR\nscoutCount\x12!\n\x0csniper_count\
    \x18\x17\x20\x01(\rR\x0bsniperCount\x12#\n\rsolider_count\x18\x18\x20\
    \x01(\rR\x0csoliderCount\x12\x1d\n\ndemo_count\x18\x19\x20\x01(\rR\tdemo\
    Count\x12\x1f\n\x0bmedic_count\x18\x1a\x20\x01(\rR\nmedicCount\x12\x1f\n\
    \x0bheavy_count\x18\x1b\x20\x01(\rR\nheavyCount\x12\x1d\n\npyro_count\
    \x18\x1c\x20\x01(\rR\tpyroCount\x12\x1b\n\tspy_count\x18\x1d\x20\x01(\rR\
    \x08spyCount\x12%\n\x0eengineer_count\x18\x1e\x20\x01(\rR\rengineerCount\
    \"\xba\x01\n$CMsgUpdateHalloweenMerasmusLootLevel\x12F\n\x07players\x18\
    \x01\x20\x03(\x0b2,.CMsgUpdateHalloweenMerasmusLootLevel.PlayerR\x07play\
    ers\x12%\n\x0emerasmus_level\x18\x02\x20\x01(\rR\rmerasmusLevel\x1a#\n\
    \x06Player\x12\x19\n\x08steam_id\x18\x01\x20\x01(\x06R\x07steamId\")\n\
    \x11CAttribute_String\x12\x14\n\x05value\x18\x01\x20\x01(\tR\x05value\"\
    \x81\x02\n!CAttribute_DynamicRecipeComponent\x12\x1b\n\tdef_index\x18\
    \x01\x20\x01(\rR\x08defIndex\x12!\n\x0citem_quality\x18\x02\x20\x01(\rR\
    \x0bitemQuality\x12'\n\x0fcomponent_flags\x18\x03\x20\x01(\rR\x0ecompone\
    ntFlags\x12+\n\x11attributes_string\x18\x04\x20\x01(\tR\x10attributesStr\
    ing\x12!\n\x0cnum_required\x18\x05\x20\x01(\rR\x0bnumRequired\x12#\n\rnu\
    m_fulfilled\x18\x06\x20\x01(\rR\x0cnumFulfilled\"\xa3\x03\nACAttribute_D\
    ynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT\x12\x1b\n\tdef_ind\
    ex\x18\x01\x20\x01(\rR\x08defIndex\x12\x19\n\x08item_def\x18\x02\x20\x01\
    (\rR\x07itemDef\x12!\n\x0citem_quality\x18\x03\x20\x01(\rR\x0bitemQualit\
    y\x12'\n\x0fcomponent_flags\x18\x04\x20\x01(\rR\x0ecomponentFlags\x12\
    \x1d\n\nitem_flags\x18\x05\x20\x01(\rR\titemFlags\x12+\n\x11attributes_s\
    tring\x18\x06\x20\x01(\tR\x10attributesString\x12!\n\x0cnum_required\x18\
    \x07\x20\x01(\rR\x0bnumRequired\x12\x1d\n\nitem_count\x18\x08\x20\x01(\r\
    R\titemCount\x12#\n\rnum_fulfilled\x18\t\x20\x01(\rR\x0cnumFulfilled\x12\
    '\n\x0fitems_fulfilled\x18\n\x20\x01(\rR\x0eitemsFulfilled\"1\n\x1bCAttr\
    ibute_ItemSlotCriteria\x12\x12\n\x04tags\x18\x01\x20\x01(\tR\x04tags\"\
    \x85\x01\n\x18CMsgSetItemSlotAttribute\x12\x17\n\x07item_id\x18\x01\x20\
    \x01(\x04R\x06itemId\x121\n\x15slot_item_original_id\x18\x02\x20\x01(\
    \x04R\x12slotItemOriginalId\x12\x1d\n\nslot_index\x18\x03\x20\x01(\rR\ts\
    lotIndex\"\x95\x01\n\nCSOWarData\x12#\n\naccount_id\x18\x01\x20\x01(\rR\
    \taccountIdB\x04\x80\xa6\x1d\x01\x12\x1b\n\x06war_id\x18\x02\x20\x01(\rR\
    \x05warIdB\x04\x80\xa6\x1d\x01\x12\x20\n\x0baffiliation\x18\x03\x20\x01(\
    \rR\x0baffiliation\x12#\n\rpoints_scored\x18\x04\x20\x01(\rR\x0cpointsSc\
    ored\"g\n\x1dCGCMsgGC_War_IndividualUpdate\x12\x19\n\x08steam_id\x18\x01\
    \x20\x01(\x06R\x07steamId\x12\x15\n\x06war_id\x18\x02\x20\x01(\rR\x05war\
    Id\x12\x14\n\x05score\x18\x03\x20\x01(\rR\x05score\"O\n\x14CGCMsgGC_War_\
    JoinWar\x12\x20\n\x0baffiliation\x18\x01\x20\x01(\rR\x0baffiliation\x12\
    \x15\n\x06war_id\x18\x02\x20\x01(\rR\x05warId\"8\n\x1fCGCMsgGC_War_Reque\
    stGlobalStats\x12\x15\n\x06war_id\x18\x01\x20\x01(\rR\x05warId\"\xbe\x01\
    \n\x20CGCMsgGC_War_GlobalStatsResponse\x12L\n\x0bside_scores\x18\x01\x20\
    \x03(\x0b2+.CGCMsgGC_War_GlobalStatsResponse.SideScoreR\nsideScores\x12\
    \x15\n\x06war_id\x18\x02\x20\x01(\rR\x05warId\x1a5\n\tSideScore\x12\x12\
    \n\x04side\x18\x01\x20\x01(\rR\x04side\x12\x14\n\x05score\x18\x02\x20\
    \x01(\x04R\x05score\"\x97\x01\n/CGCMsgGC_PlayerDuckLeaderboard_Individua\
    lUpdate\x12\x14\n\x05score\x18\x02\x20\x01(\rR\x05score\x12\x12\n\x04typ\
    e\x18\x03\x20\x01(\rR\x04type\x12\x19\n\x08score_id\x18\x04\x20\x01(\x0c\
    R\x07scoreId\x12\x1f\n\x0bscore_check\x18\x05\x20\x01(\rR\nscoreCheck\"\
    \xc7\x01\n\x1dCAttribute_WorldItemPlacement\x12(\n\x10original_item_id\
    \x18\x01\x20\x01(\x04R\x0eoriginalItemId\x12\x13\n\x05pos_x\x18\x02\x20\
    \x01(\x02R\x04posX\x12\x13\n\x05pos_y\x18\x03\x20\x01(\x02R\x04posY\x12\
    \x13\n\x05pos_z\x18\x04\x20\x01(\x02R\x04posZ\x12\x13\n\x05ang_x\x18\x05\
    \x20\x01(\x02R\x04angX\x12\x13\n\x05ang_y\x18\x06\x20\x01(\x02R\x04angY\
    \x12\x13\n\x05ang_z\x18\x07\x20\x01(\x02R\x04angZ\"\x95\x02\n\x20CGCMsg_\
    WorldItemPlacement_Update\x12(\n\x10original_item_id\x18\x01\x20\x01(\
    \x04R\x0eoriginalItemId\x12\x13\n\x05pos_x\x18\x02\x20\x01(\x02R\x04posX\
    \x12\x13\n\x05pos_y\x18\x03\x20\x01(\x02R\x04posY\x12\x13\n\x05pos_z\x18\
    \x04\x20\x01(\x02R\x04posZ\x12\x13\n\x05ang_x\x18\x05\x20\x01(\x02R\x04a\
    ngX\x12\x13\n\x05ang_y\x18\x06\x20\x01(\x02R\x04angY\x12\x13\n\x05ang_z\
    \x18\x07\x20\x01(\x02R\x04angZ\x12(\n\x10force_remove_all\x18\x08\x20\
    \x01(\x08R\x0eforceRemoveAll\x12\x1f\n\x0battrib_name\x18\t\x20\x01(\tR\
    \nattribName\"g\n\x11CMsgAcknowledgeXP\x12\x1f\n\x0bmatch_group\x18\x01\
    \x20\x01(\x05R\nmatchGroup\x121\n\x14predicted_experience\x18\x02\x20\
    \x01(\rR\x13predictedExperience\"\xc2\x03\n\x0eCMsgTFXPSource\x12D\n\x04\
    type\x18\x01\x20\x01(\x0e2\x1c.CMsgTFXPSource.XPSourceType:\x0cSOURCE_SC\
    ORER\x04typeB\x04\x80\xa6\x1d\x01\x12\x16\n\x06amount\x18\x02\x20\x01(\
    \x05R\x06amount\x12\x1f\n\x0bmatch_group\x18\x03\x20\x01(\x05R\nmatchGro\
    up\x12#\n\naccount_id\x18\x04\x20\x01(\rR\taccountIdB\x04\x80\xa6\x1d\
    \x01\x12\x1f\n\x08match_id\x18\x05\x20\x01(\x04R\x07matchIdB\x04\x80\xa6\
    \x1d\x01\"\xea\x01\n\x0cXPSourceType\x12\x10\n\x0cSOURCE_SCORE\x10\0\x12\
    \x1a\n\x16SOURCE_OBJECTIVE_BONUS\x10\x01\x12\x1a\n\x16SOURCE_COMPLETED_M\
    ATCH\x10\x02\x12\x1e\n\x1aSOURCE_COMPETITIVE_ABANDON\x10\x03\x12\x1a\n\
    \x16SOURCE_COMPETITIVE_WIN\x10\x04\x12\x1b\n\x17SOURCE_COMPETITIVE_LOSS\
    \x10\x05\x12\x1c\n\x18SOURCE_AUTOBALANCE_BONUS\x10\x06\x12\x19\n\x15SOUR\
    CE_PRESTIGE_BONUS\x10\x07\"D\n\x17CMsgTFXPSourceBreakdown\x12)\n\x07sour\
    ces\x18\x01\x20\x03(\x0b2\x0f.CMsgTFXPSourceR\x07sources\"U\n\x10CMsgTFC\
    lientInit\x12%\n\x0eclient_version\x18\x01\x20\x01(\rR\rclientVersion\
    \x12\x1a\n\x08language\x18\x02\x20\x01(\x05R\x08language\"\x8d\x04\n\x12\
    CMsgGCNotification\x12-\n\x0fnotification_id\x18\x01\x20\x01(\x04R\x0eno\
    tificationIdB\x04\x80\xa6\x1d\x01\x12\x1d\n\naccount_id\x18\x02\x20\x01(\
    \rR\taccountId\x12'\n\x0fexpiration_time\x18\x03\x20\x01(\x07R\x0eexpira\
    tionTime\x12T\n\x04type\x18\x04\x20\x01(\x0e2$.CMsgGCNotification.Notifi\
    cationType:\x1aNOTIFICATION_CUSTOM_STRINGR\x04type\x12/\n\x13notificatio\
    n_string\x18\x05\x20\x01(\tR\x12notificationString\"\xf8\x01\n\x10Notifi\
    cationType\x12'\n#NOTIFICATION_REPORTED_PLAYER_BANNED\x10\0\x12\x1e\n\
    \x1aNOTIFICATION_CUSTOM_STRING\x10\x01\x120\n,NOTIFICATION_MM_BAN_DUE_TO\
    _EXCESSIVE_REPORTS\x10\x02\x12+\n'NOTIFICATION_REPORTED_PLAYER_WAS_BANNE\
    D\x10\x03\x12\x20\n\x1cNOTIFICATION_SUPPORT_MESSAGE\x10\x04\x12\x1a\n\
    \x16NOTIFICATION_NUM_TYPES\x10\x05\"T\n\x17CMsgGCNotificationQueue\x129\
    \n\rnotifications\x18\x01\x20\x03(\x0b2\x13.CMsgGCNotificationR\rnotific\
    ations\"e\n\x1bCMsgNotificationAcknowledge\x12\x1d\n\naccount_id\x18\x01\
    \x20\x01(\rR\taccountId\x12'\n\x0fnotification_id\x18\x02\x20\x01(\x04R\
    \x0enotificationId\"\"\n\x20CMsgNotificationAcknowledgeReply\"\xe6\n\n\
    \x13CMsgGC_Match_Result\x12\x1f\n\x08match_id\x18\x01\x20\x01(\x04R\x07m\
    atchIdB\x04\x80\xa6\x1d\x01\x12\x1f\n\x0bmatch_group\x18\x02\x20\x01(\
    \x05R\nmatchGroup\x12D\n\x06status\x18\x03\x20\x01(\x0e2\x1b.CMsgGC_Matc\
    h_Result.Status:\x0fMATCH_SUCCEEDEDR\x06status\x12\x1a\n\x08duration\x18\
    \x04\x20\x01(\rR\x08duration\x12\x1b\n\tred_score\x18\x05\x20\x01(\rR\
    \x08redScore\x12\x1d\n\nblue_score\x18\x06\x20\x01(\rR\tblueScore\x12!\n\
    \x0cwinning_team\x18\x07\x20\x01(\rR\x0bwinningTeam\x12\x1b\n\tmap_index\
    \x18\x08\x20\x01(\rR\x08mapIndex\x12\x1e\n\tgame_type\x18\t\x20\x01(\r:\
    \x010R\x08gameType\x125\n\x07players\x18\n\x20\x03(\x0b2\x1b.CMsgGC_Matc\
    h_Result.PlayerR\x07players\x12\x1d\n\nwin_reason\x18\r\x20\x01(\rR\twin\
    Reason\x12\x14\n\x05flags\x18\x0e\x20\x01(\rR\x05flags\x12\x12\n\x04bots\
    \x18\x10\x20\x01(\rR\x04bots\x1a\xd5\x05\n\x06Player\x12\x19\n\x08steam_\
    id\x18\x01\x20\x01(\x06R\x07steamId\x12*\n\x11original_party_id\x18\x02\
    \x20\x01(\x04R\x0foriginalPartyId\x12\x12\n\x04team\x18\x03\x20\x01(\rR\
    \x04team\x12\x14\n\x05score\x18\x04\x20\x01(\rR\x05score\x12\x12\n\x04pi\
    ng\x18\x05\x20\x01(\rR\x04ping\x12\x14\n\x05flags\x18\x06\x20\x01(\rR\
    \x05flags\x12\x12\n\x04rank\x18\t\x20\x01(\rR\x04rank\x12%\n\x0eclasses_\
    played\x18\n\x20\x01(\rR\rclassesPlayed\x12\x14\n\x05kills\x18\x0b\x20\
    \x01(\rR\x05kills\x12\x16\n\x06deaths\x18\x0c\x20\x01(\rR\x06deaths\x12\
    \x16\n\x06damage\x18\r\x20\x01(\rR\x06damage\x12\x18\n\x07healing\x18\
    \x0e\x20\x01(\rR\x07healing\x12\x18\n\x07support\x18\x0f\x20\x01(\rR\x07\
    support\x12\x1f\n\x0bscore_medal\x18\x10\x20\x01(\rR\nscoreMedal\x12\x1f\
    \n\x0bkills_medal\x18\x11\x20\x01(\rR\nkillsMedal\x12!\n\x0cdamage_medal\
    \x18\x12\x20\x01(\rR\x0bdamageMedal\x12#\n\rhealing_medal\x18\x13\x20\
    \x01(\rR\x0chealingMedal\x12#\n\rsupport_medal\x18\x14\x20\x01(\rR\x0csu\
    pportMedal\x122\n\x0cxp_breakdown\x18\x15\x20\x03(\x0b2\x0f.CMsgTFXPSour\
    ceR\x0bxpBreakdown\x12\x1d\n\nleave_time\x18\x16\x20\x01(\rR\tleaveTime\
    \x12V\n\x0cleave_reason\x18\x17\x20\x01(\x0e2\x13.TFMatchLeaveReason:\
    \x1eTFMatchLeaveReason_UNSPECIFIEDR\x0bleaveReason\x12!\n\x0cconnect_tim\
    e\x18\x18\x20\x01(\rR\x0bconnectTime\"\xb6\x01\n\x06Status\x12\x13\n\x0f\
    MATCH_SUCCEEDED\x10\0\x12\x13\n\x0fMATCH_FAILED_GC\x10\x01\x12\x18\n\x14\
    MATCH_FAILED_TRUSTED\x10\x02\x12\x18\n\x14MATCH_FAILED_ABANDON\x10\x03\
    \x12\x18\n\x14MATCH_FAILED_UNKNOWN\x10\x05\x12\x18\n\x14MATCH_FAILED_TIM\
    EOUT\x10\x06\x12\x1a\n\x16MATCH_FINISHED_ABANDON\x10\x07\"\x1d\n\x1bCMsg\
    GC_Match_ResultResponse\"E\n\x19CEconItemPreviewDataBlock\x12(\n\x08econ\
    item\x18\x01\x20\x01(\x0b2\x0c.CSOEconItemR\x08econitem\"\x91\x01\n+CMsg\
    GC_Client2GCEconPreviewDataBlockRequest\x12\x17\n\x07param_s\x18\x01\x20\
    \x01(\x04R\x06paramS\x12\x17\n\x07param_a\x18\x02\x20\x01(\x04R\x06param\
    A\x12\x17\n\x07param_d\x18\x03\x20\x01(\x04R\x06paramD\x12\x17\n\x07para\
    m_m\x18\x04\x20\x01(\x04R\x06paramM\"f\n,CMsgGC_Client2GCEconPreviewData\
    BlockResponse\x126\n\x08iteminfo\x18\x01\x20\x01(\x0b2\x1a.CEconItemPrev\
    iewDataBlockR\x08iteminfo\"\xc4\x06\n\x16CSOTFLadderPlayerStats\x12#\n\n\
    account_id\x18\x01\x20\x01(\rR\taccountIdB\x04\x80\xa6\x1d\x01\x12%\n\
    \x0bmatch_group\x18\x02\x20\x01(\x05R\nmatchGroupB\x04\x80\xa6\x1d\x01\
    \x12!\n\tseason_id\x18\x03\x20\x01(\rR\x08seasonIdB\x04\x80\xa6\x1d\x01\
    \x12\x14\n\x05games\x18\t\x20\x01(\rR\x05games\x12\x14\n\x05score\x18\n\
    \x20\x01(\rR\x05score\x12\x14\n\x05kills\x18\x0b\x20\x01(\rR\x05kills\
    \x12\x16\n\x06deaths\x18\x0c\x20\x01(\rR\x06deaths\x12\x16\n\x06damage\
    \x18\r\x20\x01(\rR\x06damage\x12\x18\n\x07healing\x18\x0e\x20\x01(\rR\
    \x07healing\x12\x18\n\x07support\x18\x0f\x20\x01(\rR\x07support\x12!\n\
    \x0cscore_bronze\x18\x10\x20\x01(\rR\x0bscoreBronze\x12!\n\x0cscore_silv\
    er\x18\x11\x20\x01(\rR\x0bscoreSilver\x12\x1d\n\nscore_gold\x18\x12\x20\
    \x01(\rR\tscoreGold\x12!\n\x0ckills_bronze\x18\x13\x20\x01(\rR\x0bkillsB\
    ronze\x12!\n\x0ckills_silver\x18\x14\x20\x01(\rR\x0bkillsSilver\x12\x1d\
    \n\nkills_gold\x18\x15\x20\x01(\rR\tkillsGold\x12#\n\rdamage_bronze\x18\
    \x16\x20\x01(\rR\x0cdamageBronze\x12#\n\rdamage_silver\x18\x17\x20\x01(\
    \rR\x0cdamageSilver\x12\x1f\n\x0bdamage_gold\x18\x18\x20\x01(\rR\ndamage\
    Gold\x12%\n\x0ehealing_bronze\x18\x19\x20\x01(\rR\rhealingBronze\x12%\n\
    \x0ehealing_silver\x18\x1a\x20\x01(\rR\rhealingSilver\x12!\n\x0chealing_\
    gold\x18\x1b\x20\x01(\rR\x0bhealingGold\x12%\n\x0esupport_bronze\x18\x1c\
    \x20\x01(\rR\rsupportBronze\x12%\n\x0esupport_silver\x18\x1d\x20\x01(\rR\
    \rsupportSilver\x12!\n\x0csupport_gold\x18\x1e\x20\x01(\rR\x0bsupportGol\
    d\"\xd8\x01\n\x0fCSOTFRatingData\x12#\n\naccount_id\x18\x01\x20\x01(\rR\
    \taccountIdB\x04\x80\xa6\x1d\x01\x12%\n\x0brating_type\x18\x02\x20\x01(\
    \x05R\nratingTypeB\x04\x80\xa6\x1d\x01\x12%\n\x0erating_primary\x18\x03\
    \x20\x01(\rR\rratingPrimary\x12)\n\x10rating_secondary\x18\x04\x20\x01(\
    \rR\x0fratingSecondary\x12'\n\x0frating_tertiary\x18\x05\x20\x01(\rR\x0e\
    ratingTertiary\"\xb6\x01\n\x1eCMsgGC_TFVoteKickPlayerRequest\x12\x1b\n\t\
    target_id\x18\x02\x20\x01(\x04R\x08targetId\x12\x19\n\x08voter_id\x18\
    \x03\x20\x01(\x04R\x07voterId\x12A\n\x06reason\x18\x04\x20\x01(\x0e2\x11\
    .TFVoteKickReason:\x16TFVoteKickReason_OtherR\x06reason\x12\x19\n\x08mat\
    ch_id\x18\x05\x20\x01(\x04R\x07matchId\"\x8c\x01\n$CMsgGC_VoteKickPlayer\
    RequestResponse\x12\x18\n\x07allowed\x18\x01\x20\x01(\x08R\x07allowed\
    \x12#\n\rvoter_inhibit\x18\x03\x20\x01(\x08R\x0cvoterInhibit\x12%\n\x0et\
    arget_inhibit\x18\x04\x20\x01(\x08R\rtargetInhibit\"$\n\"CMsgGC_DailyCom\
    petitiveStatsRollup\"\x93\x04\n+CMsgGC_DailyCompetitiveStatsRollup_Respo\
    nse\x12X\n\x08rankdata\x18\x01\x20\x03(\x0b2<.CMsgGC_DailyCompetitiveSta\
    tsRollup_Response.RankBucketEntryR\x08rankdata\x1a\x89\x03\n\x0fRankBuck\
    etEntry\x12\x12\n\x04rank\x18\x01\x20\x01(\rR\x04rank\x12\x18\n\x07recor\
    ds\x18\x02\x20\x01(\rR\x07records\x12\x1b\n\tavg_score\x18\x03\x20\x01(\
    \rR\x08avgScore\x12\x1f\n\x0bstdev_score\x18\x04\x20\x01(\rR\nstdevScore\
    \x12\x1b\n\tavg_kills\x18\x05\x20\x01(\rR\x08avgKills\x12\x1f\n\x0bstdev\
    _kills\x18\x06\x20\x01(\rR\nstdevKills\x12\x1d\n\navg_damage\x18\x07\x20\
    \x01(\rR\tavgDamage\x12!\n\x0cstdev_damage\x18\x08\x20\x01(\rR\x0bstdevD\
    amage\x12\x1f\n\x0bavg_healing\x18\t\x20\x01(\rR\navgHealing\x12#\n\rstd\
    ev_healing\x18\n\x20\x01(\rR\x0cstdevHealing\x12\x1f\n\x0bavg_support\
    \x18\x0b\x20\x01(\rR\navgSupport\x12#\n\rstdev_support\x18\x0c\x20\x01(\
    \rR\x0cstdevSupport\"\x92\x02\n\x13CMsgGC_ReportPlayer\x12*\n\x11account\
    _id_target\x18\x01\x20\x01(\rR\x0faccountIdTarget\x12E\n\x06reason\x18\
    \x02\x20\x01(\x0e2\x1c.CMsgGC_ReportPlayer.EReason:\x0fkReason_INVALIDR\
    \x06reason\"\x87\x01\n\x07EReason\x12\x13\n\x0fkReason_INVALID\x10\0\x12\
    \x14\n\x10kReason_CHEATING\x10\x01\x12\x10\n\x0ckReason_IDLE\x10\x02\x12\
    \x16\n\x12kReason_HARASSMENT\x10\x03\x12\x14\n\x10kReason_GRIEFING\x10\
    \x04\x12\x11\n\rkReason_COUNT\x10\x05\"\xd8\x06\n\x1bCSOTFMatchResultPla\
    yerStats\x12\x1f\n\x08match_id\x18\x01\x20\x01(\x04R\x07matchIdB\x04\x80\
    \xa6\x1d\x01\x12#\n\naccount_id\x18\x02\x20\x01(\rR\taccountIdB\x04\x80\
    \xa6\x1d\x01\x12%\n\x0bmatch_group\x18\x03\x20\x01(\x05R\nmatchGroupB\
    \x04\x80\xa6\x1d\x01\x12\x18\n\x07endtime\x18\x04\x20\x01(\rR\x07endtime\
    \x12\x1b\n\tseason_id\x18\x05\x20\x01(\rR\x08seasonId\x12\x16\n\x06statu\
    s\x18\x06\x20\x01(\rR\x06status\x12*\n\x11original_party_id\x18\x07\x20\
    \x01(\rR\x0foriginalPartyId\x12\x12\n\x04team\x18\x08\x20\x01(\rR\x04tea\
    m\x12\x14\n\x05score\x18\t\x20\x01(\rR\x05score\x12\x12\n\x04ping\x18\n\
    \x20\x01(\rR\x04ping\x12\x14\n\x05flags\x18\x0b\x20\x01(\rR\x05flags\x12\
    %\n\x0edisplay_rating\x18\x0c\x20\x01(\rR\rdisplayRating\x122\n\x15displ\
    ay_rating_change\x18\r\x20\x01(\x05R\x13displayRatingChange\x12\x12\n\
    \x04rank\x18\x0e\x20\x01(\rR\x04rank\x12%\n\x0eclasses_played\x18\x0f\
    \x20\x01(\rR\rclassesPlayed\x12\x14\n\x05kills\x18\x10\x20\x01(\rR\x05ki\
    lls\x12\x16\n\x06deaths\x18\x11\x20\x01(\rR\x06deaths\x12\x16\n\x06damag\
    e\x18\x12\x20\x01(\rR\x06damage\x12\x18\n\x07healing\x18\x13\x20\x01(\rR\
    \x07healing\x12\x18\n\x07support\x18\x14\x20\x01(\rR\x07support\x12\x1f\
    \n\x0bscore_medal\x18\x15\x20\x01(\rR\nscoreMedal\x12\x1f\n\x0bkills_med\
    al\x18\x16\x20\x01(\rR\nkillsMedal\x12!\n\x0cdamage_medal\x18\x17\x20\
    \x01(\rR\x0bdamageMedal\x12#\n\rhealing_medal\x18\x18\x20\x01(\rR\x0chea\
    lingMedal\x12#\n\rsupport_medal\x18\x19\x20\x01(\rR\x0csupportMedal\x12\
    \x1b\n\tmap_index\x18\x1a\x20\x01(\rR\x08mapIndex\x12!\n\x0cwinning_team\
    \x18\x1b\x20\x01(\rR\x0bwinningTeam\"\x1e\n\x1cCMsgGCRequestMatchMakerSt\
    ats\"S\n\x1aCMsgGCDataCenterPopulation\x12\x12\n\x04name\x18\x01\x20\x01\
    (\tR\x04name\x12!\n\x0chealth_ratio\x18\x02\x20\x01(\x02R\x0bhealthRatio\
    \"y\n$CMsgGCMatchGroupDataCenterPopulation\x12Q\n\x16data_center_populat\
    ion\x18\x01\x20\x03(\x0b2\x1b.CMsgGCDataCenterPopulationR\x14dataCenterP\
    opulation\"\xae\x01\n\x1dCMsgGCMatchMakerStatsResponse\x12\x1b\n\tmap_co\
    unt\x18\x01\x20\x03(\rR\x08mapCount\x12p\n!matchgroup_data_center_popula\
    tion\x18\x02\x20\x03(\x0b2%.CMsgGCMatchGroupDataCenterPopulationR\x1emat\
    chgroupDataCenterPopulation\"b\n\x16CMsgGCMatchHistoryLoad\x12H\n\x0bmat\
    ch_group\x18\x01\x20\x01(\x0e2\x0e.ETFMatchGroup:\x17k_eTFMatchGroup_Inv\
    alidR\nmatchGroup\"\xaf\x02\n\x1bCMsgGCDataCenterPing_Update\x12B\n\x08p\
    ingdata\x18\x01\x20\x03(\x0b2&.CMsgGCDataCenterPing_Update.PingEntryR\
    \x08pingdata\x1a\x81\x01\n\tPingEntry\x12\x12\n\x04name\x18\x01\x20\x01(\
    \tR\x04name\x12\x12\n\x04ping\x18\x02\x20\x01(\rR\x04ping\x12L\n\x0bping\
    _status\x18\x03\x20\x01(\x0e2#.CMsgGCDataCenterPing_Update.Status:\x06No\
    rmalR\npingStatus\"H\n\x06Status\x12\x0b\n\x07Invalid\x10\0\x12\n\n\x06N\
    ormal\x10\x01\x12\x0f\n\x0bUnreachable\x10\x02\x12\x14\n\x10FallbackToDC\
    Ping\x10\x03\"8\n\x1aCMsgGC_KickPlayerFromLobby\x12\x1a\n\x08targetID\
    \x18\x01\x20\x01(\x04R\x08targetID\"\x82\x01\n\x13CMsgGCSurveyRequest\
    \x12P\n\rquestion_type\x18\x01\x20\x01(\x0e2\x13.SurveyQuestionType:\x16\
    QUESTION_MATCH_QUALITYR\x0cquestionType\x12\x19\n\x08match_id\x18\x02\
    \x20\x01(\x04R\x07matchId\"\x9f\x01\n\x14CMsgGCSurveyResponse\x12P\n\rqu\
    estion_type\x18\x01\x20\x01(\x0e2\x13.SurveyQuestionType:\x16QUESTION_MA\
    TCH_QUALITYR\x0cquestionType\x12\x19\n\x08match_id\x18\x02\x20\x01(\x04R\
    \x07matchId\x12\x1a\n\x08response\x18\x03\x20\x01(\x05R\x08response\"\
    \xea\x02\n\x0fCSOQuestMapNode\x12#\n\naccount_id\x18\x01\x20\x01(\rR\tac\
    countIdB\x04\x80\xa6\x1d\x01\x12\x20\n\x08defindex\x18\x03\x20\x01(\rR\
    \x08defindexB\x04\x80\xa6\x1d\x01\x12\x17\n\x07node_id\x18\x04\x20\x01(\
    \rR\x06nodeId\x12)\n\rstar_0_earned\x18\x06\x20\x01(\x08:\x05falseR\x0bs\
    tar0Earned\x12)\n\rstar_1_earned\x18\x07\x20\x01(\x08:\x05falseR\x0bstar\
    1Earned\x12)\n\rstar_2_earned\x18\x08\x20\x01(\x08:\x05falseR\x0bstar2Ea\
    rned\x12(\n\x0cloot_claimed\x18\t\x20\x01(\x08:\x05falseR\x0blootClaimed\
    \x12/\n\x12selected_quest_def\x18\n\x20\x01(\r:\x010R\x10selectedQuestDe\
    f\x12\x1b\n\tmap_cycle\x18\x0b\x20\x01(\rR\x08mapCycle\"\xab\x02\n\x08CS\
    OQuest\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\x12\x1f\n\
    \x08quest_id\x18\x02\x20\x01(\x04R\x07questIdB\x04\x80\xa6\x1d\x01\x12\
    \x1a\n\x08defindex\x18\x03\x20\x01(\rR\x08defindex\x12\x1d\n\x06active\
    \x18\x04\x20\x01(\x08:\x05falseR\x06active\x12\x19\n\x08points_0\x18\x05\
    \x20\x01(\rR\x07points0\x12\x19\n\x08points_1\x18\x06\x20\x01(\rR\x07poi\
    nts1\x12\x19\n\x08points_2\x18\x07\x20\x01(\rR\x07points2\x126\n\x18ques\
    t_map_node_source_id\x18\x08\x20\x01(\rR\x14questMapNodeSourceId\x12\x1b\
    \n\tmap_cycle\x18\t\x20\x01(\rR\x08mapCycle\"\xb0\x01\n\x19CSOQuestMapRe\
    wardPurchase\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\x12\
    \x20\n\x08defindex\x18\x02\x20\x01(\rR\x08defindexB\x04\x80\xa6\x1d\x01\
    \x12\x14\n\x05count\x18\x03\x20\x01(\rR\x05count\x12\x1b\n\tmap_cycle\
    \x18\x04\x20\x01(\rR\x08mapCycle\x12\x1f\n\x0bpurchase_id\x18\x05\x20\
    \x01(\rR\npurchaseId\"0\n\x13CMsgGCQuestIdentify\x12\x19\n\x08quest_id\
    \x18\x01\x20\x01(\x04R\x07questId\"<\n\x12CMsgGCQuestDevGive\x12&\n\x0fq\
    uest_def_index\x18\x01\x20\x01(\rR\rquestDefIndex\"<\n\x15CMsgGCQuestNod\
    eTurnIn\x12#\n\rnode_defindex\x18\x01\x20\x01(\rR\x0cnodeDefindex\"f\n\
    \x18CMsgGCQuestMapUnlockNode\x12#\n\rnode_defindex\x18\x01\x20\x01(\rR\
    \x0cnodeDefindex\x12%\n\x0equest_defindex\x18\x02\x20\x01(\rR\rquestDefi\
    ndex\"\x84\x01\n\x1dCMsgGCNewMatchForLobbyRequest\x12(\n\x10current_matc\
    h_id\x18\x01\x20\x01(\x04R\x0ecurrentMatchId\x12\x1e\n\x0bnext_map_id\
    \x18\x02\x20\x01(\rR\tnextMapId\x12\x19\n\x08lobby_id\x18\x03\x20\x01(\
    \x04R\x07lobbyId\":\n\x1eCMsgGCNewMatchForLobbyResponse\x12\x18\n\x07suc\
    cess\x18\x01\x20\x01(\x08R\x07success\"\x82\x02\n#CMsgGCChangeMatchPlaye\
    rTeamsRequest\x12\x19\n\x08match_id\x18\x01\x20\x01(\x04R\x07matchId\x12\
    \x19\n\x08lobby_id\x18\x02\x20\x01(\x04R\x07lobbyId\x12C\n\x06member\x18\
    \x03\x20\x03(\x0b2+.CMsgGCChangeMatchPlayerTeamsRequest.MemberR\x06membe\
    r\x1a`\n\x06Member\x12\x1b\n\tmember_id\x18\x01\x20\x01(\x04R\x08memberI\
    d\x129\n\x08new_team\x18\x02\x20\x01(\x0e2\x0b.TF_GC_TEAM:\x11TF_GC_TEAM\
    _NOTEAMR\x07newTeam\"@\n$CMsgGCChangeMatchPlayerTeamsResponse\x12\x18\n\
    \x07success\x18\x01\x20\x01(\x08R\x07success\"W\n\x19CMsgGCQuestComplete\
    _Debug\x12\x19\n\x08quest_id\x18\x01\x20\x01(\x04R\x07questId\x12\x1f\n\
    \x0bpoints_type\x18\x02\x20\x01(\rR\npointsType\"\x9c\x01\n\x14CMsgGCQue\
    stMap_Debug\x12'\n\x0freset_operation\x18\x01\x20\x01(\rR\x0eresetOperat\
    ion\x12\x1f\n\x0bgive_credit\x18\x02\x20\x01(\rR\ngiveCredit\x12:\n\x0bu\
    nlock_node\x18\x03\x20\x01(\x0b2\x19.CMsgGCQuestMapUnlockNodeR\nunlockNo\
    de\"N\n\x1cCMsgGCQuestMapPurchaseReward\x12.\n\x13store_item_defindex\
    \x18\x01\x20\x01(\rR\x11storeItemDefindex\"6\n\x13CMsgGCQuestResponse\
    \x12\x1f\n\x07success\x18\x01\x20\x01(\x08:\x05falseR\x07success\":\n\"C\
    MsgGCSetDisablePartyQuestProgress\x12\x14\n\x05state\x18\x01\x20\x01(\
    \x08R\x05state\"\xa6\x02\n\x17CMsgQuestProgressReport\x12\x19\n\x08quest\
    _id\x18\x01\x20\x01(\x04R\x07questId\x12\"\n\rstar_0_earned\x18\x02\x20\
    \x01(\x08R\x0bstar0Earned\x12\"\n\rstar_1_earned\x18\x03\x20\x01(\x08R\
    \x0bstar1Earned\x12\"\n\rstar_2_earned\x18\x04\x20\x01(\x08R\x0bstar2Ear\
    ned\x12!\n\x0citems_earned\x18\x05\x20\x03(\x04R\x0bitemsEarned\x122\n\
    \x15reward_credits_earned\x18\x06\x20\x01(\rR\x13rewardCreditsEarned\x12\
    -\n\x12contract_completed\x18\x07\x20\x01(\x08R\x11contractCompleted\"[\
    \n\x13CMsgConsumePaintkit\x12\x1b\n\tsource_id\x18\x01\x20\x01(\x06R\x08\
    sourceId\x12'\n\x0ftarget_defindex\x18\x02\x20\x01(\rR\x0etargetDefindex\
    \"{\n\x13CMsgPainkitDevGrant\x12+\n\x11paintkit_defindex\x18\x01\x20\x01\
    (\rR\x10paintkitDefindex\x12\x12\n\x04wear\x18\x02\x20\x01(\x02R\x04wear\
    \x12#\n\ritem_defindex\x18\x03\x20\x01(\rR\x0citemDefindex\"\xc6\x01\n\
    \x13GCQuestStrangeEvent\x12(\n\x10owner_account_id\x18\x01\x20\x01(\rR\
    \x0eownerAccountId\x12*\n\x11scorer_account_id\x18\x02\x20\x01(\rR\x0fsc\
    orerAccountId\x12\x19\n\x08quest_id\x18\x03\x20\x01(\x04R\x07questId\x12\
    (\n\x10strange_event_id\x18\x04\x20\x01(\rR\x0estrangeEventId\x12\x14\n\
    \x05score\x18\x05\x20\x01(\rR\x05score\"<\n\rCMsgSDRTicket\x12+\n\x11ser\
    ialized_ticket\x18\x01\x20\x01(\x0cR\x10serializedTicket*\x823\n\x08ETFG\
    CMsg\x12\x1a\n\x15k_EMsgGCReportWarKill\x10\x89'\x12\"\n\x1dk_EMsgGCKick\
    Player_DEPRECATED\x10\x9c'\x12'\n\"k_EMsgGCStartedTraining_DEPRECATED\
    \x10\x9d'\x12.\n)k_EMsgGCFreeTrial_ChooseMostHelpfulFriend\x10\x9e'\x12\
    \x1e\n\x19k_EMsgGCRequestTF2Friends\x10\x9f'\x12&\n!k_EMsgGCRequestTF2Fr\
    iendsResponse\x10\xa0'\x12&\n!k_EMsgGCReplay_SubmitContestEntry\x10\xa2'\
    \x12.\n)k_EMsgGCReplay_SubmitContestEntryResponse\x10\xa3'\x12\x1a\n\x15\
    k_EMsgGCSaxxy_Awarded\x10\xa5'\x12'\n\"k_EMsgGCFreeTrial_ThankedBySomeon\
    e\x10\xa4'\x12%\n\x20k_EMsgGCFreeTrial_ThankedSomeone\x10\xa6'\x12)\n$k_\
    EMsgGCFreeTrial_ConvertedToPremium\x10\xa7'\x128\n3k_EMsgGCMeetThePyroSi\
    lliness_BananaCraft_DEPRECATED\x10\xa8'\x126\n1k_EMsgGCMVMARG_HighFiveSu\
    ccessResponse_DEPRECATED\x10\xa9'\x12/\n*k_EMsgGCMVMARG_HighFiveOnClient\
    _DEPRECATED\x10\xaa'\x12\"\n\x1dk_EMsgGCCoaching_AddToCoaches\x10\xd0(\
    \x12*\n%k_EMsgGCCoaching_AddToCoachesResponse\x10\xd1(\x12'\n\"k_EMsgGCC\
    oaching_RemoveFromCoaches\x10\xd2(\x12/\n*k_EMsgGCCoaching_RemoveFromCoa\
    chesResponse\x10\xd3(\x12\x1f\n\x1ak_EMsgGCCoaching_FindCoach\x10\xd4(\
    \x12'\n\"k_EMsgGCCoaching_FindCoachResponse\x10\xd5(\x12\x1e\n\x19k_EMsg\
    GCCoaching_AskCoach\x10\xd6(\x12&\n!k_EMsgGCCoaching_AskCoachResponse\
    \x10\xd7(\x12#\n\x1ek_EMsgGCCoaching_CoachJoinGame\x10\xd8(\x12\"\n\x1dk\
    _EMsgGCCoaching_CoachJoining\x10\xd9(\x12!\n\x1ck_EMsgGCCoaching_CoachJo\
    ined\x10\xda(\x12&\n!k_EMsgGCCoaching_LikeCurrentCoach\x10\xdb(\x12(\n#k\
    _EMsgGCCoaching_RemoveCurrentCoach\x10\xdc(\x12'\n\"k_EMsgGCCoaching_Alr\
    eadyRatedCoach\x10\xdd(\x12\x1a\n\x15k_EMsgGC_Duel_Request\x10\xfc*\x12\
    \x1b\n\x16k_EMsgGC_Duel_Response\x10\xfd*\x12\x1a\n\x15k_EMsgGC_Duel_Res\
    ults\x10\xfe*\x12\x19\n\x14k_EMsgGC_Duel_Status\x10\xff*\x12/\n*k_EMsgGC\
    _Halloween_ReservedItem_DEPRECATED\x10\xe0+\x12,\n'k_EMsgGC_Halloween_Gr\
    antItem_DEPRECATED\x10\xe1+\x124\n/k_EMsgGC_Halloween_GrantItemResponse_\
    DEPRECATED\x10\xe4+\x126\n1k_EMsgGC_Halloween_Cheat_QueryResponse_DEPREC\
    ATED\x10\xe5+\x12.\n)k_EMsgGC_Halloween_ItemClaimed_DEPRECATED\x10\xe6+\
    \x12$\n\x1fk_EMsgGC_Halloween_ReservedItem\x10\xe7+\x12!\n\x1ck_EMsgGC_H\
    alloween_GrantItem\x10\xe8+\x12)\n$k_EMsgGC_Halloween_GrantItemResponse\
    \x10\xe9+\x128\n3k_EMsgGC_Halloween_Cheat_QueryResponse_DEPRECATED_2\x10\
    \xea+\x120\n+k_EMsgGC_Halloween_ItemClaimed_DEPRECATED_2\x10\xeb+\x12'\n\
    \"k_EMsgGC_Halloween_ServerBossEvent\x10\xec+\x12$\n\x1fk_EMsgGC_Hallowe\
    en_Merasmus2012\x10\xed+\x12/\n*k_EMsgGC_Halloween_UpdateMerasmusLootLev\
    el\x10\xee+\x12\"\n\x1dk_EMsgGC_GameServer_LevelInfo\x10\xc4,\x12&\n!k_E\
    MsgGC_GameServer_AuthChallenge\x10\xc5,\x12.\n)k_EMsgGC_GameServer_AuthC\
    hallengeResponse\x10\xc6,\x12'\n\"k_EMsgGC_GameServer_CreateIdentity\x10\
    \xc7,\x12/\n*k_EMsgGC_GameServer_CreateIdentityResponse\x10\xc8,\x12\x1d\
    \n\x18k_EMsgGC_GameServer_List\x10\xc9,\x12%\n\x20k_EMsgGC_GameServer_Li\
    stResponse\x10\xca,\x12#\n\x1ek_EMsgGC_GameServer_AuthResult\x10\xcb,\
    \x12&\n!k_EMsgGC_GameServer_ResetIdentity\x10\xcc,\x12.\n)k_EMsgGC_GameS\
    erver_ResetIdentityResponse\x10\xcd,\x12.\n)k_EMsgGC_Client_UseServerMod\
    ificationItem\x10\xce,\x127\n2k_EMsgGC_Client_UseServerModificationItem_\
    Response\x10\xcf,\x122\n-k_EMsgGC_GameServer_UseServerModificationItem\
    \x10\xd0,\x12;\n6k_EMsgGC_GameServer_UseServerModificationItem_Response\
    \x10\xd1,\x126\n1k_EMsgGC_GameServer_ServerModificationItemExpired\x10\
    \xd2,\x12.\n)k_EMsgGC_GameServer_ModificationItemState\x10\xd3,\x12\"\n\
    \x1dk_EMsgGC_GameServer_AckPolicy\x10\xd4,\x12*\n%k_EMsgGC_GameServer_Ac\
    kPolicyResponse\x10\xd5,\x12\x1d\n\x18k_EMsgGC_QP_ScoreServers\x10\xa8-\
    \x12%\n\x20k_EMsgGC_QP_ScoreServersResponse\x10\xa9-\x12\x1e\n\x19k_EMsg\
    GC_QP_PlayerJoining\x10\xaa-\x124\n/k_EMsgGC_PickupItemEligibility_Query\
    _DEPRECATED\x10\xf0.\x126\n1k_EMsgGC_PickupItemEligibility_Query_DEPRECA\
    TED_2\x10\xf1.\x124\n/k_EMsgGC_IncrementKillCountAttribute_DEPRECATED\
    \x10\xd4/\x123\n.k_EMsgGC_IncrementKillCountResponse_DEPRECATED\x10\xd5/\
    \x12\x1f\n\x1ak_EMsgGCAbandonCurrentGame\x10\xdb0\x12\x1d\n\x18k_EMsgFor\
    ceSOCacheResend\x10\xdd0\x12#\n\x1ek_EMsgGCRequestChatChannelList\x10\
    \xf40\x12+\n&k_EMsgGCRequestChatChannelListResponse\x10\xf50\x12\x14\n\
    \x0fk_EMsgGCReadyUp\x10\xfe0\x12'\n\"k_EMsgGCKickedFromMatchmakingQueue\
    \x10\xff0\x12\x1b\n\x16k_EMsgGCLeaverDetected\x10\x801\x12#\n\x1ek_EMsgG\
    CLeaverDetectedResponse\x10\x8f1\x12\x1c\n\x17k_EMsgGCExitMatchmaking\
    \x10\x911\x12\x20\n\x1bk_EMsgGCMatchmakingProgress\x10\x951\x12\x1b\n\
    \x16k_EMsgGCMvMVictoryInfo\x10\x961\x12(\n#k_EMsgGCGameServerMatchmaking\
    Status\x10\x971\x12\x17\n\x12k_EMsgGCMvMVictory\x10\x991\x12\x1c\n\x17k_\
    EMsgGCMvMVictoryReply\x10\x9a1\x12#\n\x1ek_EMsgGCGameServerKickingLobby\
    \x10\x9b1\x12+\n&k_EMsgGCLeaveGameAndPrepareToJoinParty\x10\x9c1\x12!\n\
    \x1ck_EMsgGC_UpdatePeriodicEvent\x10\x802\x12.\n)k_EMsgGC_DuckLeaderboar\
    d_IndividualUpdate\x10\x812\x122\n-k_EMsgGC_Client2GCEconPreviewDataBloc\
    kRequest\x10\x822\x123\n.k_EMsgGC_Client2GCEconPreviewDataBlockResponse\
    \x10\x832\x12)\n$k_EMsgGC_ClientVerificationChallenge\x10\xe42\x121\n,k_\
    EMsgGC_ClientVerificationChallengeResponse\x10\xe52\x12/\n*k_EMsgGC_Clie\
    ntVerificationVerboseResponse\x10\xe62\x12(\n#k_EMsgGC_ClientSetItemSlot\
    Attribute\x10\xe72\x12\"\n\x1dk_EMsgGC_War_IndividualUpdate\x10\xe92\x12\
    \x19\n\x14k_EMsgGC_War_JoinWar\x10\xea2\x12$\n\x1fk_EMsgGC_War_RequestGl\
    obalStats\x10\xeb2\x12%\n\x20k_EMsgGC_War_GlobalStatsResponse\x10\xec2\
    \x12*\n%k_EMsgGC_WorldItemPlacement_Attribute\x10\xee2\x12'\n\"k_EMsgGC_\
    WorldItemPlacement_Update\x10\xef2\x12\x1a\n\x15k_EMsgGC_Match_Result\
    \x10\xf02\x12\"\n\x1dk_EMsgGCVoteKickPlayerRequest\x10\xf12\x12*\n%k_EMs\
    gGCVoteKickPlayerRequestResponse\x10\xf22\x12)\n$k_EMsgGC_DailyCompetiti\
    veStatsRollup\x10\xf42\x122\n-k_EMsgGC_DailyCompetitiveStatsRollup_Respo\
    nse\x10\xf52\x12\"\n\x1dk_EMsgGC_WorldStatusBroadcast\x10\xf62\x12\x1a\n\
    \x15k_EMsgGC_ReportPlayer\x10\xf72\x12\"\n\x1dk_EMsgGC_Match_ResultRespo\
    nse\x10\xf82\x12+\n&k_EMsgGCGameServerKickingLobbyResponse\x10\xf92\x12\
    \x1c\n\x17k_EMsgGCPlayerLeftMatch\x10\xfa2\x12$\n\x1fk_EMsgGCPlayerLeftM\
    atchResponse\x10\xfb2\x12#\n\x1ek_EMsgGCRequestMatchMakerStats\x10\xfc2\
    \x12$\n\x1fk_EMsgGCMatchMakerStatsResponse\x10\xfd2\x12\x1d\n\x18k_EMsgG\
    CMatchHistoryLoad\x10\xfe2\x12\x1b\n\x16k_EMsgGC_AcknowledgeXP\x10\xff2\
    \x12\"\n\x1dk_EMsgGCDataCenterPing_Update\x10\x803\x12%\n\x20k_EMsgGC_No\
    tificationAcknowledge\x10\x813\x12*\n%k_EMsgGC_NotificationAcknowledgeRe\
    ply\x10\x823\x12!\n\x1ck_EMsgGC_KickPlayerFromLobby\x10\x833\x12#\n\x1ek\
    _EMsgGC_SurveyQuestionRequest\x10\x863\x12$\n\x1fk_EMsgGC_SurveyQuestion\
    Response\x10\x873\x12\x1a\n\x15k_EMsgGC_TFClientInit\x10\x883\x12%\n\x20\
    k_EMsgGC_NewMatchForLobbyRequest\x10\x893\x12&\n!k_EMsgGC_NewMatchForLob\
    byResponse\x10\x8a3\x12+\n&k_EMsgGC_ChangeMatchPlayerTeamsRequest\x10\
    \x8b3\x12,\n'k_EMsgGC_ChangeMatchPlayerTeamsResponse\x10\x8c3\x12\x1b\n\
    \x16k_EMsgGC_QuestIdentify\x10\x8d3\x12\x1a\n\x15k_EMsgGC_QuestDevGive\
    \x10\x8e3\x12\x20\n\x1bk_EMsgGCQuestComplete_Debug\x10\x903\x12\x1b\n\
    \x16k_EMsgGC_QuestMapDebug\x10\x913\x12\x20\n\x1bk_EMsgGC_QuestMapUnlock\
    Node\x10\x933\x12$\n\x1fk_EMsgGC_QuestMapPurchaseReward\x10\x953\x12*\n%\
    k_EMsgGC_SetDisablePartyQuestProgress\x10\x963\x12\x20\n\x1bk_EMsgGCQues\
    tProgressReport\x10\x993\x12\x1d\n\x18k_EMsgGCParty_SetOptions\x10\x9a3\
    \x12%\n\x20k_EMsgGCParty_SetOptionsResponse\x10\x9b3\x12\x20\n\x1bk_EMsg\
    GCParty_QueueForMatch\x10\x9c3\x12(\n#k_EMsgGCParty_QueueForMatchRespons\
    e\x10\x9d3\x12\"\n\x1dk_EMsgGCParty_RemoveFromQueue\x10\x9e3\x12*\n%k_EM\
    sgGCParty_RemoveFromQueueResponse\x10\x9f3\x12\x1f\n\x1ak_EMsgGCParty_In\
    vitePlayer\x10\xa03\x12$\n\x1fk_EMsgGCParty_RequestJoinPlayer\x10\xa13\
    \x12\x1b\n\x16k_EMsgGCParty_SendChat\x10\xa23\x12\x1a\n\x15k_EMsgGCParty\
    _ChatMsg\x10\xa33\x12\x1c\n\x17k_EMsgGCQuestNodeTurnIn\x10\xa43\x12\x1c\
    \n\x17k_EMsgGCConsumePaintKit\x10\xa53\x12\x1e\n\x19k_EMsgGC_Painkit_Dev\
    Grant\x10\xa63\x12\"\n\x1dk_EMsgGCParty_QueueForStandby\x10\xa73\x12*\n%\
    k_EMsgGCParty_QueueForStandbyResponse\x10\xa83\x12)\n$k_EMsgGCParty_Remo\
    veFromStandbyQueue\x10\xa93\x121\n,k_EMsgGCParty_RemoveFromStandbyQueueR\
    esponse\x10\xaa3\x12%\n\x20k_EMsgGCParty_ClearPendingPlayer\x10\xab3\x12\
    -\n(k_EMsgGCParty_ClearPendingPlayerResponse\x10\xac3\x12)\n$k_EMsgGCPar\
    ty_ClearOtherPartyRequest\x10\xad3\x121\n,k_EMsgGCParty_ClearOtherPartyR\
    equestResponse\x10\xae3\x12\"\n\x1dk_EMsgGCParty_PromoteToLeader\x10\xaf\
    3\x12\x1d\n\x18k_EMsgGCParty_KickMember\x10\xb03\x12\x1e\n\x19k_EMsgGCQu\
    estStrangeEvent\x10\xb13\x12\x1f\n\x1ak_EMsgGC_AcceptLobbyInvite\x10\xb2\
    3\x12$\n\x1fk_EMsgGC_AcceptLobbyInviteReply\x10\xb33\x12\x17\n\x12k_EMsg\
    GC_SDRTicket\x10\xb43\x12\"\n\x1dk_EMsgGC_ProcessMatchVoteKick\x10\xb53\
    \x12*\n%k_EMsgGC_ProcessMatchVoteKickResponse\x10\xb63\x12\x1d\n\x18k_EM\
    sgGCDev_GrantWarKill\x10\x91N*H\n\x1bEServerModificationItemType\x12)\n%\
    kGameServerModificationItem_Halloween\x10\x01*\x9b\x02\n\x13ETFSyncedMMM\
    enuStep\x12*\n\x1dk_eTFSyncedMMMenuStep_Invalid\x10\xff\xff\xff\xff\xff\
    \xff\xff\xff\xff\x01\x12\x1e\n\x1ak_eTFSyncedMMMenuStep_None\x10\0\x12*\
    \n&k_eTFSyncedMMMenuStep_Configuring_Mode\x10\x01\x12,\n(k_eTFSyncedMMMe\
    nuStep_MvM_Selecting_Mode\x10\x02\x12,\n(k_eTFSyncedMMMenuStep_MvM_Selec\
    ting_Tour\x10\x03\x120\n,k_eTFSyncedMMMenuStep_MvM_Selecting_Missions\
    \x10\x04*\x91\x06\n\rETFMatchGroup\x12$\n\x17k_eTFMatchGroup_Invalid\x10\
    \xff\xff\xff\xff\xff\xff\xff\xff\xff\x01\x12\x20\n\x1ck_eTFMatchGroup_Mv\
    M_Practice\x10\0\x12\x1e\n\x1ak_eTFMatchGroup_MvM_MannUp\x10\x01\x12\x19\
    \n\x15k_eTFMatchGroup_First\x10\0\x12\x1f\n\x1bk_eTFMatchGroup_MvM_Defau\
    lt\x10\0\x12\x1d\n\x19k_eTFMatchGroup_MvM_First\x10\0\x12\x1c\n\x18k_eTF\
    MatchGroup_MvM_Last\x10\x01\x12\x1e\n\x1ak_eTFMatchGroup_Ladder_6v6\x10\
    \x02\x12\x1e\n\x1ak_eTFMatchGroup_Ladder_9v9\x10\x03\x12\x20\n\x1ck_eTFM\
    atchGroup_Ladder_12v12\x10\x04\x12\"\n\x1ek_eTFMatchGroup_Ladder_Default\
    \x10\x02\x12\x20\n\x1ck_eTFMatchGroup_Ladder_First\x10\x02\x12\x1f\n\x1b\
    k_eTFMatchGroup_Ladder_Last\x10\x04\x12\x1e\n\x1ak_eTFMatchGroup_Casual_\
    6v6\x10\x05\x12\x1e\n\x1ak_eTFMatchGroup_Casual_9v9\x10\x06\x12\x20\n\
    \x1ck_eTFMatchGroup_Casual_12v12\x10\x07\x12\"\n\x1ek_eTFMatchGroup_Casu\
    al_Default\x10\x07\x12\x20\n\x1ck_eTFMatchGroup_Casual_First\x10\x05\x12\
    \x1f\n\x1bk_eTFMatchGroup_Casual_Last\x10\x07\x12%\n!k_eTFMatchGroup_Eve\
    nt_Placeholder\x10\x08\x12!\n\x1dk_eTFMatchGroup_Event_Default\x10\x08\
    \x12\x1f\n\x1bk_eTFMatchGroup_Event_First\x10\x08\x12\x1e\n\x1ak_eTFMatc\
    hGroup_Event_Last\x10\x08\x1a\x02\x10\x01*\xc1\x02\n\x10ETFPartyChatType\
    \x12\x1e\n\x1ak_eTFPartyChatType_Invalid\x10\0\x12!\n\x1dk_eTFPartyChatT\
    ype_MemberChat\x10\x01\x12,\n'k_eTFPartyChatType_Synthetic_MemberJoin\
    \x10\xe8\x07\x12-\n(k_eTFPartyChatType_Synthetic_MemberLeave\x10\xe9\x07\
    \x12,\n'k_eTFPartyChatType_Synthetic_SendFailed\x10\xea\x07\x12.\n)k_eTF\
    PartyChatType_Synthetic_MemberOnline\x10\xeb\x07\x12/\n*k_eTFPartyChatTy\
    pe_Synthetic_MemberOffline\x10\xec\x07*\x81\x02\n\x0fTF_GC_GameState\x12\
    \x1e\n\x1aTF_GC_GAMESTATE_STATE_INIT\x10\0\x12,\n(TF_GC_GAMESTATE_WAIT_F\
    OR_PLAYERS_TO_LOAD\x10\x01\x12!\n\x1dTF_GC_GAMESTATE_STRATEGY_TIME\x10\
    \x03\x12$\n\x20TF_GC_GAMESTATE_GAME_IN_PROGRESS\x10\x05\x12\x1d\n\x19TF_\
    GC_GAMESTATE_POST_GAME\x10\x06\x12\x1e\n\x1aTF_GC_GAMESTATE_DISCONNECT\
    \x10\x07\x12\x18\n\x14TF_GC_GAMESTATE_LAST\x10\x08*\xa8\x01\n\nTF_GC_TEA\
    M\x12\x18\n\x14TF_GC_TEAM_DEFENDERS\x10\0\x12\x17\n\x13TF_GC_TEAM_INVADE\
    RS\x10\x01\x12\x1a\n\x16TF_GC_TEAM_BROADCASTER\x10\x02\x12\x18\n\x14TF_G\
    C_TEAM_SPECTATOR\x10\x03\x12\x1a\n\x16TF_GC_TEAM_PLAYER_POOL\x10\x04\x12\
    \x15\n\x11TF_GC_TEAM_NOTEAM\x10\x05*\xfa\x01\n\x12TFMatchLeaveReason\x12\
    \"\n\x1eTFMatchLeaveReason_UNSPECIFIED\x10\0\x12\x20\n\x1cTFMatchLeaveRe\
    ason_VOTE_KICK\x10\x01\x12\x1b\n\x17TFMatchLeaveReason_IDLE\x10\x02\x12!\
    \n\x1dTFMatchLeaveReason_ADMIN_KICK\x10\x03\x12\x1b\n\x17TFMatchLeaveRea\
    son_AWOL\x10\x04\x12\x1e\n\x1aTFMatchLeaveReason_NO_SHOW\x10\x05\x12!\n\
    \x1dTFMatchLeaveReason_GC_REMOVED\x10\x06*\x87\x01\n\x10TFVoteKickReason\
    \x12\x1a\n\x16TFVoteKickReason_Other\x10\0\x12\x1d\n\x19TFVoteKickReason\
    _Cheating\x10\x01\x12\x19\n\x15TFVoteKickReason_Idle\x10\x02\x12\x1d\n\
    \x19TFVoteKickReason_Scamming\x10\x03*\xf3\x01\n\x16ServerMatchmakingSta\
    te\x12\"\n\x1eServerMatchmakingState_INVALID\x10\0\x12,\n(ServerMatchmak\
    ingState_NOT_PARTICIPATING\x10\x01\x12\x20\n\x1cServerMatchmakingState_E\
    MPTY\x10\x02\x12<\n8ServerMatchmakingState_ACTIVE_MATCH_REQUESTING_LATE_\
    JOIN\x10\x03\x12'\n#ServerMatchmakingState_ACTIVE_MATCH\x10\x04*\x9c\x01\
    \n\x12SurveyQuestionType\x12\x1a\n\x16QUESTION_MATCH_QUALITY\x10\0\x12\
    \x18\n\x14QUESTION_MAP_QUALITY\x10\x01\x12\x19\n\x15QUESTION_COMP_INQUIR\
    Y\x10\x02\x12\x1b\n\x17QUESTION_CASUAL_INQUIRY\x10\x03\x12\x18\n\x14QUES\
    TION_RANDOM_CRIT\x10\x04B\x05H\x01\x80\x01\0J\xe0\xb6\x04\n\x07\x12\x05\
    \0\0\xd7\x0c\x01\n\t\n\x02\x03\0\x12\x03\0\x07\x1c\n\t\n\x02\x03\x01\x12\
    \x03\x01\x07\x1e\n\x08\n\x01\x08\x12\x03\x03\0\x1c\n\t\n\x02\x08\t\x12\
    \x03\x03\0\x1c\n\x08\n\x01\x08\x12\x03\x04\0#\n\t\n\x02\x08\x10\x12\x03\
    \x04\0#\n\x0b\n\x02\x05\0\x12\x05\x06\0\xac\x01\x01\n\n\n\x03\x05\0\x01\
    \x12\x03\x06\x05\r\n\x0b\n\x04\x05\0\x02\0\x12\x03\x07\x08%\n\x0c\n\x05\
    \x05\0\x02\0\x01\x12\x03\x07\x08\x1d\n\x0c\n\x05\x05\0\x02\0\x02\x12\x03\
    \x07\x20$\n\x0b\n\x04\x05\0\x02\x01\x12\x03\x08\x08-\n\x0c\n\x05\x05\0\
    \x02\x01\x01\x12\x03\x08\x08%\n\x0c\n\x05\x05\0\x02\x01\x02\x12\x03\x08(\
    ,\n\x0b\n\x04\x05\0\x02\x02\x12\x03\t\x082\n\x0c\n\x05\x05\0\x02\x02\x01\
    \x12\x03\t\x08*\n\x0c\n\x05\x05\0\x02\x02\x02\x12\x03\t-1\n\x0b\n\x04\
    \x05\0\x02\x03\x12\x03\n\x089\n\x0c\n\x05\x05\0\x02\x03\x01\x12\x03\n\
    \x081\n\x0c\n\x05\x05\0\x02\x03\x02\x12\x03\n48\n\x0b\n\x04\x05\0\x02\
    \x04\x12\x03\x0b\x08)\n\x0c\n\x05\x05\0\x02\x04\x01\x12\x03\x0b\x08!\n\
    \x0c\n\x05\x05\0\x02\x04\x02\x12\x03\x0b$(\n\x0b\n\x04\x05\0\x02\x05\x12\
    \x03\x0c\x081\n\x0c\n\x05\x05\0\x02\x05\x01\x12\x03\x0c\x08)\n\x0c\n\x05\
    \x05\0\x02\x05\x02\x12\x03\x0c,0\n\x0b\n\x04\x05\0\x02\x06\x12\x03\r\x08\
    1\n\x0c\n\x05\x05\0\x02\x06\x01\x12\x03\r\x08)\n\x0c\n\x05\x05\0\x02\x06\
    \x02\x12\x03\r,0\n\x0b\n\x04\x05\0\x02\x07\x12\x03\x0e\x089\n\x0c\n\x05\
    \x05\0\x02\x07\x01\x12\x03\x0e\x081\n\x0c\n\x05\x05\0\x02\x07\x02\x12\
    \x03\x0e48\n\x0b\n\x04\x05\0\x02\x08\x12\x03\x0f\x08%\n\x0c\n\x05\x05\0\
    \x02\x08\x01\x12\x03\x0f\x08\x1d\n\x0c\n\x05\x05\0\x02\x08\x02\x12\x03\
    \x0f\x20$\n\x0b\n\x04\x05\0\x02\t\x12\x03\x10\x082\n\x0c\n\x05\x05\0\x02\
    \t\x01\x12\x03\x10\x08*\n\x0c\n\x05\x05\0\x02\t\x02\x12\x03\x10-1\n\x0b\
    \n\x04\x05\0\x02\n\x12\x03\x11\x080\n\x0c\n\x05\x05\0\x02\n\x01\x12\x03\
    \x11\x08(\n\x0c\n\x05\x05\0\x02\n\x02\x12\x03\x11+/\n\x0b\n\x04\x05\0\
    \x02\x0b\x12\x03\x12\x084\n\x0c\n\x05\x05\0\x02\x0b\x01\x12\x03\x12\x08,\
    \n\x0c\n\x05\x05\0\x02\x0b\x02\x12\x03\x12/3\n\x0b\n\x04\x05\0\x02\x0c\
    \x12\x03\x13\x08C\n\x0c\n\x05\x05\0\x02\x0c\x01\x12\x03\x13\x08;\n\x0c\n\
    \x05\x05\0\x02\x0c\x02\x12\x03\x13>B\n\x0b\n\x04\x05\0\x02\r\x12\x03\x14\
    \x08A\n\x0c\n\x05\x05\0\x02\r\x01\x12\x03\x14\x089\n\x0c\n\x05\x05\0\x02\
    \r\x02\x12\x03\x14<@\n\x0b\n\x04\x05\0\x02\x0e\x12\x03\x15\x08:\n\x0c\n\
    \x05\x05\0\x02\x0e\x01\x12\x03\x15\x082\n\x0c\n\x05\x05\0\x02\x0e\x02\
    \x12\x03\x1559\n\x0b\n\x04\x05\0\x02\x0f\x12\x03\x16\x08-\n\x0c\n\x05\
    \x05\0\x02\x0f\x01\x12\x03\x16\x08%\n\x0c\n\x05\x05\0\x02\x0f\x02\x12\
    \x03\x16(,\n\x0b\n\x04\x05\0\x02\x10\x12\x03\x17\x085\n\x0c\n\x05\x05\0\
    \x02\x10\x01\x12\x03\x17\x08-\n\x0c\n\x05\x05\0\x02\x10\x02\x12\x03\x170\
    4\n\x0b\n\x04\x05\0\x02\x11\x12\x03\x18\x082\n\x0c\n\x05\x05\0\x02\x11\
    \x01\x12\x03\x18\x08*\n\x0c\n\x05\x05\0\x02\x11\x02\x12\x03\x18-1\n\x0b\
    \n\x04\x05\0\x02\x12\x12\x03\x19\x08:\n\x0c\n\x05\x05\0\x02\x12\x01\x12\
    \x03\x19\x082\n\x0c\n\x05\x05\0\x02\x12\x02\x12\x03\x1959\n\x0b\n\x04\
    \x05\0\x02\x13\x12\x03\x1a\x08*\n\x0c\n\x05\x05\0\x02\x13\x01\x12\x03\
    \x1a\x08\"\n\x0c\n\x05\x05\0\x02\x13\x02\x12\x03\x1a%)\n\x0b\n\x04\x05\0\
    \x02\x14\x12\x03\x1b\x082\n\x0c\n\x05\x05\0\x02\x14\x01\x12\x03\x1b\x08*\
    \n\x0c\n\x05\x05\0\x02\x14\x02\x12\x03\x1b-1\n\x0b\n\x04\x05\0\x02\x15\
    \x12\x03\x1c\x08)\n\x0c\n\x05\x05\0\x02\x15\x01\x12\x03\x1c\x08!\n\x0c\n\
    \x05\x05\0\x02\x15\x02\x12\x03\x1c$(\n\x0b\n\x04\x05\0\x02\x16\x12\x03\
    \x1d\x081\n\x0c\n\x05\x05\0\x02\x16\x01\x12\x03\x1d\x08)\n\x0c\n\x05\x05\
    \0\x02\x16\x02\x12\x03\x1d,0\n\x0b\n\x04\x05\0\x02\x17\x12\x03\x1e\x08.\
    \n\x0c\n\x05\x05\0\x02\x17\x01\x12\x03\x1e\x08&\n\x0c\n\x05\x05\0\x02\
    \x17\x02\x12\x03\x1e)-\n\x0b\n\x04\x05\0\x02\x18\x12\x03\x1f\x08-\n\x0c\
    \n\x05\x05\0\x02\x18\x01\x12\x03\x1f\x08%\n\x0c\n\x05\x05\0\x02\x18\x02\
    \x12\x03\x1f(,\n\x0b\n\x04\x05\0\x02\x19\x12\x03\x20\x08,\n\x0c\n\x05\
    \x05\0\x02\x19\x01\x12\x03\x20\x08$\n\x0c\n\x05\x05\0\x02\x19\x02\x12\
    \x03\x20'+\n\x0b\n\x04\x05\0\x02\x1a\x12\x03!\x081\n\x0c\n\x05\x05\0\x02\
    \x1a\x01\x12\x03!\x08)\n\x0c\n\x05\x05\0\x02\x1a\x02\x12\x03!,0\n\x0b\n\
    \x04\x05\0\x02\x1b\x12\x03\"\x083\n\x0c\n\x05\x05\0\x02\x1b\x01\x12\x03\
    \"\x08+\n\x0c\n\x05\x05\0\x02\x1b\x02\x12\x03\".2\n\x0b\n\x04\x05\0\x02\
    \x1c\x12\x03#\x082\n\x0c\n\x05\x05\0\x02\x1c\x01\x12\x03#\x08*\n\x0c\n\
    \x05\x05\0\x02\x1c\x02\x12\x03#-1\n\x0b\n\x04\x05\0\x02\x1d\x12\x03$\x08\
    %\n\x0c\n\x05\x05\0\x02\x1d\x01\x12\x03$\x08\x1d\n\x0c\n\x05\x05\0\x02\
    \x1d\x02\x12\x03$\x20$\n\x0b\n\x04\x05\0\x02\x1e\x12\x03%\x08&\n\x0c\n\
    \x05\x05\0\x02\x1e\x01\x12\x03%\x08\x1e\n\x0c\n\x05\x05\0\x02\x1e\x02\
    \x12\x03%!%\n\x0b\n\x04\x05\0\x02\x1f\x12\x03&\x08%\n\x0c\n\x05\x05\0\
    \x02\x1f\x01\x12\x03&\x08\x1d\n\x0c\n\x05\x05\0\x02\x1f\x02\x12\x03&\x20\
    $\n\x0b\n\x04\x05\0\x02\x20\x12\x03'\x08$\n\x0c\n\x05\x05\0\x02\x20\x01\
    \x12\x03'\x08\x1c\n\x0c\n\x05\x05\0\x02\x20\x02\x12\x03'\x1f#\n\x0b\n\
    \x04\x05\0\x02!\x12\x03(\x08:\n\x0c\n\x05\x05\0\x02!\x01\x12\x03(\x082\n\
    \x0c\n\x05\x05\0\x02!\x02\x12\x03(59\n\x0b\n\x04\x05\0\x02\"\x12\x03)\
    \x087\n\x0c\n\x05\x05\0\x02\"\x01\x12\x03)\x08/\n\x0c\n\x05\x05\0\x02\"\
    \x02\x12\x03)26\n\x0b\n\x04\x05\0\x02#\x12\x03*\x08?\n\x0c\n\x05\x05\0\
    \x02#\x01\x12\x03*\x087\n\x0c\n\x05\x05\0\x02#\x02\x12\x03*:>\n\x0b\n\
    \x04\x05\0\x02$\x12\x03+\x08A\n\x0c\n\x05\x05\0\x02$\x01\x12\x03+\x089\n\
    \x0c\n\x05\x05\0\x02$\x02\x12\x03+<@\n\x0b\n\x04\x05\0\x02%\x12\x03,\x08\
    9\n\x0c\n\x05\x05\0\x02%\x01\x12\x03,\x081\n\x0c\n\x05\x05\0\x02%\x02\
    \x12\x03,48\n\x0b\n\x04\x05\0\x02&\x12\x03-\x08/\n\x0c\n\x05\x05\0\x02&\
    \x01\x12\x03-\x08'\n\x0c\n\x05\x05\0\x02&\x02\x12\x03-*.\n\x0b\n\x04\x05\
    \0\x02'\x12\x03.\x08,\n\x0c\n\x05\x05\0\x02'\x01\x12\x03.\x08$\n\x0c\n\
    \x05\x05\0\x02'\x02\x12\x03.'+\n\x0b\n\x04\x05\0\x02(\x12\x03/\x084\n\
    \x0c\n\x05\x05\0\x02(\x01\x12\x03/\x08,\n\x0c\n\x05\x05\0\x02(\x02\x12\
    \x03//3\n\x0b\n\x04\x05\0\x02)\x12\x030\x08C\n\x0c\n\x05\x05\0\x02)\x01\
    \x12\x030\x08;\n\x0c\n\x05\x05\0\x02)\x02\x12\x030>B\n\x0b\n\x04\x05\0\
    \x02*\x12\x031\x08;\n\x0c\n\x05\x05\0\x02*\x01\x12\x031\x083\n\x0c\n\x05\
    \x05\0\x02*\x02\x12\x0316:\n\x0b\n\x04\x05\0\x02+\x12\x032\x082\n\x0c\n\
    \x05\x05\0\x02+\x01\x12\x032\x08*\n\x0c\n\x05\x05\0\x02+\x02\x12\x032-1\
    \n\x0b\n\x04\x05\0\x02,\x12\x033\x08/\n\x0c\n\x05\x05\0\x02,\x01\x12\x03\
    3\x08'\n\x0c\n\x05\x05\0\x02,\x02\x12\x033*.\n\x0b\n\x04\x05\0\x02-\x12\
    \x034\x08:\n\x0c\n\x05\x05\0\x02-\x01\x12\x034\x082\n\x0c\n\x05\x05\0\
    \x02-\x02\x12\x03459\n\x0b\n\x04\x05\0\x02.\x12\x035\x08-\n\x0c\n\x05\
    \x05\0\x02.\x01\x12\x035\x08%\n\x0c\n\x05\x05\0\x02.\x02\x12\x035(,\n\
    \x0b\n\x04\x05\0\x02/\x12\x036\x081\n\x0c\n\x05\x05\0\x02/\x01\x12\x036\
    \x08)\n\x0c\n\x05\x05\0\x02/\x02\x12\x036,0\n\x0b\n\x04\x05\0\x020\x12\
    \x037\x089\n\x0c\n\x05\x05\0\x020\x01\x12\x037\x081\n\x0c\n\x05\x05\0\
    \x020\x02\x12\x03748\n\x0b\n\x04\x05\0\x021\x12\x038\x082\n\x0c\n\x05\
    \x05\0\x021\x01\x12\x038\x08*\n\x0c\n\x05\x05\0\x021\x02\x12\x038-1\n\
    \x0b\n\x04\x05\0\x022\x12\x039\x08:\n\x0c\n\x05\x05\0\x022\x01\x12\x039\
    \x082\n\x0c\n\x05\x05\0\x022\x02\x12\x03959\n\x0b\n\x04\x05\0\x023\x12\
    \x03:\x08(\n\x0c\n\x05\x05\0\x023\x01\x12\x03:\x08\x20\n\x0c\n\x05\x05\0\
    \x023\x02\x12\x03:#'\n\x0b\n\x04\x05\0\x024\x12\x03;\x080\n\x0c\n\x05\
    \x05\0\x024\x01\x12\x03;\x08(\n\x0c\n\x05\x05\0\x024\x02\x12\x03;+/\n\
    \x0b\n\x04\x05\0\x025\x12\x03<\x08.\n\x0c\n\x05\x05\0\x025\x01\x12\x03<\
    \x08&\n\x0c\n\x05\x05\0\x025\x02\x12\x03<)-\n\x0b\n\x04\x05\0\x026\x12\
    \x03=\x081\n\x0c\n\x05\x05\0\x026\x01\x12\x03=\x08)\n\x0c\n\x05\x05\0\
    \x026\x02\x12\x03=,0\n\x0b\n\x04\x05\0\x027\x12\x03>\x089\n\x0c\n\x05\
    \x05\0\x027\x01\x12\x03>\x081\n\x0c\n\x05\x05\0\x027\x02\x12\x03>48\n\
    \x0b\n\x04\x05\0\x028\x12\x03?\x089\n\x0c\n\x05\x05\0\x028\x01\x12\x03?\
    \x081\n\x0c\n\x05\x05\0\x028\x02\x12\x03?48\n\x0b\n\x04\x05\0\x029\x12\
    \x03@\x08B\n\x0c\n\x05\x05\0\x029\x01\x12\x03@\x08:\n\x0c\n\x05\x05\0\
    \x029\x02\x12\x03@=A\n\x0b\n\x04\x05\0\x02:\x12\x03A\x08=\n\x0c\n\x05\
    \x05\0\x02:\x01\x12\x03A\x085\n\x0c\n\x05\x05\0\x02:\x02\x12\x03A8<\n\
    \x0b\n\x04\x05\0\x02;\x12\x03B\x08F\n\x0c\n\x05\x05\0\x02;\x01\x12\x03B\
    \x08>\n\x0c\n\x05\x05\0\x02;\x02\x12\x03BAE\n\x0b\n\x04\x05\0\x02<\x12\
    \x03C\x08A\n\x0c\n\x05\x05\0\x02<\x01\x12\x03C\x089\n\x0c\n\x05\x05\0\
    \x02<\x02\x12\x03C<@\n\x0b\n\x04\x05\0\x02=\x12\x03D\x089\n\x0c\n\x05\
    \x05\0\x02=\x01\x12\x03D\x081\n\x0c\n\x05\x05\0\x02=\x02\x12\x03D48\n\
    \x0b\n\x04\x05\0\x02>\x12\x03E\x08-\n\x0c\n\x05\x05\0\x02>\x01\x12\x03E\
    \x08%\n\x0c\n\x05\x05\0\x02>\x02\x12\x03E(,\n\x0b\n\x04\x05\0\x02?\x12\
    \x03F\x085\n\x0c\n\x05\x05\0\x02?\x01\x12\x03F\x08-\n\x0c\n\x05\x05\0\
    \x02?\x02\x12\x03F04\n\x0b\n\x04\x05\0\x02@\x12\x03G\x08(\n\x0c\n\x05\
    \x05\0\x02@\x01\x12\x03G\x08\x20\n\x0c\n\x05\x05\0\x02@\x02\x12\x03G#'\n\
    \x0b\n\x04\x05\0\x02A\x12\x03H\x080\n\x0c\n\x05\x05\0\x02A\x01\x12\x03H\
    \x08(\n\x0c\n\x05\x05\0\x02A\x02\x12\x03H+/\n\x0b\n\x04\x05\0\x02B\x12\
    \x03I\x08)\n\x0c\n\x05\x05\0\x02B\x01\x12\x03I\x08!\n\x0c\n\x05\x05\0\
    \x02B\x02\x12\x03I$(\n\x0b\n\x04\x05\0\x02C\x12\x03J\x08?\n\x0c\n\x05\
    \x05\0\x02C\x01\x12\x03J\x087\n\x0c\n\x05\x05\0\x02C\x02\x12\x03J:>\n\
    \x0b\n\x04\x05\0\x02D\x12\x03K\x08A\n\x0c\n\x05\x05\0\x02D\x01\x12\x03K\
    \x089\n\x0c\n\x05\x05\0\x02D\x02\x12\x03K<@\n\x0b\n\x04\x05\0\x02E\x12\
    \x03L\x08?\n\x0c\n\x05\x05\0\x02E\x01\x12\x03L\x087\n\x0c\n\x05\x05\0\
    \x02E\x02\x12\x03L:>\n\x0b\n\x04\x05\0\x02F\x12\x03M\x08>\n\x0c\n\x05\
    \x05\0\x02F\x01\x12\x03M\x086\n\x0c\n\x05\x05\0\x02F\x02\x12\x03M9=\n\
    \x0b\n\x04\x05\0\x02G\x12\x03N\x08*\n\x0c\n\x05\x05\0\x02G\x01\x12\x03N\
    \x08\"\n\x0c\n\x05\x05\0\x02G\x02\x12\x03N%)\n\x0b\n\x04\x05\0\x02H\x12\
    \x03O\x08(\n\x0c\n\x05\x05\0\x02H\x01\x12\x03O\x08\x20\n\x0c\n\x05\x05\0\
    \x02H\x02\x12\x03O#'\n\x0b\n\x04\x05\0\x02I\x12\x03P\x08.\n\x0c\n\x05\
    \x05\0\x02I\x01\x12\x03P\x08&\n\x0c\n\x05\x05\0\x02I\x02\x12\x03P)-\n\
    \x0b\n\x04\x05\0\x02J\x12\x03Q\x086\n\x0c\n\x05\x05\0\x02J\x01\x12\x03Q\
    \x08.\n\x0c\n\x05\x05\0\x02J\x02\x12\x03Q15\n\x0b\n\x04\x05\0\x02K\x12\
    \x03R\x08\x1f\n\x0c\n\x05\x05\0\x02K\x01\x12\x03R\x08\x17\n\x0c\n\x05\
    \x05\0\x02K\x02\x12\x03R\x1a\x1e\n\x0b\n\x04\x05\0\x02L\x12\x03S\x082\n\
    \x0c\n\x05\x05\0\x02L\x01\x12\x03S\x08*\n\x0c\n\x05\x05\0\x02L\x02\x12\
    \x03S-1\n\x0b\n\x04\x05\0\x02M\x12\x03T\x08&\n\x0c\n\x05\x05\0\x02M\x01\
    \x12\x03T\x08\x1e\n\x0c\n\x05\x05\0\x02M\x02\x12\x03T!%\n\x0b\n\x04\x05\
    \0\x02N\x12\x03U\x08.\n\x0c\n\x05\x05\0\x02N\x01\x12\x03U\x08&\n\x0c\n\
    \x05\x05\0\x02N\x02\x12\x03U)-\n\x0b\n\x04\x05\0\x02O\x12\x03V\x08'\n\
    \x0c\n\x05\x05\0\x02O\x01\x12\x03V\x08\x1f\n\x0c\n\x05\x05\0\x02O\x02\
    \x12\x03V\"&\n\x0b\n\x04\x05\0\x02P\x12\x03W\x08+\n\x0c\n\x05\x05\0\x02P\
    \x01\x12\x03W\x08#\n\x0c\n\x05\x05\0\x02P\x02\x12\x03W&*\n\x0b\n\x04\x05\
    \0\x02Q\x12\x03X\x08&\n\x0c\n\x05\x05\0\x02Q\x01\x12\x03X\x08\x1e\n\x0c\
    \n\x05\x05\0\x02Q\x02\x12\x03X!%\n\x0b\n\x04\x05\0\x02R\x12\x03Y\x083\n\
    \x0c\n\x05\x05\0\x02R\x01\x12\x03Y\x08+\n\x0c\n\x05\x05\0\x02R\x02\x12\
    \x03Y.2\n\x0b\n\x04\x05\0\x02S\x12\x03Z\x08\"\n\x0c\n\x05\x05\0\x02S\x01\
    \x12\x03Z\x08\x1a\n\x0c\n\x05\x05\0\x02S\x02\x12\x03Z\x1d!\n\x0b\n\x04\
    \x05\0\x02T\x12\x03[\x08'\n\x0c\n\x05\x05\0\x02T\x01\x12\x03[\x08\x1f\n\
    \x0c\n\x05\x05\0\x02T\x02\x12\x03[\"&\n\x0b\n\x04\x05\0\x02U\x12\x03\\\
    \x08.\n\x0c\n\x05\x05\0\x02U\x01\x12\x03\\\x08&\n\x0c\n\x05\x05\0\x02U\
    \x02\x12\x03\\)-\n\x0b\n\x04\x05\0\x02V\x12\x03]\x086\n\x0c\n\x05\x05\0\
    \x02V\x01\x12\x03]\x08.\n\x0c\n\x05\x05\0\x02V\x02\x12\x03]15\n\x0b\n\
    \x04\x05\0\x02W\x12\x03^\x08,\n\x0c\n\x05\x05\0\x02W\x01\x12\x03^\x08$\n\
    \x0c\n\x05\x05\0\x02W\x02\x12\x03^'+\n\x0b\n\x04\x05\0\x02X\x12\x03_\x08\
    9\n\x0c\n\x05\x05\0\x02X\x01\x12\x03_\x081\n\x0c\n\x05\x05\0\x02X\x02\
    \x12\x03_48\n\x0b\n\x04\x05\0\x02Y\x12\x03`\x08=\n\x0c\n\x05\x05\0\x02Y\
    \x01\x12\x03`\x085\n\x0c\n\x05\x05\0\x02Y\x02\x12\x03`8<\n\x0b\n\x04\x05\
    \0\x02Z\x12\x03a\x08>\n\x0c\n\x05\x05\0\x02Z\x01\x12\x03a\x086\n\x0c\n\
    \x05\x05\0\x02Z\x02\x12\x03a9=\n\x0b\n\x04\x05\0\x02[\x12\x03b\x084\n\
    \x0c\n\x05\x05\0\x02[\x01\x12\x03b\x08,\n\x0c\n\x05\x05\0\x02[\x02\x12\
    \x03b/3\n\x0b\n\x04\x05\0\x02\\\x12\x03c\x08<\n\x0c\n\x05\x05\0\x02\\\
    \x01\x12\x03c\x084\n\x0c\n\x05\x05\0\x02\\\x02\x12\x03c7;\n\x0b\n\x04\
    \x05\0\x02]\x12\x03d\x08:\n\x0c\n\x05\x05\0\x02]\x01\x12\x03d\x082\n\x0c\
    \n\x05\x05\0\x02]\x02\x12\x03d59\n\x0b\n\x04\x05\0\x02^\x12\x03e\x083\n\
    \x0c\n\x05\x05\0\x02^\x01\x12\x03e\x08+\n\x0c\n\x05\x05\0\x02^\x02\x12\
    \x03e.2\n\x0b\n\x04\x05\0\x02_\x12\x03f\x08-\n\x0c\n\x05\x05\0\x02_\x01\
    \x12\x03f\x08%\n\x0c\n\x05\x05\0\x02_\x02\x12\x03f(,\n\x0b\n\x04\x05\0\
    \x02`\x12\x03g\x08$\n\x0c\n\x05\x05\0\x02`\x01\x12\x03g\x08\x1c\n\x0c\n\
    \x05\x05\0\x02`\x02\x12\x03g\x1f#\n\x0b\n\x04\x05\0\x02a\x12\x03h\x08/\n\
    \x0c\n\x05\x05\0\x02a\x01\x12\x03h\x08'\n\x0c\n\x05\x05\0\x02a\x02\x12\
    \x03h*.\n\x0b\n\x04\x05\0\x02b\x12\x03i\x080\n\x0c\n\x05\x05\0\x02b\x01\
    \x12\x03i\x08(\n\x0c\n\x05\x05\0\x02b\x02\x12\x03i+/\n\x0b\n\x04\x05\0\
    \x02c\x12\x03j\x085\n\x0c\n\x05\x05\0\x02c\x01\x12\x03j\x08-\n\x0c\n\x05\
    \x05\0\x02c\x02\x12\x03j04\n\x0b\n\x04\x05\0\x02d\x12\x03k\x082\n\x0c\n\
    \x05\x05\0\x02d\x01\x12\x03k\x08*\n\x0c\n\x05\x05\0\x02d\x02\x12\x03k-1\
    \n\x0b\n\x04\x05\0\x02e\x12\x03l\x08%\n\x0c\n\x05\x05\0\x02e\x01\x12\x03\
    l\x08\x1d\n\x0c\n\x05\x05\0\x02e\x02\x12\x03l\x20$\n\x0b\n\x04\x05\0\x02\
    f\x12\x03m\x08-\n\x0c\n\x05\x05\0\x02f\x01\x12\x03m\x08%\n\x0c\n\x05\x05\
    \0\x02f\x02\x12\x03m(,\n\x0b\n\x04\x05\0\x02g\x12\x03n\x085\n\x0c\n\x05\
    \x05\0\x02g\x01\x12\x03n\x08-\n\x0c\n\x05\x05\0\x02g\x02\x12\x03n04\n\
    \x0b\n\x04\x05\0\x02h\x12\x03o\x084\n\x0c\n\x05\x05\0\x02h\x01\x12\x03o\
    \x08,\n\x0c\n\x05\x05\0\x02h\x02\x12\x03o/3\n\x0b\n\x04\x05\0\x02i\x12\
    \x03p\x08=\n\x0c\n\x05\x05\0\x02i\x01\x12\x03p\x085\n\x0c\n\x05\x05\0\
    \x02i\x02\x12\x03p8<\n\x0b\n\x04\x05\0\x02j\x12\x03q\x08-\n\x0c\n\x05\
    \x05\0\x02j\x01\x12\x03q\x08%\n\x0c\n\x05\x05\0\x02j\x02\x12\x03q(,\n\
    \x0b\n\x04\x05\0\x02k\x12\x03r\x08%\n\x0c\n\x05\x05\0\x02k\x01\x12\x03r\
    \x08\x1d\n\x0c\n\x05\x05\0\x02k\x02\x12\x03r\x20$\n\x0b\n\x04\x05\0\x02l\
    \x12\x03s\x08-\n\x0c\n\x05\x05\0\x02l\x01\x12\x03s\x08%\n\x0c\n\x05\x05\
    \0\x02l\x02\x12\x03s(,\n\x0b\n\x04\x05\0\x02m\x12\x03t\x086\n\x0c\n\x05\
    \x05\0\x02m\x01\x12\x03t\x08.\n\x0c\n\x05\x05\0\x02m\x02\x12\x03t15\n\
    \x0b\n\x04\x05\0\x02n\x12\x03u\x08'\n\x0c\n\x05\x05\0\x02n\x01\x12\x03u\
    \x08\x1f\n\x0c\n\x05\x05\0\x02n\x02\x12\x03u\"&\n\x0b\n\x04\x05\0\x02o\
    \x12\x03v\x08/\n\x0c\n\x05\x05\0\x02o\x01\x12\x03v\x08'\n\x0c\n\x05\x05\
    \0\x02o\x02\x12\x03v*.\n\x0b\n\x04\x05\0\x02p\x12\x03w\x08.\n\x0c\n\x05\
    \x05\0\x02p\x01\x12\x03w\x08&\n\x0c\n\x05\x05\0\x02p\x02\x12\x03w)-\n\
    \x0b\n\x04\x05\0\x02q\x12\x03x\x08/\n\x0c\n\x05\x05\0\x02q\x01\x12\x03x\
    \x08'\n\x0c\n\x05\x05\0\x02q\x02\x12\x03x*.\n\x0b\n\x04\x05\0\x02r\x12\
    \x03y\x08(\n\x0c\n\x05\x05\0\x02r\x01\x12\x03y\x08\x20\n\x0c\n\x05\x05\0\
    \x02r\x02\x12\x03y#'\n\x0b\n\x04\x05\0\x02s\x12\x03z\x08&\n\x0c\n\x05\
    \x05\0\x02s\x01\x12\x03z\x08\x1e\n\x0c\n\x05\x05\0\x02s\x02\x12\x03z!%\n\
    \x0b\n\x04\x05\0\x02t\x12\x03{\x08-\n\x0c\n\x05\x05\0\x02t\x01\x12\x03{\
    \x08%\n\x0c\n\x05\x05\0\x02t\x02\x12\x03{(,\n\x0b\n\x04\x05\0\x02u\x12\
    \x03|\x080\n\x0c\n\x05\x05\0\x02u\x01\x12\x03|\x08(\n\x0c\n\x05\x05\0\
    \x02u\x02\x12\x03|+/\n\x0b\n\x04\x05\0\x02v\x12\x03}\x085\n\x0c\n\x05\
    \x05\0\x02v\x01\x12\x03}\x08-\n\x0c\n\x05\x05\0\x02v\x02\x12\x03}04\n\
    \x0b\n\x04\x05\0\x02w\x12\x03~\x08,\n\x0c\n\x05\x05\0\x02w\x01\x12\x03~\
    \x08$\n\x0c\n\x05\x05\0\x02w\x02\x12\x03~'+\n\x0b\n\x04\x05\0\x02x\x12\
    \x03\x7f\x08.\n\x0c\n\x05\x05\0\x02x\x01\x12\x03\x7f\x08&\n\x0c\n\x05\
    \x05\0\x02x\x02\x12\x03\x7f)-\n\x0c\n\x04\x05\0\x02y\x12\x04\x80\x01\x08\
    /\n\r\n\x05\x05\0\x02y\x01\x12\x04\x80\x01\x08'\n\r\n\x05\x05\0\x02y\x02\
    \x12\x04\x80\x01*.\n\x0c\n\x04\x05\0\x02z\x12\x04\x81\x01\x08%\n\r\n\x05\
    \x05\0\x02z\x01\x12\x04\x81\x01\x08\x1d\n\r\n\x05\x05\0\x02z\x02\x12\x04\
    \x81\x01\x20$\n\x0c\n\x04\x05\0\x02{\x12\x04\x82\x01\x080\n\r\n\x05\x05\
    \0\x02{\x01\x12\x04\x82\x01\x08(\n\r\n\x05\x05\0\x02{\x02\x12\x04\x82\
    \x01+/\n\x0c\n\x04\x05\0\x02|\x12\x04\x83\x01\x081\n\r\n\x05\x05\0\x02|\
    \x01\x12\x04\x83\x01\x08)\n\r\n\x05\x05\0\x02|\x02\x12\x04\x83\x01,0\n\
    \x0c\n\x04\x05\0\x02}\x12\x04\x84\x01\x086\n\r\n\x05\x05\0\x02}\x01\x12\
    \x04\x84\x01\x08.\n\r\n\x05\x05\0\x02}\x02\x12\x04\x84\x0115\n\x0c\n\x04\
    \x05\0\x02~\x12\x04\x85\x01\x087\n\r\n\x05\x05\0\x02~\x01\x12\x04\x85\
    \x01\x08/\n\r\n\x05\x05\0\x02~\x02\x12\x04\x85\x0126\n\x0c\n\x04\x05\0\
    \x02\x7f\x12\x04\x86\x01\x08&\n\r\n\x05\x05\0\x02\x7f\x01\x12\x04\x86\
    \x01\x08\x1e\n\r\n\x05\x05\0\x02\x7f\x02\x12\x04\x86\x01!%\n\r\n\x05\x05\
    \0\x02\x80\x01\x12\x04\x87\x01\x08%\n\x0e\n\x06\x05\0\x02\x80\x01\x01\
    \x12\x04\x87\x01\x08\x1d\n\x0e\n\x06\x05\0\x02\x80\x01\x02\x12\x04\x87\
    \x01\x20$\n\r\n\x05\x05\0\x02\x81\x01\x12\x04\x88\x01\x08+\n\x0e\n\x06\
    \x05\0\x02\x81\x01\x01\x12\x04\x88\x01\x08#\n\x0e\n\x06\x05\0\x02\x81\
    \x01\x02\x12\x04\x88\x01&*\n\r\n\x05\x05\0\x02\x82\x01\x12\x04\x89\x01\
    \x08&\n\x0e\n\x06\x05\0\x02\x82\x01\x01\x12\x04\x89\x01\x08\x1e\n\x0e\n\
    \x06\x05\0\x02\x82\x01\x02\x12\x04\x89\x01!%\n\r\n\x05\x05\0\x02\x83\x01\
    \x12\x04\x8a\x01\x08+\n\x0e\n\x06\x05\0\x02\x83\x01\x01\x12\x04\x8a\x01\
    \x08#\n\x0e\n\x06\x05\0\x02\x83\x01\x02\x12\x04\x8a\x01&*\n\r\n\x05\x05\
    \0\x02\x84\x01\x12\x04\x8b\x01\x08/\n\x0e\n\x06\x05\0\x02\x84\x01\x01\
    \x12\x04\x8b\x01\x08'\n\x0e\n\x06\x05\0\x02\x84\x01\x02\x12\x04\x8b\x01*\
    .\n\r\n\x05\x05\0\x02\x85\x01\x12\x04\x8c\x01\x085\n\x0e\n\x06\x05\0\x02\
    \x85\x01\x01\x12\x04\x8c\x01\x08-\n\x0e\n\x06\x05\0\x02\x85\x01\x02\x12\
    \x04\x8c\x0104\n\r\n\x05\x05\0\x02\x86\x01\x12\x04\x8d\x01\x08+\n\x0e\n\
    \x06\x05\0\x02\x86\x01\x01\x12\x04\x8d\x01\x08#\n\x0e\n\x06\x05\0\x02\
    \x86\x01\x02\x12\x04\x8d\x01&*\n\r\n\x05\x05\0\x02\x87\x01\x12\x04\x8e\
    \x01\x08(\n\x0e\n\x06\x05\0\x02\x87\x01\x01\x12\x04\x8e\x01\x08\x20\n\
    \x0e\n\x06\x05\0\x02\x87\x01\x02\x12\x04\x8e\x01#'\n\r\n\x05\x05\0\x02\
    \x88\x01\x12\x04\x8f\x01\x080\n\x0e\n\x06\x05\0\x02\x88\x01\x01\x12\x04\
    \x8f\x01\x08(\n\x0e\n\x06\x05\0\x02\x88\x01\x02\x12\x04\x8f\x01+/\n\r\n\
    \x05\x05\0\x02\x89\x01\x12\x04\x90\x01\x08+\n\x0e\n\x06\x05\0\x02\x89\
    \x01\x01\x12\x04\x90\x01\x08#\n\x0e\n\x06\x05\0\x02\x89\x01\x02\x12\x04\
    \x90\x01&*\n\r\n\x05\x05\0\x02\x8a\x01\x12\x04\x91\x01\x083\n\x0e\n\x06\
    \x05\0\x02\x8a\x01\x01\x12\x04\x91\x01\x08+\n\x0e\n\x06\x05\0\x02\x8a\
    \x01\x02\x12\x04\x91\x01.2\n\r\n\x05\x05\0\x02\x8b\x01\x12\x04\x92\x01\
    \x08-\n\x0e\n\x06\x05\0\x02\x8b\x01\x01\x12\x04\x92\x01\x08%\n\x0e\n\x06\
    \x05\0\x02\x8b\x01\x02\x12\x04\x92\x01(,\n\r\n\x05\x05\0\x02\x8c\x01\x12\
    \x04\x93\x01\x085\n\x0e\n\x06\x05\0\x02\x8c\x01\x01\x12\x04\x93\x01\x08-\
    \n\x0e\n\x06\x05\0\x02\x8c\x01\x02\x12\x04\x93\x0104\n\r\n\x05\x05\0\x02\
    \x8d\x01\x12\x04\x94\x01\x08*\n\x0e\n\x06\x05\0\x02\x8d\x01\x01\x12\x04\
    \x94\x01\x08\"\n\x0e\n\x06\x05\0\x02\x8d\x01\x02\x12\x04\x94\x01%)\n\r\n\
    \x05\x05\0\x02\x8e\x01\x12\x04\x95\x01\x08/\n\x0e\n\x06\x05\0\x02\x8e\
    \x01\x01\x12\x04\x95\x01\x08'\n\x0e\n\x06\x05\0\x02\x8e\x01\x02\x12\x04\
    \x95\x01*.\n\r\n\x05\x05\0\x02\x8f\x01\x12\x04\x96\x01\x08&\n\x0e\n\x06\
    \x05\0\x02\x8f\x01\x01\x12\x04\x96\x01\x08\x1e\n\x0e\n\x06\x05\0\x02\x8f\
    \x01\x02\x12\x04\x96\x01!%\n\r\n\x05\x05\0\x02\x90\x01\x12\x04\x97\x01\
    \x08%\n\x0e\n\x06\x05\0\x02\x90\x01\x01\x12\x04\x97\x01\x08\x1d\n\x0e\n\
    \x06\x05\0\x02\x90\x01\x02\x12\x04\x97\x01\x20$\n\r\n\x05\x05\0\x02\x91\
    \x01\x12\x04\x98\x01\x08'\n\x0e\n\x06\x05\0\x02\x91\x01\x01\x12\x04\x98\
    \x01\x08\x1f\n\x0e\n\x06\x05\0\x02\x91\x01\x02\x12\x04\x98\x01\"&\n\r\n\
    \x05\x05\0\x02\x92\x01\x12\x04\x99\x01\x08'\n\x0e\n\x06\x05\0\x02\x92\
    \x01\x01\x12\x04\x99\x01\x08\x1f\n\x0e\n\x06\x05\0\x02\x92\x01\x02\x12\
    \x04\x99\x01\"&\n\r\n\x05\x05\0\x02\x93\x01\x12\x04\x9a\x01\x08)\n\x0e\n\
    \x06\x05\0\x02\x93\x01\x01\x12\x04\x9a\x01\x08!\n\x0e\n\x06\x05\0\x02\
    \x93\x01\x02\x12\x04\x9a\x01$(\n\r\n\x05\x05\0\x02\x94\x01\x12\x04\x9b\
    \x01\x08-\n\x0e\n\x06\x05\0\x02\x94\x01\x01\x12\x04\x9b\x01\x08%\n\x0e\n\
    \x06\x05\0\x02\x94\x01\x02\x12\x04\x9b\x01(,\n\r\n\x05\x05\0\x02\x95\x01\
    \x12\x04\x9c\x01\x085\n\x0e\n\x06\x05\0\x02\x95\x01\x01\x12\x04\x9c\x01\
    \x08-\n\x0e\n\x06\x05\0\x02\x95\x01\x02\x12\x04\x9c\x0104\n\r\n\x05\x05\
    \0\x02\x96\x01\x12\x04\x9d\x01\x084\n\x0e\n\x06\x05\0\x02\x96\x01\x01\
    \x12\x04\x9d\x01\x08,\n\x0e\n\x06\x05\0\x02\x96\x01\x02\x12\x04\x9d\x01/\
    3\n\r\n\x05\x05\0\x02\x97\x01\x12\x04\x9e\x01\x08<\n\x0e\n\x06\x05\0\x02\
    \x97\x01\x01\x12\x04\x9e\x01\x084\n\x0e\n\x06\x05\0\x02\x97\x01\x02\x12\
    \x04\x9e\x017;\n\r\n\x05\x05\0\x02\x98\x01\x12\x04\x9f\x01\x080\n\x0e\n\
    \x06\x05\0\x02\x98\x01\x01\x12\x04\x9f\x01\x08(\n\x0e\n\x06\x05\0\x02\
    \x98\x01\x02\x12\x04\x9f\x01+/\n\r\n\x05\x05\0\x02\x99\x01\x12\x04\xa0\
    \x01\x088\n\x0e\n\x06\x05\0\x02\x99\x01\x01\x12\x04\xa0\x01\x080\n\x0e\n\
    \x06\x05\0\x02\x99\x01\x02\x12\x04\xa0\x0137\n\r\n\x05\x05\0\x02\x9a\x01\
    \x12\x04\xa1\x01\x084\n\x0e\n\x06\x05\0\x02\x9a\x01\x01\x12\x04\xa1\x01\
    \x08,\n\x0e\n\x06\x05\0\x02\x9a\x01\x02\x12\x04\xa1\x01/3\n\r\n\x05\x05\
    \0\x02\x9b\x01\x12\x04\xa2\x01\x08<\n\x0e\n\x06\x05\0\x02\x9b\x01\x01\
    \x12\x04\xa2\x01\x084\n\x0e\n\x06\x05\0\x02\x9b\x01\x02\x12\x04\xa2\x017\
    ;\n\r\n\x05\x05\0\x02\x9c\x01\x12\x04\xa3\x01\x08-\n\x0e\n\x06\x05\0\x02\
    \x9c\x01\x01\x12\x04\xa3\x01\x08%\n\x0e\n\x06\x05\0\x02\x9c\x01\x02\x12\
    \x04\xa3\x01(,\n\r\n\x05\x05\0\x02\x9d\x01\x12\x04\xa4\x01\x08(\n\x0e\n\
    \x06\x05\0\x02\x9d\x01\x01\x12\x04\xa4\x01\x08\x20\n\x0e\n\x06\x05\0\x02\
    \x9d\x01\x02\x12\x04\xa4\x01#'\n\r\n\x05\x05\0\x02\x9e\x01\x12\x04\xa5\
    \x01\x08)\n\x0e\n\x06\x05\0\x02\x9e\x01\x01\x12\x04\xa5\x01\x08!\n\x0e\n\
    \x06\x05\0\x02\x9e\x01\x02\x12\x04\xa5\x01$(\n\r\n\x05\x05\0\x02\x9f\x01\
    \x12\x04\xa6\x01\x08*\n\x0e\n\x06\x05\0\x02\x9f\x01\x01\x12\x04\xa6\x01\
    \x08\"\n\x0e\n\x06\x05\0\x02\x9f\x01\x02\x12\x04\xa6\x01%)\n\r\n\x05\x05\
    \0\x02\xa0\x01\x12\x04\xa7\x01\x08/\n\x0e\n\x06\x05\0\x02\xa0\x01\x01\
    \x12\x04\xa7\x01\x08'\n\x0e\n\x06\x05\0\x02\xa0\x01\x02\x12\x04\xa7\x01*\
    .\n\r\n\x05\x05\0\x02\xa1\x01\x12\x04\xa8\x01\x08\"\n\x0e\n\x06\x05\0\
    \x02\xa1\x01\x01\x12\x04\xa8\x01\x08\x1a\n\x0e\n\x06\x05\0\x02\xa1\x01\
    \x02\x12\x04\xa8\x01\x1d!\n\r\n\x05\x05\0\x02\xa2\x01\x12\x04\xa9\x01\
    \x08-\n\x0e\n\x06\x05\0\x02\xa2\x01\x01\x12\x04\xa9\x01\x08%\n\x0e\n\x06\
    \x05\0\x02\xa2\x01\x02\x12\x04\xa9\x01(,\n\r\n\x05\x05\0\x02\xa3\x01\x12\
    \x04\xaa\x01\x085\n\x0e\n\x06\x05\0\x02\xa3\x01\x01\x12\x04\xaa\x01\x08-\
    \n\x0e\n\x06\x05\0\x02\xa3\x01\x02\x12\x04\xaa\x0104\n\r\n\x05\x05\0\x02\
    \xa4\x01\x12\x04\xab\x01\x08)\n\x0e\n\x06\x05\0\x02\xa4\x01\x01\x12\x04\
    \xab\x01\x08\x20\n\x0e\n\x06\x05\0\x02\xa4\x01\x02\x12\x04\xab\x01#(\n\
    \x0c\n\x02\x05\x01\x12\x06\xae\x01\0\xb0\x01\x01\n\x0b\n\x03\x05\x01\x01\
    \x12\x04\xae\x01\x05\x20\n\x0c\n\x04\x05\x01\x02\0\x12\x04\xaf\x01\x082\
    \n\r\n\x05\x05\x01\x02\0\x01\x12\x04\xaf\x01\x08-\n\r\n\x05\x05\x01\x02\
    \0\x02\x12\x04\xaf\x0101\n\x0c\n\x02\x05\x02\x12\x06\xb2\x01\0\xb9\x01\
    \x01\n\x0b\n\x03\x05\x02\x01\x12\x04\xb2\x01\x05\x18\n\x0c\n\x04\x05\x02\
    \x02\0\x12\x04\xb3\x01\x08+\n\r\n\x05\x05\x02\x02\0\x01\x12\x04\xb3\x01\
    \x08%\n\r\n\x05\x05\x02\x02\0\x02\x12\x04\xb3\x01(*\n\x0c\n\x04\x05\x02\
    \x02\x01\x12\x04\xb4\x01\x08'\n\r\n\x05\x05\x02\x02\x01\x01\x12\x04\xb4\
    \x01\x08\"\n\r\n\x05\x05\x02\x02\x01\x02\x12\x04\xb4\x01%&\n\x0c\n\x04\
    \x05\x02\x02\x02\x12\x04\xb5\x01\x083\n\r\n\x05\x05\x02\x02\x02\x01\x12\
    \x04\xb5\x01\x08.\n\r\n\x05\x05\x02\x02\x02\x02\x12\x04\xb5\x0112\n\x0c\
    \n\x04\x05\x02\x02\x03\x12\x04\xb6\x01\x085\n\r\n\x05\x05\x02\x02\x03\
    \x01\x12\x04\xb6\x01\x080\n\r\n\x05\x05\x02\x02\x03\x02\x12\x04\xb6\x013\
    4\n\x0c\n\x04\x05\x02\x02\x04\x12\x04\xb7\x01\x085\n\r\n\x05\x05\x02\x02\
    \x04\x01\x12\x04\xb7\x01\x080\n\r\n\x05\x05\x02\x02\x04\x02\x12\x04\xb7\
    \x0134\n\x0c\n\x04\x05\x02\x02\x05\x12\x04\xb8\x01\x089\n\r\n\x05\x05\
    \x02\x02\x05\x01\x12\x04\xb8\x01\x084\n\r\n\x05\x05\x02\x02\x05\x02\x12\
    \x04\xb8\x0178\n\x0c\n\x02\x05\x03\x12\x06\xbb\x01\0\xd4\x01\x01\n\x0b\n\
    \x03\x05\x03\x01\x12\x04\xbb\x01\x05\x12\n\x0b\n\x03\x05\x03\x03\x12\x04\
    \xbc\x01\x08\"\n\x0c\n\x04\x05\x03\x03\x02\x12\x04\xbc\x01\x08\"\n\x0c\n\
    \x04\x05\x03\x02\0\x12\x04\xbd\x01\x08%\n\r\n\x05\x05\x03\x02\0\x01\x12\
    \x04\xbd\x01\x08\x1f\n\r\n\x05\x05\x03\x02\0\x02\x12\x04\xbd\x01\"$\n\
    \x0c\n\x04\x05\x03\x02\x01\x12\x04\xbe\x01\x08)\n\r\n\x05\x05\x03\x02\
    \x01\x01\x12\x04\xbe\x01\x08$\n\r\n\x05\x05\x03\x02\x01\x02\x12\x04\xbe\
    \x01'(\n\x0c\n\x04\x05\x03\x02\x02\x12\x04\xbf\x01\x08'\n\r\n\x05\x05\
    \x03\x02\x02\x01\x12\x04\xbf\x01\x08\"\n\r\n\x05\x05\x03\x02\x02\x02\x12\
    \x04\xbf\x01%&\n\x0c\n\x04\x05\x03\x02\x03\x12\x04\xc0\x01\x08\"\n\r\n\
    \x05\x05\x03\x02\x03\x01\x12\x04\xc0\x01\x08\x1d\n\r\n\x05\x05\x03\x02\
    \x03\x02\x12\x04\xc0\x01\x20!\n\x0c\n\x04\x05\x03\x02\x04\x12\x04\xc1\
    \x01\x08(\n\r\n\x05\x05\x03\x02\x04\x01\x12\x04\xc1\x01\x08#\n\r\n\x05\
    \x05\x03\x02\x04\x02\x12\x04\xc1\x01&'\n\x0c\n\x04\x05\x03\x02\x05\x12\
    \x04\xc2\x01\x08&\n\r\n\x05\x05\x03\x02\x05\x01\x12\x04\xc2\x01\x08!\n\r\
    \n\x05\x05\x03\x02\x05\x02\x12\x04\xc2\x01$%\n\x0c\n\x04\x05\x03\x02\x06\
    \x12\x04\xc3\x01\x08%\n\r\n\x05\x05\x03\x02\x06\x01\x12\x04\xc3\x01\x08\
    \x20\n\r\n\x05\x05\x03\x02\x06\x02\x12\x04\xc3\x01#$\n\x0c\n\x04\x05\x03\
    \x02\x07\x12\x04\xc4\x01\x08'\n\r\n\x05\x05\x03\x02\x07\x01\x12\x04\xc4\
    \x01\x08\"\n\r\n\x05\x05\x03\x02\x07\x02\x12\x04\xc4\x01%&\n\x0c\n\x04\
    \x05\x03\x02\x08\x12\x04\xc5\x01\x08'\n\r\n\x05\x05\x03\x02\x08\x01\x12\
    \x04\xc5\x01\x08\"\n\r\n\x05\x05\x03\x02\x08\x02\x12\x04\xc5\x01%&\n\x0c\
    \n\x04\x05\x03\x02\t\x12\x04\xc6\x01\x08)\n\r\n\x05\x05\x03\x02\t\x01\
    \x12\x04\xc6\x01\x08$\n\r\n\x05\x05\x03\x02\t\x02\x12\x04\xc6\x01'(\n\
    \x0c\n\x04\x05\x03\x02\n\x12\x04\xc7\x01\x08+\n\r\n\x05\x05\x03\x02\n\
    \x01\x12\x04\xc7\x01\x08&\n\r\n\x05\x05\x03\x02\n\x02\x12\x04\xc7\x01)*\
    \n\x0c\n\x04\x05\x03\x02\x0b\x12\x04\xc8\x01\x08)\n\r\n\x05\x05\x03\x02\
    \x0b\x01\x12\x04\xc8\x01\x08$\n\r\n\x05\x05\x03\x02\x0b\x02\x12\x04\xc8\
    \x01'(\n\x0c\n\x04\x05\x03\x02\x0c\x12\x04\xc9\x01\x08(\n\r\n\x05\x05\
    \x03\x02\x0c\x01\x12\x04\xc9\x01\x08#\n\r\n\x05\x05\x03\x02\x0c\x02\x12\
    \x04\xc9\x01&'\n\x0c\n\x04\x05\x03\x02\r\x12\x04\xca\x01\x08'\n\r\n\x05\
    \x05\x03\x02\r\x01\x12\x04\xca\x01\x08\"\n\r\n\x05\x05\x03\x02\r\x02\x12\
    \x04\xca\x01%&\n\x0c\n\x04\x05\x03\x02\x0e\x12\x04\xcb\x01\x08'\n\r\n\
    \x05\x05\x03\x02\x0e\x01\x12\x04\xcb\x01\x08\"\n\r\n\x05\x05\x03\x02\x0e\
    \x02\x12\x04\xcb\x01%&\n\x0c\n\x04\x05\x03\x02\x0f\x12\x04\xcc\x01\x08)\
    \n\r\n\x05\x05\x03\x02\x0f\x01\x12\x04\xcc\x01\x08$\n\r\n\x05\x05\x03\
    \x02\x0f\x02\x12\x04\xcc\x01'(\n\x0c\n\x04\x05\x03\x02\x10\x12\x04\xcd\
    \x01\x08+\n\r\n\x05\x05\x03\x02\x10\x01\x12\x04\xcd\x01\x08&\n\r\n\x05\
    \x05\x03\x02\x10\x02\x12\x04\xcd\x01)*\n\x0c\n\x04\x05\x03\x02\x11\x12\
    \x04\xce\x01\x08)\n\r\n\x05\x05\x03\x02\x11\x01\x12\x04\xce\x01\x08$\n\r\
    \n\x05\x05\x03\x02\x11\x02\x12\x04\xce\x01'(\n\x0c\n\x04\x05\x03\x02\x12\
    \x12\x04\xcf\x01\x08(\n\r\n\x05\x05\x03\x02\x12\x01\x12\x04\xcf\x01\x08#\
    \n\r\n\x05\x05\x03\x02\x12\x02\x12\x04\xcf\x01&'\n\x0c\n\x04\x05\x03\x02\
    \x13\x12\x04\xd0\x01\x08.\n\r\n\x05\x05\x03\x02\x13\x01\x12\x04\xd0\x01\
    \x08)\n\r\n\x05\x05\x03\x02\x13\x02\x12\x04\xd0\x01,-\n\x0c\n\x04\x05\
    \x03\x02\x14\x12\x04\xd1\x01\x08*\n\r\n\x05\x05\x03\x02\x14\x01\x12\x04\
    \xd1\x01\x08%\n\r\n\x05\x05\x03\x02\x14\x02\x12\x04\xd1\x01()\n\x0c\n\
    \x04\x05\x03\x02\x15\x12\x04\xd2\x01\x08(\n\r\n\x05\x05\x03\x02\x15\x01\
    \x12\x04\xd2\x01\x08#\n\r\n\x05\x05\x03\x02\x15\x02\x12\x04\xd2\x01&'\n\
    \x0c\n\x04\x05\x03\x02\x16\x12\x04\xd3\x01\x08'\n\r\n\x05\x05\x03\x02\
    \x16\x01\x12\x04\xd3\x01\x08\"\n\r\n\x05\x05\x03\x02\x16\x02\x12\x04\xd3\
    \x01%&\n\x0c\n\x02\x05\x04\x12\x06\xd6\x01\0\xde\x01\x01\n\x0b\n\x03\x05\
    \x04\x01\x12\x04\xd6\x01\x05\x15\n\x0c\n\x04\x05\x04\x02\0\x12\x04\xd7\
    \x01\x08'\n\r\n\x05\x05\x04\x02\0\x01\x12\x04\xd7\x01\x08\"\n\r\n\x05\
    \x05\x04\x02\0\x02\x12\x04\xd7\x01%&\n\x0c\n\x04\x05\x04\x02\x01\x12\x04\
    \xd8\x01\x08*\n\r\n\x05\x05\x04\x02\x01\x01\x12\x04\xd8\x01\x08%\n\r\n\
    \x05\x05\x04\x02\x01\x02\x12\x04\xd8\x01()\n\x0c\n\x04\x05\x04\x02\x02\
    \x12\x04\xd9\x01\x087\n\r\n\x05\x05\x04\x02\x02\x01\x12\x04\xd9\x01\x08/\
    \n\r\n\x05\x05\x04\x02\x02\x02\x12\x04\xd9\x0126\n\x0c\n\x04\x05\x04\x02\
    \x03\x12\x04\xda\x01\x088\n\r\n\x05\x05\x04\x02\x03\x01\x12\x04\xda\x01\
    \x080\n\r\n\x05\x05\x04\x02\x03\x02\x12\x04\xda\x0137\n\x0c\n\x04\x05\
    \x04\x02\x04\x12\x04\xdb\x01\x087\n\r\n\x05\x05\x04\x02\x04\x01\x12\x04\
    \xdb\x01\x08/\n\r\n\x05\x05\x04\x02\x04\x02\x12\x04\xdb\x0126\n\x0c\n\
    \x04\x05\x04\x02\x05\x12\x04\xdc\x01\x089\n\r\n\x05\x05\x04\x02\x05\x01\
    \x12\x04\xdc\x01\x081\n\r\n\x05\x05\x04\x02\x05\x02\x12\x04\xdc\x0148\n\
    \x0c\n\x04\x05\x04\x02\x06\x12\x04\xdd\x01\x08:\n\r\n\x05\x05\x04\x02\
    \x06\x01\x12\x04\xdd\x01\x082\n\r\n\x05\x05\x04\x02\x06\x02\x12\x04\xdd\
    \x0159\n\x0c\n\x02\x05\x05\x12\x06\xe0\x01\0\xe8\x01\x01\n\x0b\n\x03\x05\
    \x05\x01\x12\x04\xe0\x01\x05\x14\n\x0c\n\x04\x05\x05\x02\0\x12\x04\xe1\
    \x01\x08'\n\r\n\x05\x05\x05\x02\0\x01\x12\x04\xe1\x01\x08\"\n\r\n\x05\
    \x05\x05\x02\0\x02\x12\x04\xe1\x01%&\n\x0c\n\x04\x05\x05\x02\x01\x12\x04\
    \xe2\x01\x085\n\r\n\x05\x05\x05\x02\x01\x01\x12\x04\xe2\x01\x080\n\r\n\
    \x05\x05\x05\x02\x01\x02\x12\x04\xe2\x0134\n\x0c\n\x04\x05\x05\x02\x02\
    \x12\x04\xe3\x01\x08*\n\r\n\x05\x05\x05\x02\x02\x01\x12\x04\xe3\x01\x08%\
    \n\r\n\x05\x05\x05\x02\x02\x02\x12\x04\xe3\x01()\n\x0c\n\x04\x05\x05\x02\
    \x03\x12\x04\xe4\x01\x08-\n\r\n\x05\x05\x05\x02\x03\x01\x12\x04\xe4\x01\
    \x08(\n\r\n\x05\x05\x05\x02\x03\x02\x12\x04\xe4\x01+,\n\x0c\n\x04\x05\
    \x05\x02\x04\x12\x04\xe5\x01\x08&\n\r\n\x05\x05\x05\x02\x04\x01\x12\x04\
    \xe5\x01\x08!\n\r\n\x05\x05\x05\x02\x04\x02\x12\x04\xe5\x01$%\n\x0c\n\
    \x04\x05\x05\x02\x05\x12\x04\xe6\x01\x08'\n\r\n\x05\x05\x05\x02\x05\x01\
    \x12\x04\xe6\x01\x08\"\n\r\n\x05\x05\x05\x02\x05\x02\x12\x04\xe6\x01%&\n\
    \x0c\n\x04\x05\x05\x02\x06\x12\x04\xe7\x01\x08!\n\r\n\x05\x05\x05\x02\
    \x06\x01\x12\x04\xe7\x01\x08\x1c\n\r\n\x05\x05\x05\x02\x06\x02\x12\x04\
    \xe7\x01\x1f\x20\n\x0c\n\x02\x05\x06\x12\x06\xea\x01\0\xf1\x01\x01\n\x0b\
    \n\x03\x05\x06\x01\x12\x04\xea\x01\x05\x0f\n\x0c\n\x04\x05\x06\x02\0\x12\
    \x04\xeb\x01\x08!\n\r\n\x05\x05\x06\x02\0\x01\x12\x04\xeb\x01\x08\x1c\n\
    \r\n\x05\x05\x06\x02\0\x02\x12\x04\xeb\x01\x1f\x20\n\x0c\n\x04\x05\x06\
    \x02\x01\x12\x04\xec\x01\x08\x20\n\r\n\x05\x05\x06\x02\x01\x01\x12\x04\
    \xec\x01\x08\x1b\n\r\n\x05\x05\x06\x02\x01\x02\x12\x04\xec\x01\x1e\x1f\n\
    \x0c\n\x04\x05\x06\x02\x02\x12\x04\xed\x01\x08#\n\r\n\x05\x05\x06\x02\
    \x02\x01\x12\x04\xed\x01\x08\x1e\n\r\n\x05\x05\x06\x02\x02\x02\x12\x04\
    \xed\x01!\"\n\x0c\n\x04\x05\x06\x02\x03\x12\x04\xee\x01\x08!\n\r\n\x05\
    \x05\x06\x02\x03\x01\x12\x04\xee\x01\x08\x1c\n\r\n\x05\x05\x06\x02\x03\
    \x02\x12\x04\xee\x01\x1f\x20\n\x0c\n\x04\x05\x06\x02\x04\x12\x04\xef\x01\
    \x08#\n\r\n\x05\x05\x06\x02\x04\x01\x12\x04\xef\x01\x08\x1e\n\r\n\x05\
    \x05\x06\x02\x04\x02\x12\x04\xef\x01!\"\n\x0c\n\x04\x05\x06\x02\x05\x12\
    \x04\xf0\x01\x08\x1e\n\r\n\x05\x05\x06\x02\x05\x01\x12\x04\xf0\x01\x08\
    \x19\n\r\n\x05\x05\x06\x02\x05\x02\x12\x04\xf0\x01\x1c\x1d\n\x0c\n\x02\
    \x05\x07\x12\x06\xf3\x01\0\xfb\x01\x01\n\x0b\n\x03\x05\x07\x01\x12\x04\
    \xf3\x01\x05\x17\n\x0c\n\x04\x05\x07\x02\0\x12\x04\xf4\x01\x08+\n\r\n\
    \x05\x05\x07\x02\0\x01\x12\x04\xf4\x01\x08&\n\r\n\x05\x05\x07\x02\0\x02\
    \x12\x04\xf4\x01)*\n\x0c\n\x04\x05\x07\x02\x01\x12\x04\xf5\x01\x08)\n\r\
    \n\x05\x05\x07\x02\x01\x01\x12\x04\xf5\x01\x08$\n\r\n\x05\x05\x07\x02\
    \x01\x02\x12\x04\xf5\x01'(\n\x0c\n\x04\x05\x07\x02\x02\x12\x04\xf6\x01\
    \x08$\n\r\n\x05\x05\x07\x02\x02\x01\x12\x04\xf6\x01\x08\x1f\n\r\n\x05\
    \x05\x07\x02\x02\x02\x12\x04\xf6\x01\"#\n\x0c\n\x04\x05\x07\x02\x03\x12\
    \x04\xf7\x01\x08*\n\r\n\x05\x05\x07\x02\x03\x01\x12\x04\xf7\x01\x08%\n\r\
    \n\x05\x05\x07\x02\x03\x02\x12\x04\xf7\x01()\n\x0c\n\x04\x05\x07\x02\x04\
    \x12\x04\xf8\x01\x08$\n\r\n\x05\x05\x07\x02\x04\x01\x12\x04\xf8\x01\x08\
    \x1f\n\r\n\x05\x05\x07\x02\x04\x02\x12\x04\xf8\x01\"#\n\x0c\n\x04\x05\
    \x07\x02\x05\x12\x04\xf9\x01\x08'\n\r\n\x05\x05\x07\x02\x05\x01\x12\x04\
    \xf9\x01\x08\"\n\r\n\x05\x05\x07\x02\x05\x02\x12\x04\xf9\x01%&\n\x0c\n\
    \x04\x05\x07\x02\x06\x12\x04\xfa\x01\x08*\n\r\n\x05\x05\x07\x02\x06\x01\
    \x12\x04\xfa\x01\x08%\n\r\n\x05\x05\x07\x02\x06\x02\x12\x04\xfa\x01()\n\
    \x0c\n\x02\x05\x08\x12\x06\xfd\x01\0\x82\x02\x01\n\x0b\n\x03\x05\x08\x01\
    \x12\x04\xfd\x01\x05\x15\n\x0c\n\x04\x05\x08\x02\0\x12\x04\xfe\x01\x08#\
    \n\r\n\x05\x05\x08\x02\0\x01\x12\x04\xfe\x01\x08\x1e\n\r\n\x05\x05\x08\
    \x02\0\x02\x12\x04\xfe\x01!\"\n\x0c\n\x04\x05\x08\x02\x01\x12\x04\xff\
    \x01\x08&\n\r\n\x05\x05\x08\x02\x01\x01\x12\x04\xff\x01\x08!\n\r\n\x05\
    \x05\x08\x02\x01\x02\x12\x04\xff\x01$%\n\x0c\n\x04\x05\x08\x02\x02\x12\
    \x04\x80\x02\x08\"\n\r\n\x05\x05\x08\x02\x02\x01\x12\x04\x80\x02\x08\x1d\
    \n\r\n\x05\x05\x08\x02\x02\x02\x12\x04\x80\x02\x20!\n\x0c\n\x04\x05\x08\
    \x02\x03\x12\x04\x81\x02\x08&\n\r\n\x05\x05\x08\x02\x03\x01\x12\x04\x81\
    \x02\x08!\n\r\n\x05\x05\x08\x02\x03\x02\x12\x04\x81\x02$%\n\x0c\n\x02\
    \x05\t\x12\x06\x84\x02\0\x8a\x02\x01\n\x0b\n\x03\x05\t\x01\x12\x04\x84\
    \x02\x05\x1b\n\x0c\n\x04\x05\t\x02\0\x12\x04\x85\x02\x08+\n\r\n\x05\x05\
    \t\x02\0\x01\x12\x04\x85\x02\x08&\n\r\n\x05\x05\t\x02\0\x02\x12\x04\x85\
    \x02)*\n\x0c\n\x04\x05\t\x02\x01\x12\x04\x86\x02\x085\n\r\n\x05\x05\t\
    \x02\x01\x01\x12\x04\x86\x02\x080\n\r\n\x05\x05\t\x02\x01\x02\x12\x04\
    \x86\x0234\n\x0c\n\x04\x05\t\x02\x02\x12\x04\x87\x02\x08)\n\r\n\x05\x05\
    \t\x02\x02\x01\x12\x04\x87\x02\x08$\n\r\n\x05\x05\t\x02\x02\x02\x12\x04\
    \x87\x02'(\n\x0c\n\x04\x05\t\x02\x03\x12\x04\x88\x02\x08E\n\r\n\x05\x05\
    \t\x02\x03\x01\x12\x04\x88\x02\x08@\n\r\n\x05\x05\t\x02\x03\x02\x12\x04\
    \x88\x02CD\n\x0c\n\x04\x05\t\x02\x04\x12\x04\x89\x02\x080\n\r\n\x05\x05\
    \t\x02\x04\x01\x12\x04\x89\x02\x08+\n\r\n\x05\x05\t\x02\x04\x02\x12\x04\
    \x89\x02./\n\x0c\n\x02\x05\n\x12\x06\x8c\x02\0\x92\x02\x01\n\x0b\n\x03\
    \x05\n\x01\x12\x04\x8c\x02\x05\x17\n\x0c\n\x04\x05\n\x02\0\x12\x04\x8d\
    \x02\x08#\n\r\n\x05\x05\n\x02\0\x01\x12\x04\x8d\x02\x08\x1e\n\r\n\x05\
    \x05\n\x02\0\x02\x12\x04\x8d\x02!\"\n\x0c\n\x04\x05\n\x02\x01\x12\x04\
    \x8e\x02\x08!\n\r\n\x05\x05\n\x02\x01\x01\x12\x04\x8e\x02\x08\x1c\n\r\n\
    \x05\x05\n\x02\x01\x02\x12\x04\x8e\x02\x1f\x20\n\x0c\n\x04\x05\n\x02\x02\
    \x12\x04\x8f\x02\x08\"\n\r\n\x05\x05\n\x02\x02\x01\x12\x04\x8f\x02\x08\
    \x1d\n\r\n\x05\x05\n\x02\x02\x02\x12\x04\x8f\x02\x20!\n\x0c\n\x04\x05\n\
    \x02\x03\x12\x04\x90\x02\x08$\n\r\n\x05\x05\n\x02\x03\x01\x12\x04\x90\
    \x02\x08\x1f\n\r\n\x05\x05\n\x02\x03\x02\x12\x04\x90\x02\"#\n\x0c\n\x04\
    \x05\n\x02\x04\x12\x04\x91\x02\x08!\n\r\n\x05\x05\n\x02\x04\x01\x12\x04\
    \x91\x02\x08\x1c\n\r\n\x05\x05\n\x02\x04\x02\x12\x04\x91\x02\x1f\x20\n\
    \x0c\n\x02\x04\0\x12\x06\x94\x02\0\x98\x02\x01\n\x0b\n\x03\x04\0\x01\x12\
    \x04\x94\x02\x08#\n\x0c\n\x04\x04\0\x02\0\x12\x04\x95\x02\x08)\n\r\n\x05\
    \x04\0\x02\0\x04\x12\x04\x95\x02\x08\x10\n\r\n\x05\x04\0\x02\0\x05\x12\
    \x04\x95\x02\x11\x16\n\r\n\x05\x04\0\x02\0\x01\x12\x04\x95\x02\x17$\n\r\
    \n\x05\x04\0\x02\0\x03\x12\x04\x95\x02'(\n\x0c\n\x04\x04\0\x02\x01\x12\
    \x04\x96\x02\x08\"\n\r\n\x05\x04\0\x02\x01\x04\x12\x04\x96\x02\x08\x10\n\
    \r\n\x05\x04\0\x02\x01\x05\x12\x04\x96\x02\x11\x15\n\r\n\x05\x04\0\x02\
    \x01\x01\x12\x04\x96\x02\x16\x1d\n\r\n\x05\x04\0\x02\x01\x03\x12\x04\x96\
    \x02\x20!\n\x0c\n\x04\x04\0\x02\x02\x12\x04\x97\x02\x08&\n\r\n\x05\x04\0\
    \x02\x02\x04\x12\x04\x97\x02\x08\x10\n\r\n\x05\x04\0\x02\x02\x05\x12\x04\
    \x97\x02\x11\x17\n\r\n\x05\x04\0\x02\x02\x01\x12\x04\x97\x02\x18!\n\r\n\
    \x05\x04\0\x02\x02\x03\x12\x04\x97\x02$%\n\x0c\n\x02\x04\x01\x12\x06\x9a\
    \x02\0\x9d\x02\x01\n\x0b\n\x03\x04\x01\x01\x12\x04\x9a\x02\x08\x1c\n\x0c\
    \n\x04\x04\x01\x02\0\x12\x04\x9b\x02\x08+\n\r\n\x05\x04\x01\x02\0\x04\
    \x12\x04\x9b\x02\x08\x10\n\r\n\x05\x04\x01\x02\0\x05\x12\x04\x9b\x02\x11\
    \x16\n\r\n\x05\x04\x01\x02\0\x01\x12\x04\x9b\x02\x17&\n\r\n\x05\x04\x01\
    \x02\0\x03\x12\x04\x9b\x02)*\n\x0c\n\x04\x04\x01\x02\x01\x12\x04\x9c\x02\
    \x08&\n\r\n\x05\x04\x01\x02\x01\x04\x12\x04\x9c\x02\x08\x10\n\r\n\x05\
    \x04\x01\x02\x01\x05\x12\x04\x9c\x02\x11\x17\n\r\n\x05\x04\x01\x02\x01\
    \x01\x12\x04\x9c\x02\x18!\n\r\n\x05\x04\x01\x02\x01\x03\x12\x04\x9c\x02$\
    %\n\x0c\n\x02\x04\x02\x12\x06\x9f\x02\0\xa3\x02\x01\n\x0b\n\x03\x04\x02\
    \x01\x12\x04\x9f\x02\x08%\n\x0c\n\x04\x04\x02\x02\0\x12\x04\xa0\x02\x08+\
    \n\r\n\x05\x04\x02\x02\0\x04\x12\x04\xa0\x02\x08\x10\n\r\n\x05\x04\x02\
    \x02\0\x05\x12\x04\xa0\x02\x11\x17\n\r\n\x05\x04\x02\x02\0\x01\x12\x04\
    \xa0\x02\x18&\n\r\n\x05\x04\x02\x02\0\x03\x12\x04\xa0\x02)*\n\x0c\n\x04\
    \x04\x02\x02\x01\x12\x04\xa1\x02\x08*\n\r\n\x05\x04\x02\x02\x01\x04\x12\
    \x04\xa1\x02\x08\x10\n\r\n\x05\x04\x02\x02\x01\x05\x12\x04\xa1\x02\x11\
    \x15\n\r\n\x05\x04\x02\x02\x01\x01\x12\x04\xa1\x02\x16%\n\r\n\x05\x04\
    \x02\x02\x01\x03\x12\x04\xa1\x02()\n\x0c\n\x04\x04\x02\x02\x02\x12\x04\
    \xa2\x02\x08&\n\r\n\x05\x04\x02\x02\x02\x04\x12\x04\xa2\x02\x08\x10\n\r\
    \n\x05\x04\x02\x02\x02\x05\x12\x04\xa2\x02\x11\x17\n\r\n\x05\x04\x02\x02\
    \x02\x01\x12\x04\xa2\x02\x18!\n\r\n\x05\x04\x02\x02\x02\x03\x12\x04\xa2\
    \x02$%\n\x0c\n\x02\x04\x03\x12\x06\xa5\x02\0\xab\x02\x01\n\x0b\n\x03\x04\
    \x03\x01\x12\x04\xa5\x02\x08\x19\n\x0c\n\x04\x04\x03\x02\0\x12\x04\xa6\
    \x02\x08J\n\r\n\x05\x04\x03\x02\0\x04\x12\x04\xa6\x02\x08\x10\n\r\n\x05\
    \x04\x03\x02\0\x05\x12\x04\xa6\x02\x11\x15\n\r\n\x05\x04\x03\x02\0\x01\
    \x12\x04\xa6\x02\x163\n\r\n\x05\x04\x03\x02\0\x03\x12\x04\xa6\x0267\n\r\
    \n\x05\x04\x03\x02\0\x08\x12\x04\xa6\x028I\n\r\n\x05\x04\x03\x02\0\x07\
    \x12\x04\xa6\x02CH\n\x0c\n\x04\x04\x03\x02\x01\x12\x04\xa7\x02\x08Z\n\r\
    \n\x05\x04\x03\x02\x01\x04\x12\x04\xa7\x02\x08\x10\n\r\n\x05\x04\x03\x02\
    \x01\x06\x12\x04\xa7\x02\x11\x1f\n\r\n\x05\x04\x03\x02\x01\x01\x12\x04\
    \xa7\x02\x201\n\r\n\x05\x04\x03\x02\x01\x03\x12\x04\xa7\x0245\n\r\n\x05\
    \x04\x03\x02\x01\x08\x12\x04\xa7\x026Y\n\r\n\x05\x04\x03\x02\x01\x07\x12\
    \x04\xa7\x02AX\n\x0c\n\x04\x04\x03\x02\x02\x12\x04\xa8\x02\x08=\n\r\n\
    \x05\x04\x03\x02\x02\x04\x12\x04\xa8\x02\x08\x10\n\r\n\x05\x04\x03\x02\
    \x02\x05\x12\x04\xa8\x02\x11\x18\n\r\n\x05\x04\x03\x02\x02\x01\x12\x04\
    \xa8\x02\x19*\n\r\n\x05\x04\x03\x02\x02\x03\x12\x04\xa8\x02-.\n\r\n\x05\
    \x04\x03\x02\x02\x08\x12\x04\xa8\x02/<\n\r\n\x05\x04\x03\x02\x02\x07\x12\
    \x04\xa8\x02:;\n\x0c\n\x04\x04\x03\x02\x03\x12\x04\xa9\x02\x082\n\r\n\
    \x05\x04\x03\x02\x03\x04\x12\x04\xa9\x02\x08\x10\n\r\n\x05\x04\x03\x02\
    \x03\x05\x12\x04\xa9\x02\x11\x17\n\r\n\x05\x04\x03\x02\x03\x01\x12\x04\
    \xa9\x02\x18-\n\r\n\x05\x04\x03\x02\x03\x03\x12\x04\xa9\x0201\n\x0c\n\
    \x04\x04\x03\x02\x04\x12\x04\xaa\x02\x08:\n\r\n\x05\x04\x03\x02\x04\x04\
    \x12\x04\xaa\x02\x08\x10\n\r\n\x05\x04\x03\x02\x04\x06\x12\x04\xaa\x02\
    \x11\x1f\n\r\n\x05\x04\x03\x02\x04\x01\x12\x04\xaa\x02\x205\n\r\n\x05\
    \x04\x03\x02\x04\x03\x12\x04\xaa\x0289\n\x0c\n\x02\x04\x04\x12\x06\xad\
    \x02\0\xb4\x02\x01\n\x0b\n\x03\x04\x04\x01\x12\x04\xad\x02\x08\x18\n\x0c\
    \n\x04\x04\x04\x02\0\x12\x04\xae\x02\x08<\n\r\n\x05\x04\x04\x02\0\x04\
    \x12\x04\xae\x02\x08\x10\n\r\n\x05\x04\x04\x02\0\x05\x12\x04\xae\x02\x11\
    \x17\n\r\n\x05\x04\x04\x02\0\x01\x12\x04\xae\x02\x18\"\n\r\n\x05\x04\x04\
    \x02\0\x03\x12\x04\xae\x02%&\n\r\n\x05\x04\x04\x02\0\x08\x12\x04\xae\x02\
    ';\n\x10\n\x08\x04\x04\x02\0\x08\xe0\xd4\x03\x12\x04\xae\x02(:\n\x0c\n\
    \x04\x04\x04\x02\x01\x12\x04\xaf\x02\x08&\n\r\n\x05\x04\x04\x02\x01\x04\
    \x12\x04\xaf\x02\x08\x10\n\r\n\x05\x04\x04\x02\x01\x05\x12\x04\xaf\x02\
    \x11\x17\n\r\n\x05\x04\x04\x02\x01\x01\x12\x04\xaf\x02\x18!\n\r\n\x05\
    \x04\x04\x02\x01\x03\x12\x04\xaf\x02$%\n\x0c\n\x04\x04\x04\x02\x02\x12\
    \x04\xb0\x02\x08(\n\r\n\x05\x04\x04\x02\x02\x04\x12\x04\xb0\x02\x08\x10\
    \n\r\n\x05\x04\x04\x02\x02\x05\x12\x04\xb0\x02\x11\x17\n\r\n\x05\x04\x04\
    \x02\x02\x01\x12\x04\xb0\x02\x18#\n\r\n\x05\x04\x04\x02\x02\x03\x12\x04\
    \xb0\x02&'\n\x0c\n\x04\x04\x04\x02\x03\x12\x04\xb1\x02\x081\n\r\n\x05\
    \x04\x04\x02\x03\x04\x12\x04\xb1\x02\x08\x10\n\r\n\x05\x04\x04\x02\x03\
    \x05\x12\x04\xb1\x02\x11\x17\n\r\n\x05\x04\x04\x02\x03\x01\x12\x04\xb1\
    \x02\x18,\n\r\n\x05\x04\x04\x02\x03\x03\x12\x04\xb1\x02/0\n\x0c\n\x04\
    \x04\x04\x02\x04\x12\x04\xb2\x02\x080\n\r\n\x05\x04\x04\x02\x04\x04\x12\
    \x04\xb2\x02\x08\x10\n\r\n\x05\x04\x04\x02\x04\x05\x12\x04\xb2\x02\x11\
    \x17\n\r\n\x05\x04\x04\x02\x04\x01\x12\x04\xb2\x02\x18+\n\r\n\x05\x04\
    \x04\x02\x04\x03\x12\x04\xb2\x02./\n\x0c\n\x04\x04\x04\x02\x05\x12\x04\
    \xb3\x02\x08-\n\r\n\x05\x04\x04\x02\x05\x04\x12\x04\xb3\x02\x08\x10\n\r\
    \n\x05\x04\x04\x02\x05\x05\x12\x04\xb3\x02\x11\x17\n\r\n\x05\x04\x04\x02\
    \x05\x01\x12\x04\xb3\x02\x18(\n\r\n\x05\x04\x04\x02\x05\x03\x12\x04\xb3\
    \x02+,\n\x0c\n\x02\x04\x05\x12\x06\xb6\x02\0\xba\x02\x01\n\x0b\n\x03\x04\
    \x05\x01\x12\x04\xb6\x02\x08\x1c\n\x0c\n\x04\x04\x05\x02\0\x12\x04\xb7\
    \x02\x08<\n\r\n\x05\x04\x05\x02\0\x04\x12\x04\xb7\x02\x08\x10\n\r\n\x05\
    \x04\x05\x02\0\x05\x12\x04\xb7\x02\x11\x17\n\r\n\x05\x04\x05\x02\0\x01\
    \x12\x04\xb7\x02\x18\"\n\r\n\x05\x04\x05\x02\0\x03\x12\x04\xb7\x02%&\n\r\
    \n\x05\x04\x05\x02\0\x08\x12\x04\xb7\x02';\n\x10\n\x08\x04\x05\x02\0\x08\
    \xe0\xd4\x03\x12\x04\xb7\x02(:\n\x0c\n\x04\x04\x05\x02\x01\x12\x04\xb8\
    \x02\x08;\n\r\n\x05\x04\x05\x02\x01\x04\x12\x04\xb8\x02\x08\x10\n\r\n\
    \x05\x04\x05\x02\x01\x05\x12\x04\xb8\x02\x11\x17\n\r\n\x05\x04\x05\x02\
    \x01\x01\x12\x04\xb8\x02\x18!\n\r\n\x05\x04\x05\x02\x01\x03\x12\x04\xb8\
    \x02$%\n\r\n\x05\x04\x05\x02\x01\x08\x12\x04\xb8\x02&:\n\x10\n\x08\x04\
    \x05\x02\x01\x08\xe0\xd4\x03\x12\x04\xb8\x02'9\n\x0c\n\x04\x04\x05\x02\
    \x02\x12\x04\xb9\x02\x08/\n\r\n\x05\x04\x05\x02\x02\x04\x12\x04\xb9\x02\
    \x08\x10\n\r\n\x05\x04\x05\x02\x02\x05\x12\x04\xb9\x02\x11\x17\n\r\n\x05\
    \x04\x05\x02\x02\x01\x12\x04\xb9\x02\x18*\n\r\n\x05\x04\x05\x02\x02\x03\
    \x12\x04\xb9\x02-.\n\x0c\n\x02\x04\x06\x12\x06\xbc\x02\0\xbe\x02\x01\n\
    \x0b\n\x03\x04\x06\x01\x12\x04\xbc\x02\x08.\n\x0c\n\x04\x04\x06\x02\0\
    \x12\x04\xbd\x02\x08.\n\r\n\x05\x04\x06\x02\0\x04\x12\x04\xbd\x02\x08\
    \x10\n\r\n\x05\x04\x06\x02\0\x05\x12\x04\xbd\x02\x11\x17\n\r\n\x05\x04\
    \x06\x02\0\x01\x12\x04\xbd\x02\x18)\n\r\n\x05\x04\x06\x02\0\x03\x12\x04\
    \xbd\x02,-\n\x0c\n\x02\x04\x07\x12\x06\xc0\x02\0\xc2\x02\x01\n\x0b\n\x03\
    \x04\x07\x01\x12\x04\xc0\x02\x08\x1f\n\x0c\n\x04\x04\x07\x02\0\x12\x04\
    \xc1\x02\x08(\n\r\n\x05\x04\x07\x02\0\x04\x12\x04\xc1\x02\x08\x10\n\r\n\
    \x05\x04\x07\x02\0\x05\x12\x04\xc1\x02\x11\x17\n\r\n\x05\x04\x07\x02\0\
    \x01\x12\x04\xc1\x02\x18#\n\r\n\x05\x04\x07\x02\0\x03\x12\x04\xc1\x02&'\
    \n\x0c\n\x02\x04\x08\x12\x06\xc4\x02\0\xc6\x02\x01\n\x0b\n\x03\x04\x08\
    \x01\x12\x04\xc4\x02\x08'\n\x0c\n\x04\x04\x08\x02\0\x12\x04\xc5\x02\x08(\
    \n\r\n\x05\x04\x08\x02\0\x04\x12\x04\xc5\x02\x08\x10\n\r\n\x05\x04\x08\
    \x02\0\x05\x12\x04\xc5\x02\x11\x17\n\r\n\x05\x04\x08\x02\0\x01\x12\x04\
    \xc5\x02\x18#\n\r\n\x05\x04\x08\x02\0\x03\x12\x04\xc5\x02&'\n\x0c\n\x02\
    \x04\t\x12\x06\xc8\x02\0\xca\x02\x01\n\x0b\n\x03\x04\t\x01\x12\x04\xc8\
    \x02\x08\x17\n\x0c\n\x04\x04\t\x02\0\x12\x04\xc9\x02\x081\n\r\n\x05\x04\
    \t\x02\0\x04\x12\x04\xc9\x02\x08\x10\n\r\n\x05\x04\t\x02\0\x05\x12\x04\
    \xc9\x02\x11\x17\n\r\n\x05\x04\t\x02\0\x01\x12\x04\xc9\x02\x18,\n\r\n\
    \x05\x04\t\x02\0\x03\x12\x04\xc9\x02/0\n\x0c\n\x02\x04\n\x12\x06\xcc\x02\
    \0\xce\x02\x01\n\x0b\n\x03\x04\n\x01\x12\x04\xcc\x02\x08\x1e\n\x0c\n\x04\
    \x04\n\x02\0\x12\x04\xcd\x02\x08-\n\r\n\x05\x04\n\x02\0\x04\x12\x04\xcd\
    \x02\x08\x10\n\r\n\x05\x04\n\x02\0\x05\x12\x04\xcd\x02\x11\x17\n\r\n\x05\
    \x04\n\x02\0\x01\x12\x04\xcd\x02\x18(\n\r\n\x05\x04\n\x02\0\x03\x12\x04\
    \xcd\x02+,\n\x0c\n\x02\x04\x0b\x12\x06\xd0\x02\0\xd1\x02\x01\n\x0b\n\x03\
    \x04\x0b\x01\x12\x04\xd0\x02\x08\x1c\n\x0c\n\x02\x04\x0c\x12\x06\xd3\x02\
    \0\xd4\x02\x01\n\x0b\n\x03\x04\x0c\x01\x12\x04\xd3\x02\x08)\n\x0c\n\x02\
    \x04\r\x12\x06\xd6\x02\0\xd9\x02\x01\n\x0b\n\x03\x04\r\x01\x12\x04\xd6\
    \x02\x08\x18\n\x0c\n\x04\x04\r\x02\0\x12\x04\xd7\x02\x08%\n\r\n\x05\x04\
    \r\x02\0\x04\x12\x04\xd7\x02\x08\x10\n\r\n\x05\x04\r\x02\0\x05\x12\x04\
    \xd7\x02\x11\x17\n\r\n\x05\x04\r\x02\0\x01\x12\x04\xd7\x02\x18\x20\n\r\n\
    \x05\x04\r\x02\0\x03\x12\x04\xd7\x02#$\n\x0c\n\x04\x04\r\x02\x01\x12\x04\
    \xd8\x02\x08)\n\r\n\x05\x04\r\x02\x01\x04\x12\x04\xd8\x02\x08\x10\n\r\n\
    \x05\x04\r\x02\x01\x05\x12\x04\xd8\x02\x11\x17\n\r\n\x05\x04\r\x02\x01\
    \x01\x12\x04\xd8\x02\x18$\n\r\n\x05\x04\r\x02\x01\x03\x12\x04\xd8\x02'(\
    \n\x0c\n\x02\x04\x0e\x12\x06\xdb\x02\0\xde\x02\x01\n\x0b\n\x03\x04\x0e\
    \x01\x12\x04\xdb\x02\x08$\n\x0c\n\x04\x04\x0e\x02\0\x12\x04\xdc\x02\x08(\
    \n\r\n\x05\x04\x0e\x02\0\x04\x12\x04\xdc\x02\x08\x10\n\r\n\x05\x04\x0e\
    \x02\0\x05\x12\x04\xdc\x02\x11\x17\n\r\n\x05\x04\x0e\x02\0\x01\x12\x04\
    \xdc\x02\x18#\n\r\n\x05\x04\x0e\x02\0\x03\x12\x04\xdc\x02&'\n\x0c\n\x04\
    \x04\x0e\x02\x01\x12\x04\xdd\x02\x08%\n\r\n\x05\x04\x0e\x02\x01\x04\x12\
    \x04\xdd\x02\x08\x10\n\r\n\x05\x04\x0e\x02\x01\x05\x12\x04\xdd\x02\x11\
    \x17\n\r\n\x05\x04\x0e\x02\x01\x01\x12\x04\xdd\x02\x18\x20\n\r\n\x05\x04\
    \x0e\x02\x01\x03\x12\x04\xdd\x02#$\n\x0c\n\x02\x04\x0f\x12\x06\xe0\x02\0\
    \xe2\x02\x01\n\x0b\n\x03\x04\x0f\x01\x12\x04\xe0\x02\x08,\n\x0c\n\x04\
    \x04\x0f\x02\0\x12\x04\xe1\x02\x08\"\n\r\n\x05\x04\x0f\x02\0\x04\x12\x04\
    \xe1\x02\x08\x10\n\r\n\x05\x04\x0f\x02\0\x05\x12\x04\xe1\x02\x11\x15\n\r\
    \n\x05\x04\x0f\x02\0\x01\x12\x04\xe1\x02\x16\x1d\n\r\n\x05\x04\x0f\x02\0\
    \x03\x12\x04\xe1\x02\x20!\n\x0c\n\x02\x04\x10\x12\x06\xe4\x02\0\xe9\x02\
    \x01\n\x0b\n\x03\x04\x10\x01\x12\x04\xe4\x02\x08\x20\n\x0c\n\x04\x04\x10\
    \x02\0\x12\x04\xe5\x02\x08'\n\r\n\x05\x04\x10\x02\0\x04\x12\x04\xe5\x02\
    \x08\x10\n\r\n\x05\x04\x10\x02\0\x05\x12\x04\xe5\x02\x11\x18\n\r\n\x05\
    \x04\x10\x02\0\x01\x12\x04\xe5\x02\x19\"\n\r\n\x05\x04\x10\x02\0\x03\x12\
    \x04\xe5\x02%&\n\x0c\n\x04\x04\x10\x02\x01\x12\x04\xe6\x02\x08/\n\r\n\
    \x05\x04\x10\x02\x01\x04\x12\x04\xe6\x02\x08\x10\n\r\n\x05\x04\x10\x02\
    \x01\x05\x12\x04\xe6\x02\x11\x17\n\r\n\x05\x04\x10\x02\x01\x01\x12\x04\
    \xe6\x02\x18*\n\r\n\x05\x04\x10\x02\x01\x03\x12\x04\xe6\x02-.\n\x0c\n\
    \x04\x04\x10\x02\x02\x12\x04\xe7\x02\x08,\n\r\n\x05\x04\x10\x02\x02\x04\
    \x12\x04\xe7\x02\x08\x10\n\r\n\x05\x04\x10\x02\x02\x05\x12\x04\xe7\x02\
    \x11\x17\n\r\n\x05\x04\x10\x02\x02\x01\x12\x04\xe7\x02\x18'\n\r\n\x05\
    \x04\x10\x02\x02\x03\x12\x04\xe7\x02*+\n\x0c\n\x04\x04\x10\x02\x03\x12\
    \x04\xe8\x02\x08/\n\r\n\x05\x04\x10\x02\x03\x04\x12\x04\xe8\x02\x08\x10\
    \n\r\n\x05\x04\x10\x02\x03\x05\x12\x04\xe8\x02\x11\x17\n\r\n\x05\x04\x10\
    \x02\x03\x01\x12\x04\xe8\x02\x18*\n\r\n\x05\x04\x10\x02\x03\x03\x12\x04\
    \xe8\x02-.\n\x0c\n\x02\x04\x11\x12\x06\xeb\x02\0\xec\x02\x01\n\x0b\n\x03\
    \x04\x11\x01\x12\x04\xeb\x02\x08#\n\x0c\n\x02\x04\x12\x12\x06\xee\x02\0\
    \xef\x02\x01\n\x0b\n\x03\x04\x12\x01\x12\x04\xee\x02\x08(\n\x0c\n\x02\
    \x04\x13\x12\x06\xf1\x02\0\xf3\x02\x01\n\x0b\n\x03\x04\x13\x01\x12\x04\
    \xf1\x02\x08\x20\n\x0c\n\x04\x04\x13\x02\0\x12\x04\xf2\x02\x087\n\r\n\
    \x05\x04\x13\x02\0\x04\x12\x04\xf2\x02\x08\x10\n\r\n\x05\x04\x13\x02\0\
    \x05\x12\x04\xf2\x02\x11\x17\n\r\n\x05\x04\x13\x02\0\x01\x12\x04\xf2\x02\
    \x182\n\r\n\x05\x04\x13\x02\0\x03\x12\x04\xf2\x0256\n\x0c\n\x02\x04\x14\
    \x12\x06\xf5\x02\0\xf9\x02\x01\n\x0b\n\x03\x04\x14\x01\x12\x04\xf5\x02\
    \x08(\n\x0c\n\x04\x04\x14\x02\0\x12\x04\xf6\x02\x08&\n\r\n\x05\x04\x14\
    \x02\0\x04\x12\x04\xf6\x02\x08\x10\n\r\n\x05\x04\x14\x02\0\x05\x12\x04\
    \xf6\x02\x11\x15\n\r\n\x05\x04\x14\x02\0\x01\x12\x04\xf6\x02\x16!\n\r\n\
    \x05\x04\x14\x02\0\x03\x12\x04\xf6\x02$%\n\x0c\n\x04\x04\x14\x02\x01\x12\
    \x04\xf7\x02\x08&\n\r\n\x05\x04\x14\x02\x01\x04\x12\x04\xf7\x02\x08\x10\
    \n\r\n\x05\x04\x14\x02\x01\x05\x12\x04\xf7\x02\x11\x17\n\r\n\x05\x04\x14\
    \x02\x01\x01\x12\x04\xf7\x02\x18!\n\r\n\x05\x04\x14\x02\x01\x03\x12\x04\
    \xf7\x02$%\n\x0c\n\x04\x04\x14\x02\x02\x12\x04\xf8\x02\x08'\n\r\n\x05\
    \x04\x14\x02\x02\x04\x12\x04\xf8\x02\x08\x10\n\r\n\x05\x04\x14\x02\x02\
    \x05\x12\x04\xf8\x02\x11\x17\n\r\n\x05\x04\x14\x02\x02\x01\x12\x04\xf8\
    \x02\x18\"\n\r\n\x05\x04\x14\x02\x02\x03\x12\x04\xf8\x02%&\n\x0c\n\x02\
    \x04\x15\x12\x06\xfb\x02\0\xfe\x02\x01\n\x0b\n\x03\x04\x15\x01\x12\x04\
    \xfb\x02\x08\x1f\n\x0c\n\x04\x04\x15\x02\0\x12\x04\xfc\x02\x08/\n\r\n\
    \x05\x04\x15\x02\0\x04\x12\x04\xfc\x02\x08\x10\n\r\n\x05\x04\x15\x02\0\
    \x05\x12\x04\xfc\x02\x11\x17\n\r\n\x05\x04\x15\x02\0\x01\x12\x04\xfc\x02\
    \x18*\n\r\n\x05\x04\x15\x02\0\x03\x12\x04\xfc\x02-.\n\x0c\n\x04\x04\x15\
    \x02\x01\x12\x04\xfd\x02\x08,\n\r\n\x05\x04\x15\x02\x01\x04\x12\x04\xfd\
    \x02\x08\x10\n\r\n\x05\x04\x15\x02\x01\x05\x12\x04\xfd\x02\x11\x15\n\r\n\
    \x05\x04\x15\x02\x01\x01\x12\x04\xfd\x02\x16'\n\r\n\x05\x04\x15\x02\x01\
    \x03\x12\x04\xfd\x02*+\n\x0c\n\x02\x04\x16\x12\x06\x80\x03\0\x82\x03\x01\
    \n\x0b\n\x03\x04\x16\x01\x12\x04\x80\x03\x08'\n\x0c\n\x04\x04\x16\x02\0\
    \x12\x04\x81\x03\x085\n\r\n\x05\x04\x16\x02\0\x04\x12\x04\x81\x03\x08\
    \x10\n\r\n\x05\x04\x16\x02\0\x05\x12\x04\x81\x03\x11\x15\n\r\n\x05\x04\
    \x16\x02\0\x01\x12\x04\x81\x03\x160\n\r\n\x05\x04\x16\x02\0\x03\x12\x04\
    \x81\x0334\n\x0c\n\x02\x04\x17\x12\x06\x84\x03\0\x89\x03\x01\n\x0b\n\x03\
    \x04\x17\x01\x12\x04\x84\x03\x08$\n\x0c\n\x04\x04\x17\x02\0\x12\x04\x85\
    \x03\x08$\n\r\n\x05\x04\x17\x02\0\x04\x12\x04\x85\x03\x08\x10\n\r\n\x05\
    \x04\x17\x02\0\x05\x12\x04\x85\x03\x11\x15\n\r\n\x05\x04\x17\x02\0\x01\
    \x12\x04\x85\x03\x16\x1f\n\r\n\x05\x04\x17\x02\0\x03\x12\x04\x85\x03\"#\
    \n\x0c\n\x04\x04\x17\x02\x01\x12\x04\x86\x03\x08+\n\r\n\x05\x04\x17\x02\
    \x01\x04\x12\x04\x86\x03\x08\x10\n\r\n\x05\x04\x17\x02\x01\x05\x12\x04\
    \x86\x03\x11\x17\n\r\n\x05\x04\x17\x02\x01\x01\x12\x04\x86\x03\x18&\n\r\
    \n\x05\x04\x17\x02\x01\x03\x12\x04\x86\x03)*\n\x0c\n\x04\x04\x17\x02\x02\
    \x12\x04\x87\x03\x08(\n\r\n\x05\x04\x17\x02\x02\x04\x12\x04\x87\x03\x08\
    \x10\n\r\n\x05\x04\x17\x02\x02\x05\x12\x04\x87\x03\x11\x17\n\r\n\x05\x04\
    \x17\x02\x02\x01\x12\x04\x87\x03\x18#\n\r\n\x05\x04\x17\x02\x02\x03\x12\
    \x04\x87\x03&'\n\x0c\n\x04\x04\x17\x02\x03\x12\x04\x88\x03\x08/\n\r\n\
    \x05\x04\x17\x02\x03\x04\x12\x04\x88\x03\x08\x10\n\r\n\x05\x04\x17\x02\
    \x03\x05\x12\x04\x88\x03\x11\x17\n\r\n\x05\x04\x17\x02\x03\x01\x12\x04\
    \x88\x03\x18*\n\r\n\x05\x04\x17\x02\x03\x03\x12\x04\x88\x03-.\n\x0c\n\
    \x02\x04\x18\x12\x06\x8b\x03\0\x8e\x03\x01\n\x0b\n\x03\x04\x18\x01\x12\
    \x04\x8b\x03\x08#\n\x0c\n\x04\x04\x18\x02\0\x12\x04\x8c\x03\x08-\n\r\n\
    \x05\x04\x18\x02\0\x04\x12\x04\x8c\x03\x08\x10\n\r\n\x05\x04\x18\x02\0\
    \x05\x12\x04\x8c\x03\x11\x17\n\r\n\x05\x04\x18\x02\0\x01\x12\x04\x8c\x03\
    \x18(\n\r\n\x05\x04\x18\x02\0\x03\x12\x04\x8c\x03+,\n\x0c\n\x04\x04\x18\
    \x02\x01\x12\x04\x8d\x03\x08/\n\r\n\x05\x04\x18\x02\x01\x04\x12\x04\x8d\
    \x03\x08\x10\n\r\n\x05\x04\x18\x02\x01\x05\x12\x04\x8d\x03\x11\x17\n\r\n\
    \x05\x04\x18\x02\x01\x01\x12\x04\x8d\x03\x18*\n\r\n\x05\x04\x18\x02\x01\
    \x03\x12\x04\x8d\x03-.\n\x0c\n\x02\x04\x19\x12\x06\x90\x03\0\x92\x03\x01\
    \n\x0b\n\x03\x04\x19\x01\x12\x04\x90\x03\x08\"\n\x0c\n\x04\x04\x19\x02\0\
    \x12\x04\x91\x03\x08-\n\r\n\x05\x04\x19\x02\0\x04\x12\x04\x91\x03\x08\
    \x10\n\r\n\x05\x04\x19\x02\0\x05\x12\x04\x91\x03\x11\x17\n\r\n\x05\x04\
    \x19\x02\0\x01\x12\x04\x91\x03\x18(\n\r\n\x05\x04\x19\x02\0\x03\x12\x04\
    \x91\x03+,\n\x0c\n\x02\x04\x1a\x12\x06\x94\x03\0\x96\x03\x01\n\x0b\n\x03\
    \x04\x1a\x01\x12\x04\x94\x03\x08'\n\x0c\n\x04\x04\x1a\x02\0\x12\x04\x95\
    \x03\x08%\n\r\n\x05\x04\x1a\x02\0\x04\x12\x04\x95\x03\x08\x10\n\r\n\x05\
    \x04\x1a\x02\0\x05\x12\x04\x95\x03\x11\x15\n\r\n\x05\x04\x1a\x02\0\x01\
    \x12\x04\x95\x03\x16\x20\n\r\n\x05\x04\x1a\x02\0\x03\x12\x04\x95\x03#$\n\
    \x0c\n\x02\x04\x1b\x12\x06\x98\x03\0\x9a\x03\x01\n\x0b\n\x03\x04\x1b\x01\
    \x12\x04\x98\x03\x08)\n\x0c\n\x04\x04\x1b\x02\0\x12\x04\x99\x03\x08-\n\r\
    \n\x05\x04\x1b\x02\0\x04\x12\x04\x99\x03\x08\x10\n\r\n\x05\x04\x1b\x02\0\
    \x05\x12\x04\x99\x03\x11\x17\n\r\n\x05\x04\x1b\x02\0\x01\x12\x04\x99\x03\
    \x18(\n\r\n\x05\x04\x1b\x02\0\x03\x12\x04\x99\x03+,\n\x0c\n\x02\x04\x1c\
    \x12\x06\x9c\x03\0\xa7\x03\x01\n\x0b\n\x03\x04\x1c\x01\x12\x04\x9c\x03\
    \x08$\n\x0e\n\x04\x04\x1c\x03\0\x12\x06\x9d\x03\x08\xa4\x03\t\n\r\n\x05\
    \x04\x1c\x03\0\x01\x12\x04\x9d\x03\x10\x1a\n\x0e\n\x06\x04\x1c\x03\0\x02\
    \0\x12\x04\x9e\x03\x103\n\x0f\n\x07\x04\x1c\x03\0\x02\0\x04\x12\x04\x9e\
    \x03\x10\x18\n\x0f\n\x07\x04\x1c\x03\0\x02\0\x05\x12\x04\x9e\x03\x19\x1f\
    \n\x0f\n\x07\x04\x1c\x03\0\x02\0\x01\x12\x04\x9e\x03\x20.\n\x0f\n\x07\
    \x04\x1c\x03\0\x02\0\x03\x12\x04\x9e\x0312\n\x0e\n\x06\x04\x1c\x03\0\x02\
    \x01\x12\x04\x9f\x03\x100\n\x0f\n\x07\x04\x1c\x03\0\x02\x01\x04\x12\x04\
    \x9f\x03\x10\x18\n\x0f\n\x07\x04\x1c\x03\0\x02\x01\x05\x12\x04\x9f\x03\
    \x19\x1f\n\x0f\n\x07\x04\x1c\x03\0\x02\x01\x01\x12\x04\x9f\x03\x20+\n\
    \x0f\n\x07\x04\x1c\x03\0\x02\x01\x03\x12\x04\x9f\x03./\n\x0e\n\x06\x04\
    \x1c\x03\0\x02\x02\x12\x04\xa0\x03\x10.\n\x0f\n\x07\x04\x1c\x03\0\x02\
    \x02\x04\x12\x04\xa0\x03\x10\x18\n\x0f\n\x07\x04\x1c\x03\0\x02\x02\x05\
    \x12\x04\xa0\x03\x19\x1f\n\x0f\n\x07\x04\x1c\x03\0\x02\x02\x01\x12\x04\
    \xa0\x03\x20)\n\x0f\n\x07\x04\x1c\x03\0\x02\x02\x03\x12\x04\xa0\x03,-\n\
    \x0e\n\x06\x04\x1c\x03\0\x02\x03\x12\x04\xa1\x03\x10-\n\x0f\n\x07\x04\
    \x1c\x03\0\x02\x03\x04\x12\x04\xa1\x03\x10\x18\n\x0f\n\x07\x04\x1c\x03\0\
    \x02\x03\x05\x12\x04\xa1\x03\x19\x1f\n\x0f\n\x07\x04\x1c\x03\0\x02\x03\
    \x01\x12\x04\xa1\x03\x20(\n\x0f\n\x07\x04\x1c\x03\0\x02\x03\x03\x12\x04\
    \xa1\x03+,\n\x0e\n\x06\x04\x1c\x03\0\x02\x04\x12\x04\xa2\x03\x10.\n\x0f\
    \n\x07\x04\x1c\x03\0\x02\x04\x04\x12\x04\xa2\x03\x10\x18\n\x0f\n\x07\x04\
    \x1c\x03\0\x02\x04\x05\x12\x04\xa2\x03\x19\x1f\n\x0f\n\x07\x04\x1c\x03\0\
    \x02\x04\x01\x12\x04\xa2\x03\x20)\n\x0f\n\x07\x04\x1c\x03\0\x02\x04\x03\
    \x12\x04\xa2\x03,-\n\x0e\n\x06\x04\x1c\x03\0\x02\x05\x12\x04\xa3\x03\x10\
    .\n\x0f\n\x07\x04\x1c\x03\0\x02\x05\x04\x12\x04\xa3\x03\x10\x18\n\x0f\n\
    \x07\x04\x1c\x03\0\x02\x05\x05\x12\x04\xa3\x03\x19\x1e\n\x0f\n\x07\x04\
    \x1c\x03\0\x02\x05\x01\x12\x04\xa3\x03\x1f)\n\x0f\n\x07\x04\x1c\x03\0\
    \x02\x05\x03\x12\x04\xa3\x03,-\n\x0c\n\x04\x04\x1c\x02\0\x12\x04\xa6\x03\
    \x08F\n\r\n\x05\x04\x1c\x02\0\x04\x12\x04\xa6\x03\x08\x10\n\r\n\x05\x04\
    \x1c\x02\0\x06\x12\x04\xa6\x03\x119\n\r\n\x05\x04\x1c\x02\0\x01\x12\x04\
    \xa6\x03:A\n\r\n\x05\x04\x1c\x02\0\x03\x12\x04\xa6\x03DE\n\x0c\n\x02\x04\
    \x1d\x12\x06\xa9\x03\0\xb3\x03\x01\n\x0b\n\x03\x04\x1d\x01\x12\x04\xa9\
    \x03\x08,\n\x0e\n\x04\x04\x1d\x03\0\x12\x06\xaa\x03\x08\xb0\x03\t\n\r\n\
    \x05\x04\x1d\x03\0\x01\x12\x04\xaa\x03\x10\x1a\n\x0e\n\x06\x04\x1d\x03\0\
    \x02\0\x12\x04\xab\x03\x103\n\x0f\n\x07\x04\x1d\x03\0\x02\0\x04\x12\x04\
    \xab\x03\x10\x18\n\x0f\n\x07\x04\x1d\x03\0\x02\0\x05\x12\x04\xab\x03\x19\
    \x1f\n\x0f\n\x07\x04\x1d\x03\0\x02\0\x01\x12\x04\xab\x03\x20.\n\x0f\n\
    \x07\x04\x1d\x03\0\x02\0\x03\x12\x04\xab\x0312\n\x0e\n\x06\x04\x1d\x03\0\
    \x02\x01\x12\x04\xac\x03\x100\n\x0f\n\x07\x04\x1d\x03\0\x02\x01\x04\x12\
    \x04\xac\x03\x10\x18\n\x0f\n\x07\x04\x1d\x03\0\x02\x01\x05\x12\x04\xac\
    \x03\x19\x1f\n\x0f\n\x07\x04\x1d\x03\0\x02\x01\x01\x12\x04\xac\x03\x20+\
    \n\x0f\n\x07\x04\x1d\x03\0\x02\x01\x03\x12\x04\xac\x03./\n\x0e\n\x06\x04\
    \x1d\x03\0\x02\x02\x12\x04\xad\x03\x10/\n\x0f\n\x07\x04\x1d\x03\0\x02\
    \x02\x04\x12\x04\xad\x03\x10\x18\n\x0f\n\x07\x04\x1d\x03\0\x02\x02\x05\
    \x12\x04\xad\x03\x19\x1e\n\x0f\n\x07\x04\x1d\x03\0\x02\x02\x01\x12\x04\
    \xad\x03\x1f*\n\x0f\n\x07\x04\x1d\x03\0\x02\x02\x03\x12\x04\xad\x03-.\n\
    \x0e\n\x06\x04\x1d\x03\0\x02\x03\x12\x04\xae\x03\x10-\n\x0f\n\x07\x04\
    \x1d\x03\0\x02\x03\x04\x12\x04\xae\x03\x10\x18\n\x0f\n\x07\x04\x1d\x03\0\
    \x02\x03\x05\x12\x04\xae\x03\x19\x1f\n\x0f\n\x07\x04\x1d\x03\0\x02\x03\
    \x01\x12\x04\xae\x03\x20(\n\x0f\n\x07\x04\x1d\x03\0\x02\x03\x03\x12\x04\
    \xae\x03+,\n\x0e\n\x06\x04\x1d\x03\0\x02\x04\x12\x04\xaf\x03\x102\n\x0f\
    \n\x07\x04\x1d\x03\0\x02\x04\x04\x12\x04\xaf\x03\x10\x18\n\x0f\n\x07\x04\
    \x1d\x03\0\x02\x04\x05\x12\x04\xaf\x03\x19\x1f\n\x0f\n\x07\x04\x1d\x03\0\
    \x02\x04\x01\x12\x04\xaf\x03\x20-\n\x0f\n\x07\x04\x1d\x03\0\x02\x04\x03\
    \x12\x04\xaf\x0301\n\x0c\n\x04\x04\x1d\x02\0\x12\x04\xb2\x03\x08N\n\r\n\
    \x05\x04\x1d\x02\0\x04\x12\x04\xb2\x03\x08\x10\n\r\n\x05\x04\x1d\x02\0\
    \x06\x12\x04\xb2\x03\x11A\n\r\n\x05\x04\x1d\x02\0\x01\x12\x04\xb2\x03BI\
    \n\r\n\x05\x04\x1d\x02\0\x03\x12\x04\xb2\x03LM\n\x0c\n\x02\x04\x1e\x12\
    \x06\xb5\x03\0\xb7\x03\x01\n\x0b\n\x03\x04\x1e\x01\x12\x04\xb5\x03\x08%\
    \n\x0c\n\x04\x04\x1e\x02\0\x12\x04\xb6\x03\x08'\n\r\n\x05\x04\x1e\x02\0\
    \x04\x12\x04\xb6\x03\x08\x10\n\r\n\x05\x04\x1e\x02\0\x05\x12\x04\xb6\x03\
    \x11\x17\n\r\n\x05\x04\x1e\x02\0\x01\x12\x04\xb6\x03\x18\"\n\r\n\x05\x04\
    \x1e\x02\0\x03\x12\x04\xb6\x03%&\n\x0c\n\x02\x04\x1f\x12\x06\xb9\x03\0\
    \xbc\x03\x01\n\x0b\n\x03\x04\x1f\x01\x12\x04\xb9\x03\x08#\n\x0c\n\x04\
    \x04\x1f\x02\0\x12\x04\xba\x03\x08'\n\r\n\x05\x04\x1f\x02\0\x04\x12\x04\
    \xba\x03\x08\x10\n\r\n\x05\x04\x1f\x02\0\x05\x12\x04\xba\x03\x11\x15\n\r\
    \n\x05\x04\x1f\x02\0\x01\x12\x04\xba\x03\x16\"\n\r\n\x05\x04\x1f\x02\0\
    \x03\x12\x04\xba\x03%&\n\x0c\n\x04\x04\x1f\x02\x01\x12\x04\xbb\x03\x08'\
    \n\r\n\x05\x04\x1f\x02\x01\x04\x12\x04\xbb\x03\x08\x10\n\r\n\x05\x04\x1f\
    \x02\x01\x05\x12\x04\xbb\x03\x11\x17\n\r\n\x05\x04\x1f\x02\x01\x01\x12\
    \x04\xbb\x03\x18\"\n\r\n\x05\x04\x1f\x02\x01\x03\x12\x04\xbb\x03%&\n\x0c\
    \n\x02\x04\x20\x12\x06\xbe\x03\0\xc0\x03\x01\n\x0b\n\x03\x04\x20\x01\x12\
    \x04\xbe\x03\x08'\n\x0c\n\x04\x04\x20\x02\0\x12\x04\xbf\x03\x08-\n\r\n\
    \x05\x04\x20\x02\0\x04\x12\x04\xbf\x03\x08\x10\n\r\n\x05\x04\x20\x02\0\
    \x05\x12\x04\xbf\x03\x11\x17\n\r\n\x05\x04\x20\x02\0\x01\x12\x04\xbf\x03\
    \x18(\n\r\n\x05\x04\x20\x02\0\x03\x12\x04\xbf\x03+,\n\x0c\n\x02\x04!\x12\
    \x06\xc2\x03\0\xc8\x03\x01\n\x0b\n\x03\x04!\x01\x12\x04\xc2\x03\x08$\n\
    \x0c\n\x04\x04!\x02\0\x12\x04\xc3\x03\x08(\n\r\n\x05\x04!\x02\0\x04\x12\
    \x04\xc3\x03\x08\x10\n\r\n\x05\x04!\x02\0\x05\x12\x04\xc3\x03\x11\x15\n\
    \r\n\x05\x04!\x02\0\x01\x12\x04\xc3\x03\x16#\n\r\n\x05\x04!\x02\0\x03\
    \x12\x04\xc3\x03&'\n\x0c\n\x04\x04!\x02\x01\x12\x04\xc4\x03\x080\n\r\n\
    \x05\x04!\x02\x01\x04\x12\x04\xc4\x03\x08\x10\n\r\n\x05\x04!\x02\x01\x05\
    \x12\x04\xc4\x03\x11\x16\n\r\n\x05\x04!\x02\x01\x01\x12\x04\xc4\x03\x17+\
    \n\r\n\x05\x04!\x02\x01\x03\x12\x04\xc4\x03./\n\x0c\n\x04\x04!\x02\x02\
    \x12\x04\xc5\x03\x086\n\r\n\x05\x04!\x02\x02\x04\x12\x04\xc5\x03\x08\x10\
    \n\r\n\x05\x04!\x02\x02\x05\x12\x04\xc5\x03\x11\x16\n\r\n\x05\x04!\x02\
    \x02\x01\x12\x04\xc5\x03\x171\n\r\n\x05\x04!\x02\x02\x03\x12\x04\xc5\x03\
    45\n\x0c\n\x04\x04!\x02\x03\x12\x04\xc6\x03\x08*\n\r\n\x05\x04!\x02\x03\
    \x04\x12\x04\xc6\x03\x08\x10\n\r\n\x05\x04!\x02\x03\x05\x12\x04\xc6\x03\
    \x11\x15\n\r\n\x05\x04!\x02\x03\x01\x12\x04\xc6\x03\x16%\n\r\n\x05\x04!\
    \x02\x03\x03\x12\x04\xc6\x03()\n\x0c\n\x04\x04!\x02\x04\x12\x04\xc7\x03\
    \x08$\n\r\n\x05\x04!\x02\x04\x04\x12\x04\xc7\x03\x08\x10\n\r\n\x05\x04!\
    \x02\x04\x05\x12\x04\xc7\x03\x11\x17\n\r\n\x05\x04!\x02\x04\x01\x12\x04\
    \xc7\x03\x18\x1f\n\r\n\x05\x04!\x02\x04\x03\x12\x04\xc7\x03\"#\n\x0c\n\
    \x02\x04\"\x12\x06\xca\x03\0\xcd\x03\x01\n\x0b\n\x03\x04\"\x01\x12\x04\
    \xca\x03\x08/\n\x0c\n\x04\x04\"\x02\0\x12\x04\xcb\x03\x083\n\r\n\x05\x04\
    \"\x02\0\x04\x12\x04\xcb\x03\x08\x10\n\r\n\x05\x04\"\x02\0\x05\x12\x04\
    \xcb\x03\x11\x17\n\r\n\x05\x04\"\x02\0\x01\x12\x04\xcb\x03\x18.\n\r\n\
    \x05\x04\"\x02\0\x03\x12\x04\xcb\x0312\n\x0c\n\x04\x04\"\x02\x01\x12\x04\
    \xcc\x03\x083\n\r\n\x05\x04\"\x02\x01\x04\x12\x04\xcc\x03\x08\x10\n\r\n\
    \x05\x04\"\x02\x01\x05\x12\x04\xcc\x03\x11\x16\n\r\n\x05\x04\"\x02\x01\
    \x01\x12\x04\xcc\x03\x17.\n\r\n\x05\x04\"\x02\x01\x03\x12\x04\xcc\x0312\
    \n\x0c\n\x02\x04#\x12\x06\xcf\x03\0\xd1\x03\x01\n\x0b\n\x03\x04#\x01\x12\
    \x04\xcf\x03\x08(\n\x0c\n\x04\x04#\x02\0\x12\x04\xd0\x03\x08'\n\r\n\x05\
    \x04#\x02\0\x04\x12\x04\xd0\x03\x08\x10\n\r\n\x05\x04#\x02\0\x05\x12\x04\
    \xd0\x03\x11\x17\n\r\n\x05\x04#\x02\0\x01\x12\x04\xd0\x03\x18\"\n\r\n\
    \x05\x04#\x02\0\x03\x12\x04\xd0\x03%&\n\x0c\n\x02\x04$\x12\x06\xd3\x03\0\
    \xdf\x03\x01\n\x0b\n\x03\x04$\x01\x12\x04\xd3\x03\x080\n\x0e\n\x04\x04$\
    \x04\0\x12\x06\xd4\x03\x08\xd9\x03\t\n\r\n\x05\x04$\x04\0\x01\x12\x04\
    \xd4\x03\r\x14\n\x0e\n\x06\x04$\x04\0\x02\0\x12\x04\xd5\x03\x10+\n\x0f\n\
    \x07\x04$\x04\0\x02\0\x01\x12\x04\xd5\x03\x10&\n\x0f\n\x07\x04$\x04\0\
    \x02\0\x02\x12\x04\xd5\x03)*\n\x0e\n\x06\x04$\x04\0\x02\x01\x12\x04\xd6\
    \x03\x10%\n\x0f\n\x07\x04$\x04\0\x02\x01\x01\x12\x04\xd6\x03\x10\x1f\n\
    \x0f\n\x07\x04$\x04\0\x02\x01\x02\x12\x04\xd6\x03\"$\n\x0e\n\x06\x04$\
    \x04\0\x02\x02\x12\x04\xd7\x03\x10%\n\x0f\n\x07\x04$\x04\0\x02\x02\x01\
    \x12\x04\xd7\x03\x10\x1f\n\x0f\n\x07\x04$\x04\0\x02\x02\x02\x12\x04\xd7\
    \x03\"$\n\x0e\n\x06\x04$\x04\0\x02\x03\x12\x04\xd8\x03\x10$\n\x0f\n\x07\
    \x04$\x04\0\x02\x03\x01\x12\x04\xd8\x03\x10\x1f\n\x0f\n\x07\x04$\x04\0\
    \x02\x03\x02\x12\x04\xd8\x03\"#\n\x0c\n\x04\x04$\x02\0\x12\x04\xdb\x03\
    \x08*\n\r\n\x05\x04$\x02\0\x04\x12\x04\xdb\x03\x08\x10\n\r\n\x05\x04$\
    \x02\0\x05\x12\x04\xdb\x03\x11\x15\n\r\n\x05\x04$\x02\0\x01\x12\x04\xdb\
    \x03\x16%\n\r\n\x05\x04$\x02\0\x03\x12\x04\xdb\x03()\n\x0c\n\x04\x04$\
    \x02\x01\x12\x04\xdc\x03\x083\n\r\n\x05\x04$\x02\x01\x04\x12\x04\xdc\x03\
    \x08\x10\n\r\n\x05\x04$\x02\x01\x05\x12\x04\xdc\x03\x11\x17\n\r\n\x05\
    \x04$\x02\x01\x01\x12\x04\xdc\x03\x18.\n\r\n\x05\x04$\x02\x01\x03\x12\
    \x04\xdc\x0312\n\x0c\n\x04\x04$\x02\x02\x12\x04\xdd\x03\x087\n\r\n\x05\
    \x04$\x02\x02\x04\x12\x04\xdd\x03\x08\x10\n\r\n\x05\x04$\x02\x02\x05\x12\
    \x04\xdd\x03\x11\x17\n\r\n\x05\x04$\x02\x02\x01\x12\x04\xdd\x03\x182\n\r\
    \n\x05\x04$\x02\x02\x03\x12\x04\xdd\x0356\n\x0c\n\x04\x04$\x02\x03\x12\
    \x04\xde\x03\x08q\n\r\n\x05\x04$\x02\x03\x04\x12\x04\xde\x03\x08\x10\n\r\
    \n\x05\x04$\x02\x03\x06\x12\x04\xde\x03\x11B\n\r\n\x05\x04$\x02\x03\x01\
    \x12\x04\xde\x03CI\n\r\n\x05\x04$\x02\x03\x03\x12\x04\xde\x03LM\n\r\n\
    \x05\x04$\x02\x03\x08\x12\x04\xde\x03Np\n\r\n\x05\x04$\x02\x03\x07\x12\
    \x04\xde\x03Yo\n\x0c\n\x02\x04%\x12\x06\xe1\x03\0\xe3\x03\x01\n\x0b\n\
    \x03\x04%\x01\x12\x04\xe1\x03\x08\x1e\n\x0c\n\x04\x04%\x02\0\x12\x04\xe2\
    \x03\x08'\n\r\n\x05\x04%\x02\0\x04\x12\x04\xe2\x03\x08\x10\n\r\n\x05\x04\
    %\x02\0\x05\x12\x04\xe2\x03\x11\x17\n\r\n\x05\x04%\x02\0\x01\x12\x04\xe2\
    \x03\x18\"\n\r\n\x05\x04%\x02\0\x03\x12\x04\xe2\x03%&\n\x0c\n\x02\x04&\
    \x12\x06\xe5\x03\0\xee\x03\x01\n\x0b\n\x03\x04&\x01\x12\x04\xe5\x03\x08&\
    \n\x0e\n\x04\x04&\x03\0\x12\x06\xe6\x03\x08\xeb\x03\t\n\r\n\x05\x04&\x03\
    \0\x01\x12\x04\xe6\x03\x10\"\n\x0e\n\x06\x04&\x03\0\x02\0\x12\x04\xe7\
    \x03\x10;\n\x0f\n\x07\x04&\x03\0\x02\0\x04\x12\x04\xe7\x03\x10\x18\n\x0f\
    \n\x07\x04&\x03\0\x02\0\x05\x12\x04\xe7\x03\x19\x1f\n\x0f\n\x07\x04&\x03\
    \0\x02\0\x01\x12\x04\xe7\x03\x206\n\x0f\n\x07\x04&\x03\0\x02\0\x03\x12\
    \x04\xe7\x039:\n\x0e\n\x06\x04&\x03\0\x02\x01\x12\x04\xe8\x03\x10?\n\x0f\
    \n\x07\x04&\x03\0\x02\x01\x04\x12\x04\xe8\x03\x10\x18\n\x0f\n\x07\x04&\
    \x03\0\x02\x01\x05\x12\x04\xe8\x03\x19\x1f\n\x0f\n\x07\x04&\x03\0\x02\
    \x01\x01\x12\x04\xe8\x03\x20:\n\x0f\n\x07\x04&\x03\0\x02\x01\x03\x12\x04\
    \xe8\x03=>\n\x0e\n\x06\x04&\x03\0\x02\x02\x12\x04\xe9\x03\x108\n\x0f\n\
    \x07\x04&\x03\0\x02\x02\x04\x12\x04\xe9\x03\x10\x18\n\x0f\n\x07\x04&\x03\
    \0\x02\x02\x05\x12\x04\xe9\x03\x19\x1e\n\x0f\n\x07\x04&\x03\0\x02\x02\
    \x01\x12\x04\xe9\x03\x1f3\n\x0f\n\x07\x04&\x03\0\x02\x02\x03\x12\x04\xe9\
    \x0367\n\x0e\n\x06\x04&\x03\0\x02\x03\x12\x04\xea\x03\x10>\n\x0f\n\x07\
    \x04&\x03\0\x02\x03\x04\x12\x04\xea\x03\x10\x18\n\x0f\n\x07\x04&\x03\0\
    \x02\x03\x05\x12\x04\xea\x03\x19\x1e\n\x0f\n\x07\x04&\x03\0\x02\x03\x01\
    \x12\x04\xea\x03\x1f9\n\x0f\n\x07\x04&\x03\0\x02\x03\x03\x12\x04\xea\x03\
    <=\n\x0c\n\x04\x04&\x02\0\x12\x04\xed\x03\x08[\n\r\n\x05\x04&\x02\0\x04\
    \x12\x04\xed\x03\x08\x10\n\r\n\x05\x04&\x02\0\x06\x12\x04\xed\x03\x11C\n\
    \r\n\x05\x04&\x02\0\x01\x12\x04\xed\x03DV\n\r\n\x05\x04&\x02\0\x03\x12\
    \x04\xed\x03YZ\n\x0c\n\x02\x04'\x12\x06\xf0\x03\0\xf2\x03\x01\n\x0b\n\
    \x03\x04'\x01\x12\x04\xf0\x03\x08'\n\x0c\n\x04\x04'\x02\0\x12\x04\xf1\
    \x03\x083\n\r\n\x05\x04'\x02\0\x04\x12\x04\xf1\x03\x08\x10\n\r\n\x05\x04\
    '\x02\0\x05\x12\x04\xf1\x03\x11\x17\n\r\n\x05\x04'\x02\0\x01\x12\x04\xf1\
    \x03\x18.\n\r\n\x05\x04'\x02\0\x03\x12\x04\xf1\x0312\n\x0c\n\x02\x04(\
    \x12\x06\xf4\x03\0\xf8\x03\x01\n\x0b\n\x03\x04(\x01\x12\x04\xf4\x03\x08/\
    \n\x0c\n\x04\x04(\x02\0\x12\x04\xf5\x03\x08;\n\r\n\x05\x04(\x02\0\x04\
    \x12\x04\xf5\x03\x08\x10\n\r\n\x05\x04(\x02\0\x05\x12\x04\xf5\x03\x11\
    \x15\n\r\n\x05\x04(\x02\0\x01\x12\x04\xf5\x03\x166\n\r\n\x05\x04(\x02\0\
    \x03\x12\x04\xf5\x039:\n\x0c\n\x04\x04(\x02\x01\x12\x04\xf6\x03\x083\n\r\
    \n\x05\x04(\x02\x01\x04\x12\x04\xf6\x03\x08\x10\n\r\n\x05\x04(\x02\x01\
    \x05\x12\x04\xf6\x03\x11\x17\n\r\n\x05\x04(\x02\x01\x01\x12\x04\xf6\x03\
    \x18.\n\r\n\x05\x04(\x02\x01\x03\x12\x04\xf6\x0312\n\x0c\n\x04\x04(\x02\
    \x02\x12\x04\xf7\x03\x087\n\r\n\x05\x04(\x02\x02\x04\x12\x04\xf7\x03\x08\
    \x10\n\r\n\x05\x04(\x02\x02\x05\x12\x04\xf7\x03\x11\x17\n\r\n\x05\x04(\
    \x02\x02\x01\x12\x04\xf7\x03\x182\n\r\n\x05\x04(\x02\x02\x03\x12\x04\xf7\
    \x0356\n\x0c\n\x02\x04)\x12\x06\xfa\x03\0\xfb\x03\x01\n\x0b\n\x03\x04)\
    \x01\x12\x04\xfa\x03\x08#\n\x0c\n\x02\x04*\x12\x06\xfd\x03\0\x80\x04\x01\
    \n\x0b\n\x03\x04*\x01\x12\x04\xfd\x03\x08+\n\x0c\n\x04\x04*\x02\0\x12\
    \x04\xfe\x03\x08#\n\r\n\x05\x04*\x02\0\x04\x12\x04\xfe\x03\x08\x10\n\r\n\
    \x05\x04*\x02\0\x05\x12\x04\xfe\x03\x11\x17\n\r\n\x05\x04*\x02\0\x01\x12\
    \x04\xfe\x03\x18\x1e\n\r\n\x05\x04*\x02\0\x03\x12\x04\xfe\x03!\"\n\x0c\n\
    \x04\x04*\x02\x01\x12\x04\xff\x03\x08$\n\r\n\x05\x04*\x02\x01\x04\x12\
    \x04\xff\x03\x08\x10\n\r\n\x05\x04*\x02\x01\x05\x12\x04\xff\x03\x11\x17\
    \n\r\n\x05\x04*\x02\x01\x01\x12\x04\xff\x03\x18\x1f\n\r\n\x05\x04*\x02\
    \x01\x03\x12\x04\xff\x03\"#\n\x0c\n\x02\x04+\x12\x06\x82\x04\0\x84\x04\
    \x01\n\x0b\n\x03\x04+\x01\x12\x04\x82\x04\x08/\n\x0c\n\x04\x04+\x02\0\
    \x12\x04\x83\x04\x08$\n\r\n\x05\x04+\x02\0\x04\x12\x04\x83\x04\x08\x10\n\
    \r\n\x05\x04+\x02\0\x05\x12\x04\x83\x04\x11\x17\n\r\n\x05\x04+\x02\0\x01\
    \x12\x04\x83\x04\x18\x1f\n\r\n\x05\x04+\x02\0\x03\x12\x04\x83\x04\"#\n\
    \x0c\n\x02\x04,\x12\x06\x86\x04\0\x90\x04\x01\n\x0b\n\x03\x04,\x01\x12\
    \x04\x86\x04\x088\n\x0e\n\x04\x04,\x04\0\x12\x06\x87\x04\x08\x8d\x04\t\n\
    \r\n\x05\x04,\x04\0\x01\x12\x04\x87\x04\r,\n\x0e\n\x06\x04,\x04\0\x02\0\
    \x12\x04\x88\x04\x10A\n\x0f\n\x07\x04,\x04\0\x02\0\x01\x12\x04\x88\x04\
    \x10<\n\x0f\n\x07\x04,\x04\0\x02\0\x02\x12\x04\x88\x04?@\n\x0e\n\x06\x04\
    ,\x04\0\x02\x01\x12\x04\x89\x04\x10M\n\x0f\n\x07\x04,\x04\0\x02\x01\x01\
    \x12\x04\x89\x04\x10H\n\x0f\n\x07\x04,\x04\0\x02\x01\x02\x12\x04\x89\x04\
    KL\n\x0e\n\x06\x04,\x04\0\x02\x02\x12\x04\x8a\x04\x10A\n\x0f\n\x07\x04,\
    \x04\0\x02\x02\x01\x12\x04\x8a\x04\x10<\n\x0f\n\x07\x04,\x04\0\x02\x02\
    \x02\x12\x04\x8a\x04?@\n\x0e\n\x06\x04,\x04\0\x02\x03\x12\x04\x8b\x04\
    \x10B\n\x0f\n\x07\x04,\x04\0\x02\x03\x01\x12\x04\x8b\x04\x10=\n\x0f\n\
    \x07\x04,\x04\0\x02\x03\x02\x12\x04\x8b\x04@A\n\x0e\n\x06\x04,\x04\0\x02\
    \x04\x12\x04\x8c\x04\x10G\n\x0f\n\x07\x04,\x04\0\x02\x04\x01\x12\x04\x8c\
    \x04\x10B\n\x0f\n\x07\x04,\x04\0\x02\x04\x02\x12\x04\x8c\x04EF\n\r\n\x04\
    \x04,\x02\0\x12\x05\x8f\x04\x08\xae\x01\n\r\n\x05\x04,\x02\0\x04\x12\x04\
    \x8f\x04\x08\x10\n\r\n\x05\x04,\x02\0\x06\x12\x04\x8f\x04\x11b\n\r\n\x05\
    \x04,\x02\0\x01\x12\x04\x8f\x04cp\n\r\n\x05\x04,\x02\0\x03\x12\x04\x8f\
    \x04st\n\x0e\n\x05\x04,\x02\0\x08\x12\x05\x8f\x04u\xad\x01\n\x0f\n\x05\
    \x04,\x02\0\x07\x12\x06\x8f\x04\x80\x01\xac\x01\n\x0c\n\x02\x04-\x12\x06\
    \x92\x04\0\x94\x04\x01\n\x0b\n\x03\x04-\x01\x12\x04\x92\x04\x083\n\x0c\n\
    \x04\x04-\x02\0\x12\x04\x93\x04\x08v\n\r\n\x05\x04-\x02\0\x04\x12\x04\
    \x93\x04\x08\x10\n\r\n\x05\x04-\x02\0\x06\x12\x04\x93\x04\x11-\n\r\n\x05\
    \x04-\x02\0\x01\x12\x04\x93\x04.?\n\r\n\x05\x04-\x02\0\x03\x12\x04\x93\
    \x04BC\n\r\n\x05\x04-\x02\0\x08\x12\x04\x93\x04Du\n\r\n\x05\x04-\x02\0\
    \x07\x12\x04\x93\x04Ot\n\x0c\n\x02\x04.\x12\x06\x96\x04\0\x9f\x04\x01\n\
    \x0b\n\x03\x04.\x01\x12\x04\x96\x04\x08<\n\x0e\n\x04\x04.\x04\0\x12\x06\
    \x97\x04\x08\x9b\x04\t\n\r\n\x05\x04.\x04\0\x01\x12\x04\x97\x04\r2\n\x0e\
    \n\x06\x04.\x04\0\x02\0\x12\x04\x98\x04\x10C\n\x0f\n\x07\x04.\x04\0\x02\
    \0\x01\x12\x04\x98\x04\x10>\n\x0f\n\x07\x04.\x04\0\x02\0\x02\x12\x04\x98\
    \x04AB\n\x0e\n\x06\x04.\x04\0\x02\x01\x12\x04\x99\x04\x10G\n\x0f\n\x07\
    \x04.\x04\0\x02\x01\x01\x12\x04\x99\x04\x10B\n\x0f\n\x07\x04.\x04\0\x02\
    \x01\x02\x12\x04\x99\x04EF\n\x0e\n\x06\x04.\x04\0\x02\x02\x12\x04\x9a\
    \x04\x10E\n\x0f\n\x07\x04.\x04\0\x02\x02\x01\x12\x04\x9a\x04\x10@\n\x0f\
    \n\x07\x04.\x04\0\x02\x02\x02\x12\x04\x9a\x04CD\n\x0c\n\x04\x04.\x02\0\
    \x12\x04\x9d\x04\x08v\n\r\n\x05\x04.\x02\0\x04\x12\x04\x9d\x04\x08\x10\n\
    \r\n\x05\x04.\x02\0\x06\x12\x04\x9d\x04\x11-\n\r\n\x05\x04.\x02\0\x01\
    \x12\x04\x9d\x04.?\n\r\n\x05\x04.\x02\0\x03\x12\x04\x9d\x04BC\n\r\n\x05\
    \x04.\x02\0\x08\x12\x04\x9d\x04Du\n\r\n\x05\x04.\x02\0\x07\x12\x04\x9d\
    \x04Ot\n\r\n\x04\x04.\x02\x01\x12\x05\x9e\x04\x08\xc1\x01\n\r\n\x05\x04.\
    \x02\x01\x04\x12\x04\x9e\x04\x08\x10\n\r\n\x05\x04.\x02\x01\x06\x12\x04\
    \x9e\x04\x11l\n\x0e\n\x05\x04.\x02\x01\x01\x12\x05\x9e\x04m\x81\x01\n\
    \x0f\n\x05\x04.\x02\x01\x03\x12\x06\x9e\x04\x84\x01\x85\x01\n\x0f\n\x05\
    \x04.\x02\x01\x08\x12\x06\x9e\x04\x86\x01\xc0\x01\n\x0f\n\x05\x04.\x02\
    \x01\x07\x12\x06\x9e\x04\x91\x01\xbf\x01\n\x0c\n\x02\x04/\x12\x06\xa1\
    \x04\0\xa3\x04\x01\n\x0b\n\x03\x04/\x01\x12\x04\xa1\x04\x087\n\x0c\n\x04\
    \x04/\x02\0\x12\x04\xa2\x04\x08v\n\r\n\x05\x04/\x02\0\x04\x12\x04\xa2\
    \x04\x08\x10\n\r\n\x05\x04/\x02\0\x06\x12\x04\xa2\x04\x11-\n\r\n\x05\x04\
    /\x02\0\x01\x12\x04\xa2\x04.?\n\r\n\x05\x04/\x02\0\x03\x12\x04\xa2\x04BC\
    \n\r\n\x05\x04/\x02\0\x08\x12\x04\xa2\x04Du\n\r\n\x05\x04/\x02\0\x07\x12\
    \x04\xa2\x04Ot\n\x0c\n\x02\x040\x12\x06\xa5\x04\0\xa8\x04\x01\n\x0b\n\
    \x03\x040\x01\x12\x04\xa5\x04\x080\n\x0c\n\x04\x040\x02\0\x12\x04\xa6\
    \x04\x08v\n\r\n\x05\x040\x02\0\x04\x12\x04\xa6\x04\x08\x10\n\r\n\x05\x04\
    0\x02\0\x06\x12\x04\xa6\x04\x11-\n\r\n\x05\x040\x02\0\x01\x12\x04\xa6\
    \x04.?\n\r\n\x05\x040\x02\0\x03\x12\x04\xa6\x04BC\n\r\n\x05\x040\x02\0\
    \x08\x12\x04\xa6\x04Du\n\r\n\x05\x040\x02\0\x07\x12\x04\xa6\x04Ot\n\x0c\
    \n\x04\x040\x02\x01\x12\x04\xa7\x04\x08!\n\r\n\x05\x040\x02\x01\x04\x12\
    \x04\xa7\x04\x08\x10\n\r\n\x05\x040\x02\x01\x05\x12\x04\xa7\x04\x11\x15\
    \n\r\n\x05\x040\x02\x01\x01\x12\x04\xa7\x04\x16\x1c\n\r\n\x05\x040\x02\
    \x01\x03\x12\x04\xa7\x04\x1f\x20\n\x0c\n\x02\x041\x12\x06\xaa\x04\0\xaf\
    \x04\x01\n\x0b\n\x03\x041\x01\x12\x04\xaa\x04\x08%\n\x0c\n\x04\x041\x02\
    \0\x12\x04\xab\x04\x08\x1d\n\r\n\x05\x041\x02\0\x04\x12\x04\xab\x04\x08\
    \x10\n\r\n\x05\x041\x02\0\x05\x12\x04\xab\x04\x11\x16\n\r\n\x05\x041\x02\
    \0\x01\x12\x04\xab\x04\x17\x18\n\r\n\x05\x041\x02\0\x03\x12\x04\xab\x04\
    \x1b\x1c\n\x0c\n\x04\x041\x02\x01\x12\x04\xac\x04\x08\x1d\n\r\n\x05\x041\
    \x02\x01\x04\x12\x04\xac\x04\x08\x10\n\r\n\x05\x041\x02\x01\x05\x12\x04\
    \xac\x04\x11\x16\n\r\n\x05\x041\x02\x01\x01\x12\x04\xac\x04\x17\x18\n\r\
    \n\x05\x041\x02\x01\x03\x12\x04\xac\x04\x1b\x1c\n\x0c\n\x04\x041\x02\x02\
    \x12\x04\xad\x04\x08\x1d\n\r\n\x05\x041\x02\x02\x04\x12\x04\xad\x04\x08\
    \x10\n\r\n\x05\x041\x02\x02\x05\x12\x04\xad\x04\x11\x16\n\r\n\x05\x041\
    \x02\x02\x01\x12\x04\xad\x04\x17\x18\n\r\n\x05\x041\x02\x02\x03\x12\x04\
    \xad\x04\x1b\x1c\n\x0c\n\x04\x041\x02\x03\x12\x04\xae\x04\x08,\n\r\n\x05\
    \x041\x02\x03\x04\x12\x04\xae\x04\x08\x10\n\r\n\x05\x041\x02\x03\x05\x12\
    \x04\xae\x04\x11\x17\n\r\n\x05\x041\x02\x03\x01\x12\x04\xae\x04\x18'\n\r\
    \n\x05\x041\x02\x03\x03\x12\x04\xae\x04*+\n\x0c\n\x02\x042\x12\x06\xb1\
    \x04\0\xb5\x04\x01\n\x0b\n\x03\x042\x01\x12\x04\xb1\x04\x08\"\n\x0c\n\
    \x04\x042\x02\0\x12\x04\xb2\x04\x081\n\r\n\x05\x042\x02\0\x04\x12\x04\
    \xb2\x04\x08\x10\n\r\n\x05\x042\x02\0\x05\x12\x04\xb2\x04\x11\x17\n\r\n\
    \x05\x042\x02\0\x01\x12\x04\xb2\x04\x18,\n\r\n\x05\x042\x02\0\x03\x12\
    \x04\xb2\x04/0\n\x0c\n\x04\x042\x02\x01\x12\x04\xb3\x04\x08%\n\r\n\x05\
    \x042\x02\x01\x04\x12\x04\xb3\x04\x08\x10\n\r\n\x05\x042\x02\x01\x05\x12\
    \x04\xb3\x04\x11\x17\n\r\n\x05\x042\x02\x01\x01\x12\x04\xb3\x04\x18\x20\
    \n\r\n\x05\x042\x02\x01\x03\x12\x04\xb3\x04#$\n\x0c\n\x04\x042\x02\x02\
    \x12\x04\xb4\x04\x08\"\n\r\n\x05\x042\x02\x02\x04\x12\x04\xb4\x04\x08\
    \x10\n\r\n\x05\x042\x02\x02\x05\x12\x04\xb4\x04\x11\x15\n\r\n\x05\x042\
    \x02\x02\x01\x12\x04\xb4\x04\x16\x1d\n\r\n\x05\x042\x02\x02\x03\x12\x04\
    \xb4\x04\x20!\n\x0c\n\x02\x043\x12\x06\xb7\x04\0\xb9\x04\x01\n\x0b\n\x03\
    \x043\x01\x12\x04\xb7\x04\x08*\n\x0c\n\x04\x043\x02\0\x12\x04\xb8\x04\
    \x081\n\r\n\x05\x043\x02\0\x04\x12\x04\xb8\x04\x08\x10\n\r\n\x05\x043\
    \x02\0\x05\x12\x04\xb8\x04\x11\x17\n\r\n\x05\x043\x02\0\x01\x12\x04\xb8\
    \x04\x18,\n\r\n\x05\x043\x02\0\x03\x12\x04\xb8\x04/0\n\x0c\n\x02\x044\
    \x12\x06\xbb\x04\0\xbc\x04\x01\n\x0b\n\x03\x044\x01\x12\x04\xbb\x04\x08$\
    \n\x0c\n\x02\x045\x12\x06\xbe\x04\0\xc1\x04\x01\n\x0b\n\x03\x045\x01\x12\
    \x04\xbe\x04\x08*\n\x0c\n\x04\x045\x02\0\x12\x04\xbf\x04\x08'\n\r\n\x05\
    \x045\x02\0\x04\x12\x04\xbf\x04\x08\x10\n\r\n\x05\x045\x02\0\x05\x12\x04\
    \xbf\x04\x11\x17\n\r\n\x05\x045\x02\0\x01\x12\x04\xbf\x04\x18\"\n\r\n\
    \x05\x045\x02\0\x03\x12\x04\xbf\x04%&\n\x0c\n\x04\x045\x02\x01\x12\x04\
    \xc0\x04\x08(\n\r\n\x05\x045\x02\x01\x04\x12\x04\xc0\x04\x08\x10\n\r\n\
    \x05\x045\x02\x01\x05\x12\x04\xc0\x04\x11\x17\n\r\n\x05\x045\x02\x01\x01\
    \x12\x04\xc0\x04\x18#\n\r\n\x05\x045\x02\x01\x03\x12\x04\xc0\x04&'\n\x0c\
    \n\x02\x046\x12\x06\xc3\x04\0\xc7\x04\x01\n\x0b\n\x03\x046\x01\x12\x04\
    \xc3\x04\x082\n\x0c\n\x04\x046\x02\0\x12\x04\xc4\x04\x08'\n\r\n\x05\x046\
    \x02\0\x04\x12\x04\xc4\x04\x08\x10\n\r\n\x05\x046\x02\0\x05\x12\x04\xc4\
    \x04\x11\x17\n\r\n\x05\x046\x02\0\x01\x12\x04\xc4\x04\x18\"\n\r\n\x05\
    \x046\x02\0\x03\x12\x04\xc4\x04%&\n\x0c\n\x04\x046\x02\x01\x12\x04\xc5\
    \x04\x08'\n\r\n\x05\x046\x02\x01\x04\x12\x04\xc5\x04\x08\x10\n\r\n\x05\
    \x046\x02\x01\x05\x12\x04\xc5\x04\x11\x15\n\r\n\x05\x046\x02\x01\x01\x12\
    \x04\xc5\x04\x16\"\n\r\n\x05\x046\x02\x01\x03\x12\x04\xc5\x04%&\n\x0c\n\
    \x04\x046\x02\x02\x12\x04\xc6\x04\x08%\n\r\n\x05\x046\x02\x02\x04\x12\
    \x04\xc6\x04\x08\x10\n\r\n\x05\x046\x02\x02\x05\x12\x04\xc6\x04\x11\x17\
    \n\r\n\x05\x046\x02\x02\x01\x12\x04\xc6\x04\x18\x20\n\r\n\x05\x046\x02\
    \x02\x03\x12\x04\xc6\x04#$\n\x0c\n\x02\x047\x12\x06\xc9\x04\0\xde\x04\
    \x01\n\x0b\n\x03\x047\x01\x12\x04\xc9\x04\x08\x18\n\x0e\n\x04\x047\x03\0\
    \x12\x06\xca\x04\x08\xd0\x04\t\n\r\n\x05\x047\x03\0\x01\x12\x04\xca\x04\
    \x10\x18\n\x0e\n\x06\x047\x03\0\x02\0\x12\x04\xcb\x04\x10.\n\x0f\n\x07\
    \x047\x03\0\x02\0\x04\x12\x04\xcb\x04\x10\x18\n\x0f\n\x07\x047\x03\0\x02\
    \0\x05\x12\x04\xcb\x04\x19\x20\n\x0f\n\x07\x047\x03\0\x02\0\x01\x12\x04\
    \xcb\x04!)\n\x0f\n\x07\x047\x03\0\x02\0\x03\x12\x04\xcb\x04,-\n\x0e\n\
    \x06\x047\x03\0\x02\x01\x12\x04\xcc\x04\x10b\n\x0f\n\x07\x047\x03\0\x02\
    \x01\x04\x12\x04\xcc\x04\x10\x18\n\x0f\n\x07\x047\x03\0\x02\x01\x06\x12\
    \x04\xcc\x04\x19'\n\x0f\n\x07\x047\x03\0\x02\x01\x01\x12\x04\xcc\x04(9\n\
    \x0f\n\x07\x047\x03\0\x02\x01\x03\x12\x04\xcc\x04<=\n\x0f\n\x07\x047\x03\
    \0\x02\x01\x08\x12\x04\xcc\x04>a\n\x0f\n\x07\x047\x03\0\x02\x01\x07\x12\
    \x04\xcc\x04I`\n\x0e\n\x06\x047\x03\0\x02\x02\x12\x04\xcd\x04\x105\n\x0f\
    \n\x07\x047\x03\0\x02\x02\x04\x12\x04\xcd\x04\x10\x18\n\x0f\n\x07\x047\
    \x03\0\x02\x02\x05\x12\x04\xcd\x04\x19\x1d\n\x0f\n\x07\x047\x03\0\x02\
    \x02\x01\x12\x04\xcd\x04\x1e0\n\x0f\n\x07\x047\x03\0\x02\x02\x03\x12\x04\
    \xcd\x0434\n\x0e\n\x06\x047\x03\0\x02\x03\x12\x04\xce\x04\x10)\n\x0f\n\
    \x07\x047\x03\0\x02\x03\x04\x12\x04\xce\x04\x10\x18\n\x0f\n\x07\x047\x03\
    \0\x02\x03\x05\x12\x04\xce\x04\x19\x1d\n\x0f\n\x07\x047\x03\0\x02\x03\
    \x01\x12\x04\xce\x04\x1e$\n\x0f\n\x07\x047\x03\0\x02\x03\x03\x12\x04\xce\
    \x04'(\n\x0e\n\x06\x047\x03\0\x02\x04\x12\x04\xcf\x04\x103\n\x0f\n\x07\
    \x047\x03\0\x02\x04\x04\x12\x04\xcf\x04\x10\x18\n\x0f\n\x07\x047\x03\0\
    \x02\x04\x05\x12\x04\xcf\x04\x19\x1f\n\x0f\n\x07\x047\x03\0\x02\x04\x01\
    \x12\x04\xcf\x04\x20.\n\x0f\n\x07\x047\x03\0\x02\x04\x03\x12\x04\xcf\x04\
    12\n\x0c\n\x04\x047\x02\0\x12\x04\xd2\x04\x08&\n\r\n\x05\x047\x02\0\x04\
    \x12\x04\xd2\x04\x08\x10\n\r\n\x05\x047\x02\0\x05\x12\x04\xd2\x04\x11\
    \x15\n\r\n\x05\x047\x02\0\x01\x12\x04\xd2\x04\x16!\n\r\n\x05\x047\x02\0\
    \x03\x12\x04\xd2\x04$%\n\x0c\n\x04\x047\x02\x01\x12\x04\xd3\x04\x08/\n\r\
    \n\x05\x047\x02\x01\x04\x12\x04\xd3\x04\x08\x10\n\r\n\x05\x047\x02\x01\
    \x05\x12\x04\xd3\x04\x11\x17\n\r\n\x05\x047\x02\x01\x01\x12\x04\xd3\x04\
    \x18*\n\r\n\x05\x047\x02\x01\x03\x12\x04\xd3\x04-.\n\x0c\n\x04\x047\x02\
    \x02\x12\x04\xd4\x04\x08(\n\r\n\x05\x047\x02\x02\x04\x12\x04\xd4\x04\x08\
    \x10\n\r\n\x05\x047\x02\x02\x05\x12\x04\xd4\x04\x11\x17\n\r\n\x05\x047\
    \x02\x02\x01\x12\x04\xd4\x04\x18#\n\r\n\x05\x047\x02\x02\x03\x12\x04\xd4\
    \x04&'\n\x0c\n\x04\x047\x02\x03\x12\x04\xd5\x04\x08-\n\r\n\x05\x047\x02\
    \x03\x04\x12\x04\xd5\x04\x08\x10\n\r\n\x05\x047\x02\x03\x05\x12\x04\xd5\
    \x04\x11\x15\n\r\n\x05\x047\x02\x03\x01\x12\x04\xd5\x04\x16(\n\r\n\x05\
    \x047\x02\x03\x03\x12\x04\xd5\x04+,\n\x0c\n\x04\x047\x02\x04\x12\x04\xd6\
    \x04\x08(\n\r\n\x05\x047\x02\x04\x04\x12\x04\xd6\x04\x08\x10\n\r\n\x05\
    \x047\x02\x04\x05\x12\x04\xd6\x04\x11\x17\n\r\n\x05\x047\x02\x04\x01\x12\
    \x04\xd6\x04\x18\"\n\r\n\x05\x047\x02\x04\x03\x12\x04\xd6\x04%'\n\x0c\n\
    \x04\x047\x02\x05\x12\x04\xd7\x04\x08F\n\r\n\x05\x047\x02\x05\x04\x12\
    \x04\xd7\x04\x08\x10\n\r\n\x05\x047\x02\x05\x06\x12\x04\xd7\x04\x110\n\r\
    \n\x05\x047\x02\x05\x01\x12\x04\xd7\x041@\n\r\n\x05\x047\x02\x05\x03\x12\
    \x04\xd7\x04CE\n\x0c\n\x04\x047\x02\x06\x12\x04\xd8\x04\x08:\n\r\n\x05\
    \x047\x02\x06\x04\x12\x04\xd8\x04\x08\x10\n\r\n\x05\x047\x02\x06\x06\x12\
    \x04\xd8\x04\x11+\n\r\n\x05\x047\x02\x06\x01\x12\x04\xd8\x04,4\n\r\n\x05\
    \x047\x02\x06\x03\x12\x04\xd8\x0479\n\x0c\n\x04\x047\x02\x07\x12\x04\xd9\
    \x04\x08)\n\r\n\x05\x047\x02\x07\x04\x12\x04\xd9\x04\x08\x10\n\r\n\x05\
    \x047\x02\x07\x05\x12\x04\xd9\x04\x11\x15\n\r\n\x05\x047\x02\x07\x01\x12\
    \x04\xd9\x04\x16#\n\r\n\x05\x047\x02\x07\x03\x12\x04\xd9\x04&(\n\x0c\n\
    \x04\x047\x02\x08\x12\x04\xda\x04\x08)\n\r\n\x05\x047\x02\x08\x04\x12\
    \x04\xda\x04\x08\x10\n\r\n\x05\x047\x02\x08\x05\x12\x04\xda\x04\x11\x15\
    \n\r\n\x05\x047\x02\x08\x01\x12\x04\xda\x04\x16#\n\r\n\x05\x047\x02\x08\
    \x03\x12\x04\xda\x04&(\n\x0c\n\x04\x047\x02\t\x12\x04\xdb\x04\x08/\n\r\n\
    \x05\x047\x02\t\x04\x12\x04\xdb\x04\x08\x10\n\r\n\x05\x047\x02\t\x05\x12\
    \x04\xdb\x04\x11\x15\n\r\n\x05\x047\x02\t\x01\x12\x04\xdb\x04\x16)\n\r\n\
    \x05\x047\x02\t\x03\x12\x04\xdb\x04,.\n\x0c\n\x04\x047\x02\n\x12\x04\xdc\
    \x04\x08/\n\r\n\x05\x047\x02\n\x04\x12\x04\xdc\x04\x08\x10\n\r\n\x05\x04\
    7\x02\n\x05\x12\x04\xdc\x04\x11\x15\n\r\n\x05\x047\x02\n\x01\x12\x04\xdc\
    \x04\x16)\n\r\n\x05\x047\x02\n\x03\x12\x04\xdc\x04,.\n\x0c\n\x04\x047\
    \x02\x0b\x12\x04\xdd\x04\x08)\n\r\n\x05\x047\x02\x0b\x04\x12\x04\xdd\x04\
    \x08\x10\n\r\n\x05\x047\x02\x0b\x05\x12\x04\xdd\x04\x11\x15\n\r\n\x05\
    \x047\x02\x0b\x01\x12\x04\xdd\x04\x16#\n\r\n\x05\x047\x02\x0b\x03\x12\
    \x04\xdd\x04&(\n\x0c\n\x02\x048\x12\x06\xe0\x04\0\xe9\x04\x01\n\x0b\n\
    \x03\x048\x01\x12\x04\xe0\x04\x08\x1c\n\x0e\n\x04\x048\x04\0\x12\x06\xe1\
    \x04\x08\xe4\x04\t\n\r\n\x05\x048\x04\0\x01\x12\x04\xe1\x04\r\x12\n\x0e\
    \n\x06\x048\x04\0\x02\0\x12\x04\xe2\x04\x10\x1c\n\x0f\n\x07\x048\x04\0\
    \x02\0\x01\x12\x04\xe2\x04\x10\x17\n\x0f\n\x07\x048\x04\0\x02\0\x02\x12\
    \x04\xe2\x04\x1a\x1b\n\x0e\n\x06\x048\x04\0\x02\x01\x12\x04\xe3\x04\x10$\
    \n\x0f\n\x07\x048\x04\0\x02\x01\x01\x12\x04\xe3\x04\x10\x1f\n\x0f\n\x07\
    \x048\x04\0\x02\x01\x02\x12\x04\xe3\x04\"#\n\x0c\n\x04\x048\x02\0\x12\
    \x04\xe6\x04\x08%\n\r\n\x05\x048\x02\0\x04\x12\x04\xe6\x04\x08\x10\n\r\n\
    \x05\x048\x02\0\x05\x12\x04\xe6\x04\x11\x18\n\r\n\x05\x048\x02\0\x01\x12\
    \x04\xe6\x04\x19\x20\n\r\n\x05\x048\x02\0\x03\x12\x04\xe6\x04#$\n\x0c\n\
    \x04\x048\x02\x01\x12\x04\xe7\x04\x08J\n\r\n\x05\x048\x02\x01\x04\x12\
    \x04\xe7\x04\x08\x10\n\r\n\x05\x048\x02\x01\x06\x12\x04\xe7\x04\x11,\n\r\
    \n\x05\x048\x02\x01\x01\x12\x04\xe7\x04-1\n\r\n\x05\x048\x02\x01\x03\x12\
    \x04\xe7\x0445\n\r\n\x05\x048\x02\x01\x08\x12\x04\xe7\x046I\n\r\n\x05\
    \x048\x02\x01\x07\x12\x04\xe7\x04AH\n\x0c\n\x04\x048\x02\x02\x12\x04\xe8\
    \x04\x08%\n\r\n\x05\x048\x02\x02\x04\x12\x04\xe8\x04\x08\x10\n\r\n\x05\
    \x048\x02\x02\x05\x12\x04\xe8\x04\x11\x18\n\r\n\x05\x048\x02\x02\x01\x12\
    \x04\xe8\x04\x19\x20\n\r\n\x05\x048\x02\x02\x03\x12\x04\xe8\x04#$\n\x0c\
    \n\x02\x049\x12\x06\xeb\x04\0\xee\x04\x01\n\x0b\n\x03\x049\x01\x12\x04\
    \xeb\x04\x08\x19\n\x0c\n\x04\x049\x02\0\x12\x04\xec\x04\x08[\n\r\n\x05\
    \x049\x02\0\x04\x12\x04\xec\x04\x08\x10\n\r\n\x05\x049\x02\0\x06\x12\x04\
    \xec\x04\x11%\n\r\n\x05\x049\x02\0\x01\x12\x04\xec\x04&/\n\r\n\x05\x049\
    \x02\0\x03\x12\x04\xec\x0423\n\r\n\x05\x049\x02\0\x08\x12\x04\xec\x044Z\
    \n\r\n\x05\x049\x02\0\x07\x12\x04\xec\x04?Y\n\x0c\n\x04\x049\x02\x01\x12\
    \x04\xed\x04\x08T\n\r\n\x05\x049\x02\x01\x04\x12\x04\xed\x04\x08\x10\n\r\
    \n\x05\x049\x02\x01\x06\x12\x04\xed\x04\x11\x1f\n\r\n\x05\x049\x02\x01\
    \x01\x12\x04\xed\x04\x20+\n\r\n\x05\x049\x02\x01\x03\x12\x04\xed\x04./\n\
    \r\n\x05\x049\x02\x01\x08\x12\x04\xed\x040S\n\r\n\x05\x049\x02\x01\x07\
    \x12\x04\xed\x04;R\n\x0c\n\x02\x04:\x12\x06\xf0\x04\0\xf7\x04\x01\n\x0b\
    \n\x03\x04:\x01\x12\x04\xf0\x04\x08\"\n\x0c\n\x04\x04:\x02\0\x12\x04\xf1\
    \x04\x08'\n\r\n\x05\x04:\x02\0\x04\x12\x04\xf1\x04\x08\x10\n\r\n\x05\x04\
    :\x02\0\x05\x12\x04\xf1\x04\x11\x15\n\r\n\x05\x04:\x02\0\x01\x12\x04\xf1\
    \x04\x16\"\n\r\n\x05\x04:\x02\0\x03\x12\x04\xf1\x04%&\n\x0c\n\x04\x04:\
    \x02\x01\x12\x04\xf2\x04\x08A\n\r\n\x05\x04:\x02\x01\x04\x12\x04\xf2\x04\
    \x08\x10\n\r\n\x05\x04:\x02\x01\x05\x12\x04\xf2\x04\x11\x17\n\r\n\x05\
    \x04:\x02\x01\x01\x12\x04\xf2\x04\x18-\n\r\n\x05\x04:\x02\x01\x03\x12\
    \x04\xf2\x0402\n\r\n\x05\x04:\x02\x01\x08\x12\x04\xf2\x043@\n\r\n\x05\
    \x04:\x02\x01\x07\x12\x04\xf2\x04>?\n\x0c\n\x04\x04:\x02\x02\x12\x04\xf3\
    \x04\x08-\n\r\n\x05\x04:\x02\x02\x04\x12\x04\xf3\x04\x08\x10\n\r\n\x05\
    \x04:\x02\x02\x05\x12\x04\xf3\x04\x11\x17\n\r\n\x05\x04:\x02\x02\x01\x12\
    \x04\xf3\x04\x18'\n\r\n\x05\x04:\x02\x02\x03\x12\x04\xf3\x04*,\n\x0c\n\
    \x04\x04:\x02\x03\x12\x04\xf4\x04\x081\n\r\n\x05\x04:\x02\x03\x04\x12\
    \x04\xf4\x04\x08\x10\n\r\n\x05\x04:\x02\x03\x05\x12\x04\xf4\x04\x11\x17\
    \n\r\n\x05\x04:\x02\x03\x01\x12\x04\xf4\x04\x18+\n\r\n\x05\x04:\x02\x03\
    \x03\x12\x04\xf4\x04.0\n\x0c\n\x04\x04:\x02\x04\x12\x04\xf5\x04\x083\n\r\
    \n\x05\x04:\x02\x04\x04\x12\x04\xf5\x04\x08\x10\n\r\n\x05\x04:\x02\x04\
    \x05\x12\x04\xf5\x04\x11\x17\n\r\n\x05\x04:\x02\x04\x01\x12\x04\xf5\x04\
    \x18-\n\r\n\x05\x04:\x02\x04\x03\x12\x04\xf5\x0402\n\x0c\n\x04\x04:\x02\
    \x05\x12\x04\xf6\x04\x08>\n\r\n\x05\x04:\x02\x05\x04\x12\x04\xf6\x04\x08\
    \x10\n\r\n\x05\x04:\x02\x05\x06\x12\x04\xf6\x04\x11(\n\r\n\x05\x04:\x02\
    \x05\x01\x12\x04\xf6\x04)8\n\r\n\x05\x04:\x02\x05\x03\x12\x04\xf6\x04;=\
    \n\x0c\n\x02\x04;\x12\x06\xf9\x04\0\xfb\x04\x01\n\x0b\n\x03\x04;\x01\x12\
    \x04\xf9\x04\x08\x1e\n\x0c\n\x04\x04;\x02\0\x12\x04\xfa\x04\x080\n\r\n\
    \x05\x04;\x02\0\x04\x12\x04\xfa\x04\x08\x10\n\r\n\x05\x04;\x02\0\x05\x12\
    \x04\xfa\x04\x11\x18\n\r\n\x05\x04;\x02\0\x01\x12\x04\xfa\x04\x19+\n\r\n\
    \x05\x04;\x02\0\x03\x12\x04\xfa\x04./\n\x0c\n\x02\x04<\x12\x06\xfd\x04\0\
    \xff\x04\x01\n\x0b\n\x03\x04<\x01\x12\x04\xfd\x04\x08&\n\x0c\n\x04\x04<\
    \x02\0\x12\x04\xfe\x04\x08,\n\r\n\x05\x04<\x02\0\x04\x12\x04\xfe\x04\x08\
    \x10\n\r\n\x05\x04<\x02\0\x05\x12\x04\xfe\x04\x11\x15\n\r\n\x05\x04<\x02\
    \0\x01\x12\x04\xfe\x04\x16'\n\r\n\x05\x04<\x02\0\x03\x12\x04\xfe\x04*+\n\
    \x0c\n\x02\x04=\x12\x06\x81\x05\0\x86\x05\x01\n\x0b\n\x03\x04=\x01\x12\
    \x04\x81\x05\x08\x17\n\x0c\n\x04\x04=\x02\0\x12\x04\x82\x05\x08-\n\r\n\
    \x05\x04=\x02\0\x04\x12\x04\x82\x05\x08\x10\n\r\n\x05\x04=\x02\0\x05\x12\
    \x04\x82\x05\x11\x15\n\r\n\x05\x04=\x02\0\x01\x12\x04\x82\x05\x16(\n\r\n\
    \x05\x04=\x02\0\x03\x12\x04\x82\x05+,\n\x0c\n\x04\x04=\x02\x01\x12\x04\
    \x83\x05\x08@\n\r\n\x05\x04=\x02\x01\x04\x12\x04\x83\x05\x08\x10\n\r\n\
    \x05\x04=\x02\x01\x06\x12\x04\x83\x05\x11,\n\r\n\x05\x04=\x02\x01\x01\
    \x12\x04\x83\x05-;\n\r\n\x05\x04=\x02\x01\x03\x12\x04\x83\x05>?\n\x0c\n\
    \x04\x04=\x02\x02\x12\x04\x84\x05\x08E\n\r\n\x05\x04=\x02\x02\x04\x12\
    \x04\x84\x05\x08\x10\n\r\n\x05\x04=\x02\x02\x06\x12\x04\x84\x05\x110\n\r\
    \n\x05\x04=\x02\x02\x01\x12\x04\x84\x051@\n\r\n\x05\x04=\x02\x02\x03\x12\
    \x04\x84\x05CD\n\x0c\n\x04\x04=\x02\x03\x12\x04\x85\x05\x087\n\r\n\x05\
    \x04=\x02\x03\x04\x12\x04\x85\x05\x08\x10\n\r\n\x05\x04=\x02\x03\x06\x12\
    \x04\x85\x05\x11#\n\r\n\x05\x04=\x02\x03\x01\x12\x04\x85\x05$2\n\r\n\x05\
    \x04=\x02\x03\x03\x12\x04\x85\x0556\n\x0c\n\x02\x04>\x12\x06\x88\x05\0\
    \x8b\x05\x01\n\x0b\n\x03\x04>\x01\x12\x04\x88\x05\x08\x1b\n\x0c\n\x04\
    \x04>\x02\0\x12\x04\x89\x05\x08&\n\r\n\x05\x04>\x02\0\x04\x12\x04\x89\
    \x05\x08\x10\n\r\n\x05\x04>\x02\0\x05\x12\x04\x89\x05\x11\x18\n\r\n\x05\
    \x04>\x02\0\x01\x12\x04\x89\x05\x19!\n\r\n\x05\x04>\x02\0\x03\x12\x04\
    \x89\x05$%\n\x0c\n\x04\x04>\x02\x01\x12\x04\x8a\x05\x08.\n\r\n\x05\x04>\
    \x02\x01\x04\x12\x04\x8a\x05\x08\x10\n\r\n\x05\x04>\x02\x01\x06\x12\x04\
    \x8a\x05\x11!\n\r\n\x05\x04>\x02\x01\x01\x12\x04\x8a\x05\")\n\r\n\x05\
    \x04>\x02\x01\x03\x12\x04\x8a\x05,-\n\x0c\n\x02\x04?\x12\x06\x8d\x05\0\
    \x8e\x05\x01\n\x0b\n\x03\x04?\x01\x12\x04\x8d\x05\x08#\n\x0c\n\x02\x04@\
    \x12\x06\x90\x05\0\x94\x05\x01\n\x0b\n\x03\x04@\x01\x12\x04\x90\x05\x08\
    \x1e\n\x0c\n\x04\x04@\x02\0\x12\x04\x91\x05\x08&\n\r\n\x05\x04@\x02\0\
    \x04\x12\x04\x91\x05\x08\x10\n\r\n\x05\x04@\x02\0\x05\x12\x04\x91\x05\
    \x11\x18\n\r\n\x05\x04@\x02\0\x01\x12\x04\x91\x05\x19!\n\r\n\x05\x04@\
    \x02\0\x03\x12\x04\x91\x05$%\n\x0c\n\x04\x04@\x02\x01\x12\x04\x92\x05\
    \x084\n\r\n\x05\x04@\x02\x01\x04\x12\x04\x92\x05\x08\x10\n\r\n\x05\x04@\
    \x02\x01\x06\x12\x04\x92\x05\x11!\n\r\n\x05\x04@\x02\x01\x01\x12\x04\x92\
    \x05\"/\n\r\n\x05\x04@\x02\x01\x03\x12\x04\x92\x0523\n\x0c\n\x04\x04@\
    \x02\x02\x12\x04\x93\x05\x08T\n\r\n\x05\x04@\x02\x02\x04\x12\x04\x93\x05\
    \x08\x10\n\r\n\x05\x04@\x02\x02\x06\x12\x04\x93\x05\x11\x1f\n\r\n\x05\
    \x04@\x02\x02\x01\x12\x04\x93\x05\x20+\n\r\n\x05\x04@\x02\x02\x03\x12\
    \x04\x93\x05./\n\r\n\x05\x04@\x02\x02\x08\x12\x04\x93\x050S\n\r\n\x05\
    \x04@\x02\x02\x07\x12\x04\x93\x05;R\n\x0c\n\x02\x04A\x12\x06\x96\x05\0\
    \x97\x05\x01\n\x0b\n\x03\x04A\x01\x12\x04\x96\x05\x08&\n\x0c\n\x02\x04B\
    \x12\x06\x99\x05\0\x9c\x05\x01\n\x0b\n\x03\x04B\x01\x12\x04\x99\x05\x08\
    \x20\n\x0c\n\x04\x04B\x02\0\x12\x04\x9a\x05\x08&\n\r\n\x05\x04B\x02\0\
    \x04\x12\x04\x9a\x05\x08\x10\n\r\n\x05\x04B\x02\0\x05\x12\x04\x9a\x05\
    \x11\x18\n\r\n\x05\x04B\x02\0\x01\x12\x04\x9a\x05\x19!\n\r\n\x05\x04B\
    \x02\0\x03\x12\x04\x9a\x05$%\n\x0c\n\x04\x04B\x02\x01\x12\x04\x9b\x05\
    \x08,\n\r\n\x05\x04B\x02\x01\x04\x12\x04\x9b\x05\x08\x10\n\r\n\x05\x04B\
    \x02\x01\x05\x12\x04\x9b\x05\x11\x18\n\r\n\x05\x04B\x02\x01\x01\x12\x04\
    \x9b\x05\x19'\n\r\n\x05\x04B\x02\x01\x03\x12\x04\x9b\x05*+\n\x0c\n\x02\
    \x04C\x12\x06\x9e\x05\0\x9f\x05\x01\n\x0b\n\x03\x04C\x01\x12\x04\x9e\x05\
    \x08(\n\x0c\n\x02\x04D\x12\x06\xa1\x05\0\xa4\x05\x01\n\x0b\n\x03\x04D\
    \x01\x12\x04\xa1\x05\x08\x20\n\x0c\n\x04\x04D\x02\0\x12\x04\xa2\x05\x08&\
    \n\r\n\x05\x04D\x02\0\x04\x12\x04\xa2\x05\x08\x10\n\r\n\x05\x04D\x02\0\
    \x05\x12\x04\xa2\x05\x11\x18\n\r\n\x05\x04D\x02\0\x01\x12\x04\xa2\x05\
    \x19!\n\r\n\x05\x04D\x02\0\x03\x12\x04\xa2\x05$%\n\x0c\n\x04\x04D\x02\
    \x01\x12\x04\xa3\x05\x08T\n\r\n\x05\x04D\x02\x01\x04\x12\x04\xa3\x05\x08\
    \x10\n\r\n\x05\x04D\x02\x01\x06\x12\x04\xa3\x05\x11\x1f\n\r\n\x05\x04D\
    \x02\x01\x01\x12\x04\xa3\x05\x20+\n\r\n\x05\x04D\x02\x01\x03\x12\x04\xa3\
    \x05./\n\r\n\x05\x04D\x02\x01\x08\x12\x04\xa3\x050S\n\r\n\x05\x04D\x02\
    \x01\x07\x12\x04\xa3\x05;R\n\x0c\n\x02\x04E\x12\x06\xa6\x05\0\xa7\x05\
    \x01\n\x0b\n\x03\x04E\x01\x12\x04\xa6\x05\x08(\n\x0c\n\x02\x04F\x12\x06\
    \xa9\x05\0\xab\x05\x01\n\x0b\n\x03\x04F\x01\x12\x04\xa9\x05\x08'\n\x0c\n\
    \x04\x04F\x02\0\x12\x04\xaa\x05\x08&\n\r\n\x05\x04F\x02\0\x04\x12\x04\
    \xaa\x05\x08\x10\n\r\n\x05\x04F\x02\0\x05\x12\x04\xaa\x05\x11\x18\n\r\n\
    \x05\x04F\x02\0\x01\x12\x04\xaa\x05\x19!\n\r\n\x05\x04F\x02\0\x03\x12\
    \x04\xaa\x05$%\n\x0c\n\x02\x04G\x12\x06\xad\x05\0\xae\x05\x01\n\x0b\n\
    \x03\x04G\x01\x12\x04\xad\x05\x08/\n\x0c\n\x02\x04H\x12\x06\xb0\x05\0\
    \xb4\x05\x01\n\x0b\n\x03\x04H\x01\x12\x04\xb0\x05\x08\x1d\n\x0c\n\x04\
    \x04H\x02\0\x12\x04\xb1\x05\x08&\n\r\n\x05\x04H\x02\0\x04\x12\x04\xb1\
    \x05\x08\x10\n\r\n\x05\x04H\x02\0\x05\x12\x04\xb1\x05\x11\x18\n\r\n\x05\
    \x04H\x02\0\x01\x12\x04\xb1\x05\x19!\n\r\n\x05\x04H\x02\0\x03\x12\x04\
    \xb1\x05$%\n\x0c\n\x04\x04H\x02\x01\x12\x04\xb2\x05\x08'\n\r\n\x05\x04H\
    \x02\x01\x04\x12\x04\xb2\x05\x08\x10\n\r\n\x05\x04H\x02\x01\x05\x12\x04\
    \xb2\x05\x11\x18\n\r\n\x05\x04H\x02\x01\x01\x12\x04\xb2\x05\x19\"\n\r\n\
    \x05\x04H\x02\x01\x03\x12\x04\xb2\x05%&\n\x0c\n\x04\x04H\x02\x02\x12\x04\
    \xb3\x05\x084\n\r\n\x05\x04H\x02\x02\x04\x12\x04\xb3\x05\x08\x10\n\r\n\
    \x05\x04H\x02\x02\x05\x12\x04\xb3\x05\x11\x15\n\r\n\x05\x04H\x02\x02\x01\
    \x12\x04\xb3\x05\x16/\n\r\n\x05\x04H\x02\x02\x03\x12\x04\xb3\x0523\n\x0c\
    \n\x02\x04I\x12\x06\xb6\x05\0\xbb\x05\x01\n\x0b\n\x03\x04I\x01\x12\x04\
    \xb6\x05\x08\"\n\x0c\n\x04\x04I\x02\0\x12\x04\xb7\x05\x08.\n\r\n\x05\x04\
    I\x02\0\x04\x12\x04\xb7\x05\x08\x10\n\r\n\x05\x04I\x02\0\x05\x12\x04\xb7\
    \x05\x11\x18\n\r\n\x05\x04I\x02\0\x01\x12\x04\xb7\x05\x19)\n\r\n\x05\x04\
    I\x02\0\x03\x12\x04\xb7\x05,-\n\x0c\n\x04\x04I\x02\x01\x12\x04\xb8\x05\
    \x08,\n\r\n\x05\x04I\x02\x01\x04\x12\x04\xb8\x05\x08\x10\n\r\n\x05\x04I\
    \x02\x01\x05\x12\x04\xb8\x05\x11\x18\n\r\n\x05\x04I\x02\x01\x01\x12\x04\
    \xb8\x05\x19'\n\r\n\x05\x04I\x02\x01\x03\x12\x04\xb8\x05*+\n\x0c\n\x04\
    \x04I\x02\x02\x12\x04\xb9\x05\x08+\n\r\n\x05\x04I\x02\x02\x04\x12\x04\
    \xb9\x05\x08\x10\n\r\n\x05\x04I\x02\x02\x05\x12\x04\xb9\x05\x11\x18\n\r\
    \n\x05\x04I\x02\x02\x01\x12\x04\xb9\x05\x19&\n\r\n\x05\x04I\x02\x02\x03\
    \x12\x04\xb9\x05)*\n\x0c\n\x04\x04I\x02\x03\x12\x04\xba\x05\x08+\n\r\n\
    \x05\x04I\x02\x03\x04\x12\x04\xba\x05\x08\x10\n\r\n\x05\x04I\x02\x03\x05\
    \x12\x04\xba\x05\x11\x15\n\r\n\x05\x04I\x02\x03\x01\x12\x04\xba\x05\x16&\
    \n\r\n\x05\x04I\x02\x03\x03\x12\x04\xba\x05)*\n\x0c\n\x02\x04J\x12\x06\
    \xbd\x05\0\xc0\x05\x01\n\x0b\n\x03\x04J\x01\x12\x04\xbd\x05\x08#\n\x0c\n\
    \x04\x04J\x02\0\x12\x04\xbe\x05\x08&\n\r\n\x05\x04J\x02\0\x04\x12\x04\
    \xbe\x05\x08\x10\n\r\n\x05\x04J\x02\0\x05\x12\x04\xbe\x05\x11\x18\n\r\n\
    \x05\x04J\x02\0\x01\x12\x04\xbe\x05\x19!\n\r\n\x05\x04J\x02\0\x03\x12\
    \x04\xbe\x05$%\n\x0c\n\x04\x04J\x02\x01\x12\x04\xbf\x05\x08/\n\r\n\x05\
    \x04J\x02\x01\x04\x12\x04\xbf\x05\x08\x10\n\r\n\x05\x04J\x02\x01\x05\x12\
    \x04\xbf\x05\x11\x18\n\r\n\x05\x04J\x02\x01\x01\x12\x04\xbf\x05\x19*\n\r\
    \n\x05\x04J\x02\x01\x03\x12\x04\xbf\x05-.\n\x0c\n\x02\x04K\x12\x06\xc2\
    \x05\0\xc3\x05\x01\n\x0b\n\x03\x04K\x01\x12\x04\xc2\x05\x08+\n\x0c\n\x02\
    \x04L\x12\x06\xc5\x05\0\xc7\x05\x01\n\x0b\n\x03\x04L\x01\x12\x04\xc5\x05\
    \x08'\n\x0c\n\x04\x04L\x02\0\x12\x04\xc6\x05\x08,\n\r\n\x05\x04L\x02\0\
    \x04\x12\x04\xc6\x05\x08\x10\n\r\n\x05\x04L\x02\0\x05\x12\x04\xc6\x05\
    \x11\x18\n\r\n\x05\x04L\x02\0\x01\x12\x04\xc6\x05\x19'\n\r\n\x05\x04L\
    \x02\0\x03\x12\x04\xc6\x05*+\n\x0c\n\x02\x04M\x12\x06\xc9\x05\0\xca\x05\
    \x01\n\x0b\n\x03\x04M\x01\x12\x04\xc9\x05\x08/\n\x0c\n\x02\x04N\x12\x06\
    \xcc\x05\0\xcf\x05\x01\n\x0b\n\x03\x04N\x01\x12\x04\xcc\x05\x08\x20\n\
    \x0c\n\x04\x04N\x02\0\x12\x04\xcd\x05\x08&\n\r\n\x05\x04N\x02\0\x04\x12\
    \x04\xcd\x05\x08\x10\n\r\n\x05\x04N\x02\0\x05\x12\x04\xcd\x05\x11\x18\n\
    \r\n\x05\x04N\x02\0\x01\x12\x04\xcd\x05\x19!\n\r\n\x05\x04N\x02\0\x03\
    \x12\x04\xcd\x05$%\n\x0c\n\x04\x04N\x02\x01\x12\x04\xce\x05\x08+\n\r\n\
    \x05\x04N\x02\x01\x04\x12\x04\xce\x05\x08\x10\n\r\n\x05\x04N\x02\x01\x05\
    \x12\x04\xce\x05\x11\x18\n\r\n\x05\x04N\x02\x01\x01\x12\x04\xce\x05\x19&\
    \n\r\n\x05\x04N\x02\x01\x03\x12\x04\xce\x05)*\n\x0c\n\x02\x04O\x12\x06\
    \xd1\x05\0\xd4\x05\x01\n\x0b\n\x03\x04O\x01\x12\x04\xd1\x05\x08\x1b\n\
    \x0c\n\x04\x04O\x02\0\x12\x04\xd2\x05\x08&\n\r\n\x05\x04O\x02\0\x04\x12\
    \x04\xd2\x05\x08\x10\n\r\n\x05\x04O\x02\0\x05\x12\x04\xd2\x05\x11\x18\n\
    \r\n\x05\x04O\x02\0\x01\x12\x04\xd2\x05\x19!\n\r\n\x05\x04O\x02\0\x03\
    \x12\x04\xd2\x05$%\n\x0c\n\x04\x04O\x02\x01\x12\x04\xd3\x05\x08'\n\r\n\
    \x05\x04O\x02\x01\x04\x12\x04\xd3\x05\x08\x10\n\r\n\x05\x04O\x02\x01\x05\
    \x12\x04\xd3\x05\x11\x18\n\r\n\x05\x04O\x02\x01\x01\x12\x04\xd3\x05\x19\
    \"\n\r\n\x05\x04O\x02\x01\x03\x12\x04\xd3\x05%&\n\x0c\n\x02\x04P\x12\x06\
    \xd6\x05\0\xd9\x05\x01\n\x0b\n\x03\x04P\x01\x12\x04\xd6\x05\x08\x19\n\
    \x0c\n\x04\x04P\x02\0\x12\x04\xd7\x05\x08&\n\r\n\x05\x04P\x02\0\x04\x12\
    \x04\xd7\x05\x08\x10\n\r\n\x05\x04P\x02\0\x05\x12\x04\xd7\x05\x11\x18\n\
    \r\n\x05\x04P\x02\0\x01\x12\x04\xd7\x05\x19!\n\r\n\x05\x04P\x02\0\x03\
    \x12\x04\xd7\x05$%\n\x0c\n\x04\x04P\x02\x01\x12\x04\xd8\x05\x08\x20\n\r\
    \n\x05\x04P\x02\x01\x04\x12\x04\xd8\x05\x08\x10\n\r\n\x05\x04P\x02\x01\
    \x05\x12\x04\xd8\x05\x11\x17\n\r\n\x05\x04P\x02\x01\x01\x12\x04\xd8\x05\
    \x18\x1b\n\r\n\x05\x04P\x02\x01\x03\x12\x04\xd8\x05\x1e\x1f\n\x0c\n\x02\
    \x04Q\x12\x06\xdb\x05\0\xdf\x05\x01\n\x0b\n\x03\x04Q\x01\x12\x04\xdb\x05\
    \x08\x18\n\x0c\n\x04\x04Q\x02\0\x12\x04\xdc\x05\x08S\n\r\n\x05\x04Q\x02\
    \0\x04\x12\x04\xdc\x05\x08\x10\n\r\n\x05\x04Q\x02\0\x06\x12\x04\xdc\x05\
    \x11\"\n\r\n\x05\x04Q\x02\0\x01\x12\x04\xdc\x05#'\n\r\n\x05\x04Q\x02\0\
    \x03\x12\x04\xdc\x05*+\n\r\n\x05\x04Q\x02\0\x08\x12\x04\xdc\x05,R\n\r\n\
    \x05\x04Q\x02\0\x07\x12\x04\xdc\x057Q\n\x0c\n\x04\x04Q\x02\x01\x12\x04\
    \xdd\x05\x08&\n\r\n\x05\x04Q\x02\x01\x04\x12\x04\xdd\x05\x08\x10\n\r\n\
    \x05\x04Q\x02\x01\x05\x12\x04\xdd\x05\x11\x18\n\r\n\x05\x04Q\x02\x01\x01\
    \x12\x04\xdd\x05\x19!\n\r\n\x05\x04Q\x02\x01\x03\x12\x04\xdd\x05$%\n\x0c\
    \n\x04\x04Q\x02\x02\x12\x04\xde\x05\x08\x20\n\r\n\x05\x04Q\x02\x02\x04\
    \x12\x04\xde\x05\x08\x10\n\r\n\x05\x04Q\x02\x02\x05\x12\x04\xde\x05\x11\
    \x17\n\r\n\x05\x04Q\x02\x02\x01\x12\x04\xde\x05\x18\x1b\n\r\n\x05\x04Q\
    \x02\x02\x03\x12\x04\xde\x05\x1e\x1f\n\x0c\n\x02\x04R\x12\x06\xe1\x05\0\
    \xf5\x05\x01\n\x0b\n\x03\x04R\x01\x12\x04\xe1\x05\x08\x12\n\x0e\n\x04\
    \x04R\x03\0\x12\x06\xe2\x05\x08\xe5\x05\t\n\r\n\x05\x04R\x03\0\x01\x12\
    \x04\xe2\x05\x10\x1a\n\x0e\n\x06\x04R\x03\0\x02\0\x12\x04\xe3\x05\x10\\\
    \n\x0f\n\x07\x04R\x03\0\x02\0\x04\x12\x04\xe3\x05\x10\x18\n\x0f\n\x07\
    \x04R\x03\0\x02\0\x06\x12\x04\xe3\x05\x19'\n\x0f\n\x07\x04R\x03\0\x02\0\
    \x01\x12\x04\xe3\x05(3\n\x0f\n\x07\x04R\x03\0\x02\0\x03\x12\x04\xe3\x056\
    7\n\x0f\n\x07\x04R\x03\0\x02\0\x08\x12\x04\xe3\x058[\n\x0f\n\x07\x04R\
    \x03\0\x02\0\x07\x12\x04\xe3\x05CZ\n\x0e\n\x06\x04R\x03\0\x02\x01\x12\
    \x04\xe4\x05\x101\n\x0f\n\x07\x04R\x03\0\x02\x01\x04\x12\x04\xe4\x05\x10\
    \x18\n\x0f\n\x07\x04R\x03\0\x02\x01\x05\x12\x04\xe4\x05\x19\x20\n\x0f\n\
    \x07\x04R\x03\0\x02\x01\x01\x12\x04\xe4\x05!,\n\x0f\n\x07\x04R\x03\0\x02\
    \x01\x03\x12\x04\xe4\x05/0\n\x0c\n\x04\x04R\x02\0\x12\x04\xe7\x05\x08:\n\
    \r\n\x05\x04R\x02\0\x04\x12\x04\xe7\x05\x08\x10\n\r\n\x05\x04R\x02\0\x05\
    \x12\x04\xe7\x05\x11\x17\n\r\n\x05\x04R\x02\0\x01\x12\x04\xe7\x05\x18\
    \x20\n\r\n\x05\x04R\x02\0\x03\x12\x04\xe7\x05#$\n\r\n\x05\x04R\x02\0\x08\
    \x12\x04\xe7\x05%9\n\x10\n\x08\x04R\x02\0\x08\xe0\xd4\x03\x12\x04\xe7\
    \x05&8\n\x0c\n\x04\x04R\x02\x01\x12\x04\xe8\x05\x08'\n\r\n\x05\x04R\x02\
    \x01\x04\x12\x04\xe8\x05\x08\x10\n\r\n\x05\x04R\x02\x01\x05\x12\x04\xe8\
    \x05\x11\x18\n\r\n\x05\x04R\x02\x01\x01\x12\x04\xe8\x05\x19\"\n\r\n\x05\
    \x04R\x02\x01\x03\x12\x04\xe8\x05%&\n\x0c\n\x04\x04R\x02\x02\x12\x04\xe9\
    \x05\x08(\n\r\n\x05\x04R\x02\x02\x04\x12\x04\xe9\x05\x08\x10\n\r\n\x05\
    \x04R\x02\x02\x05\x12\x04\xe9\x05\x11\x18\n\r\n\x05\x04R\x02\x02\x01\x12\
    \x04\xe9\x05\x19#\n\r\n\x05\x04R\x02\x02\x03\x12\x04\xe9\x05&'\n\x0c\n\
    \x04\x04R\x02\x03\x12\x04\xea\x05\x080\n\r\n\x05\x04R\x02\x03\x04\x12\
    \x04\xea\x05\x08\x10\n\r\n\x05\x04R\x02\x03\x06\x12\x04\xea\x05\x11\"\n\
    \r\n\x05\x04R\x02\x03\x01\x12\x04\xea\x05#*\n\r\n\x05\x04R\x02\x03\x03\
    \x12\x04\xea\x05-/\n\x0c\n\x04\x04R\x02\x04\x12\x04\xeb\x05\x081\n\r\n\
    \x05\x04R\x02\x04\x04\x12\x04\xeb\x05\x08\x10\n\r\n\x05\x04R\x02\x04\x05\
    \x12\x04\xeb\x05\x11\x17\n\r\n\x05\x04R\x02\x04\x01\x12\x04\xeb\x05\x18+\
    \n\r\n\x05\x04R\x02\x04\x03\x12\x04\xeb\x05.0\n\x0c\n\x04\x04R\x02\x05\
    \x12\x04\xec\x05\x08f\n\r\n\x05\x04R\x02\x05\x04\x12\x04\xec\x05\x08\x10\
    \n\r\n\x05\x04R\x02\x05\x06\x12\x04\xec\x05\x11\x1f\n\r\n\x05\x04R\x02\
    \x05\x01\x12\x04\xec\x05\x20<\n\r\n\x05\x04R\x02\x05\x03\x12\x04\xec\x05\
    ?A\n\r\n\x05\x04R\x02\x05\x08\x12\x04\xec\x05Be\n\r\n\x05\x04R\x02\x05\
    \x07\x12\x04\xec\x05Md\n\x0c\n\x04\x04R\x02\x06\x12\x04\xed\x05\x08@\n\r\
    \n\x05\x04R\x02\x06\x04\x12\x04\xed\x05\x08\x10\n\r\n\x05\x04R\x02\x06\
    \x06\x12\x04\xed\x05\x11'\n\r\n\x05\x04R\x02\x06\x01\x12\x04\xed\x05(:\n\
    \r\n\x05\x04R\x02\x06\x03\x12\x04\xed\x05=?\n\x0c\n\x04\x04R\x02\x07\x12\
    \x04\xee\x05\x08A\n\r\n\x05\x04R\x02\x07\x04\x12\x04\xee\x05\x08\x10\n\r\
    \n\x05\x04R\x02\x07\x06\x12\x04\xee\x05\x11,\n\r\n\x05\x04R\x02\x07\x01\
    \x12\x04\xee\x05-;\n\r\n\x05\x04R\x02\x07\x03\x12\x04\xee\x05>@\n\x0c\n\
    \x04\x04R\x02\x08\x12\x04\xef\x05\x080\n\r\n\x05\x04R\x02\x08\x04\x12\
    \x04\xef\x05\x08\x10\n\r\n\x05\x04R\x02\x08\x05\x12\x04\xef\x05\x11\x17\
    \n\r\n\x05\x04R\x02\x08\x01\x12\x04\xef\x05\x18*\n\r\n\x05\x04R\x02\x08\
    \x03\x12\x04\xef\x05-/\n\x0c\n\x04\x04R\x02\t\x12\x04\xf0\x05\x086\n\r\n\
    \x05\x04R\x02\t\x04\x12\x04\xf0\x05\x08\x10\n\r\n\x05\x04R\x02\t\x05\x12\
    \x04\xf0\x05\x11\x17\n\r\n\x05\x04R\x02\t\x01\x12\x04\xf0\x05\x180\n\r\n\
    \x05\x04R\x02\t\x03\x12\x04\xf0\x0535\n\x0c\n\x04\x04R\x02\n\x12\x04\xf1\
    \x05\x080\n\r\n\x05\x04R\x02\n\x04\x12\x04\xf1\x05\x08\x10\n\r\n\x05\x04\
    R\x02\n\x05\x12\x04\xf1\x05\x11\x17\n\r\n\x05\x04R\x02\n\x01\x12\x04\xf1\
    \x05\x18*\n\r\n\x05\x04R\x02\n\x03\x12\x04\xf1\x05-/\n\x0c\n\x04\x04R\
    \x02\x0b\x12\x04\xf2\x05\x086\n\r\n\x05\x04R\x02\x0b\x04\x12\x04\xf2\x05\
    \x08\x10\n\r\n\x05\x04R\x02\x0b\x05\x12\x04\xf2\x05\x11\x17\n\r\n\x05\
    \x04R\x02\x0b\x01\x12\x04\xf2\x05\x180\n\r\n\x05\x04R\x02\x0b\x03\x12\
    \x04\xf2\x0535\n\x0c\n\x04\x04R\x02\x0c\x12\x04\xf3\x05\x089\n\r\n\x05\
    \x04R\x02\x0c\x04\x12\x04\xf3\x05\x08\x10\n\r\n\x05\x04R\x02\x0c\x06\x12\
    \x04\xf3\x05\x11#\n\r\n\x05\x04R\x02\x0c\x01\x12\x04\xf3\x05$3\n\r\n\x05\
    \x04R\x02\x0c\x03\x12\x04\xf3\x0568\n\x0c\n\x04\x04R\x02\r\x12\x04\xf4\
    \x05\x08<\n\r\n\x05\x04R\x02\r\x04\x12\x04\xf4\x05\x08\x10\n\r\n\x05\x04\
    R\x02\r\x06\x12\x04\xf4\x05\x11&\n\r\n\x05\x04R\x02\r\x01\x12\x04\xf4\
    \x05'6\n\r\n\x05\x04R\x02\r\x03\x12\x04\xf4\x059;\n\x0c\n\x02\x04S\x12\
    \x06\xf7\x05\0\x85\x06\x01\n\x0b\n\x03\x04S\x01\x12\x04\xf7\x05\x08\x18\
    \n\x0e\n\x04\x04S\x03\0\x12\x06\xf8\x05\x08\xfa\x05\t\n\r\n\x05\x04S\x03\
    \0\x01\x12\x04\xf8\x05\x10\x1b\n\x0e\n\x06\x04S\x03\0\x02\0\x12\x04\xf9\
    \x05\x10-\n\x0f\n\x07\x04S\x03\0\x02\0\x04\x12\x04\xf9\x05\x10\x18\n\x0f\
    \n\x07\x04S\x03\0\x02\0\x05\x12\x04\xf9\x05\x19\x20\n\x0f\n\x07\x04S\x03\
    \0\x02\0\x01\x12\x04\xf9\x05!(\n\x0f\n\x07\x04S\x03\0\x02\0\x03\x12\x04\
    \xf9\x05+,\n\x0e\n\x04\x04S\x04\0\x12\x06\xfc\x05\x08\xff\x05\t\n\r\n\
    \x05\x04S\x04\0\x01\x12\x04\xfc\x05\r\x11\n\x0e\n\x06\x04S\x04\0\x02\0\
    \x12\x04\xfd\x05\x10#\n\x0f\n\x07\x04S\x04\0\x02\0\x01\x12\x04\xfd\x05\
    \x10\x1e\n\x0f\n\x07\x04S\x04\0\x02\0\x02\x12\x04\xfd\x05!\"\n\x0e\n\x06\
    \x04S\x04\0\x02\x01\x12\x04\xfe\x05\x10)\n\x0f\n\x07\x04S\x04\0\x02\x01\
    \x01\x12\x04\xfe\x05\x10$\n\x0f\n\x07\x04S\x04\0\x02\x01\x02\x12\x04\xfe\
    \x05'(\n\x0c\n\x04\x04S\x02\0\x12\x04\x81\x06\x08:\n\r\n\x05\x04S\x02\0\
    \x04\x12\x04\x81\x06\x08\x10\n\r\n\x05\x04S\x02\0\x05\x12\x04\x81\x06\
    \x11\x17\n\r\n\x05\x04S\x02\0\x01\x12\x04\x81\x06\x18\x20\n\r\n\x05\x04S\
    \x02\0\x03\x12\x04\x81\x06#$\n\r\n\x05\x04S\x02\0\x08\x12\x04\x81\x06%9\
    \n\x10\n\x08\x04S\x02\0\x08\xe0\xd4\x03\x12\x04\x81\x06&8\n\x0c\n\x04\
    \x04S\x02\x01\x12\x04\x82\x06\x08%\n\r\n\x05\x04S\x02\x01\x04\x12\x04\
    \x82\x06\x08\x10\n\r\n\x05\x04S\x02\x01\x05\x12\x04\x82\x06\x11\x18\n\r\
    \n\x05\x04S\x02\x01\x01\x12\x04\x82\x06\x19\x20\n\r\n\x05\x04S\x02\x01\
    \x03\x12\x04\x82\x06#$\n\x0c\n\x04\x04S\x02\x02\x12\x04\x83\x06\x08;\n\r\
    \n\x05\x04S\x02\x02\x04\x12\x04\x83\x06\x08\x10\n\r\n\x05\x04S\x02\x02\
    \x06\x12\x04\x83\x06\x11.\n\r\n\x05\x04S\x02\x02\x01\x12\x04\x83\x06/6\n\
    \r\n\x05\x04S\x02\x02\x03\x12\x04\x83\x069:\n\x0c\n\x04\x04S\x02\x03\x12\
    \x04\x84\x06\x08L\n\r\n\x05\x04S\x02\x03\x04\x12\x04\x84\x06\x08\x10\n\r\
    \n\x05\x04S\x02\x03\x06\x12\x04\x84\x06\x11'\n\r\n\x05\x04S\x02\x03\x01\
    \x12\x04\x84\x06(,\n\r\n\x05\x04S\x02\x03\x03\x12\x04\x84\x06/0\n\r\n\
    \x05\x04S\x02\x03\x08\x12\x04\x84\x061K\n\r\n\x05\x04S\x02\x03\x07\x12\
    \x04\x84\x06<J\n\x0c\n\x02\x04T\x12\x06\x87\x06\0\xa4\x06\x01\n\x0b\n\
    \x03\x04T\x01\x12\x04\x87\x06\x08\x1b\n\x0e\n\x04\x04T\x04\0\x12\x06\x88\
    \x06\x08\x8e\x06\t\n\r\n\x05\x04T\x04\0\x01\x12\x04\x88\x06\r\x19\n\x0e\
    \n\x06\x04T\x04\0\x02\0\x12\x04\x89\x06\x10\x1c\n\x0f\n\x07\x04T\x04\0\
    \x02\0\x01\x12\x04\x89\x06\x10\x17\n\x0f\n\x07\x04T\x04\0\x02\0\x02\x12\
    \x04\x89\x06\x1a\x1b\n\x0e\n\x06\x04T\x04\0\x02\x01\x12\x04\x8a\x06\x10(\
    \n\x0f\n\x07\x04T\x04\0\x02\x01\x01\x12\x04\x8a\x06\x10#\n\x0f\n\x07\x04\
    T\x04\0\x02\x01\x02\x12\x04\x8a\x06&'\n\x0e\n\x06\x04T\x04\0\x02\x02\x12\
    \x04\x8b\x06\x10\x1d\n\x0f\n\x07\x04T\x04\0\x02\x02\x01\x12\x04\x8b\x06\
    \x10\x18\n\x0f\n\x07\x04T\x04\0\x02\x02\x02\x12\x04\x8b\x06\x1b\x1c\n\
    \x0e\n\x06\x04T\x04\0\x02\x03\x12\x04\x8c\x06\x10\x1e\n\x0f\n\x07\x04T\
    \x04\0\x02\x03\x01\x12\x04\x8c\x06\x10\x19\n\x0f\n\x07\x04T\x04\0\x02\
    \x03\x02\x12\x04\x8c\x06\x1c\x1d\n\x0e\n\x06\x04T\x04\0\x02\x04\x12\x04\
    \x8d\x06\x10!\n\x0f\n\x07\x04T\x04\0\x02\x04\x01\x12\x04\x8d\x06\x10\x1c\
    \n\x0f\n\x07\x04T\x04\0\x02\x04\x02\x12\x04\x8d\x06\x1f\x20\n\x0e\n\x04\
    \x04T\x04\x01\x12\x06\x90\x06\x08\x95\x06\t\n\r\n\x05\x04T\x04\x01\x01\
    \x12\x04\x90\x06\r\x11\n\x0e\n\x06\x04T\x04\x01\x02\0\x12\x04\x91\x06\
    \x10#\n\x0f\n\x07\x04T\x04\x01\x02\0\x01\x12\x04\x91\x06\x10\x1e\n\x0f\n\
    \x07\x04T\x04\x01\x02\0\x02\x12\x04\x91\x06!\"\n\x0e\n\x06\x04T\x04\x01\
    \x02\x01\x12\x04\x92\x06\x10!\n\x0f\n\x07\x04T\x04\x01\x02\x01\x01\x12\
    \x04\x92\x06\x10\x1c\n\x0f\n\x07\x04T\x04\x01\x02\x01\x02\x12\x04\x92\
    \x06\x1f\x20\n\x0e\n\x06\x04T\x04\x01\x02\x02\x12\x04\x93\x06\x10#\n\x0f\
    \n\x07\x04T\x04\x01\x02\x02\x01\x12\x04\x93\x06\x10\x1e\n\x0f\n\x07\x04T\
    \x04\x01\x02\x02\x02\x12\x04\x93\x06!\"\n\x0e\n\x06\x04T\x04\x01\x02\x03\
    \x12\x04\x94\x06\x10%\n\x0f\n\x07\x04T\x04\x01\x02\x03\x01\x12\x04\x94\
    \x06\x10\x20\n\x0f\n\x07\x04T\x04\x01\x02\x03\x02\x12\x04\x94\x06#$\n\
    \x0c\n\x04\x04T\x02\0\x12\x04\x97\x06\x085\n\r\n\x05\x04T\x02\0\x04\x12\
    \x04\x97\x06\x08\x10\n\r\n\x05\x04T\x02\0\x05\x12\x04\x97\x06\x11\x18\n\
    \r\n\x05\x04T\x02\0\x01\x12\x04\x97\x06\x19\x1b\n\r\n\x05\x04T\x02\0\x03\
    \x12\x04\x97\x06\x1e\x1f\n\r\n\x05\x04T\x02\0\x08\x12\x04\x97\x06\x204\n\
    \x10\n\x08\x04T\x02\0\x08\xe0\xd4\x03\x12\x04\x97\x06!3\n\x0c\n\x04\x04T\
    \x02\x01\x12\x04\x98\x06\x08G\n\r\n\x05\x04T\x02\x01\x04\x12\x04\x98\x06\
    \x08\x10\n\r\n\x05\x04T\x02\x01\x06\x12\x04\x98\x06\x11\x1c\n\r\n\x05\
    \x04T\x02\x01\x01\x12\x04\x98\x06\x1d!\n\r\n\x05\x04T\x02\x01\x03\x12\
    \x04\x98\x06$%\n\r\n\x05\x04T\x02\x01\x08\x12\x04\x98\x06&F\n\r\n\x05\
    \x04T\x02\x01\x07\x12\x04\x98\x061E\n\x0c\n\x04\x04T\x02\x02\x12\x04\x99\
    \x06\x08Z\n\r\n\x05\x04T\x02\x02\x04\x12\x04\x99\x06\x08\x10\n\r\n\x05\
    \x04T\x02\x02\x06\x12\x04\x99\x06\x112\n\r\n\x05\x04T\x02\x02\x01\x12\
    \x04\x99\x063@\n\r\n\x05\x04T\x02\x02\x03\x12\x04\x99\x06CE\n\r\n\x05\
    \x04T\x02\x02\x08\x12\x04\x99\x06FY\n\r\n\x05\x04T\x02\x02\x07\x12\x04\
    \x99\x06QX\n\x0c\n\x04\x04T\x02\x03\x12\x04\x9a\x06\x08!\n\r\n\x05\x04T\
    \x02\x03\x04\x12\x04\x9a\x06\x08\x10\n\r\n\x05\x04T\x02\x03\x05\x12\x04\
    \x9a\x06\x11\x17\n\r\n\x05\x04T\x02\x03\x01\x12\x04\x9a\x06\x18\x1c\n\r\
    \n\x05\x04T\x02\x03\x03\x12\x04\x9a\x06\x1f\x20\n\x0c\n\x04\x04T\x02\x04\
    \x12\x04\x9b\x06\x08/\n\r\n\x05\x04T\x02\x04\x04\x12\x04\x9b\x06\x08\x10\
    \n\r\n\x05\x04T\x02\x04\x05\x12\x04\x9b\x06\x11\x17\n\r\n\x05\x04T\x02\
    \x04\x01\x12\x04\x9b\x06\x18)\n\r\n\x05\x04T\x02\x04\x03\x12\x04\x9b\x06\
    ,.\n\x0c\n\x04\x04T\x02\x05\x12\x04\x9c\x06\x08)\n\r\n\x05\x04T\x02\x05\
    \x04\x12\x04\x9c\x06\x08\x10\n\r\n\x05\x04T\x02\x05\x05\x12\x04\x9c\x06\
    \x11\x15\n\r\n\x05\x04T\x02\x05\x01\x12\x04\x9c\x06\x16#\n\r\n\x05\x04T\
    \x02\x05\x03\x12\x04\x9c\x06&(\n\x0c\n\x04\x04T\x02\x06\x12\x04\x9d\x06\
    \x08)\n\r\n\x05\x04T\x02\x06\x04\x12\x04\x9d\x06\x08\x10\n\r\n\x05\x04T\
    \x02\x06\x05\x12\x04\x9d\x06\x11\x17\n\r\n\x05\x04T\x02\x06\x01\x12\x04\
    \x9d\x06\x18#\n\r\n\x05\x04T\x02\x06\x03\x12\x04\x9d\x06&(\n\x0c\n\x04\
    \x04T\x02\x07\x12\x04\x9e\x06\x08/\n\r\n\x05\x04T\x02\x07\x04\x12\x04\
    \x9e\x06\x08\x10\n\r\n\x05\x04T\x02\x07\x05\x12\x04\x9e\x06\x11\x17\n\r\
    \n\x05\x04T\x02\x07\x01\x12\x04\x9e\x06\x18)\n\r\n\x05\x04T\x02\x07\x03\
    \x12\x04\x9e\x06,.\n\x0c\n\x04\x04T\x02\x08\x12\x04\x9f\x06\x08P\n\r\n\
    \x05\x04T\x02\x08\x04\x12\x04\x9f\x06\x08\x10\n\r\n\x05\x04T\x02\x08\x06\
    \x12\x04\x9f\x06\x11*\n\r\n\x05\x04T\x02\x08\x01\x12\x04\x9f\x06+/\n\r\n\
    \x05\x04T\x02\x08\x03\x12\x04\x9f\x0624\n\r\n\x05\x04T\x02\x08\x08\x12\
    \x04\x9f\x065O\n\r\n\x05\x04T\x02\x08\x07\x12\x04\x9f\x06@N\n\x0c\n\x04\
    \x04T\x02\t\x12\x04\xa0\x06\x08/\n\r\n\x05\x04T\x02\t\x04\x12\x04\xa0\
    \x06\x08\x10\n\r\n\x05\x04T\x02\t\x05\x12\x04\xa0\x06\x11\x17\n\r\n\x05\
    \x04T\x02\t\x01\x12\x04\xa0\x06\x18)\n\r\n\x05\x04T\x02\t\x03\x12\x04\
    \xa0\x06,.\n\x0c\n\x04\x04T\x02\n\x12\x04\xa1\x06\x084\n\r\n\x05\x04T\
    \x02\n\x04\x12\x04\xa1\x06\x08\x10\n\r\n\x05\x04T\x02\n\x05\x12\x04\xa1\
    \x06\x11\x17\n\r\n\x05\x04T\x02\n\x01\x12\x04\xa1\x06\x18.\n\r\n\x05\x04\
    T\x02\n\x03\x12\x04\xa1\x0613\n\x0c\n\x04\x04T\x02\x0b\x12\x04\xa2\x06\
    \x08\"\n\r\n\x05\x04T\x02\x0b\x04\x12\x04\xa2\x06\x08\x10\n\r\n\x05\x04T\
    \x02\x0b\x05\x12\x04\xa2\x06\x11\x17\n\r\n\x05\x04T\x02\x0b\x01\x12\x04\
    \xa2\x06\x18\x1c\n\r\n\x05\x04T\x02\x0b\x03\x12\x04\xa2\x06\x1f!\n\x0c\n\
    \x04\x04T\x02\x0c\x12\x04\xa3\x06\x08+\n\r\n\x05\x04T\x02\x0c\x04\x12\
    \x04\xa3\x06\x08\x10\n\r\n\x05\x04T\x02\x0c\x05\x12\x04\xa3\x06\x11\x15\
    \n\r\n\x05\x04T\x02\x0c\x01\x12\x04\xa3\x06\x16%\n\r\n\x05\x04T\x02\x0c\
    \x03\x12\x04\xa3\x06(*\n\x0c\n\x02\x04U\x12\x06\xa6\x06\0\xa9\x06\x01\n\
    \x0b\n\x03\x04U\x01\x12\x04\xa6\x06\x08\x1b\n\x0c\n\x04\x04U\x02\0\x12\
    \x04\xa7\x06\x08;\n\r\n\x05\x04U\x02\0\x04\x12\x04\xa7\x06\x08\x10\n\r\n\
    \x05\x04U\x02\0\x05\x12\x04\xa7\x06\x11\x18\n\r\n\x05\x04U\x02\0\x01\x12\
    \x04\xa7\x06\x19!\n\r\n\x05\x04U\x02\0\x03\x12\x04\xa7\x06$%\n\r\n\x05\
    \x04U\x02\0\x08\x12\x04\xa7\x06&:\n\x10\n\x08\x04U\x02\0\x08\xe0\xd4\x03\
    \x12\x04\xa7\x06'9\n\x0c\n\x04\x04U\x02\x01\x12\x04\xa8\x06\x08T\n\r\n\
    \x05\x04U\x02\x01\x04\x12\x04\xa8\x06\x08\x10\n\r\n\x05\x04U\x02\x01\x06\
    \x12\x04\xa8\x06\x11\x1f\n\r\n\x05\x04U\x02\x01\x01\x12\x04\xa8\x06\x20+\
    \n\r\n\x05\x04U\x02\x01\x03\x12\x04\xa8\x06./\n\r\n\x05\x04U\x02\x01\x08\
    \x12\x04\xa8\x060S\n\r\n\x05\x04U\x02\x01\x07\x12\x04\xa8\x06;R\n\x0c\n\
    \x02\x04V\x12\x06\xab\x06\0\xcc\x06\x01\n\x0b\n\x03\x04V\x01\x12\x04\xab\
    \x06\x08\x1c\n\x0e\n\x04\x04V\x04\0\x12\x06\xac\x06\x08\xb0\x06\t\n\r\n\
    \x05\x04V\x04\0\x01\x12\x04\xac\x06\r\x12\n\x0e\n\x06\x04V\x04\0\x02\0\
    \x12\x04\xad\x06\x10\x1c\n\x0f\n\x07\x04V\x04\0\x02\0\x01\x12\x04\xad\
    \x06\x10\x17\n\x0f\n\x07\x04V\x04\0\x02\0\x02\x12\x04\xad\x06\x1a\x1b\n\
    \x0e\n\x06\x04V\x04\0\x02\x01\x12\x04\xae\x06\x10\x20\n\x0f\n\x07\x04V\
    \x04\0\x02\x01\x01\x12\x04\xae\x06\x10\x1b\n\x0f\n\x07\x04V\x04\0\x02\
    \x01\x02\x12\x04\xae\x06\x1e\x1f\n\x0e\n\x06\x04V\x04\0\x02\x02\x12\x04\
    \xaf\x06\x10\x18\n\x0f\n\x07\x04V\x04\0\x02\x02\x01\x12\x04\xaf\x06\x10\
    \x13\n\x0f\n\x07\x04V\x04\0\x02\x02\x02\x12\x04\xaf\x06\x16\x17\n\x0e\n\
    \x04\x04V\x04\x01\x12\x06\xb2\x06\x08\xb6\x06\t\n\r\n\x05\x04V\x04\x01\
    \x01\x12\x04\xb2\x06\r\x15\n\x0e\n\x06\x04V\x04\x01\x02\0\x12\x04\xb3\
    \x06\x10\x19\n\x0f\n\x07\x04V\x04\x01\x02\0\x01\x12\x04\xb3\x06\x10\x14\
    \n\x0f\n\x07\x04V\x04\x01\x02\0\x02\x12\x04\xb3\x06\x17\x18\n\x0e\n\x06\
    \x04V\x04\x01\x02\x01\x12\x04\xb4\x06\x10&\n\x0f\n\x07\x04V\x04\x01\x02\
    \x01\x01\x12\x04\xb4\x06\x10!\n\x0f\n\x07\x04V\x04\x01\x02\x01\x02\x12\
    \x04\xb4\x06$%\n\x0e\n\x06\x04V\x04\x01\x02\x02\x12\x04\xb5\x06\x10'\n\
    \x0f\n\x07\x04V\x04\x01\x02\x02\x01\x12\x04\xb5\x06\x10\"\n\x0f\n\x07\
    \x04V\x04\x01\x02\x02\x02\x12\x04\xb5\x06%&\n\x0c\n\x04\x04V\x02\0\x12\
    \x04\xb8\x06\x08:\n\r\n\x05\x04V\x02\0\x04\x12\x04\xb8\x06\x08\x10\n\r\n\
    \x05\x04V\x02\0\x05\x12\x04\xb8\x06\x11\x17\n\r\n\x05\x04V\x02\0\x01\x12\
    \x04\xb8\x06\x18\x20\n\r\n\x05\x04V\x02\0\x03\x12\x04\xb8\x06#$\n\r\n\
    \x05\x04V\x02\0\x08\x12\x04\xb8\x06%9\n\x10\n\x08\x04V\x02\0\x08\xe0\xd4\
    \x03\x12\x04\xb8\x06&8\n\x0c\n\x04\x04V\x02\x01\x12\x04\xb9\x06\x082\n\r\
    \n\x05\x04V\x02\x01\x04\x12\x04\xb9\x06\x08\x10\n\r\n\x05\x04V\x02\x01\
    \x06\x12\x04\xb9\x06\x11%\n\r\n\x05\x04V\x02\x01\x01\x12\x04\xb9\x06&-\n\
    \r\n\x05\x04V\x02\x01\x03\x12\x04\xb9\x0601\n\x0c\n\x04\x04V\x02\x02\x12\
    \x04\xba\x06\x085\n\r\n\x05\x04V\x02\x02\x04\x12\x04\xba\x06\x08\x10\n\r\
    \n\x05\x04V\x02\x02\x05\x12\x04\xba\x06\x11\x18\n\r\n\x05\x04V\x02\x02\
    \x01\x12\x04\xba\x06\x19\"\n\r\n\x05\x04V\x02\x02\x03\x12\x04\xba\x06%&\
    \n\r\n\x05\x04V\x02\x02\x08\x12\x04\xba\x06'4\n\r\n\x05\x04V\x02\x02\x07\
    \x12\x04\xba\x0623\n\x0c\n\x04\x04V\x02\x03\x12\x04\xbb\x06\x08K\n\r\n\
    \x05\x04V\x02\x03\x04\x12\x04\xbb\x06\x08\x10\n\r\n\x05\x04V\x02\x03\x06\
    \x12\x04\xbb\x06\x11,\n\r\n\x05\x04V\x02\x03\x01\x12\x04\xbb\x06-2\n\r\n\
    \x05\x04V\x02\x03\x03\x12\x04\xbb\x0656\n\r\n\x05\x04V\x02\x03\x08\x12\
    \x04\xbb\x067J\n\r\n\x05\x04V\x02\x03\x07\x12\x04\xbb\x06BI\n\x0c\n\x04\
    \x04V\x02\x04\x12\x04\xbc\x06\x08$\n\r\n\x05\x04V\x02\x04\x04\x12\x04\
    \xbc\x06\x08\x10\n\r\n\x05\x04V\x02\x04\x05\x12\x04\xbc\x06\x11\x17\n\r\
    \n\x05\x04V\x02\x04\x01\x12\x04\xbc\x06\x18\x1f\n\r\n\x05\x04V\x02\x04\
    \x03\x12\x04\xbc\x06\"#\n\x0c\n\x04\x04V\x02\x05\x12\x04\xbd\x06\x08Y\n\
    \r\n\x05\x04V\x02\x05\x04\x12\x04\xbd\x06\x08\x10\n\r\n\x05\x04V\x02\x05\
    \x06\x12\x04\xbd\x06\x11!\n\r\n\x05\x04V\x02\x05\x01\x12\x04\xbd\x06\",\
    \n\r\n\x05\x04V\x02\x05\x03\x12\x04\xbd\x06/1\n\r\n\x05\x04V\x02\x05\x08\
    \x12\x04\xbd\x062X\n\r\n\x05\x04V\x02\x05\x07\x12\x04\xbd\x06=W\n\x0c\n\
    \x04\x04V\x02\x06\x12\x04\xbe\x06\x087\n\r\n\x05\x04V\x02\x06\x04\x12\
    \x04\xbe\x06\x08\x10\n\r\n\x05\x04V\x02\x06\x05\x12\x04\xbe\x06\x11\x17\
    \n\r\n\x05\x04V\x02\x06\x01\x12\x04\xbe\x06\x181\n\r\n\x05\x04V\x02\x06\
    \x03\x12\x04\xbe\x0646\n\x0c\n\x04\x04V\x02\x07\x12\x04\xbf\x06\x08.\n\r\
    \n\x05\x04V\x02\x07\x04\x12\x04\xbf\x06\x08\x10\n\r\n\x05\x04V\x02\x07\
    \x05\x12\x04\xbf\x06\x11\x17\n\r\n\x05\x04V\x02\x07\x01\x12\x04\xbf\x06\
    \x18(\n\r\n\x05\x04V\x02\x07\x03\x12\x04\xbf\x06+-\n\x0c\n\x04\x04V\x02\
    \x08\x12\x04\xc0\x06\x08&\n\r\n\x05\x04V\x02\x08\x04\x12\x04\xc0\x06\x08\
    \x10\n\r\n\x05\x04V\x02\x08\x05\x12\x04\xc0\x06\x11\x17\n\r\n\x05\x04V\
    \x02\x08\x01\x12\x04\xc0\x06\x18\x20\n\r\n\x05\x04V\x02\x08\x03\x12\x04\
    \xc0\x06#%\n\x0c\n\x04\x04V\x02\t\x12\x04\xc1\x06\x08*\n\r\n\x05\x04V\
    \x02\t\x04\x12\x04\xc1\x06\x08\x10\n\r\n\x05\x04V\x02\t\x05\x12\x04\xc1\
    \x06\x11\x17\n\r\n\x05\x04V\x02\t\x01\x12\x04\xc1\x06\x18$\n\r\n\x05\x04\
    V\x02\t\x03\x12\x04\xc1\x06')\n\x0c\n\x04\x04V\x02\n\x12\x04\xc2\x06\x08\
    )\n\r\n\x05\x04V\x02\n\x04\x12\x04\xc2\x06\x08\x10\n\r\n\x05\x04V\x02\n\
    \x05\x12\x04\xc2\x06\x11\x17\n\r\n\x05\x04V\x02\n\x01\x12\x04\xc2\x06\
    \x18#\n\r\n\x05\x04V\x02\n\x03\x12\x04\xc2\x06&(\n\x0c\n\x04\x04V\x02\
    \x0b\x12\x04\xc3\x06\x084\n\r\n\x05\x04V\x02\x0b\x04\x12\x04\xc3\x06\x08\
    \x10\n\r\n\x05\x04V\x02\x0b\x05\x12\x04\xc3\x06\x11\x17\n\r\n\x05\x04V\
    \x02\x0b\x01\x12\x04\xc3\x06\x18\x20\n\r\n\x05\x04V\x02\x0b\x03\x12\x04\
    \xc3\x06#%\n\r\n\x05\x04V\x02\x0b\x08\x12\x04\xc3\x06&3\n\r\n\x05\x04V\
    \x02\x0b\x07\x12\x04\xc3\x0612\n\x0c\n\x04\x04V\x02\x0c\x12\x04\xc4\x06\
    \x08)\n\r\n\x05\x04V\x02\x0c\x04\x12\x04\xc4\x06\x08\x10\n\r\n\x05\x04V\
    \x02\x0c\x05\x12\x04\xc4\x06\x11\x17\n\r\n\x05\x04V\x02\x0c\x01\x12\x04\
    \xc4\x06\x18#\n\r\n\x05\x04V\x02\x0c\x03\x12\x04\xc4\x06&(\n\x0c\n\x04\
    \x04V\x02\r\x12\x04\xc5\x06\x08#\n\r\n\x05\x04V\x02\r\x04\x12\x04\xc5\
    \x06\x08\x10\n\r\n\x05\x04V\x02\r\x05\x12\x04\xc5\x06\x11\x17\n\r\n\x05\
    \x04V\x02\r\x01\x12\x04\xc5\x06\x18\x1d\n\r\n\x05\x04V\x02\r\x03\x12\x04\
    \xc5\x06\x20\"\n\x0c\n\x04\x04V\x02\x0e\x12\x04\xc6\x06\x08.\n\r\n\x05\
    \x04V\x02\x0e\x04\x12\x04\xc6\x06\x08\x10\n\r\n\x05\x04V\x02\x0e\x05\x12\
    \x04\xc6\x06\x11\x15\n\r\n\x05\x04V\x02\x0e\x01\x12\x04\xc6\x06\x16(\n\r\
    \n\x05\x04V\x02\x0e\x03\x12\x04\xc6\x06+-\n\x0c\n\x04\x04V\x02\x0f\x12\
    \x04\xc7\x06\x08.\n\r\n\x05\x04V\x02\x0f\x04\x12\x04\xc7\x06\x08\x10\n\r\
    \n\x05\x04V\x02\x0f\x05\x12\x04\xc7\x06\x11\x17\n\r\n\x05\x04V\x02\x0f\
    \x01\x12\x04\xc7\x06\x18(\n\r\n\x05\x04V\x02\x0f\x03\x12\x04\xc7\x06+-\n\
    \x0c\n\x04\x04V\x02\x10\x12\x04\xc8\x06\x08S\n\r\n\x05\x04V\x02\x10\x04\
    \x12\x04\xc8\x06\x08\x10\n\r\n\x05\x04V\x02\x10\x06\x12\x04\xc8\x06\x11/\
    \n\r\n\x05\x04V\x02\x10\x01\x12\x04\xc8\x060<\n\r\n\x05\x04V\x02\x10\x03\
    \x12\x04\xc8\x06?A\n\r\n\x05\x04V\x02\x10\x08\x12\x04\xc8\x06BR\n\r\n\
    \x05\x04V\x02\x10\x07\x12\x04\xc8\x06MQ\n\x0c\n\x04\x04V\x02\x11\x12\x04\
    \xc9\x06\x080\n\r\n\x05\x04V\x02\x11\x04\x12\x04\xc9\x06\x08\x10\n\r\n\
    \x05\x04V\x02\x11\x05\x12\x04\xc9\x06\x11\x17\n\r\n\x05\x04V\x02\x11\x01\
    \x12\x04\xc9\x06\x18*\n\r\n\x05\x04V\x02\x11\x03\x12\x04\xc9\x06-/\n\x0c\
    \n\x04\x04V\x02\x12\x12\x04\xca\x06\x08.\n\r\n\x05\x04V\x02\x12\x04\x12\
    \x04\xca\x06\x08\x10\n\r\n\x05\x04V\x02\x12\x05\x12\x04\xca\x06\x11\x17\
    \n\r\n\x05\x04V\x02\x12\x01\x12\x04\xca\x06\x18(\n\r\n\x05\x04V\x02\x12\
    \x03\x12\x04\xca\x06+-\n\x0c\n\x04\x04V\x02\x13\x12\x04\xcb\x06\x08;\n\r\
    \n\x05\x04V\x02\x13\x04\x12\x04\xcb\x06\x08\x10\n\r\n\x05\x04V\x02\x13\
    \x06\x12\x04\xcb\x06\x11%\n\r\n\x05\x04V\x02\x13\x01\x12\x04\xcb\x06&5\n\
    \r\n\x05\x04V\x02\x13\x03\x12\x04\xcb\x068:\n\x0c\n\x02\x04W\x12\x06\xce\
    \x06\0\xd2\x06\x01\n\x0b\n\x03\x04W\x01\x12\x04\xce\x06\x08\x1b\n\x0c\n\
    \x04\x04W\x02\0\x12\x04\xcf\x06\x08+\n\r\n\x05\x04W\x02\0\x04\x12\x04\
    \xcf\x06\x08\x10\n\r\n\x05\x04W\x02\0\x05\x12\x04\xcf\x06\x11\x15\n\r\n\
    \x05\x04W\x02\0\x01\x12\x04\xcf\x06\x16&\n\r\n\x05\x04W\x02\0\x03\x12\
    \x04\xcf\x06)*\n\x0c\n\x04\x04W\x02\x01\x12\x04\xd0\x06\x08%\n\r\n\x05\
    \x04W\x02\x01\x04\x12\x04\xd0\x06\x08\x10\n\r\n\x05\x04W\x02\x01\x05\x12\
    \x04\xd0\x06\x11\x17\n\r\n\x05\x04W\x02\x01\x01\x12\x04\xd0\x06\x18\x20\
    \n\r\n\x05\x04W\x02\x01\x03\x12\x04\xd0\x06#$\n\x0c\n\x04\x04W\x02\x02\
    \x12\x04\xd1\x06\x08%\n\r\n\x05\x04W\x02\x02\x04\x12\x04\xd1\x06\x08\x10\
    \n\r\n\x05\x04W\x02\x02\x05\x12\x04\xd1\x06\x11\x17\n\r\n\x05\x04W\x02\
    \x02\x01\x12\x04\xd1\x06\x18\x20\n\r\n\x05\x04W\x02\x02\x03\x12\x04\xd1\
    \x06#$\n\x0c\n\x02\x04X\x12\x06\xd4\x06\0\xd8\x06\x01\n\x0b\n\x03\x04X\
    \x01\x12\x04\xd4\x06\x08\x1d\n\x0c\n\x04\x04X\x02\0\x12\x04\xd5\x06\x08-\
    \n\r\n\x05\x04X\x02\0\x04\x12\x04\xd5\x06\x08\x10\n\r\n\x05\x04X\x02\0\
    \x05\x12\x04\xd5\x06\x11\x17\n\r\n\x05\x04X\x02\0\x01\x12\x04\xd5\x06\
    \x18(\n\r\n\x05\x04X\x02\0\x03\x12\x04\xd5\x06+,\n\x0c\n\x04\x04X\x02\
    \x01\x12\x04\xd6\x06\x080\n\r\n\x05\x04X\x02\x01\x04\x12\x04\xd6\x06\x08\
    \x10\n\r\n\x05\x04X\x02\x01\x05\x12\x04\xd6\x06\x11\x17\n\r\n\x05\x04X\
    \x02\x01\x01\x12\x04\xd6\x06\x18+\n\r\n\x05\x04X\x02\x01\x03\x12\x04\xd6\
    \x06./\n\x0c\n\x04\x04X\x02\x02\x12\x04\xd7\x06\x088\n\r\n\x05\x04X\x02\
    \x02\x04\x12\x04\xd7\x06\x08\x10\n\r\n\x05\x04X\x02\x02\x05\x12\x04\xd7\
    \x06\x11\x17\n\r\n\x05\x04X\x02\x02\x01\x12\x04\xd7\x06\x183\n\r\n\x05\
    \x04X\x02\x02\x03\x12\x04\xd7\x0667\n\x0c\n\x02\x04Y\x12\x06\xda\x06\0\
    \xdb\x06\x01\n\x0b\n\x03\x04Y\x01\x12\x04\xda\x06\x08\"\n\x0c\n\x02\x04Z\
    \x12\x06\xdd\x06\0\xde\x06\x01\n\x0b\n\x03\x04Z\x01\x12\x04\xdd\x06\x08)\
    \n\x0c\n\x02\x04[\x12\x06\xe0\x06\0\xe2\x06\x01\n\x0b\n\x03\x04[\x01\x12\
    \x04\xe0\x06\x08*\n\x0c\n\x04\x04[\x02\0\x12\x04\xe1\x06\x087\n\r\n\x05\
    \x04[\x02\0\x04\x12\x04\xe1\x06\x08\x10\n\r\n\x05\x04[\x02\0\x05\x12\x04\
    \xe1\x06\x11\x17\n\r\n\x05\x04[\x02\0\x01\x12\x04\xe1\x06\x182\n\r\n\x05\
    \x04[\x02\0\x03\x12\x04\xe1\x0656\n\x0c\n\x02\x04\\\x12\x06\xe4\x06\0\
    \xe5\x06\x01\n\x0b\n\x03\x04\\\x01\x12\x04\xe4\x06\x08&\n\x0c\n\x02\x04]\
    \x12\x06\xe7\x06\0\x90\x07\x01\n\x0b\n\x03\x04]\x01\x12\x04\xe7\x06\x08'\
    \n\x0e\n\x04\x04]\x03\0\x12\x06\xe8\x06\x08\xeb\x06\t\n\r\n\x05\x04]\x03\
    \0\x01\x12\x04\xe8\x06\x10\x16\n\x0e\n\x06\x04]\x03\0\x02\0\x12\x04\xe9\
    \x06\x10.\n\x0f\n\x07\x04]\x03\0\x02\0\x04\x12\x04\xe9\x06\x10\x18\n\x0f\
    \n\x07\x04]\x03\0\x02\0\x05\x12\x04\xe9\x06\x19\x20\n\x0f\n\x07\x04]\x03\
    \0\x02\0\x01\x12\x04\xe9\x06!)\n\x0f\n\x07\x04]\x03\0\x02\0\x03\x12\x04\
    \xe9\x06,-\n\x0e\n\x06\x04]\x03\0\x02\x01\x12\x04\xea\x06\x10s\n\x0f\n\
    \x07\x04]\x03\0\x02\x01\x04\x12\x04\xea\x06\x10\x18\n\x0f\n\x07\x04]\x03\
    \0\x02\x01\x06\x12\x04\xea\x06\x19L\n\x0f\n\x07\x04]\x03\0\x02\x01\x01\
    \x12\x04\xea\x06MZ\n\x0f\n\x07\x04]\x03\0\x02\x01\x03\x12\x04\xea\x06]^\
    \n\x0f\n\x07\x04]\x03\0\x02\x01\x08\x12\x04\xea\x06_r\n\x0f\n\x07\x04]\
    \x03\0\x02\x01\x07\x12\x04\xea\x06jq\n\x0e\n\x04\x04]\x04\0\x12\x06\xed\
    \x06\x08\xf1\x06\t\n\r\n\x05\x04]\x04\0\x01\x12\x04\xed\x06\r\x1f\n\x0e\
    \n\x06\x04]\x04\0\x02\0\x12\x04\xee\x06\x10\x1c\n\x0f\n\x07\x04]\x04\0\
    \x02\0\x01\x12\x04\xee\x06\x10\x17\n\x0f\n\x07\x04]\x04\0\x02\0\x02\x12\
    \x04\xee\x06\x1a\x1b\n\x0e\n\x06\x04]\x04\0\x02\x01\x12\x04\xef\x06\x10\
    \x1e\n\x0f\n\x07\x04]\x04\0\x02\x01\x01\x12\x04\xef\x06\x10\x19\n\x0f\n\
    \x07\x04]\x04\0\x02\x01\x02\x12\x04\xef\x06\x1c\x1d\n\x0e\n\x06\x04]\x04\
    \0\x02\x02\x12\x04\xf0\x06\x10\x1d\n\x0f\n\x07\x04]\x04\0\x02\x02\x01\
    \x12\x04\xf0\x06\x10\x18\n\x0f\n\x07\x04]\x04\0\x02\x02\x02\x12\x04\xf0\
    \x06\x1b\x1c\n\x0e\n\x04\x04]\x04\x01\x12\x06\xf3\x06\x08\xf8\x06\t\n\r\
    \n\x05\x04]\x04\x01\x01\x12\x04\xf3\x06\r\x12\n\x0e\n\x06\x04]\x04\x01\
    \x02\0\x12\x04\xf4\x06\x10\x19\n\x0f\n\x07\x04]\x04\x01\x02\0\x01\x12\
    \x04\xf4\x06\x10\x14\n\x0f\n\x07\x04]\x04\x01\x02\0\x02\x12\x04\xf4\x06\
    \x17\x18\n\x0e\n\x06\x04]\x04\x01\x02\x01\x12\x04\xf5\x06\x10\x1f\n\x0f\
    \n\x07\x04]\x04\x01\x02\x01\x01\x12\x04\xf5\x06\x10\x1a\n\x0f\n\x07\x04]\
    \x04\x01\x02\x01\x02\x12\x04\xf5\x06\x1d\x1e\n\x0e\n\x06\x04]\x04\x01\
    \x02\x02\x12\x04\xf6\x06\x10\x1e\n\x0f\n\x07\x04]\x04\x01\x02\x02\x01\
    \x12\x04\xf6\x06\x10\x19\n\x0f\n\x07\x04]\x04\x01\x02\x02\x02\x12\x04\
    \xf6\x06\x1c\x1d\n\x0e\n\x06\x04]\x04\x01\x02\x03\x12\x04\xf7\x06\x10'\n\
    \x0f\n\x07\x04]\x04\x01\x02\x03\x01\x12\x04\xf7\x06\x10\"\n\x0f\n\x07\
    \x04]\x04\x01\x02\x03\x02\x12\x04\xf7\x06%&\n\x0c\n\x04\x04]\x02\0\x12\
    \x04\xfa\x06\x08=\n\r\n\x05\x04]\x02\0\x04\x12\x04\xfa\x06\x08\x10\n\r\n\
    \x05\x04]\x02\0\x05\x12\x04\xfa\x06\x11\x17\n\r\n\x05\x04]\x02\0\x01\x12\
    \x04\xfa\x06\x18&\n\r\n\x05\x04]\x02\0\x03\x12\x04\xfa\x06)+\n\r\n\x05\
    \x04]\x02\0\x08\x12\x04\xfa\x06,<\n\r\n\x05\x04]\x02\0\x07\x12\x04\xfa\
    \x067;\n\x0c\n\x04\x04]\x02\x01\x12\x04\xfb\x06\x08j\n\r\n\x05\x04]\x02\
    \x01\x04\x12\x04\xfb\x06\x08\x10\n\r\n\x05\x04]\x02\x01\x06\x12\x04\xfb\
    \x06\x11(\n\r\n\x05\x04]\x02\x01\x01\x12\x04\xfb\x06):\n\r\n\x05\x04]\
    \x02\x01\x03\x12\x04\xfb\x06=>\n\r\n\x05\x04]\x02\x01\x08\x12\x04\xfb\
    \x06?i\n\r\n\x05\x04]\x02\x01\x07\x12\x04\xfb\x06Jh\n\x0c\n\x04\x04]\x02\
    \x02\x12\x04\xfc\x06\x08\x20\n\r\n\x05\x04]\x02\x02\x04\x12\x04\xfc\x06\
    \x08\x10\n\r\n\x05\x04]\x02\x02\x05\x12\x04\xfc\x06\x11\x17\n\r\n\x05\
    \x04]\x02\x02\x01\x12\x04\xfc\x06\x18\x1b\n\r\n\x05\x04]\x02\x02\x03\x12\
    \x04\xfc\x06\x1e\x1f\n\x0c\n\x04\x04]\x02\x03\x12\x04\xfd\x06\x08!\n\r\n\
    \x05\x04]\x02\x03\x04\x12\x04\xfd\x06\x08\x10\n\r\n\x05\x04]\x02\x03\x05\
    \x12\x04\xfd\x06\x11\x17\n\r\n\x05\x04]\x02\x03\x01\x12\x04\xfd\x06\x18\
    \x1c\n\r\n\x05\x04]\x02\x03\x03\x12\x04\xfd\x06\x1f\x20\n\x0c\n\x04\x04]\
    \x02\x04\x12\x04\xfe\x06\x08&\n\r\n\x05\x04]\x02\x04\x04\x12\x04\xfe\x06\
    \x08\x10\n\r\n\x05\x04]\x02\x04\x05\x12\x04\xfe\x06\x11\x17\n\r\n\x05\
    \x04]\x02\x04\x01\x12\x04\xfe\x06\x18!\n\r\n\x05\x04]\x02\x04\x03\x12\
    \x04\xfe\x06$%\n\x0c\n\x04\x04]\x02\x05\x12\x04\xff\x06\x08+\n\r\n\x05\
    \x04]\x02\x05\x04\x12\x04\xff\x06\x08\x10\n\r\n\x05\x04]\x02\x05\x05\x12\
    \x04\xff\x06\x11\x17\n\r\n\x05\x04]\x02\x05\x01\x12\x04\xff\x06\x18&\n\r\
    \n\x05\x04]\x02\x05\x03\x12\x04\xff\x06)*\n\x0c\n\x04\x04]\x02\x06\x12\
    \x04\x80\x07\x08(\n\r\n\x05\x04]\x02\x06\x04\x12\x04\x80\x07\x08\x10\n\r\
    \n\x05\x04]\x02\x06\x05\x12\x04\x80\x07\x11\x17\n\r\n\x05\x04]\x02\x06\
    \x01\x12\x04\x80\x07\x18#\n\r\n\x05\x04]\x02\x06\x03\x12\x04\x80\x07&'\n\
    \x0c\n\x04\x04]\x02\x07\x12\x04\x81\x07\x08'\n\r\n\x05\x04]\x02\x07\x04\
    \x12\x04\x81\x07\x08\x10\n\r\n\x05\x04]\x02\x07\x05\x12\x04\x81\x07\x11\
    \x17\n\r\n\x05\x04]\x02\x07\x01\x12\x04\x81\x07\x18\"\n\r\n\x05\x04]\x02\
    \x07\x03\x12\x04\x81\x07%&\n\x0c\n\x04\x04]\x02\x08\x12\x04\x82\x07\x08*\
    \n\r\n\x05\x04]\x02\x08\x04\x12\x04\x82\x07\x08\x10\n\r\n\x05\x04]\x02\
    \x08\x05\x12\x04\x82\x07\x11\x17\n\r\n\x05\x04]\x02\x08\x01\x12\x04\x82\
    \x07\x18%\n\r\n\x05\x04]\x02\x08\x03\x12\x04\x82\x07()\n\x0c\n\x04\x04]\
    \x02\t\x12\x04\x83\x07\x08+\n\r\n\x05\x04]\x02\t\x04\x12\x04\x83\x07\x08\
    \x10\n\r\n\x05\x04]\x02\t\x05\x12\x04\x83\x07\x11\x16\n\r\n\x05\x04]\x02\
    \t\x01\x12\x04\x83\x07\x17%\n\r\n\x05\x04]\x02\t\x03\x12\x04\x83\x07(*\n\
    \x0c\n\x04\x04]\x02\n\x12\x04\x84\x07\x08*\n\r\n\x05\x04]\x02\n\x04\x12\
    \x04\x84\x07\x08\x10\n\r\n\x05\x04]\x02\n\x05\x12\x04\x84\x07\x11\x15\n\
    \r\n\x05\x04]\x02\n\x01\x12\x04\x84\x07\x16$\n\r\n\x05\x04]\x02\n\x03\
    \x12\x04\x84\x07')\n\x0c\n\x04\x04]\x02\x0b\x12\x04\x85\x07\x08,\n\r\n\
    \x05\x04]\x02\x0b\x04\x12\x04\x85\x07\x08\x10\n\r\n\x05\x04]\x02\x0b\x05\
    \x12\x04\x85\x07\x11\x15\n\r\n\x05\x04]\x02\x0b\x01\x12\x04\x85\x07\x16&\
    \n\r\n\x05\x04]\x02\x0b\x03\x12\x04\x85\x07)+\n\x0c\n\x04\x04]\x02\x0c\
    \x12\x04\x86\x07\x08$\n\r\n\x05\x04]\x02\x0c\x04\x12\x04\x86\x07\x08\x10\
    \n\r\n\x05\x04]\x02\x0c\x05\x12\x04\x86\x07\x11\x17\n\r\n\x05\x04]\x02\
    \x0c\x01\x12\x04\x86\x07\x18\x1e\n\r\n\x05\x04]\x02\x0c\x03\x12\x04\x86\
    \x07!#\n\x0c\n\x04\x04]\x02\r\x12\x04\x87\x07\x08%\n\r\n\x05\x04]\x02\r\
    \x04\x12\x04\x87\x07\x08\x10\n\r\n\x05\x04]\x02\r\x05\x12\x04\x87\x07\
    \x11\x17\n\r\n\x05\x04]\x02\r\x01\x12\x04\x87\x07\x18\x1f\n\r\n\x05\x04]\
    \x02\r\x03\x12\x04\x87\x07\"$\n\x0c\n\x04\x04]\x02\x0e\x12\x04\x88\x07\
    \x08F\n\r\n\x05\x04]\x02\x0e\x04\x12\x04\x88\x07\x08\x10\n\r\n\x05\x04]\
    \x02\x0e\x06\x12\x04\x88\x07\x118\n\r\n\x05\x04]\x02\x0e\x01\x12\x04\x88\
    \x079@\n\r\n\x05\x04]\x02\x0e\x03\x12\x04\x88\x07CE\n\x0c\n\x04\x04]\x02\
    \x0f\x12\x04\x89\x07\x08Y\n\r\n\x05\x04]\x02\x0f\x04\x12\x04\x89\x07\x08\
    \x10\n\r\n\x05\x04]\x02\x0f\x06\x12\x04\x89\x07\x11!\n\r\n\x05\x04]\x02\
    \x0f\x01\x12\x04\x89\x07\",\n\r\n\x05\x04]\x02\x0f\x03\x12\x04\x89\x07/1\
    \n\r\n\x05\x04]\x02\x0f\x08\x12\x04\x89\x072X\n\r\n\x05\x04]\x02\x0f\x07\
    \x12\x04\x89\x07=W\n\x0c\n\x04\x04]\x02\x10\x12\x04\x8a\x07\x08T\n\r\n\
    \x05\x04]\x02\x10\x04\x12\x04\x8a\x07\x08\x10\n\r\n\x05\x04]\x02\x10\x06\
    \x12\x04\x8a\x07\x117\n\r\n\x05\x04]\x02\x10\x01\x12\x04\x8a\x078=\n\r\n\
    \x05\x04]\x02\x10\x03\x12\x04\x8a\x07@B\n\r\n\x05\x04]\x02\x10\x08\x12\
    \x04\x8a\x07CS\n\r\n\x05\x04]\x02\x10\x07\x12\x04\x8a\x07NR\n\x0c\n\x04\
    \x04]\x02\x11\x12\x04\x8b\x07\x08&\n\r\n\x05\x04]\x02\x11\x04\x12\x04\
    \x8b\x07\x08\x10\n\r\n\x05\x04]\x02\x11\x05\x12\x04\x8b\x07\x11\x17\n\r\
    \n\x05\x04]\x02\x11\x01\x12\x04\x8b\x07\x18\x20\n\r\n\x05\x04]\x02\x11\
    \x03\x12\x04\x8b\x07#%\n\x0c\n\x04\x04]\x02\x12\x12\x04\x8c\x07\x082\n\r\
    \n\x05\x04]\x02\x12\x04\x12\x04\x8c\x07\x08\x10\n\r\n\x05\x04]\x02\x12\
    \x05\x12\x04\x8c\x07\x11\x17\n\r\n\x05\x04]\x02\x12\x01\x12\x04\x8c\x07\
    \x18,\n\r\n\x05\x04]\x02\x12\x03\x12\x04\x8c\x07/1\n\x0c\n\x04\x04]\x02\
    \x13\x12\x04\x8d\x07\x081\n\r\n\x05\x04]\x02\x13\x04\x12\x04\x8d\x07\x08\
    \x10\n\r\n\x05\x04]\x02\x13\x05\x12\x04\x8d\x07\x11\x17\n\r\n\x05\x04]\
    \x02\x13\x01\x12\x04\x8d\x07\x18+\n\r\n\x05\x04]\x02\x13\x03\x12\x04\x8d\
    \x07.0\n\x0c\n\x04\x04]\x02\x14\x12\x04\x8e\x07\x088\n\r\n\x05\x04]\x02\
    \x14\x04\x12\x04\x8e\x07\x08\x10\n\r\n\x05\x04]\x02\x14\x05\x12\x04\x8e\
    \x07\x11\x17\n\r\n\x05\x04]\x02\x14\x01\x12\x04\x8e\x07\x18#\n\r\n\x05\
    \x04]\x02\x14\x03\x12\x04\x8e\x07&(\n\r\n\x05\x04]\x02\x14\x08\x12\x04\
    \x8e\x07)7\n\r\n\x05\x04]\x02\x14\x07\x12\x04\x8e\x0746\n\x0c\n\x04\x04]\
    \x02\x15\x12\x04\x8f\x07\x08.\n\r\n\x05\x04]\x02\x15\x04\x12\x04\x8f\x07\
    \x08\x10\n\r\n\x05\x04]\x02\x15\x05\x12\x04\x8f\x07\x11\x17\n\r\n\x05\
    \x04]\x02\x15\x01\x12\x04\x8f\x07\x18(\n\r\n\x05\x04]\x02\x15\x03\x12\
    \x04\x8f\x07+-\n\x0c\n\x02\x04^\x12\x06\x92\x07\0\xa3\x07\x01\n\x0b\n\
    \x03\x04^\x01\x12\x04\x92\x07\x08\x1f\n\x0c\n\x04\x04^\x02\0\x12\x04\x93\
    \x07\x08.\n\r\n\x05\x04^\x02\0\x04\x12\x04\x93\x07\x08\x10\n\r\n\x05\x04\
    ^\x02\0\x05\x12\x04\x93\x07\x11\x17\n\r\n\x05\x04^\x02\0\x01\x12\x04\x93\
    \x07\x18)\n\r\n\x05\x04^\x02\0\x03\x12\x04\x93\x07,-\n\x0c\n\x04\x04^\
    \x02\x01\x12\x04\x94\x07\x084\n\r\n\x05\x04^\x02\x01\x04\x12\x04\x94\x07\
    \x08\x10\n\r\n\x05\x04^\x02\x01\x05\x12\x04\x94\x07\x11\x17\n\r\n\x05\
    \x04^\x02\x01\x01\x12\x04\x94\x07\x18/\n\r\n\x05\x04^\x02\x01\x03\x12\
    \x04\x94\x0723\n\x0c\n\x04\x04^\x02\x02\x12\x04\x95\x07\x08+\n\r\n\x05\
    \x04^\x02\x02\x04\x12\x04\x95\x07\x08\x10\n\r\n\x05\x04^\x02\x02\x05\x12\
    \x04\x95\x07\x11\x17\n\r\n\x05\x04^\x02\x02\x01\x12\x04\x95\x07\x18&\n\r\
    \n\x05\x04^\x02\x02\x03\x12\x04\x95\x07)*\n\x0c\n\x04\x04^\x02\x03\x12\
    \x04\x96\x07\x08A\n\r\n\x05\x04^\x02\x03\x04\x12\x04\x96\x07\x08\x10\n\r\
    \n\x05\x04^\x02\x03\x05\x12\x04\x96\x07\x11\x17\n\r\n\x05\x04^\x02\x03\
    \x01\x12\x04\x96\x07\x18<\n\r\n\x05\x04^\x02\x03\x03\x12\x04\x96\x07?@\n\
    \x0c\n\x04\x04^\x02\x04\x12\x04\x97\x07\x08@\n\r\n\x05\x04^\x02\x04\x04\
    \x12\x04\x97\x07\x08\x10\n\r\n\x05\x04^\x02\x04\x05\x12\x04\x97\x07\x11\
    \x17\n\r\n\x05\x04^\x02\x04\x01\x12\x04\x97\x07\x18;\n\r\n\x05\x04^\x02\
    \x04\x03\x12\x04\x97\x07>?\n\x0c\n\x04\x04^\x02\x05\x12\x04\x98\x07\x08?\
    \n\r\n\x05\x04^\x02\x05\x04\x12\x04\x98\x07\x08\x10\n\r\n\x05\x04^\x02\
    \x05\x05\x12\x04\x98\x07\x11\x17\n\r\n\x05\x04^\x02\x05\x01\x12\x04\x98\
    \x07\x189\n\r\n\x05\x04^\x02\x05\x03\x12\x04\x98\x07<>\n\x0c\n\x04\x04^\
    \x02\x06\x12\x04\x99\x07\x08>\n\r\n\x05\x04^\x02\x06\x04\x12\x04\x99\x07\
    \x08\x10\n\r\n\x05\x04^\x02\x06\x05\x12\x04\x99\x07\x11\x17\n\r\n\x05\
    \x04^\x02\x06\x01\x12\x04\x99\x07\x188\n\r\n\x05\x04^\x02\x06\x03\x12\
    \x04\x99\x07;=\n\x0c\n\x04\x04^\x02\x07\x12\x04\x9a\x07\x08?\n\r\n\x05\
    \x04^\x02\x07\x04\x12\x04\x9a\x07\x08\x10\n\r\n\x05\x04^\x02\x07\x05\x12\
    \x04\x9a\x07\x11\x17\n\r\n\x05\x04^\x02\x07\x01\x12\x04\x9a\x07\x189\n\r\
    \n\x05\x04^\x02\x07\x03\x12\x04\x9a\x07<>\n\x0c\n\x04\x04^\x02\x08\x12\
    \x04\x9b\x07\x08>\n\r\n\x05\x04^\x02\x08\x04\x12\x04\x9b\x07\x08\x10\n\r\
    \n\x05\x04^\x02\x08\x05\x12\x04\x9b\x07\x11\x17\n\r\n\x05\x04^\x02\x08\
    \x01\x12\x04\x9b\x07\x188\n\r\n\x05\x04^\x02\x08\x03\x12\x04\x9b\x07;=\n\
    \x0c\n\x04\x04^\x02\t\x12\x04\x9c\x07\x08<\n\r\n\x05\x04^\x02\t\x04\x12\
    \x04\x9c\x07\x08\x10\n\r\n\x05\x04^\x02\t\x05\x12\x04\x9c\x07\x11\x17\n\
    \r\n\x05\x04^\x02\t\x01\x12\x04\x9c\x07\x186\n\r\n\x05\x04^\x02\t\x03\
    \x12\x04\x9c\x079;\n\x0c\n\x04\x04^\x02\n\x12\x04\x9d\x07\x08;\n\r\n\x05\
    \x04^\x02\n\x04\x12\x04\x9d\x07\x08\x10\n\r\n\x05\x04^\x02\n\x05\x12\x04\
    \x9d\x07\x11\x17\n\r\n\x05\x04^\x02\n\x01\x12\x04\x9d\x07\x185\n\r\n\x05\
    \x04^\x02\n\x03\x12\x04\x9d\x078:\n\x0c\n\x04\x04^\x02\x0b\x12\x04\x9e\
    \x07\x08B\n\r\n\x05\x04^\x02\x0b\x04\x12\x04\x9e\x07\x08\x10\n\r\n\x05\
    \x04^\x02\x0b\x05\x12\x04\x9e\x07\x11\x17\n\r\n\x05\x04^\x02\x0b\x01\x12\
    \x04\x9e\x07\x18<\n\r\n\x05\x04^\x02\x0b\x03\x12\x04\x9e\x07?A\n\x0c\n\
    \x04\x04^\x02\x0c\x12\x04\x9f\x07\x08A\n\r\n\x05\x04^\x02\x0c\x04\x12\
    \x04\x9f\x07\x08\x10\n\r\n\x05\x04^\x02\x0c\x05\x12\x04\x9f\x07\x11\x17\
    \n\r\n\x05\x04^\x02\x0c\x01\x12\x04\x9f\x07\x18;\n\r\n\x05\x04^\x02\x0c\
    \x03\x12\x04\x9f\x07>@\n\x0c\n\x04\x04^\x02\r\x12\x04\xa0\x07\x08?\n\r\n\
    \x05\x04^\x02\r\x04\x12\x04\xa0\x07\x08\x10\n\r\n\x05\x04^\x02\r\x05\x12\
    \x04\xa0\x07\x11\x17\n\r\n\x05\x04^\x02\r\x01\x12\x04\xa0\x07\x189\n\r\n\
    \x05\x04^\x02\r\x03\x12\x04\xa0\x07<>\n\x0c\n\x04\x04^\x02\x0e\x12\x04\
    \xa1\x07\x08>\n\r\n\x05\x04^\x02\x0e\x04\x12\x04\xa1\x07\x08\x10\n\r\n\
    \x05\x04^\x02\x0e\x05\x12\x04\xa1\x07\x11\x17\n\r\n\x05\x04^\x02\x0e\x01\
    \x12\x04\xa1\x07\x188\n\r\n\x05\x04^\x02\x0e\x03\x12\x04\xa1\x07;=\n\x0c\
    \n\x04\x04^\x02\x0f\x12\x04\xa2\x07\x08(\n\r\n\x05\x04^\x02\x0f\x04\x12\
    \x04\xa2\x07\x08\x10\n\r\n\x05\x04^\x02\x0f\x05\x12\x04\xa2\x07\x11\x17\
    \n\r\n\x05\x04^\x02\x0f\x01\x12\x04\xa2\x07\x18#\n\r\n\x05\x04^\x02\x0f\
    \x03\x12\x04\xa2\x07&'\n\x0c\n\x02\x04_\x12\x06\xa5\x07\0\xc3\x07\x01\n\
    \x0b\n\x03\x04_\x01\x12\x04\xa5\x07\x08\x1a\n\x0e\n\x04\x04_\x03\0\x12\
    \x06\xa6\x07\x08\xaa\x07\t\n\r\n\x05\x04_\x03\0\x01\x12\x04\xa6\x07\x10\
    \x14\n\x0e\n\x06\x04_\x03\0\x02\0\x12\x04\xa7\x07\x10^\n\x0f\n\x07\x04_\
    \x03\0\x02\0\x04\x12\x04\xa7\x07\x10\x18\n\x0f\n\x07\x04_\x03\0\x02\0\
    \x06\x12\x04\xa7\x07\x198\n\x0f\n\x07\x04_\x03\0\x02\0\x01\x12\x04\xa7\
    \x079E\n\x0f\n\x07\x04_\x03\0\x02\0\x03\x12\x04\xa7\x07HI\n\x0f\n\x07\
    \x04_\x03\0\x02\0\x08\x12\x04\xa7\x07J]\n\x0f\n\x07\x04_\x03\0\x02\0\x07\
    \x12\x04\xa7\x07U\\\n\x0e\n\x06\x04_\x03\0\x02\x01\x12\x04\xa8\x07\x10-\
    \n\x0f\n\x07\x04_\x03\0\x02\x01\x04\x12\x04\xa8\x07\x10\x18\n\x0f\n\x07\
    \x04_\x03\0\x02\x01\x05\x12\x04\xa8\x07\x19\x1e\n\x0f\n\x07\x04_\x03\0\
    \x02\x01\x01\x12\x04\xa8\x07\x1f(\n\x0f\n\x07\x04_\x03\0\x02\x01\x03\x12\
    \x04\xa8\x07+,\n\x0e\n\x06\x04_\x03\0\x02\x02\x12\x04\xa9\x07\x10D\n\x0f\
    \n\x07\x04_\x03\0\x02\x02\x04\x12\x04\xa9\x07\x10\x18\n\x0f\n\x07\x04_\
    \x03\0\x02\x02\x05\x12\x04\xa9\x07\x19\x20\n\x0f\n\x07\x04_\x03\0\x02\
    \x02\x01\x12\x04\xa9\x07!?\n\x0f\n\x07\x04_\x03\0\x02\x02\x03\x12\x04\
    \xa9\x07BC\n\x0e\n\x04\x04_\x03\x01\x12\x06\xac\x07\x08\xb6\x07\t\n\r\n\
    \x05\x04_\x03\x01\x01\x12\x04\xac\x07\x10\x16\n\x0e\n\x06\x04_\x03\x01\
    \x02\0\x12\x04\xad\x07\x10.\n\x0f\n\x07\x04_\x03\x01\x02\0\x04\x12\x04\
    \xad\x07\x10\x18\n\x0f\n\x07\x04_\x03\x01\x02\0\x05\x12\x04\xad\x07\x19\
    \x20\n\x0f\n\x07\x04_\x03\x01\x02\0\x01\x12\x04\xad\x07!)\n\x0f\n\x07\
    \x04_\x03\x01\x02\0\x03\x12\x04\xad\x07,-\n\x0e\n\x06\x04_\x03\x01\x02\
    \x01\x12\x04\xae\x07\x100\n\x0f\n\x07\x04_\x03\x01\x02\x01\x04\x12\x04\
    \xae\x07\x10\x18\n\x0f\n\x07\x04_\x03\x01\x02\x01\x05\x12\x04\xae\x07\
    \x19\x1d\n\x0f\n\x07\x04_\x03\x01\x02\x01\x01\x12\x04\xae\x07\x1e+\n\x0f\
    \n\x07\x04_\x03\x01\x02\x01\x03\x12\x04\xae\x07./\n\x0e\n\x06\x04_\x03\
    \x01\x02\x02\x12\x04\xaf\x07\x109\n\x0f\n\x07\x04_\x03\x01\x02\x02\x04\
    \x12\x04\xaf\x07\x10\x18\n\x0f\n\x07\x04_\x03\x01\x02\x02\x05\x12\x04\
    \xaf\x07\x19\x1d\n\x0f\n\x07\x04_\x03\x01\x02\x02\x01\x12\x04\xaf\x07\
    \x1e4\n\x0f\n\x07\x04_\x03\x01\x02\x02\x03\x12\x04\xaf\x0778\n\x0e\n\x06\
    \x04_\x03\x01\x02\x03\x12\x04\xb0\x07\x100\n\x0f\n\x07\x04_\x03\x01\x02\
    \x03\x04\x12\x04\xb0\x07\x10\x18\n\x0f\n\x07\x04_\x03\x01\x02\x03\x05\
    \x12\x04\xb0\x07\x19\x1d\n\x0f\n\x07\x04_\x03\x01\x02\x03\x01\x12\x04\
    \xb0\x07\x1e+\n\x0f\n\x07\x04_\x03\x01\x02\x03\x03\x12\x04\xb0\x07./\n\
    \x0e\n\x06\x04_\x03\x01\x02\x04\x12\x04\xb1\x07\x100\n\x0f\n\x07\x04_\
    \x03\x01\x02\x04\x04\x12\x04\xb1\x07\x10\x18\n\x0f\n\x07\x04_\x03\x01\
    \x02\x04\x05\x12\x04\xb1\x07\x19\x1f\n\x0f\n\x07\x04_\x03\x01\x02\x04\
    \x01\x12\x04\xb1\x07\x20+\n\x0f\n\x07\x04_\x03\x01\x02\x04\x03\x12\x04\
    \xb1\x07./\n\x0e\n\x06\x04_\x03\x01\x02\x05\x12\x04\xb2\x07\x108\n\x0f\n\
    \x07\x04_\x03\x01\x02\x05\x04\x12\x04\xb2\x07\x10\x18\n\x0f\n\x07\x04_\
    \x03\x01\x02\x05\x05\x12\x04\xb2\x07\x19\x1f\n\x0f\n\x07\x04_\x03\x01\
    \x02\x05\x01\x12\x04\xb2\x07\x203\n\x0f\n\x07\x04_\x03\x01\x02\x05\x03\
    \x12\x04\xb2\x0767\n\x0e\n\x06\x04_\x03\x01\x02\x06\x12\x04\xb3\x07\x10<\
    \n\x0f\n\x07\x04_\x03\x01\x02\x06\x04\x12\x04\xb3\x07\x10\x18\n\x0f\n\
    \x07\x04_\x03\x01\x02\x06\x06\x12\x04\xb3\x07\x191\n\x0f\n\x07\x04_\x03\
    \x01\x02\x06\x01\x12\x04\xb3\x0727\n\x0f\n\x07\x04_\x03\x01\x02\x06\x03\
    \x12\x04\xb3\x07:;\n\x0e\n\x06\x04_\x03\x01\x02\x07\x12\x04\xb4\x07\x102\
    \n\x0f\n\x07\x04_\x03\x01\x02\x07\x04\x12\x04\xb4\x07\x10\x18\n\x0f\n\
    \x07\x04_\x03\x01\x02\x07\x05\x12\x04\xb4\x07\x19\x1d\n\x0f\n\x07\x04_\
    \x03\x01\x02\x07\x01\x12\x04\xb4\x07\x1e-\n\x0f\n\x07\x04_\x03\x01\x02\
    \x07\x03\x12\x04\xb4\x0701\n\x0e\n\x06\x04_\x03\x01\x02\x08\x12\x04\xb5\
    \x07\x102\n\x0f\n\x07\x04_\x03\x01\x02\x08\x04\x12\x04\xb5\x07\x10\x18\n\
    \x0f\n\x07\x04_\x03\x01\x02\x08\x05\x12\x04\xb5\x07\x19\x1f\n\x0f\n\x07\
    \x04_\x03\x01\x02\x08\x01\x12\x04\xb5\x07\x20,\n\x0f\n\x07\x04_\x03\x01\
    \x02\x08\x03\x12\x04\xb5\x07/1\n\x0e\n\x04\x04_\x04\0\x12\x06\xb8\x07\
    \x08\xbe\x07\t\n\r\n\x05\x04_\x04\0\x01\x12\x04\xb8\x07\r\x18\n\x0e\n\
    \x06\x04_\x04\0\x02\0\x12\x04\xb9\x07\x10\x1c\n\x0f\n\x07\x04_\x04\0\x02\
    \0\x01\x12\x04\xb9\x07\x10\x17\n\x0f\n\x07\x04_\x04\0\x02\0\x02\x12\x04\
    \xb9\x07\x1a\x1b\n\x0e\n\x06\x04_\x04\0\x02\x01\x12\x04\xba\x07\x10\"\n\
    \x0f\n\x07\x04_\x04\0\x02\x01\x01\x12\x04\xba\x07\x10\x1d\n\x0f\n\x07\
    \x04_\x04\0\x02\x01\x02\x12\x04\xba\x07\x20!\n\x0e\n\x06\x04_\x04\0\x02\
    \x02\x12\x04\xbb\x07\x10\"\n\x0f\n\x07\x04_\x04\0\x02\x02\x01\x12\x04\
    \xbb\x07\x10\x1d\n\x0f\n\x07\x04_\x04\0\x02\x02\x02\x12\x04\xbb\x07\x20!\
    \n\x0e\n\x06\x04_\x04\0\x02\x03\x12\x04\xbc\x07\x10\x1c\n\x0f\n\x07\x04_\
    \x04\0\x02\x03\x01\x12\x04\xbc\x07\x10\x17\n\x0f\n\x07\x04_\x04\0\x02\
    \x03\x02\x12\x04\xbc\x07\x1a\x1b\n\x0e\n\x06\x04_\x04\0\x02\x04\x12\x04\
    \xbd\x07\x10\x20\n\x0f\n\x07\x04_\x04\0\x02\x04\x01\x12\x04\xbd\x07\x10\
    \x1b\n\x0f\n\x07\x04_\x04\0\x02\x04\x02\x12\x04\xbd\x07\x1e\x1f\n\x0c\n\
    \x04\x04_\x02\0\x12\x04\xc0\x07\x088\n\r\n\x05\x04_\x02\0\x04\x12\x04\
    \xc0\x07\x08\x10\n\r\n\x05\x04_\x02\0\x06\x12\x04\xc0\x07\x11+\n\r\n\x05\
    \x04_\x02\0\x01\x12\x04\xc0\x07,3\n\r\n\x05\x04_\x02\0\x03\x12\x04\xc0\
    \x0767\n\x0c\n\x04\x04_\x02\x01\x12\x04\xc1\x07\x08&\n\r\n\x05\x04_\x02\
    \x01\x04\x12\x04\xc1\x07\x08\x10\n\r\n\x05\x04_\x02\x01\x05\x12\x04\xc1\
    \x07\x11\x17\n\r\n\x05\x04_\x02\x01\x01\x12\x04\xc1\x07\x18!\n\r\n\x05\
    \x04_\x02\x01\x03\x12\x04\xc1\x07$%\n\x0c\n\x04\x04_\x02\x02\x12\x04\xc2\
    \x07\x08)\n\r\n\x05\x04_\x02\x02\x04\x12\x04\xc2\x07\x08\x10\n\r\n\x05\
    \x04_\x02\x02\x05\x12\x04\xc2\x07\x11\x17\n\r\n\x05\x04_\x02\x02\x01\x12\
    \x04\xc2\x07\x18$\n\r\n\x05\x04_\x02\x02\x03\x12\x04\xc2\x07'(\n\x0c\n\
    \x02\x04`\x12\x06\xc5\x07\0\xc9\x07\x01\n\x0b\n\x03\x04`\x01\x12\x04\xc5\
    \x07\x08\x1d\n\x0c\n\x04\x04`\x02\0\x12\x04\xc6\x07\x08*\n\r\n\x05\x04`\
    \x02\0\x04\x12\x04\xc6\x07\x08\x10\n\r\n\x05\x04`\x02\0\x05\x12\x04\xc6\
    \x07\x11\x17\n\r\n\x05\x04`\x02\0\x01\x12\x04\xc6\x07\x18%\n\r\n\x05\x04\
    `\x02\0\x03\x12\x04\xc6\x07()\n\x0c\n\x04\x04`\x02\x01\x12\x04\xc7\x07\
    \x08-\n\r\n\x05\x04`\x02\x01\x04\x12\x04\xc7\x07\x08\x10\n\r\n\x05\x04`\
    \x02\x01\x05\x12\x04\xc7\x07\x11\x17\n\r\n\x05\x04`\x02\x01\x01\x12\x04\
    \xc7\x07\x18(\n\r\n\x05\x04`\x02\x01\x03\x12\x04\xc7\x07+,\n\x0c\n\x04\
    \x04`\x02\x02\x12\x04\xc8\x07\x08,\n\r\n\x05\x04`\x02\x02\x04\x12\x04\
    \xc8\x07\x08\x10\n\r\n\x05\x04`\x02\x02\x05\x12\x04\xc8\x07\x11\x17\n\r\
    \n\x05\x04`\x02\x02\x01\x12\x04\xc8\x07\x18'\n\r\n\x05\x04`\x02\x02\x03\
    \x12\x04\xc8\x07*+\n\x0c\n\x02\x04a\x12\x06\xcb\x07\0\xd1\x07\x01\n\x0b\
    \n\x03\x04a\x01\x12\x04\xcb\x07\x08\x14\n\x0c\n\x04\x04a\x02\0\x12\x04\
    \xcc\x07\x08,\n\r\n\x05\x04a\x02\0\x04\x12\x04\xcc\x07\x08\x10\n\r\n\x05\
    \x04a\x02\0\x05\x12\x04\xcc\x07\x11\x16\n\r\n\x05\x04a\x02\0\x01\x12\x04\
    \xcc\x07\x17'\n\r\n\x05\x04a\x02\0\x03\x12\x04\xcc\x07*+\n\x0c\n\x04\x04\
    a\x02\x01\x12\x04\xcd\x07\x08*\n\r\n\x05\x04a\x02\x01\x04\x12\x04\xcd\
    \x07\x08\x10\n\r\n\x05\x04a\x02\x01\x05\x12\x04\xcd\x07\x11\x17\n\r\n\
    \x05\x04a\x02\x01\x01\x12\x04\xcd\x07\x18%\n\r\n\x05\x04a\x02\x01\x03\
    \x12\x04\xcd\x07()\n\x0c\n\x04\x04a\x02\x02\x12\x04\xce\x07\x08-\n\r\n\
    \x05\x04a\x02\x02\x04\x12\x04\xce\x07\x08\x10\n\r\n\x05\x04a\x02\x02\x05\
    \x12\x04\xce\x07\x11\x17\n\r\n\x05\x04a\x02\x02\x01\x12\x04\xce\x07\x18(\
    \n\r\n\x05\x04a\x02\x02\x03\x12\x04\xce\x07+,\n\x0c\n\x04\x04a\x02\x03\
    \x12\x04\xcf\x07\x08.\n\r\n\x05\x04a\x02\x03\x04\x12\x04\xcf\x07\x08\x10\
    \n\r\n\x05\x04a\x02\x03\x05\x12\x04\xcf\x07\x11\x17\n\r\n\x05\x04a\x02\
    \x03\x01\x12\x04\xcf\x07\x18)\n\r\n\x05\x04a\x02\x03\x03\x12\x04\xcf\x07\
    ,-\n\x0c\n\x04\x04a\x02\x04\x12\x04\xd0\x07\x08/\n\r\n\x05\x04a\x02\x04\
    \x04\x12\x04\xd0\x07\x08\x10\n\r\n\x05\x04a\x02\x04\x05\x12\x04\xd0\x07\
    \x11\x16\n\r\n\x05\x04a\x02\x04\x01\x12\x04\xd0\x07\x17*\n\r\n\x05\x04a\
    \x02\x04\x03\x12\x04\xd0\x07-.\n\x0c\n\x02\x04b\x12\x06\xd3\x07\0\xd7\
    \x07\x01\n\x0b\n\x03\x04b\x01\x12\x04\xd3\x07\x08\x16\n\x0c\n\x04\x04b\
    \x02\0\x12\x04\xd4\x07\x08-\n\r\n\x05\x04b\x02\0\x04\x12\x04\xd4\x07\x08\
    \x10\n\r\n\x05\x04b\x02\0\x05\x12\x04\xd4\x07\x11\x17\n\r\n\x05\x04b\x02\
    \0\x01\x12\x04\xd4\x07\x18(\n\r\n\x05\x04b\x02\0\x03\x12\x04\xd4\x07+,\n\
    \x0c\n\x04\x04b\x02\x01\x12\x04\xd5\x07\x08/\n\r\n\x05\x04b\x02\x01\x04\
    \x12\x04\xd5\x07\x08\x10\n\r\n\x05\x04b\x02\x01\x05\x12\x04\xd5\x07\x11\
    \x16\n\r\n\x05\x04b\x02\x01\x01\x12\x04\xd5\x07\x17*\n\r\n\x05\x04b\x02\
    \x01\x03\x12\x04\xd5\x07-.\n\x0c\n\x04\x04b\x02\x02\x12\x04\xd6\x07\x08*\
    \n\r\n\x05\x04b\x02\x02\x04\x12\x04\xd6\x07\x08\x10\n\r\n\x05\x04b\x02\
    \x02\x05\x12\x04\xd6\x07\x11\x17\n\r\n\x05\x04b\x02\x02\x01\x12\x04\xd6\
    \x07\x18%\n\r\n\x05\x04b\x02\x02\x03\x12\x04\xd6\x07()\n\x0c\n\x02\x04c\
    \x12\x06\xd9\x07\0\xe5\x07\x01\n\x0b\n\x03\x04c\x01\x12\x04\xd9\x07\x08\
    \x16\n\x0e\n\x04\x04c\x03\0\x12\x06\xda\x07\x08\xdd\x07\t\n\r\n\x05\x04c\
    \x03\0\x01\x12\x04\xda\x07\x10\x16\n\x0e\n\x06\x04c\x03\0\x02\0\x12\x04\
    \xdb\x07\x10.\n\x0f\n\x07\x04c\x03\0\x02\0\x04\x12\x04\xdb\x07\x10\x18\n\
    \x0f\n\x07\x04c\x03\0\x02\0\x05\x12\x04\xdb\x07\x19\x20\n\x0f\n\x07\x04c\
    \x03\0\x02\0\x01\x12\x04\xdb\x07!)\n\x0f\n\x07\x04c\x03\0\x02\0\x03\x12\
    \x04\xdb\x07,-\n\x0e\n\x06\x04c\x03\0\x02\x01\x12\x04\xdc\x07\x100\n\x0f\
    \n\x07\x04c\x03\0\x02\x01\x04\x12\x04\xdc\x07\x10\x18\n\x0f\n\x07\x04c\
    \x03\0\x02\x01\x05\x12\x04\xdc\x07\x19\x1d\n\x0f\n\x07\x04c\x03\0\x02\
    \x01\x01\x12\x04\xdc\x07\x1e+\n\x0f\n\x07\x04c\x03\0\x02\x01\x03\x12\x04\
    \xdc\x07./\n\x0c\n\x04\x04c\x02\0\x12\x04\xdf\x07\x081\n\r\n\x05\x04c\
    \x02\0\x04\x12\x04\xdf\x07\x08\x10\n\r\n\x05\x04c\x02\0\x05\x12\x04\xdf\
    \x07\x11\x17\n\r\n\x05\x04c\x02\0\x01\x12\x04\xdf\x07\x18,\n\r\n\x05\x04\
    c\x02\0\x03\x12\x04\xdf\x07/0\n\x0c\n\x04\x04c\x02\x01\x12\x04\xe0\x07\
    \x08-\n\r\n\x05\x04c\x02\x01\x04\x12\x04\xe0\x07\x08\x10\n\r\n\x05\x04c\
    \x02\x01\x05\x12\x04\xe0\x07\x11\x17\n\r\n\x05\x04c\x02\x01\x01\x12\x04\
    \xe0\x07\x18(\n\r\n\x05\x04c\x02\x01\x03\x12\x04\xe0\x07+,\n\x0c\n\x04\
    \x04c\x02\x02\x12\x04\xe1\x07\x08)\n\r\n\x05\x04c\x02\x02\x04\x12\x04\
    \xe1\x07\x08\x10\n\r\n\x05\x04c\x02\x02\x05\x12\x04\xe1\x07\x11\x17\n\r\
    \n\x05\x04c\x02\x02\x01\x12\x04\xe1\x07\x18$\n\r\n\x05\x04c\x02\x02\x03\
    \x12\x04\xe1\x07'(\n\x0c\n\x04\x04c\x02\x03\x12\x04\xe2\x07\x084\n\r\n\
    \x05\x04c\x02\x03\x04\x12\x04\xe2\x07\x08\x10\n\r\n\x05\x04c\x02\x03\x06\
    \x12\x04\xe2\x07\x11'\n\r\n\x05\x04c\x02\x03\x01\x12\x04\xe2\x07(/\n\r\n\
    \x05\x04c\x02\x03\x03\x12\x04\xe2\x0723\n\x0c\n\x04\x04c\x02\x04\x12\x04\
    \xe3\x07\x08%\n\r\n\x05\x04c\x02\x04\x04\x12\x04\xe3\x07\x08\x10\n\r\n\
    \x05\x04c\x02\x04\x05\x12\x04\xe3\x07\x11\x17\n\r\n\x05\x04c\x02\x04\x01\
    \x12\x04\xe3\x07\x18\x20\n\r\n\x05\x04c\x02\x04\x03\x12\x04\xe3\x07#$\n\
    \x0c\n\x04\x04c\x02\x05\x12\x04\xe4\x07\x08(\n\r\n\x05\x04c\x02\x05\x04\
    \x12\x04\xe4\x07\x08\x10\n\r\n\x05\x04c\x02\x05\x05\x12\x04\xe4\x07\x11\
    \x18\n\r\n\x05\x04c\x02\x05\x01\x12\x04\xe4\x07\x19#\n\r\n\x05\x04c\x02\
    \x05\x03\x12\x04\xe4\x07&'\n\x0c\n\x02\x04d\x12\x06\xe7\x07\0\xe8\x07\
    \x01\n\x0b\n\x03\x04d\x01\x12\x04\xe7\x07\x08!\n\x0c\n\x02\x04e\x12\x06\
    \xea\x07\0\xed\x07\x01\n\x0b\n\x03\x04e\x01\x12\x04\xea\x07\x08\"\n\x0c\
    \n\x04\x04e\x02\0\x12\x04\xeb\x07\x08%\n\r\n\x05\x04e\x02\0\x04\x12\x04\
    \xeb\x07\x08\x10\n\r\n\x05\x04e\x02\0\x05\x12\x04\xeb\x07\x11\x17\n\r\n\
    \x05\x04e\x02\0\x01\x12\x04\xeb\x07\x18\x20\n\r\n\x05\x04e\x02\0\x03\x12\
    \x04\xeb\x07#$\n\x0c\n\x04\x04e\x02\x01\x12\x04\xec\x07\x08%\n\r\n\x05\
    \x04e\x02\x01\x04\x12\x04\xec\x07\x08\x10\n\r\n\x05\x04e\x02\x01\x05\x12\
    \x04\xec\x07\x11\x17\n\r\n\x05\x04e\x02\x01\x01\x12\x04\xec\x07\x18\x20\
    \n\r\n\x05\x04e\x02\x01\x03\x12\x04\xec\x07#$\n\x0c\n\x02\x04f\x12\x06\
    \xef\x07\0\xf0\x07\x01\n\x0b\n\x03\x04f\x01\x12\x04\xef\x07\x08*\n\x0c\n\
    \x02\x04g\x12\x06\xf2\x07\0\xf4\x07\x01\n\x0b\n\x03\x04g\x01\x12\x04\xf2\
    \x07\x08*\n\x0c\n\x04\x04g\x02\0\x12\x04\xf3\x07\x08&\n\r\n\x05\x04g\x02\
    \0\x04\x12\x04\xf3\x07\x08\x10\n\r\n\x05\x04g\x02\0\x05\x12\x04\xf3\x07\
    \x11\x18\n\r\n\x05\x04g\x02\0\x01\x12\x04\xf3\x07\x19!\n\r\n\x05\x04g\
    \x02\0\x03\x12\x04\xf3\x07$%\n\x0c\n\x02\x04h\x12\x06\xf6\x07\0\xfd\x07\
    \x01\n\x0b\n\x03\x04h\x01\x12\x04\xf6\x07\x08\x1b\n\x0c\n\x04\x04h\x02\0\
    \x12\x04\xf7\x07\x08&\n\r\n\x05\x04h\x02\0\x04\x12\x04\xf7\x07\x08\x10\n\
    \r\n\x05\x04h\x02\0\x05\x12\x04\xf7\x07\x11\x18\n\r\n\x05\x04h\x02\0\x01\
    \x12\x04\xf7\x07\x19!\n\r\n\x05\x04h\x02\0\x03\x12\x04\xf7\x07$%\n\x0c\n\
    \x04\x04h\x02\x01\x12\x04\xf8\x07\x08a\n\r\n\x05\x04h\x02\x01\x04\x12\
    \x04\xf8\x07\x08\x10\n\r\n\x05\x04h\x02\x01\x06\x12\x04\xf8\x07\x11$\n\r\
    \n\x05\x04h\x02\x01\x01\x12\x04\xf8\x07%1\n\r\n\x05\x04h\x02\x01\x03\x12\
    \x04\xf8\x0745\n\r\n\x05\x04h\x02\x01\x08\x12\x04\xf8\x076`\n\r\n\x05\
    \x04h\x02\x01\x07\x12\x04\xf8\x07A_\n\x0c\n\x04\x04h\x02\x02\x12\x04\xf9\
    \x07\x08&\n\r\n\x05\x04h\x02\x02\x04\x12\x04\xf9\x07\x08\x10\n\r\n\x05\
    \x04h\x02\x02\x05\x12\x04\xf9\x07\x11\x15\n\r\n\x05\x04h\x02\x02\x01\x12\
    \x04\xf9\x07\x16!\n\r\n\x05\x04h\x02\x02\x03\x12\x04\xf9\x07$%\n\x0c\n\
    \x04\x04h\x02\x03\x12\x04\xfa\x07\x08%\n\r\n\x05\x04h\x02\x03\x04\x12\
    \x04\xfa\x07\x08\x10\n\r\n\x05\x04h\x02\x03\x05\x12\x04\xfa\x07\x11\x17\
    \n\r\n\x05\x04h\x02\x03\x01\x12\x04\xfa\x07\x18\x20\n\r\n\x05\x04h\x02\
    \x03\x03\x12\x04\xfa\x07#$\n\x0c\n\x04\x04h\x02\x04\x12\x04\xfb\x07\x08%\
    \n\r\n\x05\x04h\x02\x04\x04\x12\x04\xfb\x07\x08\x10\n\r\n\x05\x04h\x02\
    \x04\x05\x12\x04\xfb\x07\x11\x17\n\r\n\x05\x04h\x02\x04\x01\x12\x04\xfb\
    \x07\x18\x20\n\r\n\x05\x04h\x02\x04\x03\x12\x04\xfb\x07#$\n\x0c\n\x04\
    \x04h\x02\x05\x12\x04\xfc\x07\x082\n\r\n\x05\x04h\x02\x05\x04\x12\x04\
    \xfc\x07\x08\x10\n\r\n\x05\x04h\x02\x05\x06\x12\x04\xfc\x07\x11\x20\n\r\
    \n\x05\x04h\x02\x05\x01\x12\x04\xfc\x07!-\n\r\n\x05\x04h\x02\x05\x03\x12\
    \x04\xfc\x0701\n\x0c\n\x02\x04i\x12\x06\xff\x07\0\x80\x08\x01\n\x0b\n\
    \x03\x04i\x01\x12\x04\xff\x07\x08#\n\x0c\n\x02\x04j\x12\x06\x82\x08\0\
    \x8e\x08\x01\n\x0b\n\x03\x04j\x01\x12\x04\x82\x08\x08\x20\n\x0e\n\x04\
    \x04j\x03\0\x12\x06\x83\x08\x08\x86\x08\t\n\r\n\x05\x04j\x03\0\x01\x12\
    \x04\x83\x08\x10\x14\n\x0e\n\x06\x04j\x03\0\x02\0\x12\x04\x84\x08\x10.\n\
    \x0f\n\x07\x04j\x03\0\x02\0\x04\x12\x04\x84\x08\x10\x18\n\x0f\n\x07\x04j\
    \x03\0\x02\0\x05\x12\x04\x84\x08\x19\x20\n\x0f\n\x07\x04j\x03\0\x02\0\
    \x01\x12\x04\x84\x08!)\n\x0f\n\x07\x04j\x03\0\x02\0\x03\x12\x04\x84\x08,\
    -\n\x0e\n\x06\x04j\x03\0\x02\x01\x12\x04\x85\x08\x10+\n\x0f\n\x07\x04j\
    \x03\0\x02\x01\x04\x12\x04\x85\x08\x10\x18\n\x0f\n\x07\x04j\x03\0\x02\
    \x01\x05\x12\x04\x85\x08\x19\x1d\n\x0f\n\x07\x04j\x03\0\x02\x01\x01\x12\
    \x04\x85\x08\x1e&\n\x0f\n\x07\x04j\x03\0\x02\x01\x03\x12\x04\x85\x08)*\n\
    \x0c\n\x04\x04j\x02\0\x12\x04\x88\x08\x08&\n\r\n\x05\x04j\x02\0\x04\x12\
    \x04\x88\x08\x08\x10\n\r\n\x05\x04j\x02\0\x05\x12\x04\x88\x08\x11\x18\n\
    \r\n\x05\x04j\x02\0\x01\x12\x04\x88\x08\x19!\n\r\n\x05\x04j\x02\0\x03\
    \x12\x04\x88\x08$%\n\x0c\n\x04\x04j\x02\x01\x12\x04\x89\x08\x080\n\r\n\
    \x05\x04j\x02\x01\x04\x12\x04\x89\x08\x08\x10\n\r\n\x05\x04j\x02\x01\x05\
    \x12\x04\x89\x08\x11\x18\n\r\n\x05\x04j\x02\x01\x01\x12\x04\x89\x08\x19+\
    \n\r\n\x05\x04j\x02\x01\x03\x12\x04\x89\x08./\n\x0c\n\x04\x04j\x02\x02\
    \x12\x04\x8a\x08\x08-\n\r\n\x05\x04j\x02\x02\x04\x12\x04\x8a\x08\x08\x10\
    \n\r\n\x05\x04j\x02\x02\x05\x12\x04\x8a\x08\x11\x18\n\r\n\x05\x04j\x02\
    \x02\x01\x12\x04\x8a\x08\x19(\n\r\n\x05\x04j\x02\x02\x03\x12\x04\x8a\x08\
    +,\n\x0c\n\x04\x04j\x02\x03\x12\x04\x8b\x08\x08Q\n\r\n\x05\x04j\x02\x03\
    \x04\x12\x04\x8b\x08\x08\x10\n\r\n\x05\x04j\x02\x03\x06\x12\x04\x8b\x08\
    \x11\"\n\r\n\x05\x04j\x02\x03\x01\x12\x04\x8b\x08#)\n\r\n\x05\x04j\x02\
    \x03\x03\x12\x04\x8b\x08,-\n\r\n\x05\x04j\x02\x03\x08\x12\x04\x8b\x08.P\
    \n\r\n\x05\x04j\x02\x03\x07\x12\x04\x8b\x089O\n\x0c\n\x04\x04j\x02\x04\
    \x12\x04\x8c\x08\x08:\n\r\n\x05\x04j\x02\x04\x04\x12\x04\x8c\x08\x08\x10\
    \n\r\n\x05\x04j\x02\x04\x06\x12\x04\x8c\x08\x11/\n\r\n\x05\x04j\x02\x04\
    \x01\x12\x04\x8c\x0805\n\r\n\x05\x04j\x02\x04\x03\x12\x04\x8c\x0889\n\
    \x0c\n\x04\x04j\x02\x05\x12\x04\x8d\x08\x08'\n\r\n\x05\x04j\x02\x05\x04\
    \x12\x04\x8d\x08\x08\x10\n\r\n\x05\x04j\x02\x05\x05\x12\x04\x8d\x08\x11\
    \x15\n\r\n\x05\x04j\x02\x05\x01\x12\x04\x8d\x08\x16\"\n\r\n\x05\x04j\x02\
    \x05\x03\x12\x04\x8d\x08%&\n\x0c\n\x02\x04k\x12\x06\x90\x08\0\x92\x08\
    \x01\n\x0b\n\x03\x04k\x01\x12\x04\x90\x08\x08(\n\x0c\n\x04\x04k\x02\0\
    \x12\x04\x91\x08\x08\x1e\n\r\n\x05\x04k\x02\0\x04\x12\x04\x91\x08\x08\
    \x10\n\r\n\x05\x04k\x02\0\x05\x12\x04\x91\x08\x11\x15\n\r\n\x05\x04k\x02\
    \0\x01\x12\x04\x91\x08\x16\x19\n\r\n\x05\x04k\x02\0\x03\x12\x04\x91\x08\
    \x1c\x1d\n\x0c\n\x02\x04l\x12\x06\x94\x08\0\x95\x08\x01\n\x0b\n\x03\x04l\
    \x01\x12\x04\x94\x08\x085\n\x0c\n\x02\x04m\x12\x06\x97\x08\0\x9f\x08\x01\
    \n\x0b\n\x03\x04m\x01\x12\x04\x97\x08\x08%\n\x0c\n\x04\x04m\x02\0\x12\
    \x04\x98\x08\x08*\n\r\n\x05\x04m\x02\0\x04\x12\x04\x98\x08\x08\x10\n\r\n\
    \x05\x04m\x02\0\x05\x12\x04\x98\x08\x11\x17\n\r\n\x05\x04m\x02\0\x01\x12\
    \x04\x98\x08\x18%\n\r\n\x05\x04m\x02\0\x03\x12\x04\x98\x08()\n\x0c\n\x04\
    \x04m\x02\x01\x12\x04\x99\x08\x08&\n\r\n\x05\x04m\x02\x01\x04\x12\x04\
    \x99\x08\x08\x10\n\r\n\x05\x04m\x02\x01\x05\x12\x04\x99\x08\x11\x17\n\r\
    \n\x05\x04m\x02\x01\x01\x12\x04\x99\x08\x18!\n\r\n\x05\x04m\x02\x01\x03\
    \x12\x04\x99\x08$%\n\x0c\n\x04\x04m\x02\x02\x12\x04\x9a\x08\x08&\n\r\n\
    \x05\x04m\x02\x02\x04\x12\x04\x9a\x08\x08\x10\n\r\n\x05\x04m\x02\x02\x05\
    \x12\x04\x9a\x08\x11\x17\n\r\n\x05\x04m\x02\x02\x01\x12\x04\x9a\x08\x18!\
    \n\r\n\x05\x04m\x02\x02\x03\x12\x04\x9a\x08$%\n\x0c\n\x04\x04m\x02\x03\
    \x12\x04\x9b\x08\x08'\n\r\n\x05\x04m\x02\x03\x04\x12\x04\x9b\x08\x08\x10\
    \n\r\n\x05\x04m\x02\x03\x05\x12\x04\x9b\x08\x11\x17\n\r\n\x05\x04m\x02\
    \x03\x01\x12\x04\x9b\x08\x18\"\n\r\n\x05\x04m\x02\x03\x03\x12\x04\x9b\
    \x08%&\n\x0c\n\x04\x04m\x02\x04\x12\x04\x9c\x08\x08'\n\r\n\x05\x04m\x02\
    \x04\x04\x12\x04\x9c\x08\x08\x10\n\r\n\x05\x04m\x02\x04\x05\x12\x04\x9c\
    \x08\x11\x17\n\r\n\x05\x04m\x02\x04\x01\x12\x04\x9c\x08\x18\"\n\r\n\x05\
    \x04m\x02\x04\x03\x12\x04\x9c\x08%&\n\x0c\n\x04\x04m\x02\x05\x12\x04\x9d\
    \x08\x08-\n\r\n\x05\x04m\x02\x05\x04\x12\x04\x9d\x08\x08\x10\n\r\n\x05\
    \x04m\x02\x05\x05\x12\x04\x9d\x08\x11\x17\n\r\n\x05\x04m\x02\x05\x01\x12\
    \x04\x9d\x08\x18(\n\r\n\x05\x04m\x02\x05\x03\x12\x04\x9d\x08+,\n\x0c\n\
    \x04\x04m\x02\x06\x12\x04\x9e\x08\x08(\n\r\n\x05\x04m\x02\x06\x04\x12\
    \x04\x9e\x08\x08\x10\n\r\n\x05\x04m\x02\x06\x05\x12\x04\x9e\x08\x11\x16\
    \n\r\n\x05\x04m\x02\x06\x01\x12\x04\x9e\x08\x17#\n\r\n\x05\x04m\x02\x06\
    \x03\x12\x04\x9e\x08&'\n\x0c\n\x02\x04n\x12\x06\xa1\x08\0\xc0\x08\x01\n\
    \x0b\n\x03\x04n\x01\x12\x04\xa1\x08\x08\"\n\x0c\n\x04\x04n\x02\0\x12\x04\
    \xa2\x08\x08*\n\r\n\x05\x04n\x02\0\x04\x12\x04\xa2\x08\x08\x10\n\r\n\x05\
    \x04n\x02\0\x05\x12\x04\xa2\x08\x11\x17\n\r\n\x05\x04n\x02\0\x01\x12\x04\
    \xa2\x08\x18%\n\r\n\x05\x04n\x02\0\x03\x12\x04\xa2\x08()\n\x0c\n\x04\x04\
    n\x02\x01\x12\x04\xa3\x08\x08,\n\r\n\x05\x04n\x02\x01\x04\x12\x04\xa3\
    \x08\x08\x10\n\r\n\x05\x04n\x02\x01\x05\x12\x04\xa3\x08\x11\x18\n\r\n\
    \x05\x04n\x02\x01\x01\x12\x04\xa3\x08\x19'\n\r\n\x05\x04n\x02\x01\x03\
    \x12\x04\xa3\x08*+\n\x0c\n\x04\x04n\x02\x02\x12\x04\xa4\x08\x08*\n\r\n\
    \x05\x04n\x02\x02\x04\x12\x04\xa4\x08\x08\x10\n\r\n\x05\x04n\x02\x02\x05\
    \x12\x04\xa4\x08\x11\x15\n\r\n\x05\x04n\x02\x02\x01\x12\x04\xa4\x08\x16%\
    \n\r\n\x05\x04n\x02\x02\x03\x12\x04\xa4\x08()\n\x0c\n\x04\x04n\x02\x03\
    \x12\x04\xa5\x08\x08'\n\r\n\x05\x04n\x02\x03\x04\x12\x04\xa5\x08\x08\x10\
    \n\r\n\x05\x04n\x02\x03\x05\x12\x04\xa5\x08\x11\x17\n\r\n\x05\x04n\x02\
    \x03\x01\x12\x04\xa5\x08\x18\"\n\r\n\x05\x04n\x02\x03\x03\x12\x04\xa5\
    \x08%&\n\x0c\n\x04\x04n\x02\x04\x12\x04\xa6\x08\x08+\n\r\n\x05\x04n\x02\
    \x04\x04\x12\x04\xa6\x08\x08\x10\n\r\n\x05\x04n\x02\x04\x05\x12\x04\xa6\
    \x08\x11\x17\n\r\n\x05\x04n\x02\x04\x01\x12\x04\xa6\x08\x18&\n\r\n\x05\
    \x04n\x02\x04\x03\x12\x04\xa6\x08)*\n\x0c\n\x04\x04n\x02\x05\x12\x04\xa7\
    \x08\x08-\n\r\n\x05\x04n\x02\x05\x04\x12\x04\xa7\x08\x08\x10\n\r\n\x05\
    \x04n\x02\x05\x05\x12\x04\xa7\x08\x11\x17\n\r\n\x05\x04n\x02\x05\x01\x12\
    \x04\xa7\x08\x18(\n\r\n\x05\x04n\x02\x05\x03\x12\x04\xa7\x08+,\n\x0c\n\
    \x04\x04n\x02\x06\x12\x04\xa8\x08\x08&\n\r\n\x05\x04n\x02\x06\x04\x12\
    \x04\xa8\x08\x08\x10\n\r\n\x05\x04n\x02\x06\x05\x12\x04\xa8\x08\x11\x17\
    \n\r\n\x05\x04n\x02\x06\x01\x12\x04\xa8\x08\x18!\n\r\n\x05\x04n\x02\x06\
    \x03\x12\x04\xa8\x08$%\n\x0c\n\x04\x04n\x02\x07\x12\x04\xa9\x08\x08'\n\r\
    \n\x05\x04n\x02\x07\x04\x12\x04\xa9\x08\x08\x10\n\r\n\x05\x04n\x02\x07\
    \x05\x12\x04\xa9\x08\x11\x17\n\r\n\x05\x04n\x02\x07\x01\x12\x04\xa9\x08\
    \x18\"\n\r\n\x05\x04n\x02\x07\x03\x12\x04\xa9\x08%&\n\x0c\n\x04\x04n\x02\
    \x08\x12\x04\xaa\x08\x08(\n\r\n\x05\x04n\x02\x08\x04\x12\x04\xaa\x08\x08\
    \x10\n\r\n\x05\x04n\x02\x08\x05\x12\x04\xaa\x08\x11\x17\n\r\n\x05\x04n\
    \x02\x08\x01\x12\x04\xaa\x08\x18#\n\r\n\x05\x04n\x02\x08\x03\x12\x04\xaa\
    \x08&'\n\x0c\n\x04\x04n\x02\t\x12\x04\xab\x08\x08'\n\r\n\x05\x04n\x02\t\
    \x04\x12\x04\xab\x08\x08\x10\n\r\n\x05\x04n\x02\t\x05\x12\x04\xab\x08\
    \x11\x17\n\r\n\x05\x04n\x02\t\x01\x12\x04\xab\x08\x18!\n\r\n\x05\x04n\
    \x02\t\x03\x12\x04\xab\x08$&\n\x0c\n\x04\x04n\x02\n\x12\x04\xac\x08\x08,\
    \n\r\n\x05\x04n\x02\n\x04\x12\x04\xac\x08\x08\x10\n\r\n\x05\x04n\x02\n\
    \x05\x12\x04\xac\x08\x11\x17\n\r\n\x05\x04n\x02\n\x01\x12\x04\xac\x08\
    \x18&\n\r\n\x05\x04n\x02\n\x03\x12\x04\xac\x08)+\n\x0c\n\x04\x04n\x02\
    \x0b\x12\x04\xad\x08\x08,\n\r\n\x05\x04n\x02\x0b\x04\x12\x04\xad\x08\x08\
    \x10\n\r\n\x05\x04n\x02\x0b\x05\x12\x04\xad\x08\x11\x17\n\r\n\x05\x04n\
    \x02\x0b\x01\x12\x04\xad\x08\x18&\n\r\n\x05\x04n\x02\x0b\x03\x12\x04\xad\
    \x08)+\n\x0c\n\x04\x04n\x02\x0c\x12\x04\xae\x08\x08'\n\r\n\x05\x04n\x02\
    \x0c\x04\x12\x04\xae\x08\x08\x10\n\r\n\x05\x04n\x02\x0c\x05\x12\x04\xae\
    \x08\x11\x17\n\r\n\x05\x04n\x02\x0c\x01\x12\x04\xae\x08\x18!\n\r\n\x05\
    \x04n\x02\x0c\x03\x12\x04\xae\x08$&\n\x0c\n\x04\x04n\x02\r\x12\x04\xaf\
    \x08\x08(\n\r\n\x05\x04n\x02\r\x04\x12\x04\xaf\x08\x08\x10\n\r\n\x05\x04\
    n\x02\r\x05\x12\x04\xaf\x08\x11\x17\n\r\n\x05\x04n\x02\r\x01\x12\x04\xaf\
    \x08\x18\"\n\r\n\x05\x04n\x02\r\x03\x12\x04\xaf\x08%'\n\x0c\n\x04\x04n\
    \x02\x0e\x12\x04\xb0\x08\x08)\n\r\n\x05\x04n\x02\x0e\x04\x12\x04\xb0\x08\
    \x08\x10\n\r\n\x05\x04n\x02\x0e\x05\x12\x04\xb0\x08\x11\x17\n\r\n\x05\
    \x04n\x02\x0e\x01\x12\x04\xb0\x08\x18#\n\r\n\x05\x04n\x02\x0e\x03\x12\
    \x04\xb0\x08&(\n\x0c\n\x04\x04n\x02\x0f\x12\x04\xb1\x08\x08&\n\r\n\x05\
    \x04n\x02\x0f\x04\x12\x04\xb1\x08\x08\x10\n\r\n\x05\x04n\x02\x0f\x05\x12\
    \x04\xb1\x08\x11\x17\n\r\n\x05\x04n\x02\x0f\x01\x12\x04\xb1\x08\x18\x20\
    \n\r\n\x05\x04n\x02\x0f\x03\x12\x04\xb1\x08#%\n\x0c\n\x04\x04n\x02\x10\
    \x12\x04\xb2\x08\x08'\n\r\n\x05\x04n\x02\x10\x04\x12\x04\xb2\x08\x08\x10\
    \n\r\n\x05\x04n\x02\x10\x05\x12\x04\xb2\x08\x11\x17\n\r\n\x05\x04n\x02\
    \x10\x01\x12\x04\xb2\x08\x18!\n\r\n\x05\x04n\x02\x10\x03\x12\x04\xb2\x08\
    $&\n\x0c\n\x04\x04n\x02\x11\x12\x04\xb3\x08\x08'\n\r\n\x05\x04n\x02\x11\
    \x04\x12\x04\xb3\x08\x08\x10\n\r\n\x05\x04n\x02\x11\x05\x12\x04\xb3\x08\
    \x11\x17\n\r\n\x05\x04n\x02\x11\x01\x12\x04\xb3\x08\x18!\n\r\n\x05\x04n\
    \x02\x11\x03\x12\x04\xb3\x08$&\n\x0c\n\x04\x04n\x02\x12\x12\x04\xb4\x08\
    \x08&\n\r\n\x05\x04n\x02\x12\x04\x12\x04\xb4\x08\x08\x10\n\r\n\x05\x04n\
    \x02\x12\x05\x12\x04\xb4\x08\x11\x17\n\r\n\x05\x04n\x02\x12\x01\x12\x04\
    \xb4\x08\x18\x20\n\r\n\x05\x04n\x02\x12\x03\x12\x04\xb4\x08#%\n\x0c\n\
    \x04\x04n\x02\x13\x12\x04\xb5\x08\x08%\n\r\n\x05\x04n\x02\x13\x04\x12\
    \x04\xb5\x08\x08\x10\n\r\n\x05\x04n\x02\x13\x05\x12\x04\xb5\x08\x11\x17\
    \n\r\n\x05\x04n\x02\x13\x01\x12\x04\xb5\x08\x18\x1f\n\r\n\x05\x04n\x02\
    \x13\x03\x12\x04\xb5\x08\"$\n\x0c\n\x04\x04n\x02\x14\x12\x04\xb6\x08\x08\
    *\n\r\n\x05\x04n\x02\x14\x04\x12\x04\xb6\x08\x08\x10\n\r\n\x05\x04n\x02\
    \x14\x05\x12\x04\xb6\x08\x11\x17\n\r\n\x05\x04n\x02\x14\x01\x12\x04\xb6\
    \x08\x18$\n\r\n\x05\x04n\x02\x14\x03\x12\x04\xb6\x08')\n\x0c\n\x04\x04n\
    \x02\x15\x12\x04\xb7\x08\x08)\n\r\n\x05\x04n\x02\x15\x04\x12\x04\xb7\x08\
    \x08\x10\n\r\n\x05\x04n\x02\x15\x05\x12\x04\xb7\x08\x11\x17\n\r\n\x05\
    \x04n\x02\x15\x01\x12\x04\xb7\x08\x18#\n\r\n\x05\x04n\x02\x15\x03\x12\
    \x04\xb7\x08&(\n\x0c\n\x04\x04n\x02\x16\x12\x04\xb8\x08\x08*\n\r\n\x05\
    \x04n\x02\x16\x04\x12\x04\xb8\x08\x08\x10\n\r\n\x05\x04n\x02\x16\x05\x12\
    \x04\xb8\x08\x11\x17\n\r\n\x05\x04n\x02\x16\x01\x12\x04\xb8\x08\x18$\n\r\
    \n\x05\x04n\x02\x16\x03\x12\x04\xb8\x08')\n\x0c\n\x04\x04n\x02\x17\x12\
    \x04\xb9\x08\x08+\n\r\n\x05\x04n\x02\x17\x04\x12\x04\xb9\x08\x08\x10\n\r\
    \n\x05\x04n\x02\x17\x05\x12\x04\xb9\x08\x11\x17\n\r\n\x05\x04n\x02\x17\
    \x01\x12\x04\xb9\x08\x18%\n\r\n\x05\x04n\x02\x17\x03\x12\x04\xb9\x08(*\n\
    \x0c\n\x04\x04n\x02\x18\x12\x04\xba\x08\x08(\n\r\n\x05\x04n\x02\x18\x04\
    \x12\x04\xba\x08\x08\x10\n\r\n\x05\x04n\x02\x18\x05\x12\x04\xba\x08\x11\
    \x17\n\r\n\x05\x04n\x02\x18\x01\x12\x04\xba\x08\x18\"\n\r\n\x05\x04n\x02\
    \x18\x03\x12\x04\xba\x08%'\n\x0c\n\x04\x04n\x02\x19\x12\x04\xbb\x08\x08)\
    \n\r\n\x05\x04n\x02\x19\x04\x12\x04\xbb\x08\x08\x10\n\r\n\x05\x04n\x02\
    \x19\x05\x12\x04\xbb\x08\x11\x17\n\r\n\x05\x04n\x02\x19\x01\x12\x04\xbb\
    \x08\x18#\n\r\n\x05\x04n\x02\x19\x03\x12\x04\xbb\x08&(\n\x0c\n\x04\x04n\
    \x02\x1a\x12\x04\xbc\x08\x08)\n\r\n\x05\x04n\x02\x1a\x04\x12\x04\xbc\x08\
    \x08\x10\n\r\n\x05\x04n\x02\x1a\x05\x12\x04\xbc\x08\x11\x17\n\r\n\x05\
    \x04n\x02\x1a\x01\x12\x04\xbc\x08\x18#\n\r\n\x05\x04n\x02\x1a\x03\x12\
    \x04\xbc\x08&(\n\x0c\n\x04\x04n\x02\x1b\x12\x04\xbd\x08\x08(\n\r\n\x05\
    \x04n\x02\x1b\x04\x12\x04\xbd\x08\x08\x10\n\r\n\x05\x04n\x02\x1b\x05\x12\
    \x04\xbd\x08\x11\x17\n\r\n\x05\x04n\x02\x1b\x01\x12\x04\xbd\x08\x18\"\n\
    \r\n\x05\x04n\x02\x1b\x03\x12\x04\xbd\x08%'\n\x0c\n\x04\x04n\x02\x1c\x12\
    \x04\xbe\x08\x08'\n\r\n\x05\x04n\x02\x1c\x04\x12\x04\xbe\x08\x08\x10\n\r\
    \n\x05\x04n\x02\x1c\x05\x12\x04\xbe\x08\x11\x17\n\r\n\x05\x04n\x02\x1c\
    \x01\x12\x04\xbe\x08\x18!\n\r\n\x05\x04n\x02\x1c\x03\x12\x04\xbe\x08$&\n\
    \x0c\n\x04\x04n\x02\x1d\x12\x04\xbf\x08\x08,\n\r\n\x05\x04n\x02\x1d\x04\
    \x12\x04\xbf\x08\x08\x10\n\r\n\x05\x04n\x02\x1d\x05\x12\x04\xbf\x08\x11\
    \x17\n\r\n\x05\x04n\x02\x1d\x01\x12\x04\xbf\x08\x18&\n\r\n\x05\x04n\x02\
    \x1d\x03\x12\x04\xbf\x08)+\n\x0c\n\x02\x04o\x12\x06\xc2\x08\0\xc9\x08\
    \x01\n\x0b\n\x03\x04o\x01\x12\x04\xc2\x08\x08,\n\x0e\n\x04\x04o\x03\0\
    \x12\x06\xc3\x08\x08\xc5\x08\t\n\r\n\x05\x04o\x03\0\x01\x12\x04\xc3\x08\
    \x10\x16\n\x0e\n\x06\x04o\x03\0\x02\0\x12\x04\xc4\x08\x10.\n\x0f\n\x07\
    \x04o\x03\0\x02\0\x04\x12\x04\xc4\x08\x10\x18\n\x0f\n\x07\x04o\x03\0\x02\
    \0\x05\x12\x04\xc4\x08\x19\x20\n\x0f\n\x07\x04o\x03\0\x02\0\x01\x12\x04\
    \xc4\x08!)\n\x0f\n\x07\x04o\x03\0\x02\0\x03\x12\x04\xc4\x08,-\n\x0c\n\
    \x04\x04o\x02\0\x12\x04\xc7\x08\x08J\n\r\n\x05\x04o\x02\0\x04\x12\x04\
    \xc7\x08\x08\x10\n\r\n\x05\x04o\x02\0\x06\x12\x04\xc7\x08\x11=\n\r\n\x05\
    \x04o\x02\0\x01\x12\x04\xc7\x08>E\n\r\n\x05\x04o\x02\0\x03\x12\x04\xc7\
    \x08HI\n\x0c\n\x04\x04o\x02\x01\x12\x04\xc8\x08\x08+\n\r\n\x05\x04o\x02\
    \x01\x04\x12\x04\xc8\x08\x08\x10\n\r\n\x05\x04o\x02\x01\x05\x12\x04\xc8\
    \x08\x11\x17\n\r\n\x05\x04o\x02\x01\x01\x12\x04\xc8\x08\x18&\n\r\n\x05\
    \x04o\x02\x01\x03\x12\x04\xc8\x08)*\n\x0c\n\x02\x04p\x12\x06\xcb\x08\0\
    \xcd\x08\x01\n\x0b\n\x03\x04p\x01\x12\x04\xcb\x08\x08\x19\n\x0c\n\x04\
    \x04p\x02\0\x12\x04\xcc\x08\x08\"\n\r\n\x05\x04p\x02\0\x04\x12\x04\xcc\
    \x08\x08\x10\n\r\n\x05\x04p\x02\0\x05\x12\x04\xcc\x08\x11\x17\n\r\n\x05\
    \x04p\x02\0\x01\x12\x04\xcc\x08\x18\x1d\n\r\n\x05\x04p\x02\0\x03\x12\x04\
    \xcc\x08\x20!\n\x0c\n\x02\x04q\x12\x06\xcf\x08\0\xd6\x08\x01\n\x0b\n\x03\
    \x04q\x01\x12\x04\xcf\x08\x08)\n\x0c\n\x04\x04q\x02\0\x12\x04\xd0\x08\
    \x08&\n\r\n\x05\x04q\x02\0\x04\x12\x04\xd0\x08\x08\x10\n\r\n\x05\x04q\
    \x02\0\x05\x12\x04\xd0\x08\x11\x17\n\r\n\x05\x04q\x02\0\x01\x12\x04\xd0\
    \x08\x18!\n\r\n\x05\x04q\x02\0\x03\x12\x04\xd0\x08$%\n\x0c\n\x04\x04q\
    \x02\x01\x12\x04\xd1\x08\x08)\n\r\n\x05\x04q\x02\x01\x04\x12\x04\xd1\x08\
    \x08\x10\n\r\n\x05\x04q\x02\x01\x05\x12\x04\xd1\x08\x11\x17\n\r\n\x05\
    \x04q\x02\x01\x01\x12\x04\xd1\x08\x18$\n\r\n\x05\x04q\x02\x01\x03\x12\
    \x04\xd1\x08'(\n\x0c\n\x04\x04q\x02\x02\x12\x04\xd2\x08\x08,\n\r\n\x05\
    \x04q\x02\x02\x04\x12\x04\xd2\x08\x08\x10\n\r\n\x05\x04q\x02\x02\x05\x12\
    \x04\xd2\x08\x11\x17\n\r\n\x05\x04q\x02\x02\x01\x12\x04\xd2\x08\x18'\n\r\
    \n\x05\x04q\x02\x02\x03\x12\x04\xd2\x08*+\n\x0c\n\x04\x04q\x02\x03\x12\
    \x04\xd3\x08\x08.\n\r\n\x05\x04q\x02\x03\x04\x12\x04\xd3\x08\x08\x10\n\r\
    \n\x05\x04q\x02\x03\x05\x12\x04\xd3\x08\x11\x17\n\r\n\x05\x04q\x02\x03\
    \x01\x12\x04\xd3\x08\x18)\n\r\n\x05\x04q\x02\x03\x03\x12\x04\xd3\x08,-\n\
    \x0c\n\x04\x04q\x02\x04\x12\x04\xd4\x08\x08)\n\r\n\x05\x04q\x02\x04\x04\
    \x12\x04\xd4\x08\x08\x10\n\r\n\x05\x04q\x02\x04\x05\x12\x04\xd4\x08\x11\
    \x17\n\r\n\x05\x04q\x02\x04\x01\x12\x04\xd4\x08\x18$\n\r\n\x05\x04q\x02\
    \x04\x03\x12\x04\xd4\x08'(\n\x0c\n\x04\x04q\x02\x05\x12\x04\xd5\x08\x08*\
    \n\r\n\x05\x04q\x02\x05\x04\x12\x04\xd5\x08\x08\x10\n\r\n\x05\x04q\x02\
    \x05\x05\x12\x04\xd5\x08\x11\x17\n\r\n\x05\x04q\x02\x05\x01\x12\x04\xd5\
    \x08\x18%\n\r\n\x05\x04q\x02\x05\x03\x12\x04\xd5\x08()\n\x0c\n\x02\x04r\
    \x12\x06\xd8\x08\0\xe3\x08\x01\n\x0b\n\x03\x04r\x01\x12\x04\xd8\x08\x08I\
    \n\x0c\n\x04\x04r\x02\0\x12\x04\xd9\x08\x08&\n\r\n\x05\x04r\x02\0\x04\
    \x12\x04\xd9\x08\x08\x10\n\r\n\x05\x04r\x02\0\x05\x12\x04\xd9\x08\x11\
    \x17\n\r\n\x05\x04r\x02\0\x01\x12\x04\xd9\x08\x18!\n\r\n\x05\x04r\x02\0\
    \x03\x12\x04\xd9\x08$%\n\x0c\n\x04\x04r\x02\x01\x12\x04\xda\x08\x08%\n\r\
    \n\x05\x04r\x02\x01\x04\x12\x04\xda\x08\x08\x10\n\r\n\x05\x04r\x02\x01\
    \x05\x12\x04\xda\x08\x11\x17\n\r\n\x05\x04r\x02\x01\x01\x12\x04\xda\x08\
    \x18\x20\n\r\n\x05\x04r\x02\x01\x03\x12\x04\xda\x08#$\n\x0c\n\x04\x04r\
    \x02\x02\x12\x04\xdb\x08\x08)\n\r\n\x05\x04r\x02\x02\x04\x12\x04\xdb\x08\
    \x08\x10\n\r\n\x05\x04r\x02\x02\x05\x12\x04\xdb\x08\x11\x17\n\r\n\x05\
    \x04r\x02\x02\x01\x12\x04\xdb\x08\x18$\n\r\n\x05\x04r\x02\x02\x03\x12\
    \x04\xdb\x08'(\n\x0c\n\x04\x04r\x02\x03\x12\x04\xdc\x08\x08,\n\r\n\x05\
    \x04r\x02\x03\x04\x12\x04\xdc\x08\x08\x10\n\r\n\x05\x04r\x02\x03\x05\x12\
    \x04\xdc\x08\x11\x17\n\r\n\x05\x04r\x02\x03\x01\x12\x04\xdc\x08\x18'\n\r\
    \n\x05\x04r\x02\x03\x03\x12\x04\xdc\x08*+\n\x0c\n\x04\x04r\x02\x04\x12\
    \x04\xdd\x08\x08'\n\r\n\x05\x04r\x02\x04\x04\x12\x04\xdd\x08\x08\x10\n\r\
    \n\x05\x04r\x02\x04\x05\x12\x04\xdd\x08\x11\x17\n\r\n\x05\x04r\x02\x04\
    \x01\x12\x04\xdd\x08\x18\"\n\r\n\x05\x04r\x02\x04\x03\x12\x04\xdd\x08%&\
    \n\x0c\n\x04\x04r\x02\x05\x12\x04\xde\x08\x08.\n\r\n\x05\x04r\x02\x05\
    \x04\x12\x04\xde\x08\x08\x10\n\r\n\x05\x04r\x02\x05\x05\x12\x04\xde\x08\
    \x11\x17\n\r\n\x05\x04r\x02\x05\x01\x12\x04\xde\x08\x18)\n\r\n\x05\x04r\
    \x02\x05\x03\x12\x04\xde\x08,-\n\x0c\n\x04\x04r\x02\x06\x12\x04\xdf\x08\
    \x08)\n\r\n\x05\x04r\x02\x06\x04\x12\x04\xdf\x08\x08\x10\n\r\n\x05\x04r\
    \x02\x06\x05\x12\x04\xdf\x08\x11\x17\n\r\n\x05\x04r\x02\x06\x01\x12\x04\
    \xdf\x08\x18$\n\r\n\x05\x04r\x02\x06\x03\x12\x04\xdf\x08'(\n\x0c\n\x04\
    \x04r\x02\x07\x12\x04\xe0\x08\x08'\n\r\n\x05\x04r\x02\x07\x04\x12\x04\
    \xe0\x08\x08\x10\n\r\n\x05\x04r\x02\x07\x05\x12\x04\xe0\x08\x11\x17\n\r\
    \n\x05\x04r\x02\x07\x01\x12\x04\xe0\x08\x18\"\n\r\n\x05\x04r\x02\x07\x03\
    \x12\x04\xe0\x08%&\n\x0c\n\x04\x04r\x02\x08\x12\x04\xe1\x08\x08*\n\r\n\
    \x05\x04r\x02\x08\x04\x12\x04\xe1\x08\x08\x10\n\r\n\x05\x04r\x02\x08\x05\
    \x12\x04\xe1\x08\x11\x17\n\r\n\x05\x04r\x02\x08\x01\x12\x04\xe1\x08\x18%\
    \n\r\n\x05\x04r\x02\x08\x03\x12\x04\xe1\x08()\n\x0c\n\x04\x04r\x02\t\x12\
    \x04\xe2\x08\x08-\n\r\n\x05\x04r\x02\t\x04\x12\x04\xe2\x08\x08\x10\n\r\n\
    \x05\x04r\x02\t\x05\x12\x04\xe2\x08\x11\x17\n\r\n\x05\x04r\x02\t\x01\x12\
    \x04\xe2\x08\x18'\n\r\n\x05\x04r\x02\t\x03\x12\x04\xe2\x08*,\n\x0c\n\x02\
    \x04s\x12\x06\xe5\x08\0\xe7\x08\x01\n\x0b\n\x03\x04s\x01\x12\x04\xe5\x08\
    \x08#\n\x0c\n\x04\x04s\x02\0\x12\x04\xe6\x08\x08!\n\r\n\x05\x04s\x02\0\
    \x04\x12\x04\xe6\x08\x08\x10\n\r\n\x05\x04s\x02\0\x05\x12\x04\xe6\x08\
    \x11\x17\n\r\n\x05\x04s\x02\0\x01\x12\x04\xe6\x08\x18\x1c\n\r\n\x05\x04s\
    \x02\0\x03\x12\x04\xe6\x08\x1f\x20\n\x0c\n\x02\x04t\x12\x06\xe9\x08\0\
    \xed\x08\x01\n\x0b\n\x03\x04t\x01\x12\x04\xe9\x08\x08\x20\n\x0c\n\x04\
    \x04t\x02\0\x12\x04\xea\x08\x08$\n\r\n\x05\x04t\x02\0\x04\x12\x04\xea\
    \x08\x08\x10\n\r\n\x05\x04t\x02\0\x05\x12\x04\xea\x08\x11\x17\n\r\n\x05\
    \x04t\x02\0\x01\x12\x04\xea\x08\x18\x1f\n\r\n\x05\x04t\x02\0\x03\x12\x04\
    \xea\x08\"#\n\x0c\n\x04\x04t\x02\x01\x12\x04\xeb\x08\x082\n\r\n\x05\x04t\
    \x02\x01\x04\x12\x04\xeb\x08\x08\x10\n\r\n\x05\x04t\x02\x01\x05\x12\x04\
    \xeb\x08\x11\x17\n\r\n\x05\x04t\x02\x01\x01\x12\x04\xeb\x08\x18-\n\r\n\
    \x05\x04t\x02\x01\x03\x12\x04\xeb\x0801\n\x0c\n\x04\x04t\x02\x02\x12\x04\
    \xec\x08\x08'\n\r\n\x05\x04t\x02\x02\x04\x12\x04\xec\x08\x08\x10\n\r\n\
    \x05\x04t\x02\x02\x05\x12\x04\xec\x08\x11\x17\n\r\n\x05\x04t\x02\x02\x01\
    \x12\x04\xec\x08\x18\"\n\r\n\x05\x04t\x02\x02\x03\x12\x04\xec\x08%&\n\
    \x0c\n\x02\x04u\x12\x06\xef\x08\0\xf4\x08\x01\n\x0b\n\x03\x04u\x01\x12\
    \x04\xef\x08\x08\x12\n\x0c\n\x04\x04u\x02\0\x12\x04\xf0\x08\x08<\n\r\n\
    \x05\x04u\x02\0\x04\x12\x04\xf0\x08\x08\x10\n\r\n\x05\x04u\x02\0\x05\x12\
    \x04\xf0\x08\x11\x17\n\r\n\x05\x04u\x02\0\x01\x12\x04\xf0\x08\x18\"\n\r\
    \n\x05\x04u\x02\0\x03\x12\x04\xf0\x08%&\n\r\n\x05\x04u\x02\0\x08\x12\x04\
    \xf0\x08';\n\x10\n\x08\x04u\x02\0\x08\xe0\xd4\x03\x12\x04\xf0\x08(:\n\
    \x0c\n\x04\x04u\x02\x01\x12\x04\xf1\x08\x088\n\r\n\x05\x04u\x02\x01\x04\
    \x12\x04\xf1\x08\x08\x10\n\r\n\x05\x04u\x02\x01\x05\x12\x04\xf1\x08\x11\
    \x17\n\r\n\x05\x04u\x02\x01\x01\x12\x04\xf1\x08\x18\x1e\n\r\n\x05\x04u\
    \x02\x01\x03\x12\x04\xf1\x08!\"\n\r\n\x05\x04u\x02\x01\x08\x12\x04\xf1\
    \x08#7\n\x10\n\x08\x04u\x02\x01\x08\xe0\xd4\x03\x12\x04\xf1\x08$6\n\x0c\
    \n\x04\x04u\x02\x02\x12\x04\xf2\x08\x08(\n\r\n\x05\x04u\x02\x02\x04\x12\
    \x04\xf2\x08\x08\x10\n\r\n\x05\x04u\x02\x02\x05\x12\x04\xf2\x08\x11\x17\
    \n\r\n\x05\x04u\x02\x02\x01\x12\x04\xf2\x08\x18#\n\r\n\x05\x04u\x02\x02\
    \x03\x12\x04\xf2\x08&'\n\x0c\n\x04\x04u\x02\x03\x12\x04\xf3\x08\x08*\n\r\
    \n\x05\x04u\x02\x03\x04\x12\x04\xf3\x08\x08\x10\n\r\n\x05\x04u\x02\x03\
    \x05\x12\x04\xf3\x08\x11\x17\n\r\n\x05\x04u\x02\x03\x01\x12\x04\xf3\x08\
    \x18%\n\r\n\x05\x04u\x02\x03\x03\x12\x04\xf3\x08()\n\x0c\n\x02\x04v\x12\
    \x06\xf6\x08\0\xfa\x08\x01\n\x0b\n\x03\x04v\x01\x12\x04\xf6\x08\x08%\n\
    \x0c\n\x04\x04v\x02\0\x12\x04\xf7\x08\x08&\n\r\n\x05\x04v\x02\0\x04\x12\
    \x04\xf7\x08\x08\x10\n\r\n\x05\x04v\x02\0\x05\x12\x04\xf7\x08\x11\x18\n\
    \r\n\x05\x04v\x02\0\x01\x12\x04\xf7\x08\x19!\n\r\n\x05\x04v\x02\0\x03\
    \x12\x04\xf7\x08$%\n\x0c\n\x04\x04v\x02\x01\x12\x04\xf8\x08\x08#\n\r\n\
    \x05\x04v\x02\x01\x04\x12\x04\xf8\x08\x08\x10\n\r\n\x05\x04v\x02\x01\x05\
    \x12\x04\xf8\x08\x11\x17\n\r\n\x05\x04v\x02\x01\x01\x12\x04\xf8\x08\x18\
    \x1e\n\r\n\x05\x04v\x02\x01\x03\x12\x04\xf8\x08!\"\n\x0c\n\x04\x04v\x02\
    \x02\x12\x04\xf9\x08\x08\"\n\r\n\x05\x04v\x02\x02\x04\x12\x04\xf9\x08\
    \x08\x10\n\r\n\x05\x04v\x02\x02\x05\x12\x04\xf9\x08\x11\x17\n\r\n\x05\
    \x04v\x02\x02\x01\x12\x04\xf9\x08\x18\x1d\n\r\n\x05\x04v\x02\x02\x03\x12\
    \x04\xf9\x08\x20!\n\x0c\n\x02\x04w\x12\x06\xfc\x08\0\xff\x08\x01\n\x0b\n\
    \x03\x04w\x01\x12\x04\xfc\x08\x08\x1c\n\x0c\n\x04\x04w\x02\0\x12\x04\xfd\
    \x08\x08(\n\r\n\x05\x04w\x02\0\x04\x12\x04\xfd\x08\x08\x10\n\r\n\x05\x04\
    w\x02\0\x05\x12\x04\xfd\x08\x11\x17\n\r\n\x05\x04w\x02\0\x01\x12\x04\xfd\
    \x08\x18#\n\r\n\x05\x04w\x02\0\x03\x12\x04\xfd\x08&'\n\x0c\n\x04\x04w\
    \x02\x01\x12\x04\xfe\x08\x08#\n\r\n\x05\x04w\x02\x01\x04\x12\x04\xfe\x08\
    \x08\x10\n\r\n\x05\x04w\x02\x01\x05\x12\x04\xfe\x08\x11\x17\n\r\n\x05\
    \x04w\x02\x01\x01\x12\x04\xfe\x08\x18\x1e\n\r\n\x05\x04w\x02\x01\x03\x12\
    \x04\xfe\x08!\"\n\x0c\n\x02\x04x\x12\x06\x81\t\0\x83\t\x01\n\x0b\n\x03\
    \x04x\x01\x12\x04\x81\t\x08'\n\x0c\n\x04\x04x\x02\0\x12\x04\x82\t\x08#\n\
    \r\n\x05\x04x\x02\0\x04\x12\x04\x82\t\x08\x10\n\r\n\x05\x04x\x02\0\x05\
    \x12\x04\x82\t\x11\x17\n\r\n\x05\x04x\x02\0\x01\x12\x04\x82\t\x18\x1e\n\
    \r\n\x05\x04x\x02\0\x03\x12\x04\x82\t!\"\n\x0c\n\x02\x04y\x12\x06\x85\t\
    \0\x8d\t\x01\n\x0b\n\x03\x04y\x01\x12\x04\x85\t\x08(\n\x0e\n\x04\x04y\
    \x03\0\x12\x06\x86\t\x08\x89\t\t\n\r\n\x05\x04y\x03\0\x01\x12\x04\x86\t\
    \x10\x19\n\x0e\n\x06\x04y\x03\0\x02\0\x12\x04\x87\t\x10)\n\x0f\n\x07\x04\
    y\x03\0\x02\0\x04\x12\x04\x87\t\x10\x18\n\x0f\n\x07\x04y\x03\0\x02\0\x05\
    \x12\x04\x87\t\x19\x1f\n\x0f\n\x07\x04y\x03\0\x02\0\x01\x12\x04\x87\t\
    \x20$\n\x0f\n\x07\x04y\x03\0\x02\0\x03\x12\x04\x87\t'(\n\x0e\n\x06\x04y\
    \x03\0\x02\x01\x12\x04\x88\t\x10*\n\x0f\n\x07\x04y\x03\0\x02\x01\x04\x12\
    \x04\x88\t\x10\x18\n\x0f\n\x07\x04y\x03\0\x02\x01\x05\x12\x04\x88\t\x19\
    \x1f\n\x0f\n\x07\x04y\x03\0\x02\x01\x01\x12\x04\x88\t\x20%\n\x0f\n\x07\
    \x04y\x03\0\x02\x01\x03\x12\x04\x88\t()\n\x0c\n\x04\x04y\x02\0\x12\x04\
    \x8b\t\x08M\n\r\n\x05\x04y\x02\0\x04\x12\x04\x8b\t\x08\x10\n\r\n\x05\x04\
    y\x02\0\x06\x12\x04\x8b\t\x11<\n\r\n\x05\x04y\x02\0\x01\x12\x04\x8b\t=H\
    \n\r\n\x05\x04y\x02\0\x03\x12\x04\x8b\tKL\n\x0c\n\x04\x04y\x02\x01\x12\
    \x04\x8c\t\x08#\n\r\n\x05\x04y\x02\x01\x04\x12\x04\x8c\t\x08\x10\n\r\n\
    \x05\x04y\x02\x01\x05\x12\x04\x8c\t\x11\x17\n\r\n\x05\x04y\x02\x01\x01\
    \x12\x04\x8c\t\x18\x1e\n\r\n\x05\x04y\x02\x01\x03\x12\x04\x8c\t!\"\n\x0c\
    \n\x02\x04z\x12\x06\x8f\t\0\x94\t\x01\n\x0b\n\x03\x04z\x01\x12\x04\x8f\t\
    \x087\n\x0c\n\x04\x04z\x02\0\x12\x04\x90\t\x08\"\n\r\n\x05\x04z\x02\0\
    \x04\x12\x04\x90\t\x08\x10\n\r\n\x05\x04z\x02\0\x05\x12\x04\x90\t\x11\
    \x17\n\r\n\x05\x04z\x02\0\x01\x12\x04\x90\t\x18\x1d\n\r\n\x05\x04z\x02\0\
    \x03\x12\x04\x90\t\x20!\n\x0c\n\x04\x04z\x02\x01\x12\x04\x91\t\x08!\n\r\
    \n\x05\x04z\x02\x01\x04\x12\x04\x91\t\x08\x10\n\r\n\x05\x04z\x02\x01\x05\
    \x12\x04\x91\t\x11\x17\n\r\n\x05\x04z\x02\x01\x01\x12\x04\x91\t\x18\x1c\
    \n\r\n\x05\x04z\x02\x01\x03\x12\x04\x91\t\x1f\x20\n\x0c\n\x04\x04z\x02\
    \x02\x12\x04\x92\t\x08$\n\r\n\x05\x04z\x02\x02\x04\x12\x04\x92\t\x08\x10\
    \n\r\n\x05\x04z\x02\x02\x05\x12\x04\x92\t\x11\x16\n\r\n\x05\x04z\x02\x02\
    \x01\x12\x04\x92\t\x17\x1f\n\r\n\x05\x04z\x02\x02\x03\x12\x04\x92\t\"#\n\
    \x0c\n\x04\x04z\x02\x03\x12\x04\x93\t\x08(\n\r\n\x05\x04z\x02\x03\x04\
    \x12\x04\x93\t\x08\x10\n\r\n\x05\x04z\x02\x03\x05\x12\x04\x93\t\x11\x17\
    \n\r\n\x05\x04z\x02\x03\x01\x12\x04\x93\t\x18#\n\r\n\x05\x04z\x02\x03\
    \x03\x12\x04\x93\t&'\n\x0c\n\x02\x04{\x12\x06\x96\t\0\x9e\t\x01\n\x0b\n\
    \x03\x04{\x01\x12\x04\x96\t\x08%\n\x0c\n\x04\x04{\x02\0\x12\x04\x97\t\
    \x08-\n\r\n\x05\x04{\x02\0\x04\x12\x04\x97\t\x08\x10\n\r\n\x05\x04{\x02\
    \0\x05\x12\x04\x97\t\x11\x17\n\r\n\x05\x04{\x02\0\x01\x12\x04\x97\t\x18(\
    \n\r\n\x05\x04{\x02\0\x03\x12\x04\x97\t+,\n\x0c\n\x04\x04{\x02\x01\x12\
    \x04\x98\t\x08!\n\r\n\x05\x04{\x02\x01\x04\x12\x04\x98\t\x08\x10\n\r\n\
    \x05\x04{\x02\x01\x05\x12\x04\x98\t\x11\x16\n\r\n\x05\x04{\x02\x01\x01\
    \x12\x04\x98\t\x17\x1c\n\r\n\x05\x04{\x02\x01\x03\x12\x04\x98\t\x1f\x20\
    \n\x0c\n\x04\x04{\x02\x02\x12\x04\x99\t\x08!\n\r\n\x05\x04{\x02\x02\x04\
    \x12\x04\x99\t\x08\x10\n\r\n\x05\x04{\x02\x02\x05\x12\x04\x99\t\x11\x16\
    \n\r\n\x05\x04{\x02\x02\x01\x12\x04\x99\t\x17\x1c\n\r\n\x05\x04{\x02\x02\
    \x03\x12\x04\x99\t\x1f\x20\n\x0c\n\x04\x04{\x02\x03\x12\x04\x9a\t\x08!\n\
    \r\n\x05\x04{\x02\x03\x04\x12\x04\x9a\t\x08\x10\n\r\n\x05\x04{\x02\x03\
    \x05\x12\x04\x9a\t\x11\x16\n\r\n\x05\x04{\x02\x03\x01\x12\x04\x9a\t\x17\
    \x1c\n\r\n\x05\x04{\x02\x03\x03\x12\x04\x9a\t\x1f\x20\n\x0c\n\x04\x04{\
    \x02\x04\x12\x04\x9b\t\x08!\n\r\n\x05\x04{\x02\x04\x04\x12\x04\x9b\t\x08\
    \x10\n\r\n\x05\x04{\x02\x04\x05\x12\x04\x9b\t\x11\x16\n\r\n\x05\x04{\x02\
    \x04\x01\x12\x04\x9b\t\x17\x1c\n\r\n\x05\x04{\x02\x04\x03\x12\x04\x9b\t\
    \x1f\x20\n\x0c\n\x04\x04{\x02\x05\x12\x04\x9c\t\x08!\n\r\n\x05\x04{\x02\
    \x05\x04\x12\x04\x9c\t\x08\x10\n\r\n\x05\x04{\x02\x05\x05\x12\x04\x9c\t\
    \x11\x16\n\r\n\x05\x04{\x02\x05\x01\x12\x04\x9c\t\x17\x1c\n\r\n\x05\x04{\
    \x02\x05\x03\x12\x04\x9c\t\x1f\x20\n\x0c\n\x04\x04{\x02\x06\x12\x04\x9d\
    \t\x08!\n\r\n\x05\x04{\x02\x06\x04\x12\x04\x9d\t\x08\x10\n\r\n\x05\x04{\
    \x02\x06\x05\x12\x04\x9d\t\x11\x16\n\r\n\x05\x04{\x02\x06\x01\x12\x04\
    \x9d\t\x17\x1c\n\r\n\x05\x04{\x02\x06\x03\x12\x04\x9d\t\x1f\x20\n\x0c\n\
    \x02\x04|\x12\x06\xa0\t\0\xaa\t\x01\n\x0b\n\x03\x04|\x01\x12\x04\xa0\t\
    \x08(\n\x0c\n\x04\x04|\x02\0\x12\x04\xa1\t\x08-\n\r\n\x05\x04|\x02\0\x04\
    \x12\x04\xa1\t\x08\x10\n\r\n\x05\x04|\x02\0\x05\x12\x04\xa1\t\x11\x17\n\
    \r\n\x05\x04|\x02\0\x01\x12\x04\xa1\t\x18(\n\r\n\x05\x04|\x02\0\x03\x12\
    \x04\xa1\t+,\n\x0c\n\x04\x04|\x02\x01\x12\x04\xa2\t\x08!\n\r\n\x05\x04|\
    \x02\x01\x04\x12\x04\xa2\t\x08\x10\n\r\n\x05\x04|\x02\x01\x05\x12\x04\
    \xa2\t\x11\x16\n\r\n\x05\x04|\x02\x01\x01\x12\x04\xa2\t\x17\x1c\n\r\n\
    \x05\x04|\x02\x01\x03\x12\x04\xa2\t\x1f\x20\n\x0c\n\x04\x04|\x02\x02\x12\
    \x04\xa3\t\x08!\n\r\n\x05\x04|\x02\x02\x04\x12\x04\xa3\t\x08\x10\n\r\n\
    \x05\x04|\x02\x02\x05\x12\x04\xa3\t\x11\x16\n\r\n\x05\x04|\x02\x02\x01\
    \x12\x04\xa3\t\x17\x1c\n\r\n\x05\x04|\x02\x02\x03\x12\x04\xa3\t\x1f\x20\
    \n\x0c\n\x04\x04|\x02\x03\x12\x04\xa4\t\x08!\n\r\n\x05\x04|\x02\x03\x04\
    \x12\x04\xa4\t\x08\x10\n\r\n\x05\x04|\x02\x03\x05\x12\x04\xa4\t\x11\x16\
    \n\r\n\x05\x04|\x02\x03\x01\x12\x04\xa4\t\x17\x1c\n\r\n\x05\x04|\x02\x03\
    \x03\x12\x04\xa4\t\x1f\x20\n\x0c\n\x04\x04|\x02\x04\x12\x04\xa5\t\x08!\n\
    \r\n\x05\x04|\x02\x04\x04\x12\x04\xa5\t\x08\x10\n\r\n\x05\x04|\x02\x04\
    \x05\x12\x04\xa5\t\x11\x16\n\r\n\x05\x04|\x02\x04\x01\x12\x04\xa5\t\x17\
    \x1c\n\r\n\x05\x04|\x02\x04\x03\x12\x04\xa5\t\x1f\x20\n\x0c\n\x04\x04|\
    \x02\x05\x12\x04\xa6\t\x08!\n\r\n\x05\x04|\x02\x05\x04\x12\x04\xa6\t\x08\
    \x10\n\r\n\x05\x04|\x02\x05\x05\x12\x04\xa6\t\x11\x16\n\r\n\x05\x04|\x02\
    \x05\x01\x12\x04\xa6\t\x17\x1c\n\r\n\x05\x04|\x02\x05\x03\x12\x04\xa6\t\
    \x1f\x20\n\x0c\n\x04\x04|\x02\x06\x12\x04\xa7\t\x08!\n\r\n\x05\x04|\x02\
    \x06\x04\x12\x04\xa7\t\x08\x10\n\r\n\x05\x04|\x02\x06\x05\x12\x04\xa7\t\
    \x11\x16\n\r\n\x05\x04|\x02\x06\x01\x12\x04\xa7\t\x17\x1c\n\r\n\x05\x04|\
    \x02\x06\x03\x12\x04\xa7\t\x1f\x20\n\x0c\n\x04\x04|\x02\x07\x12\x04\xa8\
    \t\x08+\n\r\n\x05\x04|\x02\x07\x04\x12\x04\xa8\t\x08\x10\n\r\n\x05\x04|\
    \x02\x07\x05\x12\x04\xa8\t\x11\x15\n\r\n\x05\x04|\x02\x07\x01\x12\x04\
    \xa8\t\x16&\n\r\n\x05\x04|\x02\x07\x03\x12\x04\xa8\t)*\n\x0c\n\x04\x04|\
    \x02\x08\x12\x04\xa9\t\x08(\n\r\n\x05\x04|\x02\x08\x04\x12\x04\xa9\t\x08\
    \x10\n\r\n\x05\x04|\x02\x08\x05\x12\x04\xa9\t\x11\x17\n\r\n\x05\x04|\x02\
    \x08\x01\x12\x04\xa9\t\x18#\n\r\n\x05\x04|\x02\x08\x03\x12\x04\xa9\t&'\n\
    \x0c\n\x02\x04}\x12\x06\xac\t\0\xaf\t\x01\n\x0b\n\x03\x04}\x01\x12\x04\
    \xac\t\x08\x19\n\x0c\n\x04\x04}\x02\0\x12\x04\xad\t\x08'\n\r\n\x05\x04}\
    \x02\0\x04\x12\x04\xad\t\x08\x10\n\r\n\x05\x04}\x02\0\x05\x12\x04\xad\t\
    \x11\x16\n\r\n\x05\x04}\x02\0\x01\x12\x04\xad\t\x17\"\n\r\n\x05\x04}\x02\
    \0\x03\x12\x04\xad\t%&\n\x0c\n\x04\x04}\x02\x01\x12\x04\xae\t\x081\n\r\n\
    \x05\x04}\x02\x01\x04\x12\x04\xae\t\x08\x10\n\r\n\x05\x04}\x02\x01\x05\
    \x12\x04\xae\t\x11\x17\n\r\n\x05\x04}\x02\x01\x01\x12\x04\xae\t\x18,\n\r\
    \n\x05\x04}\x02\x01\x03\x12\x04\xae\t/0\n\x0c\n\x02\x04~\x12\x06\xb1\t\0\
    \xc2\t\x01\n\x0b\n\x03\x04~\x01\x12\x04\xb1\t\x08\x16\n\x0e\n\x04\x04~\
    \x04\0\x12\x06\xb2\t\x08\xbb\t\t\n\r\n\x05\x04~\x04\0\x01\x12\x04\xb2\t\
    \r\x19\n\x0e\n\x06\x04~\x04\0\x02\0\x12\x04\xb3\t\x10!\n\x0f\n\x07\x04~\
    \x04\0\x02\0\x01\x12\x04\xb3\t\x10\x1c\n\x0f\n\x07\x04~\x04\0\x02\0\x02\
    \x12\x04\xb3\t\x1f\x20\n\x0e\n\x06\x04~\x04\0\x02\x01\x12\x04\xb4\t\x10+\
    \n\x0f\n\x07\x04~\x04\0\x02\x01\x01\x12\x04\xb4\t\x10&\n\x0f\n\x07\x04~\
    \x04\0\x02\x01\x02\x12\x04\xb4\t)*\n\x0e\n\x06\x04~\x04\0\x02\x02\x12\
    \x04\xb5\t\x10+\n\x0f\n\x07\x04~\x04\0\x02\x02\x01\x12\x04\xb5\t\x10&\n\
    \x0f\n\x07\x04~\x04\0\x02\x02\x02\x12\x04\xb5\t)*\n\x0e\n\x06\x04~\x04\0\
    \x02\x03\x12\x04\xb6\t\x10/\n\x0f\n\x07\x04~\x04\0\x02\x03\x01\x12\x04\
    \xb6\t\x10*\n\x0f\n\x07\x04~\x04\0\x02\x03\x02\x12\x04\xb6\t-.\n\x0e\n\
    \x06\x04~\x04\0\x02\x04\x12\x04\xb7\t\x10+\n\x0f\n\x07\x04~\x04\0\x02\
    \x04\x01\x12\x04\xb7\t\x10&\n\x0f\n\x07\x04~\x04\0\x02\x04\x02\x12\x04\
    \xb7\t)*\n\x0e\n\x06\x04~\x04\0\x02\x05\x12\x04\xb8\t\x10,\n\x0f\n\x07\
    \x04~\x04\0\x02\x05\x01\x12\x04\xb8\t\x10'\n\x0f\n\x07\x04~\x04\0\x02\
    \x05\x02\x12\x04\xb8\t*+\n\x0e\n\x06\x04~\x04\0\x02\x06\x12\x04\xb9\t\
    \x10-\n\x0f\n\x07\x04~\x04\0\x02\x06\x01\x12\x04\xb9\t\x10(\n\x0f\n\x07\
    \x04~\x04\0\x02\x06\x02\x12\x04\xb9\t+,\n\x0e\n\x06\x04~\x04\0\x02\x07\
    \x12\x04\xba\t\x10*\n\x0f\n\x07\x04~\x04\0\x02\x07\x01\x12\x04\xba\t\x10\
    %\n\x0f\n\x07\x04~\x04\0\x02\x07\x02\x12\x04\xba\t()\n\x0c\n\x04\x04~\
    \x02\0\x12\x04\xbd\t\x08d\n\r\n\x05\x04~\x02\0\x04\x12\x04\xbd\t\x08\x10\
    \n\r\n\x05\x04~\x02\0\x06\x12\x04\xbd\t\x11-\n\r\n\x05\x04~\x02\0\x01\
    \x12\x04\xbd\t.2\n\r\n\x05\x04~\x02\0\x03\x12\x04\xbd\t56\n\r\n\x05\x04~\
    \x02\0\x08\x12\x04\xbd\t7c\n\r\n\x05\x04~\x02\0\x07\x12\x04\xbd\tBN\n\
    \x10\n\x08\x04~\x02\0\x08\xe0\xd4\x03\x12\x04\xbd\tPb\n\x0c\n\x04\x04~\
    \x02\x01\x12\x04\xbe\t\x08\"\n\r\n\x05\x04~\x02\x01\x04\x12\x04\xbe\t\
    \x08\x10\n\r\n\x05\x04~\x02\x01\x05\x12\x04\xbe\t\x11\x16\n\r\n\x05\x04~\
    \x02\x01\x01\x12\x04\xbe\t\x17\x1d\n\r\n\x05\x04~\x02\x01\x03\x12\x04\
    \xbe\t\x20!\n\x0c\n\x04\x04~\x02\x02\x12\x04\xbf\t\x08'\n\r\n\x05\x04~\
    \x02\x02\x04\x12\x04\xbf\t\x08\x10\n\r\n\x05\x04~\x02\x02\x05\x12\x04\
    \xbf\t\x11\x16\n\r\n\x05\x04~\x02\x02\x01\x12\x04\xbf\t\x17\"\n\r\n\x05\
    \x04~\x02\x02\x03\x12\x04\xbf\t%&\n\x0c\n\x04\x04~\x02\x03\x12\x04\xc0\t\
    \x08<\n\r\n\x05\x04~\x02\x03\x04\x12\x04\xc0\t\x08\x10\n\r\n\x05\x04~\
    \x02\x03\x05\x12\x04\xc0\t\x11\x17\n\r\n\x05\x04~\x02\x03\x01\x12\x04\
    \xc0\t\x18\"\n\r\n\x05\x04~\x02\x03\x03\x12\x04\xc0\t%&\n\r\n\x05\x04~\
    \x02\x03\x08\x12\x04\xc0\t';\n\x10\n\x08\x04~\x02\x03\x08\xe0\xd4\x03\
    \x12\x04\xc0\t(:\n\x0c\n\x04\x04~\x02\x04\x12\x04\xc1\t\x08:\n\r\n\x05\
    \x04~\x02\x04\x04\x12\x04\xc1\t\x08\x10\n\r\n\x05\x04~\x02\x04\x05\x12\
    \x04\xc1\t\x11\x17\n\r\n\x05\x04~\x02\x04\x01\x12\x04\xc1\t\x18\x20\n\r\
    \n\x05\x04~\x02\x04\x03\x12\x04\xc1\t#$\n\r\n\x05\x04~\x02\x04\x08\x12\
    \x04\xc1\t%9\n\x10\n\x08\x04~\x02\x04\x08\xe0\xd4\x03\x12\x04\xc1\t&8\n\
    \x0c\n\x02\x04\x7f\x12\x06\xc4\t\0\xc6\t\x01\n\x0b\n\x03\x04\x7f\x01\x12\
    \x04\xc4\t\x08\x1f\n\x0c\n\x04\x04\x7f\x02\0\x12\x04\xc5\t\x08-\n\r\n\
    \x05\x04\x7f\x02\0\x04\x12\x04\xc5\t\x08\x10\n\r\n\x05\x04\x7f\x02\0\x06\
    \x12\x04\xc5\t\x11\x20\n\r\n\x05\x04\x7f\x02\0\x01\x12\x04\xc5\t!(\n\r\n\
    \x05\x04\x7f\x02\0\x03\x12\x04\xc5\t+,\n\r\n\x03\x04\x80\x01\x12\x06\xc8\
    \t\0\xcb\t\x01\n\x0c\n\x04\x04\x80\x01\x01\x12\x04\xc8\t\x08\x18\n\r\n\
    \x05\x04\x80\x01\x02\0\x12\x04\xc9\t\x08+\n\x0e\n\x06\x04\x80\x01\x02\0\
    \x04\x12\x04\xc9\t\x08\x10\n\x0e\n\x06\x04\x80\x01\x02\0\x05\x12\x04\xc9\
    \t\x11\x17\n\x0e\n\x06\x04\x80\x01\x02\0\x01\x12\x04\xc9\t\x18&\n\x0e\n\
    \x06\x04\x80\x01\x02\0\x03\x12\x04\xc9\t)*\n\r\n\x05\x04\x80\x01\x02\x01\
    \x12\x04\xca\t\x08$\n\x0e\n\x06\x04\x80\x01\x02\x01\x04\x12\x04\xca\t\
    \x08\x10\n\x0e\n\x06\x04\x80\x01\x02\x01\x05\x12\x04\xca\t\x11\x16\n\x0e\
    \n\x06\x04\x80\x01\x02\x01\x01\x12\x04\xca\t\x17\x1f\n\x0e\n\x06\x04\x80\
    \x01\x02\x01\x03\x12\x04\xca\t\"#\n\r\n\x03\x04\x81\x01\x12\x06\xcd\t\0\
    \xdc\t\x01\n\x0c\n\x04\x04\x81\x01\x01\x12\x04\xcd\t\x08\x1a\n\x0f\n\x05\
    \x04\x81\x01\x04\0\x12\x06\xce\t\x08\xd5\t\t\n\x0e\n\x06\x04\x81\x01\x04\
    \0\x01\x12\x04\xce\t\r\x1d\n\x0f\n\x07\x04\x81\x01\x04\0\x02\0\x12\x04\
    \xcf\t\x108\n\x10\n\x08\x04\x81\x01\x04\0\x02\0\x01\x12\x04\xcf\t\x103\n\
    \x10\n\x08\x04\x81\x01\x04\0\x02\0\x02\x12\x04\xcf\t67\n\x0f\n\x07\x04\
    \x81\x01\x04\0\x02\x01\x12\x04\xd0\t\x10/\n\x10\n\x08\x04\x81\x01\x04\0\
    \x02\x01\x01\x12\x04\xd0\t\x10*\n\x10\n\x08\x04\x81\x01\x04\0\x02\x01\
    \x02\x12\x04\xd0\t-.\n\x0f\n\x07\x04\x81\x01\x04\0\x02\x02\x12\x04\xd1\t\
    \x10A\n\x10\n\x08\x04\x81\x01\x04\0\x02\x02\x01\x12\x04\xd1\t\x10<\n\x10\
    \n\x08\x04\x81\x01\x04\0\x02\x02\x02\x12\x04\xd1\t?@\n\x0f\n\x07\x04\x81\
    \x01\x04\0\x02\x03\x12\x04\xd2\t\x10<\n\x10\n\x08\x04\x81\x01\x04\0\x02\
    \x03\x01\x12\x04\xd2\t\x107\n\x10\n\x08\x04\x81\x01\x04\0\x02\x03\x02\
    \x12\x04\xd2\t:;\n\x0f\n\x07\x04\x81\x01\x04\0\x02\x04\x12\x04\xd3\t\x10\
    1\n\x10\n\x08\x04\x81\x01\x04\0\x02\x04\x01\x12\x04\xd3\t\x10,\n\x10\n\
    \x08\x04\x81\x01\x04\0\x02\x04\x02\x12\x04\xd3\t/0\n\x0f\n\x07\x04\x81\
    \x01\x04\0\x02\x05\x12\x04\xd4\t\x10+\n\x10\n\x08\x04\x81\x01\x04\0\x02\
    \x05\x01\x12\x04\xd4\t\x10&\n\x10\n\x08\x04\x81\x01\x04\0\x02\x05\x02\
    \x12\x04\xd4\t)*\n\r\n\x05\x04\x81\x01\x02\0\x12\x04\xd7\t\x08A\n\x0e\n\
    \x06\x04\x81\x01\x02\0\x04\x12\x04\xd7\t\x08\x10\n\x0e\n\x06\x04\x81\x01\
    \x02\0\x05\x12\x04\xd7\t\x11\x17\n\x0e\n\x06\x04\x81\x01\x02\0\x01\x12\
    \x04\xd7\t\x18'\n\x0e\n\x06\x04\x81\x01\x02\0\x03\x12\x04\xd7\t*+\n\x0e\
    \n\x06\x04\x81\x01\x02\0\x08\x12\x04\xd7\t,@\n\x11\n\t\x04\x81\x01\x02\0\
    \x08\xe0\xd4\x03\x12\x04\xd7\t-?\n\r\n\x05\x04\x81\x01\x02\x01\x12\x04\
    \xd8\t\x08'\n\x0e\n\x06\x04\x81\x01\x02\x01\x04\x12\x04\xd8\t\x08\x10\n\
    \x0e\n\x06\x04\x81\x01\x02\x01\x05\x12\x04\xd8\t\x11\x17\n\x0e\n\x06\x04\
    \x81\x01\x02\x01\x01\x12\x04\xd8\t\x18\"\n\x0e\n\x06\x04\x81\x01\x02\x01\
    \x03\x12\x04\xd8\t%&\n\r\n\x05\x04\x81\x01\x02\x02\x12\x04\xd9\t\x08-\n\
    \x0e\n\x06\x04\x81\x01\x02\x02\x04\x12\x04\xd9\t\x08\x10\n\x0e\n\x06\x04\
    \x81\x01\x02\x02\x05\x12\x04\xd9\t\x11\x18\n\x0e\n\x06\x04\x81\x01\x02\
    \x02\x01\x12\x04\xd9\t\x19(\n\x0e\n\x06\x04\x81\x01\x02\x02\x03\x12\x04\
    \xd9\t+,\n\r\n\x05\x04\x81\x01\x02\x03\x12\x04\xda\t\x08f\n\x0e\n\x06\
    \x04\x81\x01\x02\x03\x04\x12\x04\xda\t\x08\x10\n\x0e\n\x06\x04\x81\x01\
    \x02\x03\x06\x12\x04\xda\t\x115\n\x0e\n\x06\x04\x81\x01\x02\x03\x01\x12\
    \x04\xda\t6:\n\x0e\n\x06\x04\x81\x01\x02\x03\x03\x12\x04\xda\t=>\n\x0e\n\
    \x06\x04\x81\x01\x02\x03\x08\x12\x04\xda\t?e\n\x0e\n\x06\x04\x81\x01\x02\
    \x03\x07\x12\x04\xda\tJd\n\r\n\x05\x04\x81\x01\x02\x04\x12\x04\xdb\t\x08\
    0\n\x0e\n\x06\x04\x81\x01\x02\x04\x04\x12\x04\xdb\t\x08\x10\n\x0e\n\x06\
    \x04\x81\x01\x02\x04\x05\x12\x04\xdb\t\x11\x17\n\x0e\n\x06\x04\x81\x01\
    \x02\x04\x01\x12\x04\xdb\t\x18+\n\x0e\n\x06\x04\x81\x01\x02\x04\x03\x12\
    \x04\xdb\t./\n\r\n\x03\x04\x82\x01\x12\x06\xde\t\0\xe0\t\x01\n\x0c\n\x04\
    \x04\x82\x01\x01\x12\x04\xde\t\x08\x1f\n\r\n\x05\x04\x82\x01\x02\0\x12\
    \x04\xdf\t\x087\n\x0e\n\x06\x04\x82\x01\x02\0\x04\x12\x04\xdf\t\x08\x10\
    \n\x0e\n\x06\x04\x82\x01\x02\0\x06\x12\x04\xdf\t\x11$\n\x0e\n\x06\x04\
    \x82\x01\x02\0\x01\x12\x04\xdf\t%2\n\x0e\n\x06\x04\x82\x01\x02\0\x03\x12\
    \x04\xdf\t56\n\r\n\x03\x04\x83\x01\x12\x06\xe2\t\0\xe5\t\x01\n\x0c\n\x04\
    \x04\x83\x01\x01\x12\x04\xe2\t\x08#\n\r\n\x05\x04\x83\x01\x02\0\x12\x04\
    \xe3\t\x08'\n\x0e\n\x06\x04\x83\x01\x02\0\x04\x12\x04\xe3\t\x08\x10\n\
    \x0e\n\x06\x04\x83\x01\x02\0\x05\x12\x04\xe3\t\x11\x17\n\x0e\n\x06\x04\
    \x83\x01\x02\0\x01\x12\x04\xe3\t\x18\"\n\x0e\n\x06\x04\x83\x01\x02\0\x03\
    \x12\x04\xe3\t%&\n\r\n\x05\x04\x83\x01\x02\x01\x12\x04\xe4\t\x08,\n\x0e\
    \n\x06\x04\x83\x01\x02\x01\x04\x12\x04\xe4\t\x08\x10\n\x0e\n\x06\x04\x83\
    \x01\x02\x01\x05\x12\x04\xe4\t\x11\x17\n\x0e\n\x06\x04\x83\x01\x02\x01\
    \x01\x12\x04\xe4\t\x18'\n\x0e\n\x06\x04\x83\x01\x02\x01\x03\x12\x04\xe4\
    \t*+\n\r\n\x03\x04\x84\x01\x12\x06\xe7\t\0\xe8\t\x01\n\x0c\n\x04\x04\x84\
    \x01\x01\x12\x04\xe7\t\x08(\n\r\n\x03\x04\x85\x01\x12\x06\xea\t\0\x9b\n\
    \x01\n\x0c\n\x04\x04\x85\x01\x01\x12\x04\xea\t\x08\x1b\n\x0f\n\x05\x04\
    \x85\x01\x03\0\x12\x06\xeb\t\x08\x82\n\t\n\x0e\n\x06\x04\x85\x01\x03\0\
    \x01\x12\x04\xeb\t\x10\x16\n\x0f\n\x07\x04\x85\x01\x03\0\x02\0\x12\x04\
    \xec\t\x10.\n\x10\n\x08\x04\x85\x01\x03\0\x02\0\x04\x12\x04\xec\t\x10\
    \x18\n\x10\n\x08\x04\x85\x01\x03\0\x02\0\x05\x12\x04\xec\t\x19\x20\n\x10\
    \n\x08\x04\x85\x01\x03\0\x02\0\x01\x12\x04\xec\t!)\n\x10\n\x08\x04\x85\
    \x01\x03\0\x02\0\x03\x12\x04\xec\t,-\n\x0f\n\x07\x04\x85\x01\x03\0\x02\
    \x01\x12\x04\xed\t\x106\n\x10\n\x08\x04\x85\x01\x03\0\x02\x01\x04\x12\
    \x04\xed\t\x10\x18\n\x10\n\x08\x04\x85\x01\x03\0\x02\x01\x05\x12\x04\xed\
    \t\x19\x1f\n\x10\n\x08\x04\x85\x01\x03\0\x02\x01\x01\x12\x04\xed\t\x201\
    \n\x10\n\x08\x04\x85\x01\x03\0\x02\x01\x03\x12\x04\xed\t45\n\x0f\n\x07\
    \x04\x85\x01\x03\0\x02\x02\x12\x04\xee\t\x10)\n\x10\n\x08\x04\x85\x01\
    \x03\0\x02\x02\x04\x12\x04\xee\t\x10\x18\n\x10\n\x08\x04\x85\x01\x03\0\
    \x02\x02\x05\x12\x04\xee\t\x19\x1f\n\x10\n\x08\x04\x85\x01\x03\0\x02\x02\
    \x01\x12\x04\xee\t\x20$\n\x10\n\x08\x04\x85\x01\x03\0\x02\x02\x03\x12\
    \x04\xee\t'(\n\x0f\n\x07\x04\x85\x01\x03\0\x02\x03\x12\x04\xef\t\x10*\n\
    \x10\n\x08\x04\x85\x01\x03\0\x02\x03\x04\x12\x04\xef\t\x10\x18\n\x10\n\
    \x08\x04\x85\x01\x03\0\x02\x03\x05\x12\x04\xef\t\x19\x1f\n\x10\n\x08\x04\
    \x85\x01\x03\0\x02\x03\x01\x12\x04\xef\t\x20%\n\x10\n\x08\x04\x85\x01\
    \x03\0\x02\x03\x03\x12\x04\xef\t()\n\x0f\n\x07\x04\x85\x01\x03\0\x02\x04\
    \x12\x04\xf0\t\x10)\n\x10\n\x08\x04\x85\x01\x03\0\x02\x04\x04\x12\x04\
    \xf0\t\x10\x18\n\x10\n\x08\x04\x85\x01\x03\0\x02\x04\x05\x12\x04\xf0\t\
    \x19\x1f\n\x10\n\x08\x04\x85\x01\x03\0\x02\x04\x01\x12\x04\xf0\t\x20$\n\
    \x10\n\x08\x04\x85\x01\x03\0\x02\x04\x03\x12\x04\xf0\t'(\n\x0f\n\x07\x04\
    \x85\x01\x03\0\x02\x05\x12\x04\xf1\t\x10*\n\x10\n\x08\x04\x85\x01\x03\0\
    \x02\x05\x04\x12\x04\xf1\t\x10\x18\n\x10\n\x08\x04\x85\x01\x03\0\x02\x05\
    \x05\x12\x04\xf1\t\x19\x1f\n\x10\n\x08\x04\x85\x01\x03\0\x02\x05\x01\x12\
    \x04\xf1\t\x20%\n\x10\n\x08\x04\x85\x01\x03\0\x02\x05\x03\x12\x04\xf1\t(\
    )\n\x0f\n\x07\x04\x85\x01\x03\0\x02\x06\x12\x04\xf2\t\x10)\n\x10\n\x08\
    \x04\x85\x01\x03\0\x02\x06\x04\x12\x04\xf2\t\x10\x18\n\x10\n\x08\x04\x85\
    \x01\x03\0\x02\x06\x05\x12\x04\xf2\t\x19\x1f\n\x10\n\x08\x04\x85\x01\x03\
    \0\x02\x06\x01\x12\x04\xf2\t\x20$\n\x10\n\x08\x04\x85\x01\x03\0\x02\x06\
    \x03\x12\x04\xf2\t'(\n\x0f\n\x07\x04\x85\x01\x03\0\x02\x07\x12\x04\xf3\t\
    \x104\n\x10\n\x08\x04\x85\x01\x03\0\x02\x07\x04\x12\x04\xf3\t\x10\x18\n\
    \x10\n\x08\x04\x85\x01\x03\0\x02\x07\x05\x12\x04\xf3\t\x19\x1f\n\x10\n\
    \x08\x04\x85\x01\x03\0\x02\x07\x01\x12\x04\xf3\t\x20.\n\x10\n\x08\x04\
    \x85\x01\x03\0\x02\x07\x03\x12\x04\xf3\t13\n\x0f\n\x07\x04\x85\x01\x03\0\
    \x02\x08\x12\x04\xf4\t\x10+\n\x10\n\x08\x04\x85\x01\x03\0\x02\x08\x04\
    \x12\x04\xf4\t\x10\x18\n\x10\n\x08\x04\x85\x01\x03\0\x02\x08\x05\x12\x04\
    \xf4\t\x19\x1f\n\x10\n\x08\x04\x85\x01\x03\0\x02\x08\x01\x12\x04\xf4\t\
    \x20%\n\x10\n\x08\x04\x85\x01\x03\0\x02\x08\x03\x12\x04\xf4\t(*\n\x0f\n\
    \x07\x04\x85\x01\x03\0\x02\t\x12\x04\xf5\t\x10,\n\x10\n\x08\x04\x85\x01\
    \x03\0\x02\t\x04\x12\x04\xf5\t\x10\x18\n\x10\n\x08\x04\x85\x01\x03\0\x02\
    \t\x05\x12\x04\xf5\t\x19\x1f\n\x10\n\x08\x04\x85\x01\x03\0\x02\t\x01\x12\
    \x04\xf5\t\x20&\n\x10\n\x08\x04\x85\x01\x03\0\x02\t\x03\x12\x04\xf5\t)+\
    \n\x0f\n\x07\x04\x85\x01\x03\0\x02\n\x12\x04\xf6\t\x10,\n\x10\n\x08\x04\
    \x85\x01\x03\0\x02\n\x04\x12\x04\xf6\t\x10\x18\n\x10\n\x08\x04\x85\x01\
    \x03\0\x02\n\x05\x12\x04\xf6\t\x19\x1f\n\x10\n\x08\x04\x85\x01\x03\0\x02\
    \n\x01\x12\x04\xf6\t\x20&\n\x10\n\x08\x04\x85\x01\x03\0\x02\n\x03\x12\
    \x04\xf6\t)+\n\x0f\n\x07\x04\x85\x01\x03\0\x02\x0b\x12\x04\xf7\t\x10-\n\
    \x10\n\x08\x04\x85\x01\x03\0\x02\x0b\x04\x12\x04\xf7\t\x10\x18\n\x10\n\
    \x08\x04\x85\x01\x03\0\x02\x0b\x05\x12\x04\xf7\t\x19\x1f\n\x10\n\x08\x04\
    \x85\x01\x03\0\x02\x0b\x01\x12\x04\xf7\t\x20'\n\x10\n\x08\x04\x85\x01\
    \x03\0\x02\x0b\x03\x12\x04\xf7\t*,\n\x0f\n\x07\x04\x85\x01\x03\0\x02\x0c\
    \x12\x04\xf8\t\x10-\n\x10\n\x08\x04\x85\x01\x03\0\x02\x0c\x04\x12\x04\
    \xf8\t\x10\x18\n\x10\n\x08\x04\x85\x01\x03\0\x02\x0c\x05\x12\x04\xf8\t\
    \x19\x1f\n\x10\n\x08\x04\x85\x01\x03\0\x02\x0c\x01\x12\x04\xf8\t\x20'\n\
    \x10\n\x08\x04\x85\x01\x03\0\x02\x0c\x03\x12\x04\xf8\t*,\n\x0f\n\x07\x04\
    \x85\x01\x03\0\x02\r\x12\x04\xf9\t\x101\n\x10\n\x08\x04\x85\x01\x03\0\
    \x02\r\x04\x12\x04\xf9\t\x10\x18\n\x10\n\x08\x04\x85\x01\x03\0\x02\r\x05\
    \x12\x04\xf9\t\x19\x1f\n\x10\n\x08\x04\x85\x01\x03\0\x02\r\x01\x12\x04\
    \xf9\t\x20+\n\x10\n\x08\x04\x85\x01\x03\0\x02\r\x03\x12\x04\xf9\t.0\n\
    \x0f\n\x07\x04\x85\x01\x03\0\x02\x0e\x12\x04\xfa\t\x101\n\x10\n\x08\x04\
    \x85\x01\x03\0\x02\x0e\x04\x12\x04\xfa\t\x10\x18\n\x10\n\x08\x04\x85\x01\
    \x03\0\x02\x0e\x05\x12\x04\xfa\t\x19\x1f\n\x10\n\x08\x04\x85\x01\x03\0\
    \x02\x0e\x01\x12\x04\xfa\t\x20+\n\x10\n\x08\x04\x85\x01\x03\0\x02\x0e\
    \x03\x12\x04\xfa\t.0\n\x0f\n\x07\x04\x85\x01\x03\0\x02\x0f\x12\x04\xfb\t\
    \x102\n\x10\n\x08\x04\x85\x01\x03\0\x02\x0f\x04\x12\x04\xfb\t\x10\x18\n\
    \x10\n\x08\x04\x85\x01\x03\0\x02\x0f\x05\x12\x04\xfb\t\x19\x1f\n\x10\n\
    \x08\x04\x85\x01\x03\0\x02\x0f\x01\x12\x04\xfb\t\x20,\n\x10\n\x08\x04\
    \x85\x01\x03\0\x02\x0f\x03\x12\x04\xfb\t/1\n\x0f\n\x07\x04\x85\x01\x03\0\
    \x02\x10\x12\x04\xfc\t\x103\n\x10\n\x08\x04\x85\x01\x03\0\x02\x10\x04\
    \x12\x04\xfc\t\x10\x18\n\x10\n\x08\x04\x85\x01\x03\0\x02\x10\x05\x12\x04\
    \xfc\t\x19\x1f\n\x10\n\x08\x04\x85\x01\x03\0\x02\x10\x01\x12\x04\xfc\t\
    \x20-\n\x10\n\x08\x04\x85\x01\x03\0\x02\x10\x03\x12\x04\xfc\t02\n\x0f\n\
    \x07\x04\x85\x01\x03\0\x02\x11\x12\x04\xfd\t\x103\n\x10\n\x08\x04\x85\
    \x01\x03\0\x02\x11\x04\x12\x04\xfd\t\x10\x18\n\x10\n\x08\x04\x85\x01\x03\
    \0\x02\x11\x05\x12\x04\xfd\t\x19\x1f\n\x10\n\x08\x04\x85\x01\x03\0\x02\
    \x11\x01\x12\x04\xfd\t\x20-\n\x10\n\x08\x04\x85\x01\x03\0\x02\x11\x03\
    \x12\x04\xfd\t02\n\x0f\n\x07\x04\x85\x01\x03\0\x02\x12\x12\x04\xfe\t\x10\
    ;\n\x10\n\x08\x04\x85\x01\x03\0\x02\x12\x04\x12\x04\xfe\t\x10\x18\n\x10\
    \n\x08\x04\x85\x01\x03\0\x02\x12\x06\x12\x04\xfe\t\x19(\n\x10\n\x08\x04\
    \x85\x01\x03\0\x02\x12\x01\x12\x04\xfe\t)5\n\x10\n\x08\x04\x85\x01\x03\0\
    \x02\x12\x03\x12\x04\xfe\t8:\n\x0f\n\x07\x04\x85\x01\x03\0\x02\x13\x12\
    \x04\xff\t\x100\n\x10\n\x08\x04\x85\x01\x03\0\x02\x13\x04\x12\x04\xff\t\
    \x10\x18\n\x10\n\x08\x04\x85\x01\x03\0\x02\x13\x05\x12\x04\xff\t\x19\x1f\
    \n\x10\n\x08\x04\x85\x01\x03\0\x02\x13\x01\x12\x04\xff\t\x20*\n\x10\n\
    \x08\x04\x85\x01\x03\0\x02\x13\x03\x12\x04\xff\t-/\n\x0f\n\x07\x04\x85\
    \x01\x03\0\x02\x14\x12\x04\x80\n\x10j\n\x10\n\x08\x04\x85\x01\x03\0\x02\
    \x14\x04\x12\x04\x80\n\x10\x18\n\x10\n\x08\x04\x85\x01\x03\0\x02\x14\x06\
    \x12\x04\x80\n\x19,\n\x10\n\x08\x04\x85\x01\x03\0\x02\x14\x01\x12\x04\
    \x80\n-9\n\x10\n\x08\x04\x85\x01\x03\0\x02\x14\x03\x12\x04\x80\n<>\n\x10\
    \n\x08\x04\x85\x01\x03\0\x02\x14\x08\x12\x04\x80\n?i\n\x10\n\x08\x04\x85\
    \x01\x03\0\x02\x14\x07\x12\x04\x80\nJh\n\x0f\n\x07\x04\x85\x01\x03\0\x02\
    \x15\x12\x04\x81\n\x102\n\x10\n\x08\x04\x85\x01\x03\0\x02\x15\x04\x12\
    \x04\x81\n\x10\x18\n\x10\n\x08\x04\x85\x01\x03\0\x02\x15\x05\x12\x04\x81\
    \n\x19\x1f\n\x10\n\x08\x04\x85\x01\x03\0\x02\x15\x01\x12\x04\x81\n\x20,\
    \n\x10\n\x08\x04\x85\x01\x03\0\x02\x15\x03\x12\x04\x81\n/1\n\x0f\n\x05\
    \x04\x85\x01\x04\0\x12\x06\x84\n\x08\x8c\n\t\n\x0e\n\x06\x04\x85\x01\x04\
    \0\x01\x12\x04\x84\n\r\x13\n\x0f\n\x07\x04\x85\x01\x04\0\x02\0\x12\x04\
    \x85\n\x10$\n\x10\n\x08\x04\x85\x01\x04\0\x02\0\x01\x12\x04\x85\n\x10\
    \x1f\n\x10\n\x08\x04\x85\x01\x04\0\x02\0\x02\x12\x04\x85\n\"#\n\x0f\n\
    \x07\x04\x85\x01\x04\0\x02\x01\x12\x04\x86\n\x10$\n\x10\n\x08\x04\x85\
    \x01\x04\0\x02\x01\x01\x12\x04\x86\n\x10\x1f\n\x10\n\x08\x04\x85\x01\x04\
    \0\x02\x01\x02\x12\x04\x86\n\"#\n\x0f\n\x07\x04\x85\x01\x04\0\x02\x02\
    \x12\x04\x87\n\x10)\n\x10\n\x08\x04\x85\x01\x04\0\x02\x02\x01\x12\x04\
    \x87\n\x10$\n\x10\n\x08\x04\x85\x01\x04\0\x02\x02\x02\x12\x04\x87\n'(\n\
    \x0f\n\x07\x04\x85\x01\x04\0\x02\x03\x12\x04\x88\n\x10)\n\x10\n\x08\x04\
    \x85\x01\x04\0\x02\x03\x01\x12\x04\x88\n\x10$\n\x10\n\x08\x04\x85\x01\
    \x04\0\x02\x03\x02\x12\x04\x88\n'(\n\x0f\n\x07\x04\x85\x01\x04\0\x02\x04\
    \x12\x04\x89\n\x10)\n\x10\n\x08\x04\x85\x01\x04\0\x02\x04\x01\x12\x04\
    \x89\n\x10$\n\x10\n\x08\x04\x85\x01\x04\0\x02\x04\x02\x12\x04\x89\n'(\n\
    \x0f\n\x07\x04\x85\x01\x04\0\x02\x05\x12\x04\x8a\n\x10)\n\x10\n\x08\x04\
    \x85\x01\x04\0\x02\x05\x01\x12\x04\x8a\n\x10$\n\x10\n\x08\x04\x85\x01\
    \x04\0\x02\x05\x02\x12\x04\x8a\n'(\n\x0f\n\x07\x04\x85\x01\x04\0\x02\x06\
    \x12\x04\x8b\n\x10+\n\x10\n\x08\x04\x85\x01\x04\0\x02\x06\x01\x12\x04\
    \x8b\n\x10&\n\x10\n\x08\x04\x85\x01\x04\0\x02\x06\x02\x12\x04\x8b\n)*\n\
    \r\n\x05\x04\x85\x01\x02\0\x12\x04\x8e\n\x08:\n\x0e\n\x06\x04\x85\x01\
    \x02\0\x04\x12\x04\x8e\n\x08\x10\n\x0e\n\x06\x04\x85\x01\x02\0\x05\x12\
    \x04\x8e\n\x11\x17\n\x0e\n\x06\x04\x85\x01\x02\0\x01\x12\x04\x8e\n\x18\
    \x20\n\x0e\n\x06\x04\x85\x01\x02\0\x03\x12\x04\x8e\n#$\n\x0e\n\x06\x04\
    \x85\x01\x02\0\x08\x12\x04\x8e\n%9\n\x11\n\t\x04\x85\x01\x02\0\x08\xe0\
    \xd4\x03\x12\x04\x8e\n&8\n\r\n\x05\x04\x85\x01\x02\x01\x12\x04\x8f\n\x08\
    '\n\x0e\n\x06\x04\x85\x01\x02\x01\x04\x12\x04\x8f\n\x08\x10\n\x0e\n\x06\
    \x04\x85\x01\x02\x01\x05\x12\x04\x8f\n\x11\x16\n\x0e\n\x06\x04\x85\x01\
    \x02\x01\x01\x12\x04\x8f\n\x17\"\n\x0e\n\x06\x04\x85\x01\x02\x01\x03\x12\
    \x04\x8f\n%&\n\r\n\x05\x04\x85\x01\x02\x02\x12\x04\x90\n\x08T\n\x0e\n\
    \x06\x04\x85\x01\x02\x02\x04\x12\x04\x90\n\x08\x10\n\x0e\n\x06\x04\x85\
    \x01\x02\x02\x06\x12\x04\x90\n\x11,\n\x0e\n\x06\x04\x85\x01\x02\x02\x01\
    \x12\x04\x90\n-3\n\x0e\n\x06\x04\x85\x01\x02\x02\x03\x12\x04\x90\n67\n\
    \x0e\n\x06\x04\x85\x01\x02\x02\x08\x12\x04\x90\n8S\n\x0e\n\x06\x04\x85\
    \x01\x02\x02\x07\x12\x04\x90\nCR\n\r\n\x05\x04\x85\x01\x02\x03\x12\x04\
    \x91\n\x08%\n\x0e\n\x06\x04\x85\x01\x02\x03\x04\x12\x04\x91\n\x08\x10\n\
    \x0e\n\x06\x04\x85\x01\x02\x03\x05\x12\x04\x91\n\x11\x17\n\x0e\n\x06\x04\
    \x85\x01\x02\x03\x01\x12\x04\x91\n\x18\x20\n\x0e\n\x06\x04\x85\x01\x02\
    \x03\x03\x12\x04\x91\n#$\n\r\n\x05\x04\x85\x01\x02\x04\x12\x04\x92\n\x08\
    &\n\x0e\n\x06\x04\x85\x01\x02\x04\x04\x12\x04\x92\n\x08\x10\n\x0e\n\x06\
    \x04\x85\x01\x02\x04\x05\x12\x04\x92\n\x11\x17\n\x0e\n\x06\x04\x85\x01\
    \x02\x04\x01\x12\x04\x92\n\x18!\n\x0e\n\x06\x04\x85\x01\x02\x04\x03\x12\
    \x04\x92\n$%\n\r\n\x05\x04\x85\x01\x02\x05\x12\x04\x93\n\x08'\n\x0e\n\
    \x06\x04\x85\x01\x02\x05\x04\x12\x04\x93\n\x08\x10\n\x0e\n\x06\x04\x85\
    \x01\x02\x05\x05\x12\x04\x93\n\x11\x17\n\x0e\n\x06\x04\x85\x01\x02\x05\
    \x01\x12\x04\x93\n\x18\"\n\x0e\n\x06\x04\x85\x01\x02\x05\x03\x12\x04\x93\
    \n%&\n\r\n\x05\x04\x85\x01\x02\x06\x12\x04\x94\n\x08)\n\x0e\n\x06\x04\
    \x85\x01\x02\x06\x04\x12\x04\x94\n\x08\x10\n\x0e\n\x06\x04\x85\x01\x02\
    \x06\x05\x12\x04\x94\n\x11\x17\n\x0e\n\x06\x04\x85\x01\x02\x06\x01\x12\
    \x04\x94\n\x18$\n\x0e\n\x06\x04\x85\x01\x02\x06\x03\x12\x04\x94\n'(\n\r\
    \n\x05\x04\x85\x01\x02\x07\x12\x04\x95\n\x08&\n\x0e\n\x06\x04\x85\x01\
    \x02\x07\x04\x12\x04\x95\n\x08\x10\n\x0e\n\x06\x04\x85\x01\x02\x07\x05\
    \x12\x04\x95\n\x11\x17\n\x0e\n\x06\x04\x85\x01\x02\x07\x01\x12\x04\x95\n\
    \x18!\n\x0e\n\x06\x04\x85\x01\x02\x07\x03\x12\x04\x95\n$%\n\r\n\x05\x04\
    \x85\x01\x02\x08\x12\x04\x96\n\x084\n\x0e\n\x06\x04\x85\x01\x02\x08\x04\
    \x12\x04\x96\n\x08\x10\n\x0e\n\x06\x04\x85\x01\x02\x08\x05\x12\x04\x96\n\
    \x11\x17\n\x0e\n\x06\x04\x85\x01\x02\x08\x01\x12\x04\x96\n\x18!\n\x0e\n\
    \x06\x04\x85\x01\x02\x08\x03\x12\x04\x96\n$%\n\x0e\n\x06\x04\x85\x01\x02\
    \x08\x08\x12\x04\x96\n&3\n\x0e\n\x06\x04\x85\x01\x02\x08\x07\x12\x04\x96\
    \n12\n\r\n\x05\x04\x85\x01\x02\t\x12\x04\x97\n\x08:\n\x0e\n\x06\x04\x85\
    \x01\x02\t\x04\x12\x04\x97\n\x08\x10\n\x0e\n\x06\x04\x85\x01\x02\t\x06\
    \x12\x04\x97\n\x11,\n\x0e\n\x06\x04\x85\x01\x02\t\x01\x12\x04\x97\n-4\n\
    \x0e\n\x06\x04\x85\x01\x02\t\x03\x12\x04\x97\n79\n\r\n\x05\x04\x85\x01\
    \x02\n\x12\x04\x98\n\x08(\n\x0e\n\x06\x04\x85\x01\x02\n\x04\x12\x04\x98\
    \n\x08\x10\n\x0e\n\x06\x04\x85\x01\x02\n\x05\x12\x04\x98\n\x11\x17\n\x0e\
    \n\x06\x04\x85\x01\x02\n\x01\x12\x04\x98\n\x18\"\n\x0e\n\x06\x04\x85\x01\
    \x02\n\x03\x12\x04\x98\n%'\n\r\n\x05\x04\x85\x01\x02\x0b\x12\x04\x99\n\
    \x08#\n\x0e\n\x06\x04\x85\x01\x02\x0b\x04\x12\x04\x99\n\x08\x10\n\x0e\n\
    \x06\x04\x85\x01\x02\x0b\x05\x12\x04\x99\n\x11\x17\n\x0e\n\x06\x04\x85\
    \x01\x02\x0b\x01\x12\x04\x99\n\x18\x1d\n\x0e\n\x06\x04\x85\x01\x02\x0b\
    \x03\x12\x04\x99\n\x20\"\n\r\n\x05\x04\x85\x01\x02\x0c\x12\x04\x9a\n\x08\
    \"\n\x0e\n\x06\x04\x85\x01\x02\x0c\x04\x12\x04\x9a\n\x08\x10\n\x0e\n\x06\
    \x04\x85\x01\x02\x0c\x05\x12\x04\x9a\n\x11\x17\n\x0e\n\x06\x04\x85\x01\
    \x02\x0c\x01\x12\x04\x9a\n\x18\x1c\n\x0e\n\x06\x04\x85\x01\x02\x0c\x03\
    \x12\x04\x9a\n\x1f!\n\r\n\x03\x04\x86\x01\x12\x06\x9d\n\0\x9e\n\x01\n\
    \x0c\n\x04\x04\x86\x01\x01\x12\x04\x9d\n\x08#\n\r\n\x03\x04\x87\x01\x12\
    \x06\xa0\n\0\xa2\n\x01\n\x0c\n\x04\x04\x87\x01\x01\x12\x04\xa0\n\x08!\n\
    \r\n\x05\x04\x87\x01\x02\0\x12\x04\xa1\n\x08+\n\x0e\n\x06\x04\x87\x01\
    \x02\0\x04\x12\x04\xa1\n\x08\x10\n\x0e\n\x06\x04\x87\x01\x02\0\x06\x12\
    \x04\xa1\n\x11\x1d\n\x0e\n\x06\x04\x87\x01\x02\0\x01\x12\x04\xa1\n\x1e&\
    \n\x0e\n\x06\x04\x87\x01\x02\0\x03\x12\x04\xa1\n)*\n\r\n\x03\x04\x88\x01\
    \x12\x06\xa4\n\0\xa9\n\x01\n\x0c\n\x04\x04\x88\x01\x01\x12\x04\xa4\n\x08\
    3\n\r\n\x05\x04\x88\x01\x02\0\x12\x04\xa5\n\x08$\n\x0e\n\x06\x04\x88\x01\
    \x02\0\x04\x12\x04\xa5\n\x08\x10\n\x0e\n\x06\x04\x88\x01\x02\0\x05\x12\
    \x04\xa5\n\x11\x17\n\x0e\n\x06\x04\x88\x01\x02\0\x01\x12\x04\xa5\n\x18\
    \x1f\n\x0e\n\x06\x04\x88\x01\x02\0\x03\x12\x04\xa5\n\"#\n\r\n\x05\x04\
    \x88\x01\x02\x01\x12\x04\xa6\n\x08$\n\x0e\n\x06\x04\x88\x01\x02\x01\x04\
    \x12\x04\xa6\n\x08\x10\n\x0e\n\x06\x04\x88\x01\x02\x01\x05\x12\x04\xa6\n\
    \x11\x17\n\x0e\n\x06\x04\x88\x01\x02\x01\x01\x12\x04\xa6\n\x18\x1f\n\x0e\
    \n\x06\x04\x88\x01\x02\x01\x03\x12\x04\xa6\n\"#\n\r\n\x05\x04\x88\x01\
    \x02\x02\x12\x04\xa7\n\x08$\n\x0e\n\x06\x04\x88\x01\x02\x02\x04\x12\x04\
    \xa7\n\x08\x10\n\x0e\n\x06\x04\x88\x01\x02\x02\x05\x12\x04\xa7\n\x11\x17\
    \n\x0e\n\x06\x04\x88\x01\x02\x02\x01\x12\x04\xa7\n\x18\x1f\n\x0e\n\x06\
    \x04\x88\x01\x02\x02\x03\x12\x04\xa7\n\"#\n\r\n\x05\x04\x88\x01\x02\x03\
    \x12\x04\xa8\n\x08$\n\x0e\n\x06\x04\x88\x01\x02\x03\x04\x12\x04\xa8\n\
    \x08\x10\n\x0e\n\x06\x04\x88\x01\x02\x03\x05\x12\x04\xa8\n\x11\x17\n\x0e\
    \n\x06\x04\x88\x01\x02\x03\x01\x12\x04\xa8\n\x18\x1f\n\x0e\n\x06\x04\x88\
    \x01\x02\x03\x03\x12\x04\xa8\n\"#\n\r\n\x03\x04\x89\x01\x12\x06\xab\n\0\
    \xad\n\x01\n\x0c\n\x04\x04\x89\x01\x01\x12\x04\xab\n\x084\n\r\n\x05\x04\
    \x89\x01\x02\0\x12\x04\xac\n\x089\n\x0e\n\x06\x04\x89\x01\x02\0\x04\x12\
    \x04\xac\n\x08\x10\n\x0e\n\x06\x04\x89\x01\x02\0\x06\x12\x04\xac\n\x11+\
    \n\x0e\n\x06\x04\x89\x01\x02\0\x01\x12\x04\xac\n,4\n\x0e\n\x06\x04\x89\
    \x01\x02\0\x03\x12\x04\xac\n78\n\r\n\x03\x04\x8a\x01\x12\x06\xaf\n\0\xc9\
    \n\x01\n\x0c\n\x04\x04\x8a\x01\x01\x12\x04\xaf\n\x08\x1e\n\r\n\x05\x04\
    \x8a\x01\x02\0\x12\x04\xb0\n\x08<\n\x0e\n\x06\x04\x8a\x01\x02\0\x04\x12\
    \x04\xb0\n\x08\x10\n\x0e\n\x06\x04\x8a\x01\x02\0\x05\x12\x04\xb0\n\x11\
    \x17\n\x0e\n\x06\x04\x8a\x01\x02\0\x01\x12\x04\xb0\n\x18\"\n\x0e\n\x06\
    \x04\x8a\x01\x02\0\x03\x12\x04\xb0\n%&\n\x0e\n\x06\x04\x8a\x01\x02\0\x08\
    \x12\x04\xb0\n';\n\x11\n\t\x04\x8a\x01\x02\0\x08\xe0\xd4\x03\x12\x04\xb0\
    \n(:\n\r\n\x05\x04\x8a\x01\x02\x01\x12\x04\xb1\n\x08<\n\x0e\n\x06\x04\
    \x8a\x01\x02\x01\x04\x12\x04\xb1\n\x08\x10\n\x0e\n\x06\x04\x8a\x01\x02\
    \x01\x05\x12\x04\xb1\n\x11\x16\n\x0e\n\x06\x04\x8a\x01\x02\x01\x01\x12\
    \x04\xb1\n\x17\"\n\x0e\n\x06\x04\x8a\x01\x02\x01\x03\x12\x04\xb1\n%&\n\
    \x0e\n\x06\x04\x8a\x01\x02\x01\x08\x12\x04\xb1\n';\n\x11\n\t\x04\x8a\x01\
    \x02\x01\x08\xe0\xd4\x03\x12\x04\xb1\n(:\n\r\n\x05\x04\x8a\x01\x02\x02\
    \x12\x04\xb2\n\x08;\n\x0e\n\x06\x04\x8a\x01\x02\x02\x04\x12\x04\xb2\n\
    \x08\x10\n\x0e\n\x06\x04\x8a\x01\x02\x02\x05\x12\x04\xb2\n\x11\x17\n\x0e\
    \n\x06\x04\x8a\x01\x02\x02\x01\x12\x04\xb2\n\x18!\n\x0e\n\x06\x04\x8a\
    \x01\x02\x02\x03\x12\x04\xb2\n$%\n\x0e\n\x06\x04\x8a\x01\x02\x02\x08\x12\
    \x04\xb2\n&:\n\x11\n\t\x04\x8a\x01\x02\x02\x08\xe0\xd4\x03\x12\x04\xb2\n\
    '9\n\r\n\x05\x04\x8a\x01\x02\x03\x12\x04\xb3\n\x08\"\n\x0e\n\x06\x04\x8a\
    \x01\x02\x03\x04\x12\x04\xb3\n\x08\x10\n\x0e\n\x06\x04\x8a\x01\x02\x03\
    \x05\x12\x04\xb3\n\x11\x17\n\x0e\n\x06\x04\x8a\x01\x02\x03\x01\x12\x04\
    \xb3\n\x18\x1d\n\x0e\n\x06\x04\x8a\x01\x02\x03\x03\x12\x04\xb3\n\x20!\n\
    \r\n\x05\x04\x8a\x01\x02\x04\x12\x04\xb4\n\x08#\n\x0e\n\x06\x04\x8a\x01\
    \x02\x04\x04\x12\x04\xb4\n\x08\x10\n\x0e\n\x06\x04\x8a\x01\x02\x04\x05\
    \x12\x04\xb4\n\x11\x17\n\x0e\n\x06\x04\x8a\x01\x02\x04\x01\x12\x04\xb4\n\
    \x18\x1d\n\x0e\n\x06\x04\x8a\x01\x02\x04\x03\x12\x04\xb4\n\x20\"\n\r\n\
    \x05\x04\x8a\x01\x02\x05\x12\x04\xb5\n\x08#\n\x0e\n\x06\x04\x8a\x01\x02\
    \x05\x04\x12\x04\xb5\n\x08\x10\n\x0e\n\x06\x04\x8a\x01\x02\x05\x05\x12\
    \x04\xb5\n\x11\x17\n\x0e\n\x06\x04\x8a\x01\x02\x05\x01\x12\x04\xb5\n\x18\
    \x1d\n\x0e\n\x06\x04\x8a\x01\x02\x05\x03\x12\x04\xb5\n\x20\"\n\r\n\x05\
    \x04\x8a\x01\x02\x06\x12\x04\xb6\n\x08$\n\x0e\n\x06\x04\x8a\x01\x02\x06\
    \x04\x12\x04\xb6\n\x08\x10\n\x0e\n\x06\x04\x8a\x01\x02\x06\x05\x12\x04\
    \xb6\n\x11\x17\n\x0e\n\x06\x04\x8a\x01\x02\x06\x01\x12\x04\xb6\n\x18\x1e\
    \n\x0e\n\x06\x04\x8a\x01\x02\x06\x03\x12\x04\xb6\n!#\n\r\n\x05\x04\x8a\
    \x01\x02\x07\x12\x04\xb7\n\x08$\n\x0e\n\x06\x04\x8a\x01\x02\x07\x04\x12\
    \x04\xb7\n\x08\x10\n\x0e\n\x06\x04\x8a\x01\x02\x07\x05\x12\x04\xb7\n\x11\
    \x17\n\x0e\n\x06\x04\x8a\x01\x02\x07\x01\x12\x04\xb7\n\x18\x1e\n\x0e\n\
    \x06\x04\x8a\x01\x02\x07\x03\x12\x04\xb7\n!#\n\r\n\x05\x04\x8a\x01\x02\
    \x08\x12\x04\xb8\n\x08%\n\x0e\n\x06\x04\x8a\x01\x02\x08\x04\x12\x04\xb8\
    \n\x08\x10\n\x0e\n\x06\x04\x8a\x01\x02\x08\x05\x12\x04\xb8\n\x11\x17\n\
    \x0e\n\x06\x04\x8a\x01\x02\x08\x01\x12\x04\xb8\n\x18\x1f\n\x0e\n\x06\x04\
    \x8a\x01\x02\x08\x03\x12\x04\xb8\n\"$\n\r\n\x05\x04\x8a\x01\x02\t\x12\
    \x04\xb9\n\x08%\n\x0e\n\x06\x04\x8a\x01\x02\t\x04\x12\x04\xb9\n\x08\x10\
    \n\x0e\n\x06\x04\x8a\x01\x02\t\x05\x12\x04\xb9\n\x11\x17\n\x0e\n\x06\x04\
    \x8a\x01\x02\t\x01\x12\x04\xb9\n\x18\x1f\n\x0e\n\x06\x04\x8a\x01\x02\t\
    \x03\x12\x04\xb9\n\"$\n\r\n\x05\x04\x8a\x01\x02\n\x12\x04\xba\n\x08*\n\
    \x0e\n\x06\x04\x8a\x01\x02\n\x04\x12\x04\xba\n\x08\x10\n\x0e\n\x06\x04\
    \x8a\x01\x02\n\x05\x12\x04\xba\n\x11\x17\n\x0e\n\x06\x04\x8a\x01\x02\n\
    \x01\x12\x04\xba\n\x18$\n\x0e\n\x06\x04\x8a\x01\x02\n\x03\x12\x04\xba\n'\
    )\n\r\n\x05\x04\x8a\x01\x02\x0b\x12\x04\xbb\n\x08*\n\x0e\n\x06\x04\x8a\
    \x01\x02\x0b\x04\x12\x04\xbb\n\x08\x10\n\x0e\n\x06\x04\x8a\x01\x02\x0b\
    \x05\x12\x04\xbb\n\x11\x17\n\x0e\n\x06\x04\x8a\x01\x02\x0b\x01\x12\x04\
    \xbb\n\x18$\n\x0e\n\x06\x04\x8a\x01\x02\x0b\x03\x12\x04\xbb\n')\n\r\n\
    \x05\x04\x8a\x01\x02\x0c\x12\x04\xbc\n\x08(\n\x0e\n\x06\x04\x8a\x01\x02\
    \x0c\x04\x12\x04\xbc\n\x08\x10\n\x0e\n\x06\x04\x8a\x01\x02\x0c\x05\x12\
    \x04\xbc\n\x11\x17\n\x0e\n\x06\x04\x8a\x01\x02\x0c\x01\x12\x04\xbc\n\x18\
    \"\n\x0e\n\x06\x04\x8a\x01\x02\x0c\x03\x12\x04\xbc\n%'\n\r\n\x05\x04\x8a\
    \x01\x02\r\x12\x04\xbd\n\x08*\n\x0e\n\x06\x04\x8a\x01\x02\r\x04\x12\x04\
    \xbd\n\x08\x10\n\x0e\n\x06\x04\x8a\x01\x02\r\x05\x12\x04\xbd\n\x11\x17\n\
    \x0e\n\x06\x04\x8a\x01\x02\r\x01\x12\x04\xbd\n\x18$\n\x0e\n\x06\x04\x8a\
    \x01\x02\r\x03\x12\x04\xbd\n')\n\r\n\x05\x04\x8a\x01\x02\x0e\x12\x04\xbe\
    \n\x08*\n\x0e\n\x06\x04\x8a\x01\x02\x0e\x04\x12\x04\xbe\n\x08\x10\n\x0e\
    \n\x06\x04\x8a\x01\x02\x0e\x05\x12\x04\xbe\n\x11\x17\n\x0e\n\x06\x04\x8a\
    \x01\x02\x0e\x01\x12\x04\xbe\n\x18$\n\x0e\n\x06\x04\x8a\x01\x02\x0e\x03\
    \x12\x04\xbe\n')\n\r\n\x05\x04\x8a\x01\x02\x0f\x12\x04\xbf\n\x08(\n\x0e\
    \n\x06\x04\x8a\x01\x02\x0f\x04\x12\x04\xbf\n\x08\x10\n\x0e\n\x06\x04\x8a\
    \x01\x02\x0f\x05\x12\x04\xbf\n\x11\x17\n\x0e\n\x06\x04\x8a\x01\x02\x0f\
    \x01\x12\x04\xbf\n\x18\"\n\x0e\n\x06\x04\x8a\x01\x02\x0f\x03\x12\x04\xbf\
    \n%'\n\r\n\x05\x04\x8a\x01\x02\x10\x12\x04\xc0\n\x08+\n\x0e\n\x06\x04\
    \x8a\x01\x02\x10\x04\x12\x04\xc0\n\x08\x10\n\x0e\n\x06\x04\x8a\x01\x02\
    \x10\x05\x12\x04\xc0\n\x11\x17\n\x0e\n\x06\x04\x8a\x01\x02\x10\x01\x12\
    \x04\xc0\n\x18%\n\x0e\n\x06\x04\x8a\x01\x02\x10\x03\x12\x04\xc0\n(*\n\r\
    \n\x05\x04\x8a\x01\x02\x11\x12\x04\xc1\n\x08+\n\x0e\n\x06\x04\x8a\x01\
    \x02\x11\x04\x12\x04\xc1\n\x08\x10\n\x0e\n\x06\x04\x8a\x01\x02\x11\x05\
    \x12\x04\xc1\n\x11\x17\n\x0e\n\x06\x04\x8a\x01\x02\x11\x01\x12\x04\xc1\n\
    \x18%\n\x0e\n\x06\x04\x8a\x01\x02\x11\x03\x12\x04\xc1\n(*\n\r\n\x05\x04\
    \x8a\x01\x02\x12\x12\x04\xc2\n\x08)\n\x0e\n\x06\x04\x8a\x01\x02\x12\x04\
    \x12\x04\xc2\n\x08\x10\n\x0e\n\x06\x04\x8a\x01\x02\x12\x05\x12\x04\xc2\n\
    \x11\x17\n\x0e\n\x06\x04\x8a\x01\x02\x12\x01\x12\x04\xc2\n\x18#\n\x0e\n\
    \x06\x04\x8a\x01\x02\x12\x03\x12\x04\xc2\n&(\n\r\n\x05\x04\x8a\x01\x02\
    \x13\x12\x04\xc3\n\x08,\n\x0e\n\x06\x04\x8a\x01\x02\x13\x04\x12\x04\xc3\
    \n\x08\x10\n\x0e\n\x06\x04\x8a\x01\x02\x13\x05\x12\x04\xc3\n\x11\x17\n\
    \x0e\n\x06\x04\x8a\x01\x02\x13\x01\x12\x04\xc3\n\x18&\n\x0e\n\x06\x04\
    \x8a\x01\x02\x13\x03\x12\x04\xc3\n)+\n\r\n\x05\x04\x8a\x01\x02\x14\x12\
    \x04\xc4\n\x08,\n\x0e\n\x06\x04\x8a\x01\x02\x14\x04\x12\x04\xc4\n\x08\
    \x10\n\x0e\n\x06\x04\x8a\x01\x02\x14\x05\x12\x04\xc4\n\x11\x17\n\x0e\n\
    \x06\x04\x8a\x01\x02\x14\x01\x12\x04\xc4\n\x18&\n\x0e\n\x06\x04\x8a\x01\
    \x02\x14\x03\x12\x04\xc4\n)+\n\r\n\x05\x04\x8a\x01\x02\x15\x12\x04\xc5\n\
    \x08*\n\x0e\n\x06\x04\x8a\x01\x02\x15\x04\x12\x04\xc5\n\x08\x10\n\x0e\n\
    \x06\x04\x8a\x01\x02\x15\x05\x12\x04\xc5\n\x11\x17\n\x0e\n\x06\x04\x8a\
    \x01\x02\x15\x01\x12\x04\xc5\n\x18$\n\x0e\n\x06\x04\x8a\x01\x02\x15\x03\
    \x12\x04\xc5\n')\n\r\n\x05\x04\x8a\x01\x02\x16\x12\x04\xc6\n\x08,\n\x0e\
    \n\x06\x04\x8a\x01\x02\x16\x04\x12\x04\xc6\n\x08\x10\n\x0e\n\x06\x04\x8a\
    \x01\x02\x16\x05\x12\x04\xc6\n\x11\x17\n\x0e\n\x06\x04\x8a\x01\x02\x16\
    \x01\x12\x04\xc6\n\x18&\n\x0e\n\x06\x04\x8a\x01\x02\x16\x03\x12\x04\xc6\
    \n)+\n\r\n\x05\x04\x8a\x01\x02\x17\x12\x04\xc7\n\x08,\n\x0e\n\x06\x04\
    \x8a\x01\x02\x17\x04\x12\x04\xc7\n\x08\x10\n\x0e\n\x06\x04\x8a\x01\x02\
    \x17\x05\x12\x04\xc7\n\x11\x17\n\x0e\n\x06\x04\x8a\x01\x02\x17\x01\x12\
    \x04\xc7\n\x18&\n\x0e\n\x06\x04\x8a\x01\x02\x17\x03\x12\x04\xc7\n)+\n\r\
    \n\x05\x04\x8a\x01\x02\x18\x12\x04\xc8\n\x08*\n\x0e\n\x06\x04\x8a\x01\
    \x02\x18\x04\x12\x04\xc8\n\x08\x10\n\x0e\n\x06\x04\x8a\x01\x02\x18\x05\
    \x12\x04\xc8\n\x11\x17\n\x0e\n\x06\x04\x8a\x01\x02\x18\x01\x12\x04\xc8\n\
    \x18$\n\x0e\n\x06\x04\x8a\x01\x02\x18\x03\x12\x04\xc8\n')\n\r\n\x03\x04\
    \x8b\x01\x12\x06\xcb\n\0\xd1\n\x01\n\x0c\n\x04\x04\x8b\x01\x01\x12\x04\
    \xcb\n\x08\x17\n\r\n\x05\x04\x8b\x01\x02\0\x12\x04\xcc\n\x08<\n\x0e\n\
    \x06\x04\x8b\x01\x02\0\x04\x12\x04\xcc\n\x08\x10\n\x0e\n\x06\x04\x8b\x01\
    \x02\0\x05\x12\x04\xcc\n\x11\x17\n\x0e\n\x06\x04\x8b\x01\x02\0\x01\x12\
    \x04\xcc\n\x18\"\n\x0e\n\x06\x04\x8b\x01\x02\0\x03\x12\x04\xcc\n%&\n\x0e\
    \n\x06\x04\x8b\x01\x02\0\x08\x12\x04\xcc\n';\n\x11\n\t\x04\x8b\x01\x02\0\
    \x08\xe0\xd4\x03\x12\x04\xcc\n(:\n\r\n\x05\x04\x8b\x01\x02\x01\x12\x04\
    \xcd\n\x08<\n\x0e\n\x06\x04\x8b\x01\x02\x01\x04\x12\x04\xcd\n\x08\x10\n\
    \x0e\n\x06\x04\x8b\x01\x02\x01\x05\x12\x04\xcd\n\x11\x16\n\x0e\n\x06\x04\
    \x8b\x01\x02\x01\x01\x12\x04\xcd\n\x17\"\n\x0e\n\x06\x04\x8b\x01\x02\x01\
    \x03\x12\x04\xcd\n%&\n\x0e\n\x06\x04\x8b\x01\x02\x01\x08\x12\x04\xcd\n';\
    \n\x11\n\t\x04\x8b\x01\x02\x01\x08\xe0\xd4\x03\x12\x04\xcd\n(:\n\r\n\x05\
    \x04\x8b\x01\x02\x02\x12\x04\xce\n\x08+\n\x0e\n\x06\x04\x8b\x01\x02\x02\
    \x04\x12\x04\xce\n\x08\x10\n\x0e\n\x06\x04\x8b\x01\x02\x02\x05\x12\x04\
    \xce\n\x11\x17\n\x0e\n\x06\x04\x8b\x01\x02\x02\x01\x12\x04\xce\n\x18&\n\
    \x0e\n\x06\x04\x8b\x01\x02\x02\x03\x12\x04\xce\n)*\n\r\n\x05\x04\x8b\x01\
    \x02\x03\x12\x04\xcf\n\x08-\n\x0e\n\x06\x04\x8b\x01\x02\x03\x04\x12\x04\
    \xcf\n\x08\x10\n\x0e\n\x06\x04\x8b\x01\x02\x03\x05\x12\x04\xcf\n\x11\x17\
    \n\x0e\n\x06\x04\x8b\x01\x02\x03\x01\x12\x04\xcf\n\x18(\n\x0e\n\x06\x04\
    \x8b\x01\x02\x03\x03\x12\x04\xcf\n+,\n\r\n\x05\x04\x8b\x01\x02\x04\x12\
    \x04\xd0\n\x08,\n\x0e\n\x06\x04\x8b\x01\x02\x04\x04\x12\x04\xd0\n\x08\
    \x10\n\x0e\n\x06\x04\x8b\x01\x02\x04\x05\x12\x04\xd0\n\x11\x17\n\x0e\n\
    \x06\x04\x8b\x01\x02\x04\x01\x12\x04\xd0\n\x18'\n\x0e\n\x06\x04\x8b\x01\
    \x02\x04\x03\x12\x04\xd0\n*+\n\r\n\x03\x04\x8c\x01\x12\x06\xd3\n\0\xd8\n\
    \x01\n\x0c\n\x04\x04\x8c\x01\x01\x12\x04\xd3\n\x08&\n\r\n\x05\x04\x8c\
    \x01\x02\0\x12\x04\xd4\n\x08&\n\x0e\n\x06\x04\x8c\x01\x02\0\x04\x12\x04\
    \xd4\n\x08\x10\n\x0e\n\x06\x04\x8c\x01\x02\0\x05\x12\x04\xd4\n\x11\x17\n\
    \x0e\n\x06\x04\x8c\x01\x02\0\x01\x12\x04\xd4\n\x18!\n\x0e\n\x06\x04\x8c\
    \x01\x02\0\x03\x12\x04\xd4\n$%\n\r\n\x05\x04\x8c\x01\x02\x01\x12\x04\xd5\
    \n\x08%\n\x0e\n\x06\x04\x8c\x01\x02\x01\x04\x12\x04\xd5\n\x08\x10\n\x0e\
    \n\x06\x04\x8c\x01\x02\x01\x05\x12\x04\xd5\n\x11\x17\n\x0e\n\x06\x04\x8c\
    \x01\x02\x01\x01\x12\x04\xd5\n\x18\x20\n\x0e\n\x06\x04\x8c\x01\x02\x01\
    \x03\x12\x04\xd5\n#$\n\r\n\x05\x04\x8c\x01\x02\x02\x12\x04\xd6\n\x08Q\n\
    \x0e\n\x06\x04\x8c\x01\x02\x02\x04\x12\x04\xd6\n\x08\x10\n\x0e\n\x06\x04\
    \x8c\x01\x02\x02\x06\x12\x04\xd6\n\x11\"\n\x0e\n\x06\x04\x8c\x01\x02\x02\
    \x01\x12\x04\xd6\n#)\n\x0e\n\x06\x04\x8c\x01\x02\x02\x03\x12\x04\xd6\n,-\
    \n\x0e\n\x06\x04\x8c\x01\x02\x02\x08\x12\x04\xd6\n.P\n\x0e\n\x06\x04\x8c\
    \x01\x02\x02\x07\x12\x04\xd6\n9O\n\r\n\x05\x04\x8c\x01\x02\x03\x12\x04\
    \xd7\n\x08%\n\x0e\n\x06\x04\x8c\x01\x02\x03\x04\x12\x04\xd7\n\x08\x10\n\
    \x0e\n\x06\x04\x8c\x01\x02\x03\x05\x12\x04\xd7\n\x11\x17\n\x0e\n\x06\x04\
    \x8c\x01\x02\x03\x01\x12\x04\xd7\n\x18\x20\n\x0e\n\x06\x04\x8c\x01\x02\
    \x03\x03\x12\x04\xd7\n#$\n\r\n\x03\x04\x8d\x01\x12\x06\xda\n\0\xde\n\x01\
    \n\x0c\n\x04\x04\x8d\x01\x01\x12\x04\xda\n\x08,\n\r\n\x05\x04\x8d\x01\
    \x02\0\x12\x04\xdb\n\x08\"\n\x0e\n\x06\x04\x8d\x01\x02\0\x04\x12\x04\xdb\
    \n\x08\x10\n\x0e\n\x06\x04\x8d\x01\x02\0\x05\x12\x04\xdb\n\x11\x15\n\x0e\
    \n\x06\x04\x8d\x01\x02\0\x01\x12\x04\xdb\n\x16\x1d\n\x0e\n\x06\x04\x8d\
    \x01\x02\0\x03\x12\x04\xdb\n\x20!\n\r\n\x05\x04\x8d\x01\x02\x01\x12\x04\
    \xdc\n\x08(\n\x0e\n\x06\x04\x8d\x01\x02\x01\x04\x12\x04\xdc\n\x08\x10\n\
    \x0e\n\x06\x04\x8d\x01\x02\x01\x05\x12\x04\xdc\n\x11\x15\n\x0e\n\x06\x04\
    \x8d\x01\x02\x01\x01\x12\x04\xdc\n\x16#\n\x0e\n\x06\x04\x8d\x01\x02\x01\
    \x03\x12\x04\xdc\n&'\n\r\n\x05\x04\x8d\x01\x02\x02\x12\x04\xdd\n\x08)\n\
    \x0e\n\x06\x04\x8d\x01\x02\x02\x04\x12\x04\xdd\n\x08\x10\n\x0e\n\x06\x04\
    \x8d\x01\x02\x02\x05\x12\x04\xdd\n\x11\x15\n\x0e\n\x06\x04\x8d\x01\x02\
    \x02\x01\x12\x04\xdd\n\x16$\n\x0e\n\x06\x04\x8d\x01\x02\x02\x03\x12\x04\
    \xdd\n'(\n\r\n\x03\x04\x8e\x01\x12\x06\xe0\n\0\xe1\n\x01\n\x0c\n\x04\x04\
    \x8e\x01\x01\x12\x04\xe0\n\x08*\n\r\n\x03\x04\x8f\x01\x12\x06\xe3\n\0\
    \xf4\n\x01\n\x0c\n\x04\x04\x8f\x01\x01\x12\x04\xe3\n\x083\n\x0f\n\x05\
    \x04\x8f\x01\x03\0\x12\x06\xe4\n\x08\xf1\n\t\n\x0e\n\x06\x04\x8f\x01\x03\
    \0\x01\x12\x04\xe4\n\x10\x1f\n\x0f\n\x07\x04\x8f\x01\x03\0\x02\0\x12\x04\
    \xe5\n\x10)\n\x10\n\x08\x04\x8f\x01\x03\0\x02\0\x04\x12\x04\xe5\n\x10\
    \x18\n\x10\n\x08\x04\x8f\x01\x03\0\x02\0\x05\x12\x04\xe5\n\x19\x1f\n\x10\
    \n\x08\x04\x8f\x01\x03\0\x02\0\x01\x12\x04\xe5\n\x20$\n\x10\n\x08\x04\
    \x8f\x01\x03\0\x02\0\x03\x12\x04\xe5\n'(\n\x0f\n\x07\x04\x8f\x01\x03\0\
    \x02\x01\x12\x04\xe6\n\x10,\n\x10\n\x08\x04\x8f\x01\x03\0\x02\x01\x04\
    \x12\x04\xe6\n\x10\x18\n\x10\n\x08\x04\x8f\x01\x03\0\x02\x01\x05\x12\x04\
    \xe6\n\x19\x1f\n\x10\n\x08\x04\x8f\x01\x03\0\x02\x01\x01\x12\x04\xe6\n\
    \x20'\n\x10\n\x08\x04\x8f\x01\x03\0\x02\x01\x03\x12\x04\xe6\n*+\n\x0f\n\
    \x07\x04\x8f\x01\x03\0\x02\x02\x12\x04\xe7\n\x10.\n\x10\n\x08\x04\x8f\
    \x01\x03\0\x02\x02\x04\x12\x04\xe7\n\x10\x18\n\x10\n\x08\x04\x8f\x01\x03\
    \0\x02\x02\x05\x12\x04\xe7\n\x19\x1f\n\x10\n\x08\x04\x8f\x01\x03\0\x02\
    \x02\x01\x12\x04\xe7\n\x20)\n\x10\n\x08\x04\x8f\x01\x03\0\x02\x02\x03\
    \x12\x04\xe7\n,-\n\x0f\n\x07\x04\x8f\x01\x03\0\x02\x03\x12\x04\xe8\n\x10\
    0\n\x10\n\x08\x04\x8f\x01\x03\0\x02\x03\x04\x12\x04\xe8\n\x10\x18\n\x10\
    \n\x08\x04\x8f\x01\x03\0\x02\x03\x05\x12\x04\xe8\n\x19\x1f\n\x10\n\x08\
    \x04\x8f\x01\x03\0\x02\x03\x01\x12\x04\xe8\n\x20+\n\x10\n\x08\x04\x8f\
    \x01\x03\0\x02\x03\x03\x12\x04\xe8\n./\n\x0f\n\x07\x04\x8f\x01\x03\0\x02\
    \x04\x12\x04\xe9\n\x10.\n\x10\n\x08\x04\x8f\x01\x03\0\x02\x04\x04\x12\
    \x04\xe9\n\x10\x18\n\x10\n\x08\x04\x8f\x01\x03\0\x02\x04\x05\x12\x04\xe9\
    \n\x19\x1f\n\x10\n\x08\x04\x8f\x01\x03\0\x02\x04\x01\x12\x04\xe9\n\x20)\
    \n\x10\n\x08\x04\x8f\x01\x03\0\x02\x04\x03\x12\x04\xe9\n,-\n\x0f\n\x07\
    \x04\x8f\x01\x03\0\x02\x05\x12\x04\xea\n\x100\n\x10\n\x08\x04\x8f\x01\
    \x03\0\x02\x05\x04\x12\x04\xea\n\x10\x18\n\x10\n\x08\x04\x8f\x01\x03\0\
    \x02\x05\x05\x12\x04\xea\n\x19\x1f\n\x10\n\x08\x04\x8f\x01\x03\0\x02\x05\
    \x01\x12\x04\xea\n\x20+\n\x10\n\x08\x04\x8f\x01\x03\0\x02\x05\x03\x12\
    \x04\xea\n./\n\x0f\n\x07\x04\x8f\x01\x03\0\x02\x06\x12\x04\xeb\n\x10/\n\
    \x10\n\x08\x04\x8f\x01\x03\0\x02\x06\x04\x12\x04\xeb\n\x10\x18\n\x10\n\
    \x08\x04\x8f\x01\x03\0\x02\x06\x05\x12\x04\xeb\n\x19\x1f\n\x10\n\x08\x04\
    \x8f\x01\x03\0\x02\x06\x01\x12\x04\xeb\n\x20*\n\x10\n\x08\x04\x8f\x01\
    \x03\0\x02\x06\x03\x12\x04\xeb\n-.\n\x0f\n\x07\x04\x8f\x01\x03\0\x02\x07\
    \x12\x04\xec\n\x101\n\x10\n\x08\x04\x8f\x01\x03\0\x02\x07\x04\x12\x04\
    \xec\n\x10\x18\n\x10\n\x08\x04\x8f\x01\x03\0\x02\x07\x05\x12\x04\xec\n\
    \x19\x1f\n\x10\n\x08\x04\x8f\x01\x03\0\x02\x07\x01\x12\x04\xec\n\x20,\n\
    \x10\n\x08\x04\x8f\x01\x03\0\x02\x07\x03\x12\x04\xec\n/0\n\x0f\n\x07\x04\
    \x8f\x01\x03\0\x02\x08\x12\x04\xed\n\x100\n\x10\n\x08\x04\x8f\x01\x03\0\
    \x02\x08\x04\x12\x04\xed\n\x10\x18\n\x10\n\x08\x04\x8f\x01\x03\0\x02\x08\
    \x05\x12\x04\xed\n\x19\x1f\n\x10\n\x08\x04\x8f\x01\x03\0\x02\x08\x01\x12\
    \x04\xed\n\x20+\n\x10\n\x08\x04\x8f\x01\x03\0\x02\x08\x03\x12\x04\xed\n.\
    /\n\x0f\n\x07\x04\x8f\x01\x03\0\x02\t\x12\x04\xee\n\x103\n\x10\n\x08\x04\
    \x8f\x01\x03\0\x02\t\x04\x12\x04\xee\n\x10\x18\n\x10\n\x08\x04\x8f\x01\
    \x03\0\x02\t\x05\x12\x04\xee\n\x19\x1f\n\x10\n\x08\x04\x8f\x01\x03\0\x02\
    \t\x01\x12\x04\xee\n\x20-\n\x10\n\x08\x04\x8f\x01\x03\0\x02\t\x03\x12\
    \x04\xee\n02\n\x0f\n\x07\x04\x8f\x01\x03\0\x02\n\x12\x04\xef\n\x101\n\
    \x10\n\x08\x04\x8f\x01\x03\0\x02\n\x04\x12\x04\xef\n\x10\x18\n\x10\n\x08\
    \x04\x8f\x01\x03\0\x02\n\x05\x12\x04\xef\n\x19\x1f\n\x10\n\x08\x04\x8f\
    \x01\x03\0\x02\n\x01\x12\x04\xef\n\x20+\n\x10\n\x08\x04\x8f\x01\x03\0\
    \x02\n\x03\x12\x04\xef\n.0\n\x0f\n\x07\x04\x8f\x01\x03\0\x02\x0b\x12\x04\
    \xf0\n\x103\n\x10\n\x08\x04\x8f\x01\x03\0\x02\x0b\x04\x12\x04\xf0\n\x10\
    \x18\n\x10\n\x08\x04\x8f\x01\x03\0\x02\x0b\x05\x12\x04\xf0\n\x19\x1f\n\
    \x10\n\x08\x04\x8f\x01\x03\0\x02\x0b\x01\x12\x04\xf0\n\x20-\n\x10\n\x08\
    \x04\x8f\x01\x03\0\x02\x0b\x03\x12\x04\xf0\n02\n\r\n\x05\x04\x8f\x01\x02\
    \0\x12\x04\xf3\n\x08[\n\x0e\n\x06\x04\x8f\x01\x02\0\x04\x12\x04\xf3\n\
    \x08\x10\n\x0e\n\x06\x04\x8f\x01\x02\0\x06\x12\x04\xf3\n\x11M\n\x0e\n\
    \x06\x04\x8f\x01\x02\0\x01\x12\x04\xf3\nNV\n\x0e\n\x06\x04\x8f\x01\x02\0\
    \x03\x12\x04\xf3\nYZ\n\r\n\x03\x04\x90\x01\x12\x06\xf6\n\0\x82\x0b\x01\n\
    \x0c\n\x04\x04\x90\x01\x01\x12\x04\xf6\n\x08\x1b\n\x0f\n\x05\x04\x90\x01\
    \x04\0\x12\x06\xf7\n\x08\xfe\n\t\n\x0e\n\x06\x04\x90\x01\x04\0\x01\x12\
    \x04\xf7\n\r\x14\n\x0f\n\x07\x04\x90\x01\x04\0\x02\0\x12\x04\xf8\n\x10$\
    \n\x10\n\x08\x04\x90\x01\x04\0\x02\0\x01\x12\x04\xf8\n\x10\x1f\n\x10\n\
    \x08\x04\x90\x01\x04\0\x02\0\x02\x12\x04\xf8\n\"#\n\x0f\n\x07\x04\x90\
    \x01\x04\0\x02\x01\x12\x04\xf9\n\x10%\n\x10\n\x08\x04\x90\x01\x04\0\x02\
    \x01\x01\x12\x04\xf9\n\x10\x20\n\x10\n\x08\x04\x90\x01\x04\0\x02\x01\x02\
    \x12\x04\xf9\n#$\n\x0f\n\x07\x04\x90\x01\x04\0\x02\x02\x12\x04\xfa\n\x10\
    !\n\x10\n\x08\x04\x90\x01\x04\0\x02\x02\x01\x12\x04\xfa\n\x10\x1c\n\x10\
    \n\x08\x04\x90\x01\x04\0\x02\x02\x02\x12\x04\xfa\n\x1f\x20\n\x0f\n\x07\
    \x04\x90\x01\x04\0\x02\x03\x12\x04\xfb\n\x10'\n\x10\n\x08\x04\x90\x01\
    \x04\0\x02\x03\x01\x12\x04\xfb\n\x10\"\n\x10\n\x08\x04\x90\x01\x04\0\x02\
    \x03\x02\x12\x04\xfb\n%&\n\x0f\n\x07\x04\x90\x01\x04\0\x02\x04\x12\x04\
    \xfc\n\x10%\n\x10\n\x08\x04\x90\x01\x04\0\x02\x04\x01\x12\x04\xfc\n\x10\
    \x20\n\x10\n\x08\x04\x90\x01\x04\0\x02\x04\x02\x12\x04\xfc\n#$\n\x0f\n\
    \x07\x04\x90\x01\x04\0\x02\x05\x12\x04\xfd\n\x10\"\n\x10\n\x08\x04\x90\
    \x01\x04\0\x02\x05\x01\x12\x04\xfd\n\x10\x1d\n\x10\n\x08\x04\x90\x01\x04\
    \0\x02\x05\x02\x12\x04\xfd\n\x20!\n\r\n\x05\x04\x90\x01\x02\0\x12\x04\
    \x80\x0b\x08.\n\x0e\n\x06\x04\x90\x01\x02\0\x04\x12\x04\x80\x0b\x08\x10\
    \n\x0e\n\x06\x04\x90\x01\x02\0\x05\x12\x04\x80\x0b\x11\x17\n\x0e\n\x06\
    \x04\x90\x01\x02\0\x01\x12\x04\x80\x0b\x18)\n\x0e\n\x06\x04\x90\x01\x02\
    \0\x03\x12\x04\x80\x0b,-\n\r\n\x05\x04\x90\x01\x02\x01\x12\x04\x81\x0b\
    \x08U\n\x0e\n\x06\x04\x90\x01\x02\x01\x04\x12\x04\x81\x0b\x08\x10\n\x0e\
    \n\x06\x04\x90\x01\x02\x01\x06\x12\x04\x81\x0b\x11-\n\x0e\n\x06\x04\x90\
    \x01\x02\x01\x01\x12\x04\x81\x0b.4\n\x0e\n\x06\x04\x90\x01\x02\x01\x03\
    \x12\x04\x81\x0b78\n\x0e\n\x06\x04\x90\x01\x02\x01\x08\x12\x04\x81\x0b9T\
    \n\x0e\n\x06\x04\x90\x01\x02\x01\x07\x12\x04\x81\x0bDS\n\r\n\x03\x04\x91\
    \x01\x12\x06\x84\x0b\0\xa0\x0b\x01\n\x0c\n\x04\x04\x91\x01\x01\x12\x04\
    \x84\x0b\x08#\n\r\n\x05\x04\x91\x01\x02\0\x12\x04\x85\x0b\x08:\n\x0e\n\
    \x06\x04\x91\x01\x02\0\x04\x12\x04\x85\x0b\x08\x10\n\x0e\n\x06\x04\x91\
    \x01\x02\0\x05\x12\x04\x85\x0b\x11\x17\n\x0e\n\x06\x04\x91\x01\x02\0\x01\
    \x12\x04\x85\x0b\x18\x20\n\x0e\n\x06\x04\x91\x01\x02\0\x03\x12\x04\x85\
    \x0b#$\n\x0e\n\x06\x04\x91\x01\x02\0\x08\x12\x04\x85\x0b%9\n\x11\n\t\x04\
    \x91\x01\x02\0\x08\xe0\xd4\x03\x12\x04\x85\x0b&8\n\r\n\x05\x04\x91\x01\
    \x02\x01\x12\x04\x86\x0b\x08<\n\x0e\n\x06\x04\x91\x01\x02\x01\x04\x12\
    \x04\x86\x0b\x08\x10\n\x0e\n\x06\x04\x91\x01\x02\x01\x05\x12\x04\x86\x0b\
    \x11\x17\n\x0e\n\x06\x04\x91\x01\x02\x01\x01\x12\x04\x86\x0b\x18\"\n\x0e\
    \n\x06\x04\x91\x01\x02\x01\x03\x12\x04\x86\x0b%&\n\x0e\n\x06\x04\x91\x01\
    \x02\x01\x08\x12\x04\x86\x0b';\n\x11\n\t\x04\x91\x01\x02\x01\x08\xe0\xd4\
    \x03\x12\x04\x86\x0b(:\n\r\n\x05\x04\x91\x01\x02\x02\x12\x04\x87\x0b\x08\
    <\n\x0e\n\x06\x04\x91\x01\x02\x02\x04\x12\x04\x87\x0b\x08\x10\n\x0e\n\
    \x06\x04\x91\x01\x02\x02\x05\x12\x04\x87\x0b\x11\x16\n\x0e\n\x06\x04\x91\
    \x01\x02\x02\x01\x12\x04\x87\x0b\x17\"\n\x0e\n\x06\x04\x91\x01\x02\x02\
    \x03\x12\x04\x87\x0b%&\n\x0e\n\x06\x04\x91\x01\x02\x02\x08\x12\x04\x87\
    \x0b';\n\x11\n\t\x04\x91\x01\x02\x02\x08\xe0\xd4\x03\x12\x04\x87\x0b(:\n\
    \r\n\x05\x04\x91\x01\x02\x03\x12\x04\x88\x0b\x08$\n\x0e\n\x06\x04\x91\
    \x01\x02\x03\x04\x12\x04\x88\x0b\x08\x10\n\x0e\n\x06\x04\x91\x01\x02\x03\
    \x05\x12\x04\x88\x0b\x11\x17\n\x0e\n\x06\x04\x91\x01\x02\x03\x01\x12\x04\
    \x88\x0b\x18\x1f\n\x0e\n\x06\x04\x91\x01\x02\x03\x03\x12\x04\x88\x0b\"#\
    \n\r\n\x05\x04\x91\x01\x02\x04\x12\x04\x89\x0b\x08&\n\x0e\n\x06\x04\x91\
    \x01\x02\x04\x04\x12\x04\x89\x0b\x08\x10\n\x0e\n\x06\x04\x91\x01\x02\x04\
    \x05\x12\x04\x89\x0b\x11\x17\n\x0e\n\x06\x04\x91\x01\x02\x04\x01\x12\x04\
    \x89\x0b\x18!\n\x0e\n\x06\x04\x91\x01\x02\x04\x03\x12\x04\x89\x0b$%\n\r\
    \n\x05\x04\x91\x01\x02\x05\x12\x04\x8a\x0b\x08#\n\x0e\n\x06\x04\x91\x01\
    \x02\x05\x04\x12\x04\x8a\x0b\x08\x10\n\x0e\n\x06\x04\x91\x01\x02\x05\x05\
    \x12\x04\x8a\x0b\x11\x17\n\x0e\n\x06\x04\x91\x01\x02\x05\x01\x12\x04\x8a\
    \x0b\x18\x1e\n\x0e\n\x06\x04\x91\x01\x02\x05\x03\x12\x04\x8a\x0b!\"\n\r\
    \n\x05\x04\x91\x01\x02\x06\x12\x04\x8b\x0b\x08.\n\x0e\n\x06\x04\x91\x01\
    \x02\x06\x04\x12\x04\x8b\x0b\x08\x10\n\x0e\n\x06\x04\x91\x01\x02\x06\x05\
    \x12\x04\x8b\x0b\x11\x17\n\x0e\n\x06\x04\x91\x01\x02\x06\x01\x12\x04\x8b\
    \x0b\x18)\n\x0e\n\x06\x04\x91\x01\x02\x06\x03\x12\x04\x8b\x0b,-\n\r\n\
    \x05\x04\x91\x01\x02\x07\x12\x04\x8c\x0b\x08!\n\x0e\n\x06\x04\x91\x01\
    \x02\x07\x04\x12\x04\x8c\x0b\x08\x10\n\x0e\n\x06\x04\x91\x01\x02\x07\x05\
    \x12\x04\x8c\x0b\x11\x17\n\x0e\n\x06\x04\x91\x01\x02\x07\x01\x12\x04\x8c\
    \x0b\x18\x1c\n\x0e\n\x06\x04\x91\x01\x02\x07\x03\x12\x04\x8c\x0b\x1f\x20\
    \n\r\n\x05\x04\x91\x01\x02\x08\x12\x04\x8d\x0b\x08\"\n\x0e\n\x06\x04\x91\
    \x01\x02\x08\x04\x12\x04\x8d\x0b\x08\x10\n\x0e\n\x06\x04\x91\x01\x02\x08\
    \x05\x12\x04\x8d\x0b\x11\x17\n\x0e\n\x06\x04\x91\x01\x02\x08\x01\x12\x04\
    \x8d\x0b\x18\x1d\n\x0e\n\x06\x04\x91\x01\x02\x08\x03\x12\x04\x8d\x0b\x20\
    !\n\r\n\x05\x04\x91\x01\x02\t\x12\x04\x8e\x0b\x08\"\n\x0e\n\x06\x04\x91\
    \x01\x02\t\x04\x12\x04\x8e\x0b\x08\x10\n\x0e\n\x06\x04\x91\x01\x02\t\x05\
    \x12\x04\x8e\x0b\x11\x17\n\x0e\n\x06\x04\x91\x01\x02\t\x01\x12\x04\x8e\
    \x0b\x18\x1c\n\x0e\n\x06\x04\x91\x01\x02\t\x03\x12\x04\x8e\x0b\x1f!\n\r\
    \n\x05\x04\x91\x01\x02\n\x12\x04\x8f\x0b\x08#\n\x0e\n\x06\x04\x91\x01\
    \x02\n\x04\x12\x04\x8f\x0b\x08\x10\n\x0e\n\x06\x04\x91\x01\x02\n\x05\x12\
    \x04\x8f\x0b\x11\x17\n\x0e\n\x06\x04\x91\x01\x02\n\x01\x12\x04\x8f\x0b\
    \x18\x1d\n\x0e\n\x06\x04\x91\x01\x02\n\x03\x12\x04\x8f\x0b\x20\"\n\r\n\
    \x05\x04\x91\x01\x02\x0b\x12\x04\x90\x0b\x08,\n\x0e\n\x06\x04\x91\x01\
    \x02\x0b\x04\x12\x04\x90\x0b\x08\x10\n\x0e\n\x06\x04\x91\x01\x02\x0b\x05\
    \x12\x04\x90\x0b\x11\x17\n\x0e\n\x06\x04\x91\x01\x02\x0b\x01\x12\x04\x90\
    \x0b\x18&\n\x0e\n\x06\x04\x91\x01\x02\x0b\x03\x12\x04\x90\x0b)+\n\r\n\
    \x05\x04\x91\x01\x02\x0c\x12\x04\x91\x0b\x082\n\x0e\n\x06\x04\x91\x01\
    \x02\x0c\x04\x12\x04\x91\x0b\x08\x10\n\x0e\n\x06\x04\x91\x01\x02\x0c\x05\
    \x12\x04\x91\x0b\x11\x16\n\x0e\n\x06\x04\x91\x01\x02\x0c\x01\x12\x04\x91\
    \x0b\x17,\n\x0e\n\x06\x04\x91\x01\x02\x0c\x03\x12\x04\x91\x0b/1\n\r\n\
    \x05\x04\x91\x01\x02\r\x12\x04\x92\x0b\x08\"\n\x0e\n\x06\x04\x91\x01\x02\
    \r\x04\x12\x04\x92\x0b\x08\x10\n\x0e\n\x06\x04\x91\x01\x02\r\x05\x12\x04\
    \x92\x0b\x11\x17\n\x0e\n\x06\x04\x91\x01\x02\r\x01\x12\x04\x92\x0b\x18\
    \x1c\n\x0e\n\x06\x04\x91\x01\x02\r\x03\x12\x04\x92\x0b\x1f!\n\r\n\x05\
    \x04\x91\x01\x02\x0e\x12\x04\x93\x0b\x08,\n\x0e\n\x06\x04\x91\x01\x02\
    \x0e\x04\x12\x04\x93\x0b\x08\x10\n\x0e\n\x06\x04\x91\x01\x02\x0e\x05\x12\
    \x04\x93\x0b\x11\x17\n\x0e\n\x06\x04\x91\x01\x02\x0e\x01\x12\x04\x93\x0b\
    \x18&\n\x0e\n\x06\x04\x91\x01\x02\x0e\x03\x12\x04\x93\x0b)+\n\r\n\x05\
    \x04\x91\x01\x02\x0f\x12\x04\x94\x0b\x08#\n\x0e\n\x06\x04\x91\x01\x02\
    \x0f\x04\x12\x04\x94\x0b\x08\x10\n\x0e\n\x06\x04\x91\x01\x02\x0f\x05\x12\
    \x04\x94\x0b\x11\x17\n\x0e\n\x06\x04\x91\x01\x02\x0f\x01\x12\x04\x94\x0b\
    \x18\x1d\n\x0e\n\x06\x04\x91\x01\x02\x0f\x03\x12\x04\x94\x0b\x20\"\n\r\n\
    \x05\x04\x91\x01\x02\x10\x12\x04\x95\x0b\x08$\n\x0e\n\x06\x04\x91\x01\
    \x02\x10\x04\x12\x04\x95\x0b\x08\x10\n\x0e\n\x06\x04\x91\x01\x02\x10\x05\
    \x12\x04\x95\x0b\x11\x17\n\x0e\n\x06\x04\x91\x01\x02\x10\x01\x12\x04\x95\
    \x0b\x18\x1e\n\x0e\n\x06\x04\x91\x01\x02\x10\x03\x12\x04\x95\x0b!#\n\r\n\
    \x05\x04\x91\x01\x02\x11\x12\x04\x96\x0b\x08$\n\x0e\n\x06\x04\x91\x01\
    \x02\x11\x04\x12\x04\x96\x0b\x08\x10\n\x0e\n\x06\x04\x91\x01\x02\x11\x05\
    \x12\x04\x96\x0b\x11\x17\n\x0e\n\x06\x04\x91\x01\x02\x11\x01\x12\x04\x96\
    \x0b\x18\x1e\n\x0e\n\x06\x04\x91\x01\x02\x11\x03\x12\x04\x96\x0b!#\n\r\n\
    \x05\x04\x91\x01\x02\x12\x12\x04\x97\x0b\x08%\n\x0e\n\x06\x04\x91\x01\
    \x02\x12\x04\x12\x04\x97\x0b\x08\x10\n\x0e\n\x06\x04\x91\x01\x02\x12\x05\
    \x12\x04\x97\x0b\x11\x17\n\x0e\n\x06\x04\x91\x01\x02\x12\x01\x12\x04\x97\
    \x0b\x18\x1f\n\x0e\n\x06\x04\x91\x01\x02\x12\x03\x12\x04\x97\x0b\"$\n\r\
    \n\x05\x04\x91\x01\x02\x13\x12\x04\x98\x0b\x08%\n\x0e\n\x06\x04\x91\x01\
    \x02\x13\x04\x12\x04\x98\x0b\x08\x10\n\x0e\n\x06\x04\x91\x01\x02\x13\x05\
    \x12\x04\x98\x0b\x11\x17\n\x0e\n\x06\x04\x91\x01\x02\x13\x01\x12\x04\x98\
    \x0b\x18\x1f\n\x0e\n\x06\x04\x91\x01\x02\x13\x03\x12\x04\x98\x0b\"$\n\r\
    \n\x05\x04\x91\x01\x02\x14\x12\x04\x99\x0b\x08)\n\x0e\n\x06\x04\x91\x01\
    \x02\x14\x04\x12\x04\x99\x0b\x08\x10\n\x0e\n\x06\x04\x91\x01\x02\x14\x05\
    \x12\x04\x99\x0b\x11\x17\n\x0e\n\x06\x04\x91\x01\x02\x14\x01\x12\x04\x99\
    \x0b\x18#\n\x0e\n\x06\x04\x91\x01\x02\x14\x03\x12\x04\x99\x0b&(\n\r\n\
    \x05\x04\x91\x01\x02\x15\x12\x04\x9a\x0b\x08)\n\x0e\n\x06\x04\x91\x01\
    \x02\x15\x04\x12\x04\x9a\x0b\x08\x10\n\x0e\n\x06\x04\x91\x01\x02\x15\x05\
    \x12\x04\x9a\x0b\x11\x17\n\x0e\n\x06\x04\x91\x01\x02\x15\x01\x12\x04\x9a\
    \x0b\x18#\n\x0e\n\x06\x04\x91\x01\x02\x15\x03\x12\x04\x9a\x0b&(\n\r\n\
    \x05\x04\x91\x01\x02\x16\x12\x04\x9b\x0b\x08*\n\x0e\n\x06\x04\x91\x01\
    \x02\x16\x04\x12\x04\x9b\x0b\x08\x10\n\x0e\n\x06\x04\x91\x01\x02\x16\x05\
    \x12\x04\x9b\x0b\x11\x17\n\x0e\n\x06\x04\x91\x01\x02\x16\x01\x12\x04\x9b\
    \x0b\x18$\n\x0e\n\x06\x04\x91\x01\x02\x16\x03\x12\x04\x9b\x0b')\n\r\n\
    \x05\x04\x91\x01\x02\x17\x12\x04\x9c\x0b\x08+\n\x0e\n\x06\x04\x91\x01\
    \x02\x17\x04\x12\x04\x9c\x0b\x08\x10\n\x0e\n\x06\x04\x91\x01\x02\x17\x05\
    \x12\x04\x9c\x0b\x11\x17\n\x0e\n\x06\x04\x91\x01\x02\x17\x01\x12\x04\x9c\
    \x0b\x18%\n\x0e\n\x06\x04\x91\x01\x02\x17\x03\x12\x04\x9c\x0b(*\n\r\n\
    \x05\x04\x91\x01\x02\x18\x12\x04\x9d\x0b\x08+\n\x0e\n\x06\x04\x91\x01\
    \x02\x18\x04\x12\x04\x9d\x0b\x08\x10\n\x0e\n\x06\x04\x91\x01\x02\x18\x05\
    \x12\x04\x9d\x0b\x11\x17\n\x0e\n\x06\x04\x91\x01\x02\x18\x01\x12\x04\x9d\
    \x0b\x18%\n\x0e\n\x06\x04\x91\x01\x02\x18\x03\x12\x04\x9d\x0b(*\n\r\n\
    \x05\x04\x91\x01\x02\x19\x12\x04\x9e\x0b\x08'\n\x0e\n\x06\x04\x91\x01\
    \x02\x19\x04\x12\x04\x9e\x0b\x08\x10\n\x0e\n\x06\x04\x91\x01\x02\x19\x05\
    \x12\x04\x9e\x0b\x11\x17\n\x0e\n\x06\x04\x91\x01\x02\x19\x01\x12\x04\x9e\
    \x0b\x18!\n\x0e\n\x06\x04\x91\x01\x02\x19\x03\x12\x04\x9e\x0b$&\n\r\n\
    \x05\x04\x91\x01\x02\x1a\x12\x04\x9f\x0b\x08*\n\x0e\n\x06\x04\x91\x01\
    \x02\x1a\x04\x12\x04\x9f\x0b\x08\x10\n\x0e\n\x06\x04\x91\x01\x02\x1a\x05\
    \x12\x04\x9f\x0b\x11\x17\n\x0e\n\x06\x04\x91\x01\x02\x1a\x01\x12\x04\x9f\
    \x0b\x18$\n\x0e\n\x06\x04\x91\x01\x02\x1a\x03\x12\x04\x9f\x0b')\n\r\n\
    \x03\x04\x92\x01\x12\x06\xa2\x0b\0\xa3\x0b\x01\n\x0c\n\x04\x04\x92\x01\
    \x01\x12\x04\xa2\x0b\x08$\n\r\n\x03\x04\x93\x01\x12\x06\xa5\x0b\0\xa8\
    \x0b\x01\n\x0c\n\x04\x04\x93\x01\x01\x12\x04\xa5\x0b\x08\"\n\r\n\x05\x04\
    \x93\x01\x02\0\x12\x04\xa6\x0b\x08!\n\x0e\n\x06\x04\x93\x01\x02\0\x04\
    \x12\x04\xa6\x0b\x08\x10\n\x0e\n\x06\x04\x93\x01\x02\0\x05\x12\x04\xa6\
    \x0b\x11\x17\n\x0e\n\x06\x04\x93\x01\x02\0\x01\x12\x04\xa6\x0b\x18\x1c\n\
    \x0e\n\x06\x04\x93\x01\x02\0\x03\x12\x04\xa6\x0b\x1f\x20\n\r\n\x05\x04\
    \x93\x01\x02\x01\x12\x04\xa7\x0b\x08(\n\x0e\n\x06\x04\x93\x01\x02\x01\
    \x04\x12\x04\xa7\x0b\x08\x10\n\x0e\n\x06\x04\x93\x01\x02\x01\x05\x12\x04\
    \xa7\x0b\x11\x16\n\x0e\n\x06\x04\x93\x01\x02\x01\x01\x12\x04\xa7\x0b\x17\
    #\n\x0e\n\x06\x04\x93\x01\x02\x01\x03\x12\x04\xa7\x0b&'\n\r\n\x03\x04\
    \x94\x01\x12\x06\xaa\x0b\0\xac\x0b\x01\n\x0c\n\x04\x04\x94\x01\x01\x12\
    \x04\xaa\x0b\x08,\n\r\n\x05\x04\x94\x01\x02\0\x12\x04\xab\x0b\x08H\n\x0e\
    \n\x06\x04\x94\x01\x02\0\x04\x12\x04\xab\x0b\x08\x10\n\x0e\n\x06\x04\x94\
    \x01\x02\0\x06\x12\x04\xab\x0b\x11,\n\x0e\n\x06\x04\x94\x01\x02\0\x01\
    \x12\x04\xab\x0b-C\n\x0e\n\x06\x04\x94\x01\x02\0\x03\x12\x04\xab\x0bFG\n\
    \r\n\x03\x04\x95\x01\x12\x06\xae\x0b\0\xb1\x0b\x01\n\x0c\n\x04\x04\x95\
    \x01\x01\x12\x04\xae\x0b\x08%\n\r\n\x05\x04\x95\x01\x02\0\x12\x04\xaf\
    \x0b\x08&\n\x0e\n\x06\x04\x95\x01\x02\0\x04\x12\x04\xaf\x0b\x08\x10\n\
    \x0e\n\x06\x04\x95\x01\x02\0\x05\x12\x04\xaf\x0b\x11\x17\n\x0e\n\x06\x04\
    \x95\x01\x02\0\x01\x12\x04\xaf\x0b\x18!\n\x0e\n\x06\x04\x95\x01\x02\0\
    \x03\x12\x04\xaf\x0b$%\n\r\n\x05\x04\x95\x01\x02\x01\x12\x04\xb0\x0b\x08\
    ]\n\x0e\n\x06\x04\x95\x01\x02\x01\x04\x12\x04\xb0\x0b\x08\x10\n\x0e\n\
    \x06\x04\x95\x01\x02\x01\x06\x12\x04\xb0\x0b\x116\n\x0e\n\x06\x04\x95\
    \x01\x02\x01\x01\x12\x04\xb0\x0b7X\n\x0e\n\x06\x04\x95\x01\x02\x01\x03\
    \x12\x04\xb0\x0b[\\\n\r\n\x03\x04\x96\x01\x12\x06\xb3\x0b\0\xb5\x0b\x01\
    \n\x0c\n\x04\x04\x96\x01\x01\x12\x04\xb3\x0b\x08\x1e\n\r\n\x05\x04\x96\
    \x01\x02\0\x12\x04\xb4\x0b\x08T\n\x0e\n\x06\x04\x96\x01\x02\0\x04\x12\
    \x04\xb4\x0b\x08\x10\n\x0e\n\x06\x04\x96\x01\x02\0\x06\x12\x04\xb4\x0b\
    \x11\x1f\n\x0e\n\x06\x04\x96\x01\x02\0\x01\x12\x04\xb4\x0b\x20+\n\x0e\n\
    \x06\x04\x96\x01\x02\0\x03\x12\x04\xb4\x0b./\n\x0e\n\x06\x04\x96\x01\x02\
    \0\x08\x12\x04\xb4\x0b0S\n\x0e\n\x06\x04\x96\x01\x02\0\x07\x12\x04\xb4\
    \x0b;R\n\r\n\x03\x04\x97\x01\x12\x06\xb7\x0b\0\xc6\x0b\x01\n\x0c\n\x04\
    \x04\x97\x01\x01\x12\x04\xb7\x0b\x08#\n\x0f\n\x05\x04\x97\x01\x03\0\x12\
    \x06\xb8\x0b\x08\xbc\x0b\t\n\x0e\n\x06\x04\x97\x01\x03\0\x01\x12\x04\xb8\
    \x0b\x10\x19\n\x0f\n\x07\x04\x97\x01\x03\0\x02\0\x12\x04\xb9\x0b\x10)\n\
    \x10\n\x08\x04\x97\x01\x03\0\x02\0\x04\x12\x04\xb9\x0b\x10\x18\n\x10\n\
    \x08\x04\x97\x01\x03\0\x02\0\x05\x12\x04\xb9\x0b\x19\x1f\n\x10\n\x08\x04\
    \x97\x01\x03\0\x02\0\x01\x12\x04\xb9\x0b\x20$\n\x10\n\x08\x04\x97\x01\
    \x03\0\x02\0\x03\x12\x04\xb9\x0b'(\n\x0f\n\x07\x04\x97\x01\x03\0\x02\x01\
    \x12\x04\xba\x0b\x10)\n\x10\n\x08\x04\x97\x01\x03\0\x02\x01\x04\x12\x04\
    \xba\x0b\x10\x18\n\x10\n\x08\x04\x97\x01\x03\0\x02\x01\x05\x12\x04\xba\
    \x0b\x19\x1f\n\x10\n\x08\x04\x97\x01\x03\0\x02\x01\x01\x12\x04\xba\x0b\
    \x20$\n\x10\n\x08\x04\x97\x01\x03\0\x02\x01\x03\x12\x04\xba\x0b'(\n\x0f\
    \n\x07\x04\x97\x01\x03\0\x02\x02\x12\x04\xbb\x0b\x10`\n\x10\n\x08\x04\
    \x97\x01\x03\0\x02\x02\x04\x12\x04\xbb\x0b\x10\x18\n\x10\n\x08\x04\x97\
    \x01\x03\0\x02\x02\x06\x12\x04\xbb\x0b\x19<\n\x10\n\x08\x04\x97\x01\x03\
    \0\x02\x02\x01\x12\x04\xbb\x0b=H\n\x10\n\x08\x04\x97\x01\x03\0\x02\x02\
    \x03\x12\x04\xbb\x0bKL\n\x10\n\x08\x04\x97\x01\x03\0\x02\x02\x08\x12\x04\
    \xbb\x0bM_\n\x10\n\x08\x04\x97\x01\x03\0\x02\x02\x07\x12\x04\xbb\x0bX^\n\
    \x0f\n\x05\x04\x97\x01\x04\0\x12\x06\xbe\x0b\x08\xc3\x0b\t\n\x0e\n\x06\
    \x04\x97\x01\x04\0\x01\x12\x04\xbe\x0b\r\x13\n\x0f\n\x07\x04\x97\x01\x04\
    \0\x02\0\x12\x04\xbf\x0b\x10\x1c\n\x10\n\x08\x04\x97\x01\x04\0\x02\0\x01\
    \x12\x04\xbf\x0b\x10\x17\n\x10\n\x08\x04\x97\x01\x04\0\x02\0\x02\x12\x04\
    \xbf\x0b\x1a\x1b\n\x0f\n\x07\x04\x97\x01\x04\0\x02\x01\x12\x04\xc0\x0b\
    \x10\x1b\n\x10\n\x08\x04\x97\x01\x04\0\x02\x01\x01\x12\x04\xc0\x0b\x10\
    \x16\n\x10\n\x08\x04\x97\x01\x04\0\x02\x01\x02\x12\x04\xc0\x0b\x19\x1a\n\
    \x0f\n\x07\x04\x97\x01\x04\0\x02\x02\x12\x04\xc1\x0b\x10\x20\n\x10\n\x08\
    \x04\x97\x01\x04\0\x02\x02\x01\x12\x04\xc1\x0b\x10\x1b\n\x10\n\x08\x04\
    \x97\x01\x04\0\x02\x02\x02\x12\x04\xc1\x0b\x1e\x1f\n\x0f\n\x07\x04\x97\
    \x01\x04\0\x02\x03\x12\x04\xc2\x0b\x10%\n\x10\n\x08\x04\x97\x01\x04\0\
    \x02\x03\x01\x12\x04\xc2\x0b\x10\x20\n\x10\n\x08\x04\x97\x01\x04\0\x02\
    \x03\x02\x12\x04\xc2\x0b#$\n\r\n\x05\x04\x97\x01\x02\0\x12\x04\xc5\x0b\
    \x08E\n\x0e\n\x06\x04\x97\x01\x02\0\x04\x12\x04\xc5\x0b\x08\x10\n\x0e\n\
    \x06\x04\x97\x01\x02\0\x06\x12\x04\xc5\x0b\x117\n\x0e\n\x06\x04\x97\x01\
    \x02\0\x01\x12\x04\xc5\x0b8@\n\x0e\n\x06\x04\x97\x01\x02\0\x03\x12\x04\
    \xc5\x0bCD\n\r\n\x03\x04\x98\x01\x12\x06\xc8\x0b\0\xca\x0b\x01\n\x0c\n\
    \x04\x04\x98\x01\x01\x12\x04\xc8\x0b\x08\"\n\r\n\x05\x04\x98\x01\x02\0\
    \x12\x04\xc9\x0b\x08%\n\x0e\n\x06\x04\x98\x01\x02\0\x04\x12\x04\xc9\x0b\
    \x08\x10\n\x0e\n\x06\x04\x98\x01\x02\0\x05\x12\x04\xc9\x0b\x11\x17\n\x0e\
    \n\x06\x04\x98\x01\x02\0\x01\x12\x04\xc9\x0b\x18\x20\n\x0e\n\x06\x04\x98\
    \x01\x02\0\x03\x12\x04\xc9\x0b#$\n\r\n\x03\x04\x99\x01\x12\x06\xcc\x0b\0\
    \xcf\x0b\x01\n\x0c\n\x04\x04\x99\x01\x01\x12\x04\xcc\x0b\x08\x1b\n\r\n\
    \x05\x04\x99\x01\x02\0\x12\x04\xcd\x0b\x08Z\n\x0e\n\x06\x04\x99\x01\x02\
    \0\x04\x12\x04\xcd\x0b\x08\x10\n\x0e\n\x06\x04\x99\x01\x02\0\x06\x12\x04\
    \xcd\x0b\x11$\n\x0e\n\x06\x04\x99\x01\x02\0\x01\x12\x04\xcd\x0b%2\n\x0e\
    \n\x06\x04\x99\x01\x02\0\x03\x12\x04\xcd\x0b56\n\x0e\n\x06\x04\x99\x01\
    \x02\0\x08\x12\x04\xcd\x0b7Y\n\x0e\n\x06\x04\x99\x01\x02\0\x07\x12\x04\
    \xcd\x0bBX\n\r\n\x05\x04\x99\x01\x02\x01\x12\x04\xce\x0b\x08%\n\x0e\n\
    \x06\x04\x99\x01\x02\x01\x04\x12\x04\xce\x0b\x08\x10\n\x0e\n\x06\x04\x99\
    \x01\x02\x01\x05\x12\x04\xce\x0b\x11\x17\n\x0e\n\x06\x04\x99\x01\x02\x01\
    \x01\x12\x04\xce\x0b\x18\x20\n\x0e\n\x06\x04\x99\x01\x02\x01\x03\x12\x04\
    \xce\x0b#$\n\r\n\x03\x04\x9a\x01\x12\x06\xd1\x0b\0\xd5\x0b\x01\n\x0c\n\
    \x04\x04\x9a\x01\x01\x12\x04\xd1\x0b\x08\x1c\n\r\n\x05\x04\x9a\x01\x02\0\
    \x12\x04\xd2\x0b\x08Z\n\x0e\n\x06\x04\x9a\x01\x02\0\x04\x12\x04\xd2\x0b\
    \x08\x10\n\x0e\n\x06\x04\x9a\x01\x02\0\x06\x12\x04\xd2\x0b\x11$\n\x0e\n\
    \x06\x04\x9a\x01\x02\0\x01\x12\x04\xd2\x0b%2\n\x0e\n\x06\x04\x9a\x01\x02\
    \0\x03\x12\x04\xd2\x0b56\n\x0e\n\x06\x04\x9a\x01\x02\0\x08\x12\x04\xd2\
    \x0b7Y\n\x0e\n\x06\x04\x9a\x01\x02\0\x07\x12\x04\xd2\x0bBX\n\r\n\x05\x04\
    \x9a\x01\x02\x01\x12\x04\xd3\x0b\x08%\n\x0e\n\x06\x04\x9a\x01\x02\x01\
    \x04\x12\x04\xd3\x0b\x08\x10\n\x0e\n\x06\x04\x9a\x01\x02\x01\x05\x12\x04\
    \xd3\x0b\x11\x17\n\x0e\n\x06\x04\x9a\x01\x02\x01\x01\x12\x04\xd3\x0b\x18\
    \x20\n\x0e\n\x06\x04\x9a\x01\x02\x01\x03\x12\x04\xd3\x0b#$\n\r\n\x05\x04\
    \x9a\x01\x02\x02\x12\x04\xd4\x0b\x08$\n\x0e\n\x06\x04\x9a\x01\x02\x02\
    \x04\x12\x04\xd4\x0b\x08\x10\n\x0e\n\x06\x04\x9a\x01\x02\x02\x05\x12\x04\
    \xd4\x0b\x11\x16\n\x0e\n\x06\x04\x9a\x01\x02\x02\x01\x12\x04\xd4\x0b\x17\
    \x1f\n\x0e\n\x06\x04\x9a\x01\x02\x02\x03\x12\x04\xd4\x0b\"#\n\r\n\x03\
    \x04\x9b\x01\x12\x06\xd7\x0b\0\xe1\x0b\x01\n\x0c\n\x04\x04\x9b\x01\x01\
    \x12\x04\xd7\x0b\x08\x17\n\r\n\x05\x04\x9b\x01\x02\0\x12\x04\xd8\x0b\x08\
    <\n\x0e\n\x06\x04\x9b\x01\x02\0\x04\x12\x04\xd8\x0b\x08\x10\n\x0e\n\x06\
    \x04\x9b\x01\x02\0\x05\x12\x04\xd8\x0b\x11\x17\n\x0e\n\x06\x04\x9b\x01\
    \x02\0\x01\x12\x04\xd8\x0b\x18\"\n\x0e\n\x06\x04\x9b\x01\x02\0\x03\x12\
    \x04\xd8\x0b%&\n\x0e\n\x06\x04\x9b\x01\x02\0\x08\x12\x04\xd8\x0b';\n\x11\
    \n\t\x04\x9b\x01\x02\0\x08\xe0\xd4\x03\x12\x04\xd8\x0b(:\n\r\n\x05\x04\
    \x9b\x01\x02\x01\x12\x04\xd9\x0b\x08:\n\x0e\n\x06\x04\x9b\x01\x02\x01\
    \x04\x12\x04\xd9\x0b\x08\x10\n\x0e\n\x06\x04\x9b\x01\x02\x01\x05\x12\x04\
    \xd9\x0b\x11\x17\n\x0e\n\x06\x04\x9b\x01\x02\x01\x01\x12\x04\xd9\x0b\x18\
    \x20\n\x0e\n\x06\x04\x9b\x01\x02\x01\x03\x12\x04\xd9\x0b#$\n\x0e\n\x06\
    \x04\x9b\x01\x02\x01\x08\x12\x04\xd9\x0b%9\n\x11\n\t\x04\x9b\x01\x02\x01\
    \x08\xe0\xd4\x03\x12\x04\xd9\x0b&8\n\r\n\x05\x04\x9b\x01\x02\x02\x12\x04\
    \xda\x0b\x08$\n\x0e\n\x06\x04\x9b\x01\x02\x02\x04\x12\x04\xda\x0b\x08\
    \x10\n\x0e\n\x06\x04\x9b\x01\x02\x02\x05\x12\x04\xda\x0b\x11\x17\n\x0e\n\
    \x06\x04\x9b\x01\x02\x02\x01\x12\x04\xda\x0b\x18\x1f\n\x0e\n\x06\x04\x9b\
    \x01\x02\x02\x03\x12\x04\xda\x0b\"#\n\r\n\x05\x04\x9b\x01\x02\x03\x12\
    \x04\xdb\x0b\x08:\n\x0e\n\x06\x04\x9b\x01\x02\x03\x04\x12\x04\xdb\x0b\
    \x08\x10\n\x0e\n\x06\x04\x9b\x01\x02\x03\x05\x12\x04\xdb\x0b\x11\x15\n\
    \x0e\n\x06\x04\x9b\x01\x02\x03\x01\x12\x04\xdb\x0b\x16#\n\x0e\n\x06\x04\
    \x9b\x01\x02\x03\x03\x12\x04\xdb\x0b&'\n\x0e\n\x06\x04\x9b\x01\x02\x03\
    \x08\x12\x04\xdb\x0b(9\n\x0e\n\x06\x04\x9b\x01\x02\x03\x07\x12\x04\xdb\
    \x0b38\n\r\n\x05\x04\x9b\x01\x02\x04\x12\x04\xdc\x0b\x08:\n\x0e\n\x06\
    \x04\x9b\x01\x02\x04\x04\x12\x04\xdc\x0b\x08\x10\n\x0e\n\x06\x04\x9b\x01\
    \x02\x04\x05\x12\x04\xdc\x0b\x11\x15\n\x0e\n\x06\x04\x9b\x01\x02\x04\x01\
    \x12\x04\xdc\x0b\x16#\n\x0e\n\x06\x04\x9b\x01\x02\x04\x03\x12\x04\xdc\
    \x0b&'\n\x0e\n\x06\x04\x9b\x01\x02\x04\x08\x12\x04\xdc\x0b(9\n\x0e\n\x06\
    \x04\x9b\x01\x02\x04\x07\x12\x04\xdc\x0b38\n\r\n\x05\x04\x9b\x01\x02\x05\
    \x12\x04\xdd\x0b\x08:\n\x0e\n\x06\x04\x9b\x01\x02\x05\x04\x12\x04\xdd\
    \x0b\x08\x10\n\x0e\n\x06\x04\x9b\x01\x02\x05\x05\x12\x04\xdd\x0b\x11\x15\
    \n\x0e\n\x06\x04\x9b\x01\x02\x05\x01\x12\x04\xdd\x0b\x16#\n\x0e\n\x06\
    \x04\x9b\x01\x02\x05\x03\x12\x04\xdd\x0b&'\n\x0e\n\x06\x04\x9b\x01\x02\
    \x05\x08\x12\x04\xdd\x0b(9\n\x0e\n\x06\x04\x9b\x01\x02\x05\x07\x12\x04\
    \xdd\x0b38\n\r\n\x05\x04\x9b\x01\x02\x06\x12\x04\xde\x0b\x089\n\x0e\n\
    \x06\x04\x9b\x01\x02\x06\x04\x12\x04\xde\x0b\x08\x10\n\x0e\n\x06\x04\x9b\
    \x01\x02\x06\x05\x12\x04\xde\x0b\x11\x15\n\x0e\n\x06\x04\x9b\x01\x02\x06\
    \x01\x12\x04\xde\x0b\x16\"\n\x0e\n\x06\x04\x9b\x01\x02\x06\x03\x12\x04\
    \xde\x0b%&\n\x0e\n\x06\x04\x9b\x01\x02\x06\x08\x12\x04\xde\x0b'8\n\x0e\n\
    \x06\x04\x9b\x01\x02\x06\x07\x12\x04\xde\x0b27\n\r\n\x05\x04\x9b\x01\x02\
    \x07\x12\x04\xdf\x0b\x08>\n\x0e\n\x06\x04\x9b\x01\x02\x07\x04\x12\x04\
    \xdf\x0b\x08\x10\n\x0e\n\x06\x04\x9b\x01\x02\x07\x05\x12\x04\xdf\x0b\x11\
    \x17\n\x0e\n\x06\x04\x9b\x01\x02\x07\x01\x12\x04\xdf\x0b\x18*\n\x0e\n\
    \x06\x04\x9b\x01\x02\x07\x03\x12\x04\xdf\x0b-/\n\x0e\n\x06\x04\x9b\x01\
    \x02\x07\x08\x12\x04\xdf\x0b0=\n\x0e\n\x06\x04\x9b\x01\x02\x07\x07\x12\
    \x04\xdf\x0b;<\n\r\n\x05\x04\x9b\x01\x02\x08\x12\x04\xe0\x0b\x08'\n\x0e\
    \n\x06\x04\x9b\x01\x02\x08\x04\x12\x04\xe0\x0b\x08\x10\n\x0e\n\x06\x04\
    \x9b\x01\x02\x08\x05\x12\x04\xe0\x0b\x11\x17\n\x0e\n\x06\x04\x9b\x01\x02\
    \x08\x01\x12\x04\xe0\x0b\x18!\n\x0e\n\x06\x04\x9b\x01\x02\x08\x03\x12\
    \x04\xe0\x0b$&\n\r\n\x03\x04\x9c\x01\x12\x06\xe3\x0b\0\xed\x0b\x01\n\x0c\
    \n\x04\x04\x9c\x01\x01\x12\x04\xe3\x0b\x08\x10\n\r\n\x05\x04\x9c\x01\x02\
    \0\x12\x04\xe4\x0b\x08'\n\x0e\n\x06\x04\x9c\x01\x02\0\x04\x12\x04\xe4\
    \x0b\x08\x10\n\x0e\n\x06\x04\x9c\x01\x02\0\x05\x12\x04\xe4\x0b\x11\x17\n\
    \x0e\n\x06\x04\x9c\x01\x02\0\x01\x12\x04\xe4\x0b\x18\"\n\x0e\n\x06\x04\
    \x9c\x01\x02\0\x03\x12\x04\xe4\x0b%&\n\r\n\x05\x04\x9c\x01\x02\x01\x12\
    \x04\xe5\x0b\x08:\n\x0e\n\x06\x04\x9c\x01\x02\x01\x04\x12\x04\xe5\x0b\
    \x08\x10\n\x0e\n\x06\x04\x9c\x01\x02\x01\x05\x12\x04\xe5\x0b\x11\x17\n\
    \x0e\n\x06\x04\x9c\x01\x02\x01\x01\x12\x04\xe5\x0b\x18\x20\n\x0e\n\x06\
    \x04\x9c\x01\x02\x01\x03\x12\x04\xe5\x0b#$\n\x0e\n\x06\x04\x9c\x01\x02\
    \x01\x08\x12\x04\xe5\x0b%9\n\x11\n\t\x04\x9c\x01\x02\x01\x08\xe0\xd4\x03\
    \x12\x04\xe5\x0b&8\n\r\n\x05\x04\x9c\x01\x02\x02\x12\x04\xe6\x0b\x08%\n\
    \x0e\n\x06\x04\x9c\x01\x02\x02\x04\x12\x04\xe6\x0b\x08\x10\n\x0e\n\x06\
    \x04\x9c\x01\x02\x02\x05\x12\x04\xe6\x0b\x11\x17\n\x0e\n\x06\x04\x9c\x01\
    \x02\x02\x01\x12\x04\xe6\x0b\x18\x20\n\x0e\n\x06\x04\x9c\x01\x02\x02\x03\
    \x12\x04\xe6\x0b#$\n\r\n\x05\x04\x9c\x01\x02\x03\x12\x04\xe7\x0b\x083\n\
    \x0e\n\x06\x04\x9c\x01\x02\x03\x04\x12\x04\xe7\x0b\x08\x10\n\x0e\n\x06\
    \x04\x9c\x01\x02\x03\x05\x12\x04\xe7\x0b\x11\x15\n\x0e\n\x06\x04\x9c\x01\
    \x02\x03\x01\x12\x04\xe7\x0b\x16\x1c\n\x0e\n\x06\x04\x9c\x01\x02\x03\x03\
    \x12\x04\xe7\x0b\x1f\x20\n\x0e\n\x06\x04\x9c\x01\x02\x03\x08\x12\x04\xe7\
    \x0b!2\n\x0e\n\x06\x04\x9c\x01\x02\x03\x07\x12\x04\xe7\x0b,1\n\r\n\x05\
    \x04\x9c\x01\x02\x04\x12\x04\xe8\x0b\x08%\n\x0e\n\x06\x04\x9c\x01\x02\
    \x04\x04\x12\x04\xe8\x0b\x08\x10\n\x0e\n\x06\x04\x9c\x01\x02\x04\x05\x12\
    \x04\xe8\x0b\x11\x17\n\x0e\n\x06\x04\x9c\x01\x02\x04\x01\x12\x04\xe8\x0b\
    \x18\x20\n\x0e\n\x06\x04\x9c\x01\x02\x04\x03\x12\x04\xe8\x0b#$\n\r\n\x05\
    \x04\x9c\x01\x02\x05\x12\x04\xe9\x0b\x08%\n\x0e\n\x06\x04\x9c\x01\x02\
    \x05\x04\x12\x04\xe9\x0b\x08\x10\n\x0e\n\x06\x04\x9c\x01\x02\x05\x05\x12\
    \x04\xe9\x0b\x11\x17\n\x0e\n\x06\x04\x9c\x01\x02\x05\x01\x12\x04\xe9\x0b\
    \x18\x20\n\x0e\n\x06\x04\x9c\x01\x02\x05\x03\x12\x04\xe9\x0b#$\n\r\n\x05\
    \x04\x9c\x01\x02\x06\x12\x04\xea\x0b\x08%\n\x0e\n\x06\x04\x9c\x01\x02\
    \x06\x04\x12\x04\xea\x0b\x08\x10\n\x0e\n\x06\x04\x9c\x01\x02\x06\x05\x12\
    \x04\xea\x0b\x11\x17\n\x0e\n\x06\x04\x9c\x01\x02\x06\x01\x12\x04\xea\x0b\
    \x18\x20\n\x0e\n\x06\x04\x9c\x01\x02\x06\x03\x12\x04\xea\x0b#$\n\r\n\x05\
    \x04\x9c\x01\x02\x07\x12\x04\xeb\x0b\x085\n\x0e\n\x06\x04\x9c\x01\x02\
    \x07\x04\x12\x04\xeb\x0b\x08\x10\n\x0e\n\x06\x04\x9c\x01\x02\x07\x05\x12\
    \x04\xeb\x0b\x11\x17\n\x0e\n\x06\x04\x9c\x01\x02\x07\x01\x12\x04\xeb\x0b\
    \x180\n\x0e\n\x06\x04\x9c\x01\x02\x07\x03\x12\x04\xeb\x0b34\n\r\n\x05\
    \x04\x9c\x01\x02\x08\x12\x04\xec\x0b\x08&\n\x0e\n\x06\x04\x9c\x01\x02\
    \x08\x04\x12\x04\xec\x0b\x08\x10\n\x0e\n\x06\x04\x9c\x01\x02\x08\x05\x12\
    \x04\xec\x0b\x11\x17\n\x0e\n\x06\x04\x9c\x01\x02\x08\x01\x12\x04\xec\x0b\
    \x18!\n\x0e\n\x06\x04\x9c\x01\x02\x08\x03\x12\x04\xec\x0b$%\n\r\n\x03\
    \x04\x9d\x01\x12\x06\xef\x0b\0\xf5\x0b\x01\n\x0c\n\x04\x04\x9d\x01\x01\
    \x12\x04\xef\x0b\x08!\n\r\n\x05\x04\x9d\x01\x02\0\x12\x04\xf0\x0b\x08'\n\
    \x0e\n\x06\x04\x9d\x01\x02\0\x04\x12\x04\xf0\x0b\x08\x10\n\x0e\n\x06\x04\
    \x9d\x01\x02\0\x05\x12\x04\xf0\x0b\x11\x17\n\x0e\n\x06\x04\x9d\x01\x02\0\
    \x01\x12\x04\xf0\x0b\x18\"\n\x0e\n\x06\x04\x9d\x01\x02\0\x03\x12\x04\xf0\
    \x0b%&\n\r\n\x05\x04\x9d\x01\x02\x01\x12\x04\xf1\x0b\x08:\n\x0e\n\x06\
    \x04\x9d\x01\x02\x01\x04\x12\x04\xf1\x0b\x08\x10\n\x0e\n\x06\x04\x9d\x01\
    \x02\x01\x05\x12\x04\xf1\x0b\x11\x17\n\x0e\n\x06\x04\x9d\x01\x02\x01\x01\
    \x12\x04\xf1\x0b\x18\x20\n\x0e\n\x06\x04\x9d\x01\x02\x01\x03\x12\x04\xf1\
    \x0b#$\n\x0e\n\x06\x04\x9d\x01\x02\x01\x08\x12\x04\xf1\x0b%9\n\x11\n\t\
    \x04\x9d\x01\x02\x01\x08\xe0\xd4\x03\x12\x04\xf1\x0b&8\n\r\n\x05\x04\x9d\
    \x01\x02\x02\x12\x04\xf2\x0b\x08\"\n\x0e\n\x06\x04\x9d\x01\x02\x02\x04\
    \x12\x04\xf2\x0b\x08\x10\n\x0e\n\x06\x04\x9d\x01\x02\x02\x05\x12\x04\xf2\
    \x0b\x11\x17\n\x0e\n\x06\x04\x9d\x01\x02\x02\x01\x12\x04\xf2\x0b\x18\x1d\
    \n\x0e\n\x06\x04\x9d\x01\x02\x02\x03\x12\x04\xf2\x0b\x20!\n\r\n\x05\x04\
    \x9d\x01\x02\x03\x12\x04\xf3\x0b\x08&\n\x0e\n\x06\x04\x9d\x01\x02\x03\
    \x04\x12\x04\xf3\x0b\x08\x10\n\x0e\n\x06\x04\x9d\x01\x02\x03\x05\x12\x04\
    \xf3\x0b\x11\x17\n\x0e\n\x06\x04\x9d\x01\x02\x03\x01\x12\x04\xf3\x0b\x18\
    !\n\x0e\n\x06\x04\x9d\x01\x02\x03\x03\x12\x04\xf3\x0b$%\n\r\n\x05\x04\
    \x9d\x01\x02\x04\x12\x04\xf4\x0b\x08(\n\x0e\n\x06\x04\x9d\x01\x02\x04\
    \x04\x12\x04\xf4\x0b\x08\x10\n\x0e\n\x06\x04\x9d\x01\x02\x04\x05\x12\x04\
    \xf4\x0b\x11\x17\n\x0e\n\x06\x04\x9d\x01\x02\x04\x01\x12\x04\xf4\x0b\x18\
    #\n\x0e\n\x06\x04\x9d\x01\x02\x04\x03\x12\x04\xf4\x0b&'\n\r\n\x03\x04\
    \x9e\x01\x12\x06\xf7\x0b\0\xf9\x0b\x01\n\x0c\n\x04\x04\x9e\x01\x01\x12\
    \x04\xf7\x0b\x08\x1b\n\r\n\x05\x04\x9e\x01\x02\0\x12\x04\xf8\x0b\x08%\n\
    \x0e\n\x06\x04\x9e\x01\x02\0\x04\x12\x04\xf8\x0b\x08\x10\n\x0e\n\x06\x04\
    \x9e\x01\x02\0\x05\x12\x04\xf8\x0b\x11\x17\n\x0e\n\x06\x04\x9e\x01\x02\0\
    \x01\x12\x04\xf8\x0b\x18\x20\n\x0e\n\x06\x04\x9e\x01\x02\0\x03\x12\x04\
    \xf8\x0b#$\n\r\n\x03\x04\x9f\x01\x12\x06\xfb\x0b\0\xfd\x0b\x01\n\x0c\n\
    \x04\x04\x9f\x01\x01\x12\x04\xfb\x0b\x08\x1a\n\r\n\x05\x04\x9f\x01\x02\0\
    \x12\x04\xfc\x0b\x08,\n\x0e\n\x06\x04\x9f\x01\x02\0\x04\x12\x04\xfc\x0b\
    \x08\x10\n\x0e\n\x06\x04\x9f\x01\x02\0\x05\x12\x04\xfc\x0b\x11\x17\n\x0e\
    \n\x06\x04\x9f\x01\x02\0\x01\x12\x04\xfc\x0b\x18'\n\x0e\n\x06\x04\x9f\
    \x01\x02\0\x03\x12\x04\xfc\x0b*+\n\r\n\x03\x04\xa0\x01\x12\x06\xff\x0b\0\
    \x81\x0c\x01\n\x0c\n\x04\x04\xa0\x01\x01\x12\x04\xff\x0b\x08\x1d\n\r\n\
    \x05\x04\xa0\x01\x02\0\x12\x04\x80\x0c\x08*\n\x0e\n\x06\x04\xa0\x01\x02\
    \0\x04\x12\x04\x80\x0c\x08\x10\n\x0e\n\x06\x04\xa0\x01\x02\0\x05\x12\x04\
    \x80\x0c\x11\x17\n\x0e\n\x06\x04\xa0\x01\x02\0\x01\x12\x04\x80\x0c\x18%\
    \n\x0e\n\x06\x04\xa0\x01\x02\0\x03\x12\x04\x80\x0c()\n\r\n\x03\x04\xa1\
    \x01\x12\x06\x83\x0c\0\x86\x0c\x01\n\x0c\n\x04\x04\xa1\x01\x01\x12\x04\
    \x83\x0c\x08\x20\n\r\n\x05\x04\xa1\x01\x02\0\x12\x04\x84\x0c\x08*\n\x0e\
    \n\x06\x04\xa1\x01\x02\0\x04\x12\x04\x84\x0c\x08\x10\n\x0e\n\x06\x04\xa1\
    \x01\x02\0\x05\x12\x04\x84\x0c\x11\x17\n\x0e\n\x06\x04\xa1\x01\x02\0\x01\
    \x12\x04\x84\x0c\x18%\n\x0e\n\x06\x04\xa1\x01\x02\0\x03\x12\x04\x84\x0c(\
    )\n\r\n\x05\x04\xa1\x01\x02\x01\x12\x04\x85\x0c\x08+\n\x0e\n\x06\x04\xa1\
    \x01\x02\x01\x04\x12\x04\x85\x0c\x08\x10\n\x0e\n\x06\x04\xa1\x01\x02\x01\
    \x05\x12\x04\x85\x0c\x11\x17\n\x0e\n\x06\x04\xa1\x01\x02\x01\x01\x12\x04\
    \x85\x0c\x18&\n\x0e\n\x06\x04\xa1\x01\x02\x01\x03\x12\x04\x85\x0c)*\n\r\
    \n\x03\x04\xa2\x01\x12\x06\x88\x0c\0\x8c\x0c\x01\n\x0c\n\x04\x04\xa2\x01\
    \x01\x12\x04\x88\x0c\x08%\n\r\n\x05\x04\xa2\x01\x02\0\x12\x04\x89\x0c\
    \x08-\n\x0e\n\x06\x04\xa2\x01\x02\0\x04\x12\x04\x89\x0c\x08\x10\n\x0e\n\
    \x06\x04\xa2\x01\x02\0\x05\x12\x04\x89\x0c\x11\x17\n\x0e\n\x06\x04\xa2\
    \x01\x02\0\x01\x12\x04\x89\x0c\x18(\n\x0e\n\x06\x04\xa2\x01\x02\0\x03\
    \x12\x04\x89\x0c+,\n\r\n\x05\x04\xa2\x01\x02\x01\x12\x04\x8a\x0c\x08(\n\
    \x0e\n\x06\x04\xa2\x01\x02\x01\x04\x12\x04\x8a\x0c\x08\x10\n\x0e\n\x06\
    \x04\xa2\x01\x02\x01\x05\x12\x04\x8a\x0c\x11\x17\n\x0e\n\x06\x04\xa2\x01\
    \x02\x01\x01\x12\x04\x8a\x0c\x18#\n\x0e\n\x06\x04\xa2\x01\x02\x01\x03\
    \x12\x04\x8a\x0c&'\n\r\n\x05\x04\xa2\x01\x02\x02\x12\x04\x8b\x0c\x08%\n\
    \x0e\n\x06\x04\xa2\x01\x02\x02\x04\x12\x04\x8b\x0c\x08\x10\n\x0e\n\x06\
    \x04\xa2\x01\x02\x02\x05\x12\x04\x8b\x0c\x11\x17\n\x0e\n\x06\x04\xa2\x01\
    \x02\x02\x01\x12\x04\x8b\x0c\x18\x20\n\x0e\n\x06\x04\xa2\x01\x02\x02\x03\
    \x12\x04\x8b\x0c#$\n\r\n\x03\x04\xa3\x01\x12\x06\x8e\x0c\0\x90\x0c\x01\n\
    \x0c\n\x04\x04\xa3\x01\x01\x12\x04\x8e\x0c\x08&\n\r\n\x05\x04\xa3\x01\
    \x02\0\x12\x04\x8f\x0c\x08\"\n\x0e\n\x06\x04\xa3\x01\x02\0\x04\x12\x04\
    \x8f\x0c\x08\x10\n\x0e\n\x06\x04\xa3\x01\x02\0\x05\x12\x04\x8f\x0c\x11\
    \x15\n\x0e\n\x06\x04\xa3\x01\x02\0\x01\x12\x04\x8f\x0c\x16\x1d\n\x0e\n\
    \x06\x04\xa3\x01\x02\0\x03\x12\x04\x8f\x0c\x20!\n\r\n\x03\x04\xa4\x01\
    \x12\x06\x92\x0c\0\x9b\x0c\x01\n\x0c\n\x04\x04\xa4\x01\x01\x12\x04\x92\
    \x0c\x08+\n\x0f\n\x05\x04\xa4\x01\x03\0\x12\x06\x93\x0c\x08\x96\x0c\t\n\
    \x0e\n\x06\x04\xa4\x01\x03\0\x01\x12\x04\x93\x0c\x10\x16\n\x0f\n\x07\x04\
    \xa4\x01\x03\0\x02\0\x12\x04\x94\x0c\x10.\n\x10\n\x08\x04\xa4\x01\x03\0\
    \x02\0\x04\x12\x04\x94\x0c\x10\x18\n\x10\n\x08\x04\xa4\x01\x03\0\x02\0\
    \x05\x12\x04\x94\x0c\x19\x1f\n\x10\n\x08\x04\xa4\x01\x03\0\x02\0\x01\x12\
    \x04\x94\x0c\x20)\n\x10\n\x08\x04\xa4\x01\x03\0\x02\0\x03\x12\x04\x94\
    \x0c,-\n\x0f\n\x07\x04\xa4\x01\x03\0\x02\x01\x12\x04\x95\x0c\x10P\n\x10\
    \n\x08\x04\xa4\x01\x03\0\x02\x01\x04\x12\x04\x95\x0c\x10\x18\n\x10\n\x08\
    \x04\xa4\x01\x03\0\x02\x01\x06\x12\x04\x95\x0c\x19$\n\x10\n\x08\x04\xa4\
    \x01\x03\0\x02\x01\x01\x12\x04\x95\x0c%-\n\x10\n\x08\x04\xa4\x01\x03\0\
    \x02\x01\x03\x12\x04\x95\x0c01\n\x10\n\x08\x04\xa4\x01\x03\0\x02\x01\x08\
    \x12\x04\x95\x0c2O\n\x10\n\x08\x04\xa4\x01\x03\0\x02\x01\x07\x12\x04\x95\
    \x0c=N\n\r\n\x05\x04\xa4\x01\x02\0\x12\x04\x98\x0c\x08%\n\x0e\n\x06\x04\
    \xa4\x01\x02\0\x04\x12\x04\x98\x0c\x08\x10\n\x0e\n\x06\x04\xa4\x01\x02\0\
    \x05\x12\x04\x98\x0c\x11\x17\n\x0e\n\x06\x04\xa4\x01\x02\0\x01\x12\x04\
    \x98\x0c\x18\x20\n\x0e\n\x06\x04\xa4\x01\x02\0\x03\x12\x04\x98\x0c#$\n\r\
    \n\x05\x04\xa4\x01\x02\x01\x12\x04\x99\x0c\x08%\n\x0e\n\x06\x04\xa4\x01\
    \x02\x01\x04\x12\x04\x99\x0c\x08\x10\n\x0e\n\x06\x04\xa4\x01\x02\x01\x05\
    \x12\x04\x99\x0c\x11\x17\n\x0e\n\x06\x04\xa4\x01\x02\x01\x01\x12\x04\x99\
    \x0c\x18\x20\n\x0e\n\x06\x04\xa4\x01\x02\x01\x03\x12\x04\x99\x0c#$\n\r\n\
    \x05\x04\xa4\x01\x02\x02\x12\x04\x9a\x0c\x08H\n\x0e\n\x06\x04\xa4\x01\
    \x02\x02\x04\x12\x04\x9a\x0c\x08\x10\n\x0e\n\x06\x04\xa4\x01\x02\x02\x06\
    \x12\x04\x9a\x0c\x11<\n\x0e\n\x06\x04\xa4\x01\x02\x02\x01\x12\x04\x9a\
    \x0c=C\n\x0e\n\x06\x04\xa4\x01\x02\x02\x03\x12\x04\x9a\x0cFG\n\r\n\x03\
    \x04\xa5\x01\x12\x06\x9d\x0c\0\x9f\x0c\x01\n\x0c\n\x04\x04\xa5\x01\x01\
    \x12\x04\x9d\x0c\x08,\n\r\n\x05\x04\xa5\x01\x02\0\x12\x04\x9e\x0c\x08\"\
    \n\x0e\n\x06\x04\xa5\x01\x02\0\x04\x12\x04\x9e\x0c\x08\x10\n\x0e\n\x06\
    \x04\xa5\x01\x02\0\x05\x12\x04\x9e\x0c\x11\x15\n\x0e\n\x06\x04\xa5\x01\
    \x02\0\x01\x12\x04\x9e\x0c\x16\x1d\n\x0e\n\x06\x04\xa5\x01\x02\0\x03\x12\
    \x04\x9e\x0c\x20!\n\r\n\x03\x04\xa6\x01\x12\x06\xa1\x0c\0\xa4\x0c\x01\n\
    \x0c\n\x04\x04\xa6\x01\x01\x12\x04\xa1\x0c\x08!\n\r\n\x05\x04\xa6\x01\
    \x02\0\x12\x04\xa2\x0c\x08%\n\x0e\n\x06\x04\xa6\x01\x02\0\x04\x12\x04\
    \xa2\x0c\x08\x10\n\x0e\n\x06\x04\xa6\x01\x02\0\x05\x12\x04\xa2\x0c\x11\
    \x17\n\x0e\n\x06\x04\xa6\x01\x02\0\x01\x12\x04\xa2\x0c\x18\x20\n\x0e\n\
    \x06\x04\xa6\x01\x02\0\x03\x12\x04\xa2\x0c#$\n\r\n\x05\x04\xa6\x01\x02\
    \x01\x12\x04\xa3\x0c\x08(\n\x0e\n\x06\x04\xa6\x01\x02\x01\x04\x12\x04\
    \xa3\x0c\x08\x10\n\x0e\n\x06\x04\xa6\x01\x02\x01\x05\x12\x04\xa3\x0c\x11\
    \x17\n\x0e\n\x06\x04\xa6\x01\x02\x01\x01\x12\x04\xa3\x0c\x18#\n\x0e\n\
    \x06\x04\xa6\x01\x02\x01\x03\x12\x04\xa3\x0c&'\n\r\n\x03\x04\xa7\x01\x12\
    \x06\xa6\x0c\0\xaa\x0c\x01\n\x0c\n\x04\x04\xa7\x01\x01\x12\x04\xa6\x0c\
    \x08\x1c\n\r\n\x05\x04\xa7\x01\x02\0\x12\x04\xa7\x0c\x08,\n\x0e\n\x06\
    \x04\xa7\x01\x02\0\x04\x12\x04\xa7\x0c\x08\x10\n\x0e\n\x06\x04\xa7\x01\
    \x02\0\x05\x12\x04\xa7\x0c\x11\x17\n\x0e\n\x06\x04\xa7\x01\x02\0\x01\x12\
    \x04\xa7\x0c\x18'\n\x0e\n\x06\x04\xa7\x01\x02\0\x03\x12\x04\xa7\x0c*+\n\
    \r\n\x05\x04\xa7\x01\x02\x01\x12\x04\xa8\x0c\x08(\n\x0e\n\x06\x04\xa7\
    \x01\x02\x01\x04\x12\x04\xa8\x0c\x08\x10\n\x0e\n\x06\x04\xa7\x01\x02\x01\
    \x05\x12\x04\xa8\x0c\x11\x17\n\x0e\n\x06\x04\xa7\x01\x02\x01\x01\x12\x04\
    \xa8\x0c\x18#\n\x0e\n\x06\x04\xa7\x01\x02\x01\x03\x12\x04\xa8\x0c&'\n\r\
    \n\x05\x04\xa7\x01\x02\x02\x12\x04\xa9\x0c\x08;\n\x0e\n\x06\x04\xa7\x01\
    \x02\x02\x04\x12\x04\xa9\x0c\x08\x10\n\x0e\n\x06\x04\xa7\x01\x02\x02\x06\
    \x12\x04\xa9\x0c\x11*\n\x0e\n\x06\x04\xa7\x01\x02\x02\x01\x12\x04\xa9\
    \x0c+6\n\x0e\n\x06\x04\xa7\x01\x02\x02\x03\x12\x04\xa9\x0c9:\n\r\n\x03\
    \x04\xa8\x01\x12\x06\xac\x0c\0\xae\x0c\x01\n\x0c\n\x04\x04\xa8\x01\x01\
    \x12\x04\xac\x0c\x08$\n\r\n\x05\x04\xa8\x01\x02\0\x12\x04\xad\x0c\x080\n\
    \x0e\n\x06\x04\xa8\x01\x02\0\x04\x12\x04\xad\x0c\x08\x10\n\x0e\n\x06\x04\
    \xa8\x01\x02\0\x05\x12\x04\xad\x0c\x11\x17\n\x0e\n\x06\x04\xa8\x01\x02\0\
    \x01\x12\x04\xad\x0c\x18+\n\x0e\n\x06\x04\xa8\x01\x02\0\x03\x12\x04\xad\
    \x0c./\n\r\n\x03\x04\xa9\x01\x12\x06\xb0\x0c\0\xb2\x0c\x01\n\x0c\n\x04\
    \x04\xa9\x01\x01\x12\x04\xb0\x0c\x08\x1b\n\r\n\x05\x04\xa9\x01\x02\0\x12\
    \x04\xb1\x0c\x084\n\x0e\n\x06\x04\xa9\x01\x02\0\x04\x12\x04\xb1\x0c\x08\
    \x10\n\x0e\n\x06\x04\xa9\x01\x02\0\x05\x12\x04\xb1\x0c\x11\x15\n\x0e\n\
    \x06\x04\xa9\x01\x02\0\x01\x12\x04\xb1\x0c\x16\x1d\n\x0e\n\x06\x04\xa9\
    \x01\x02\0\x03\x12\x04\xb1\x0c\x20!\n\x0e\n\x06\x04\xa9\x01\x02\0\x08\
    \x12\x04\xb1\x0c\"3\n\x0e\n\x06\x04\xa9\x01\x02\0\x07\x12\x04\xb1\x0c-2\
    \n\r\n\x03\x04\xaa\x01\x12\x06\xb4\x0c\0\xb6\x0c\x01\n\x0c\n\x04\x04\xaa\
    \x01\x01\x12\x04\xb4\x0c\x08*\n\r\n\x05\x04\xaa\x01\x02\0\x12\x04\xb5\
    \x0c\x08\x20\n\x0e\n\x06\x04\xaa\x01\x02\0\x04\x12\x04\xb5\x0c\x08\x10\n\
    \x0e\n\x06\x04\xaa\x01\x02\0\x05\x12\x04\xb5\x0c\x11\x15\n\x0e\n\x06\x04\
    \xaa\x01\x02\0\x01\x12\x04\xb5\x0c\x16\x1b\n\x0e\n\x06\x04\xaa\x01\x02\0\
    \x03\x12\x04\xb5\x0c\x1e\x1f\n\r\n\x03\x04\xab\x01\x12\x06\xb8\x0c\0\xc0\
    \x0c\x01\n\x0c\n\x04\x04\xab\x01\x01\x12\x04\xb8\x0c\x08\x1f\n\r\n\x05\
    \x04\xab\x01\x02\0\x12\x04\xb9\x0c\x08%\n\x0e\n\x06\x04\xab\x01\x02\0\
    \x04\x12\x04\xb9\x0c\x08\x10\n\x0e\n\x06\x04\xab\x01\x02\0\x05\x12\x04\
    \xb9\x0c\x11\x17\n\x0e\n\x06\x04\xab\x01\x02\0\x01\x12\x04\xb9\x0c\x18\
    \x20\n\x0e\n\x06\x04\xab\x01\x02\0\x03\x12\x04\xb9\x0c#$\n\r\n\x05\x04\
    \xab\x01\x02\x01\x12\x04\xba\x0c\x08(\n\x0e\n\x06\x04\xab\x01\x02\x01\
    \x04\x12\x04\xba\x0c\x08\x10\n\x0e\n\x06\x04\xab\x01\x02\x01\x05\x12\x04\
    \xba\x0c\x11\x15\n\x0e\n\x06\x04\xab\x01\x02\x01\x01\x12\x04\xba\x0c\x16\
    #\n\x0e\n\x06\x04\xab\x01\x02\x01\x03\x12\x04\xba\x0c&'\n\r\n\x05\x04\
    \xab\x01\x02\x02\x12\x04\xbb\x0c\x08(\n\x0e\n\x06\x04\xab\x01\x02\x02\
    \x04\x12\x04\xbb\x0c\x08\x10\n\x0e\n\x06\x04\xab\x01\x02\x02\x05\x12\x04\
    \xbb\x0c\x11\x15\n\x0e\n\x06\x04\xab\x01\x02\x02\x01\x12\x04\xbb\x0c\x16\
    #\n\x0e\n\x06\x04\xab\x01\x02\x02\x03\x12\x04\xbb\x0c&'\n\r\n\x05\x04\
    \xab\x01\x02\x03\x12\x04\xbc\x0c\x08(\n\x0e\n\x06\x04\xab\x01\x02\x03\
    \x04\x12\x04\xbc\x0c\x08\x10\n\x0e\n\x06\x04\xab\x01\x02\x03\x05\x12\x04\
    \xbc\x0c\x11\x15\n\x0e\n\x06\x04\xab\x01\x02\x03\x01\x12\x04\xbc\x0c\x16\
    #\n\x0e\n\x06\x04\xab\x01\x02\x03\x03\x12\x04\xbc\x0c&'\n\r\n\x05\x04\
    \xab\x01\x02\x04\x12\x04\xbd\x0c\x08)\n\x0e\n\x06\x04\xab\x01\x02\x04\
    \x04\x12\x04\xbd\x0c\x08\x10\n\x0e\n\x06\x04\xab\x01\x02\x04\x05\x12\x04\
    \xbd\x0c\x11\x17\n\x0e\n\x06\x04\xab\x01\x02\x04\x01\x12\x04\xbd\x0c\x18\
    $\n\x0e\n\x06\x04\xab\x01\x02\x04\x03\x12\x04\xbd\x0c'(\n\r\n\x05\x04\
    \xab\x01\x02\x05\x12\x04\xbe\x0c\x082\n\x0e\n\x06\x04\xab\x01\x02\x05\
    \x04\x12\x04\xbe\x0c\x08\x10\n\x0e\n\x06\x04\xab\x01\x02\x05\x05\x12\x04\
    \xbe\x0c\x11\x17\n\x0e\n\x06\x04\xab\x01\x02\x05\x01\x12\x04\xbe\x0c\x18\
    -\n\x0e\n\x06\x04\xab\x01\x02\x05\x03\x12\x04\xbe\x0c01\n\r\n\x05\x04\
    \xab\x01\x02\x06\x12\x04\xbf\x0c\x08-\n\x0e\n\x06\x04\xab\x01\x02\x06\
    \x04\x12\x04\xbf\x0c\x08\x10\n\x0e\n\x06\x04\xab\x01\x02\x06\x05\x12\x04\
    \xbf\x0c\x11\x15\n\x0e\n\x06\x04\xab\x01\x02\x06\x01\x12\x04\xbf\x0c\x16\
    (\n\x0e\n\x06\x04\xab\x01\x02\x06\x03\x12\x04\xbf\x0c+,\n\r\n\x03\x04\
    \xac\x01\x12\x06\xc2\x0c\0\xc5\x0c\x01\n\x0c\n\x04\x04\xac\x01\x01\x12\
    \x04\xc2\x0c\x08\x1b\n\r\n\x05\x04\xac\x01\x02\0\x12\x04\xc3\x0c\x08'\n\
    \x0e\n\x06\x04\xac\x01\x02\0\x04\x12\x04\xc3\x0c\x08\x10\n\x0e\n\x06\x04\
    \xac\x01\x02\0\x05\x12\x04\xc3\x0c\x11\x18\n\x0e\n\x06\x04\xac\x01\x02\0\
    \x01\x12\x04\xc3\x0c\x19\"\n\x0e\n\x06\x04\xac\x01\x02\0\x03\x12\x04\xc3\
    \x0c%&\n\r\n\x05\x04\xac\x01\x02\x01\x12\x04\xc4\x0c\x08,\n\x0e\n\x06\
    \x04\xac\x01\x02\x01\x04\x12\x04\xc4\x0c\x08\x10\n\x0e\n\x06\x04\xac\x01\
    \x02\x01\x05\x12\x04\xc4\x0c\x11\x17\n\x0e\n\x06\x04\xac\x01\x02\x01\x01\
    \x12\x04\xc4\x0c\x18'\n\x0e\n\x06\x04\xac\x01\x02\x01\x03\x12\x04\xc4\
    \x0c*+\n\r\n\x03\x04\xad\x01\x12\x06\xc7\x0c\0\xcb\x0c\x01\n\x0c\n\x04\
    \x04\xad\x01\x01\x12\x04\xc7\x0c\x08\x1b\n\r\n\x05\x04\xad\x01\x02\0\x12\
    \x04\xc8\x0c\x08.\n\x0e\n\x06\x04\xad\x01\x02\0\x04\x12\x04\xc8\x0c\x08\
    \x10\n\x0e\n\x06\x04\xad\x01\x02\0\x05\x12\x04\xc8\x0c\x11\x17\n\x0e\n\
    \x06\x04\xad\x01\x02\0\x01\x12\x04\xc8\x0c\x18)\n\x0e\n\x06\x04\xad\x01\
    \x02\0\x03\x12\x04\xc8\x0c,-\n\r\n\x05\x04\xad\x01\x02\x01\x12\x04\xc9\
    \x0c\x08\x20\n\x0e\n\x06\x04\xad\x01\x02\x01\x04\x12\x04\xc9\x0c\x08\x10\
    \n\x0e\n\x06\x04\xad\x01\x02\x01\x05\x12\x04\xc9\x0c\x11\x16\n\x0e\n\x06\
    \x04\xad\x01\x02\x01\x01\x12\x04\xc9\x0c\x17\x1b\n\x0e\n\x06\x04\xad\x01\
    \x02\x01\x03\x12\x04\xc9\x0c\x1e\x1f\n\r\n\x05\x04\xad\x01\x02\x02\x12\
    \x04\xca\x0c\x08*\n\x0e\n\x06\x04\xad\x01\x02\x02\x04\x12\x04\xca\x0c\
    \x08\x10\n\x0e\n\x06\x04\xad\x01\x02\x02\x05\x12\x04\xca\x0c\x11\x17\n\
    \x0e\n\x06\x04\xad\x01\x02\x02\x01\x12\x04\xca\x0c\x18%\n\x0e\n\x06\x04\
    \xad\x01\x02\x02\x03\x12\x04\xca\x0c()\n\r\n\x03\x04\xae\x01\x12\x06\xcd\
    \x0c\0\xd3\x0c\x01\n\x0c\n\x04\x04\xae\x01\x01\x12\x04\xcd\x0c\x08\x1b\n\
    \r\n\x05\x04\xae\x01\x02\0\x12\x04\xce\x0c\x08-\n\x0e\n\x06\x04\xae\x01\
    \x02\0\x04\x12\x04\xce\x0c\x08\x10\n\x0e\n\x06\x04\xae\x01\x02\0\x05\x12\
    \x04\xce\x0c\x11\x17\n\x0e\n\x06\x04\xae\x01\x02\0\x01\x12\x04\xce\x0c\
    \x18(\n\x0e\n\x06\x04\xae\x01\x02\0\x03\x12\x04\xce\x0c+,\n\r\n\x05\x04\
    \xae\x01\x02\x01\x12\x04\xcf\x0c\x08.\n\x0e\n\x06\x04\xae\x01\x02\x01\
    \x04\x12\x04\xcf\x0c\x08\x10\n\x0e\n\x06\x04\xae\x01\x02\x01\x05\x12\x04\
    \xcf\x0c\x11\x17\n\x0e\n\x06\x04\xae\x01\x02\x01\x01\x12\x04\xcf\x0c\x18\
    )\n\x0e\n\x06\x04\xae\x01\x02\x01\x03\x12\x04\xcf\x0c,-\n\r\n\x05\x04\
    \xae\x01\x02\x02\x12\x04\xd0\x0c\x08%\n\x0e\n\x06\x04\xae\x01\x02\x02\
    \x04\x12\x04\xd0\x0c\x08\x10\n\x0e\n\x06\x04\xae\x01\x02\x02\x05\x12\x04\
    \xd0\x0c\x11\x17\n\x0e\n\x06\x04\xae\x01\x02\x02\x01\x12\x04\xd0\x0c\x18\
    \x20\n\x0e\n\x06\x04\xae\x01\x02\x02\x03\x12\x04\xd0\x0c#$\n\r\n\x05\x04\
    \xae\x01\x02\x03\x12\x04\xd1\x0c\x08-\n\x0e\n\x06\x04\xae\x01\x02\x03\
    \x04\x12\x04\xd1\x0c\x08\x10\n\x0e\n\x06\x04\xae\x01\x02\x03\x05\x12\x04\
    \xd1\x0c\x11\x17\n\x0e\n\x06\x04\xae\x01\x02\x03\x01\x12\x04\xd1\x0c\x18\
    (\n\x0e\n\x06\x04\xae\x01\x02\x03\x03\x12\x04\xd1\x0c+,\n\r\n\x05\x04\
    \xae\x01\x02\x04\x12\x04\xd2\x0c\x08\"\n\x0e\n\x06\x04\xae\x01\x02\x04\
    \x04\x12\x04\xd2\x0c\x08\x10\n\x0e\n\x06\x04\xae\x01\x02\x04\x05\x12\x04\
    \xd2\x0c\x11\x17\n\x0e\n\x06\x04\xae\x01\x02\x04\x01\x12\x04\xd2\x0c\x18\
    \x1d\n\x0e\n\x06\x04\xae\x01\x02\x04\x03\x12\x04\xd2\x0c\x20!\n\r\n\x03\
    \x04\xaf\x01\x12\x06\xd5\x0c\0\xd7\x0c\x01\n\x0c\n\x04\x04\xaf\x01\x01\
    \x12\x04\xd5\x0c\x08\x15\n\r\n\x05\x04\xaf\x01\x02\0\x12\x04\xd6\x0c\x08\
    -\n\x0e\n\x06\x04\xaf\x01\x02\0\x04\x12\x04\xd6\x0c\x08\x10\n\x0e\n\x06\
    \x04\xaf\x01\x02\0\x05\x12\x04\xd6\x0c\x11\x16\n\x0e\n\x06\x04\xaf\x01\
    \x02\0\x01\x12\x04\xd6\x0c\x17(\n\x0e\n\x06\x04\xaf\x01\x02\0\x03\x12\
    \x04\xd6\x0c+,\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
