// This file is generated by rust-protobuf 2.24.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `gcsdk_gcmessages.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_24_1;

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSOIDOwner {
    // message fields
    field_type: ::std::option::Option<u32>,
    id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSOIDOwner {
    fn default() -> &'a CMsgSOIDOwner {
        <CMsgSOIDOwner as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSOIDOwner {
    pub fn new() -> CMsgSOIDOwner {
        ::std::default::Default::default()
    }

    // optional uint32 type = 1;


    pub fn get_field_type(&self) -> u32 {
        self.field_type.unwrap_or(0)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: u32) {
        self.field_type = ::std::option::Option::Some(v);
    }

    // optional uint64 id = 2;


    pub fn get_id(&self) -> u64 {
        self.id.unwrap_or(0)
    }
    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u64) {
        self.id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSOIDOwner {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSOIDOwner {
        CMsgSOIDOwner::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "type",
                |m: &CMsgSOIDOwner| { &m.field_type },
                |m: &mut CMsgSOIDOwner| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "id",
                |m: &CMsgSOIDOwner| { &m.id },
                |m: &mut CMsgSOIDOwner| { &mut m.id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSOIDOwner>(
                "CMsgSOIDOwner",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSOIDOwner {
        static instance: ::protobuf::rt::LazyV2<CMsgSOIDOwner> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSOIDOwner::new)
    }
}

impl ::protobuf::Clear for CMsgSOIDOwner {
    fn clear(&mut self) {
        self.field_type = ::std::option::Option::None;
        self.id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSOIDOwner {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSOIDOwner {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSOSingleObject {
    // message fields
    owner: ::std::option::Option<u64>,
    type_id: ::std::option::Option<i32>,
    object_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    version: ::std::option::Option<u64>,
    pub owner_soid: ::protobuf::SingularPtrField<CMsgSOIDOwner>,
    service_id: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSOSingleObject {
    fn default() -> &'a CMsgSOSingleObject {
        <CMsgSOSingleObject as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSOSingleObject {
    pub fn new() -> CMsgSOSingleObject {
        ::std::default::Default::default()
    }

    // optional fixed64 owner = 1;


    pub fn get_owner(&self) -> u64 {
        self.owner.unwrap_or(0)
    }
    pub fn clear_owner(&mut self) {
        self.owner = ::std::option::Option::None;
    }

    pub fn has_owner(&self) -> bool {
        self.owner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner(&mut self, v: u64) {
        self.owner = ::std::option::Option::Some(v);
    }

    // optional int32 type_id = 2;


    pub fn get_type_id(&self) -> i32 {
        self.type_id.unwrap_or(0)
    }
    pub fn clear_type_id(&mut self) {
        self.type_id = ::std::option::Option::None;
    }

    pub fn has_type_id(&self) -> bool {
        self.type_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type_id(&mut self, v: i32) {
        self.type_id = ::std::option::Option::Some(v);
    }

    // optional bytes object_data = 3;


    pub fn get_object_data(&self) -> &[u8] {
        match self.object_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_object_data(&mut self) {
        self.object_data.clear();
    }

    pub fn has_object_data(&self) -> bool {
        self.object_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_object_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.object_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_object_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.object_data.is_none() {
            self.object_data.set_default();
        }
        self.object_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_object_data(&mut self) -> ::std::vec::Vec<u8> {
        self.object_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional fixed64 version = 4;


    pub fn get_version(&self) -> u64 {
        self.version.unwrap_or(0)
    }
    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u64) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional .CMsgSOIDOwner owner_soid = 5;


    pub fn get_owner_soid(&self) -> &CMsgSOIDOwner {
        self.owner_soid.as_ref().unwrap_or_else(|| <CMsgSOIDOwner as ::protobuf::Message>::default_instance())
    }
    pub fn clear_owner_soid(&mut self) {
        self.owner_soid.clear();
    }

    pub fn has_owner_soid(&self) -> bool {
        self.owner_soid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner_soid(&mut self, v: CMsgSOIDOwner) {
        self.owner_soid = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner_soid(&mut self) -> &mut CMsgSOIDOwner {
        if self.owner_soid.is_none() {
            self.owner_soid.set_default();
        }
        self.owner_soid.as_mut().unwrap()
    }

    // Take field
    pub fn take_owner_soid(&mut self) -> CMsgSOIDOwner {
        self.owner_soid.take().unwrap_or_else(|| CMsgSOIDOwner::new())
    }

    // optional uint32 service_id = 6;


    pub fn get_service_id(&self) -> u32 {
        self.service_id.unwrap_or(0)
    }
    pub fn clear_service_id(&mut self) {
        self.service_id = ::std::option::Option::None;
    }

    pub fn has_service_id(&self) -> bool {
        self.service_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_service_id(&mut self, v: u32) {
        self.service_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSOSingleObject {
    fn is_initialized(&self) -> bool {
        for v in &self.owner_soid {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.owner = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.type_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.object_data)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.version = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.owner_soid)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.service_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.owner {
            my_size += 9;
        }
        if let Some(v) = self.type_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.object_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.version {
            my_size += 9;
        }
        if let Some(ref v) = self.owner_soid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.service_id {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.owner {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.type_id {
            os.write_int32(2, v)?;
        }
        if let Some(ref v) = self.object_data.as_ref() {
            os.write_bytes(3, &v)?;
        }
        if let Some(v) = self.version {
            os.write_fixed64(4, v)?;
        }
        if let Some(ref v) = self.owner_soid.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.service_id {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSOSingleObject {
        CMsgSOSingleObject::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "owner",
                |m: &CMsgSOSingleObject| { &m.owner },
                |m: &mut CMsgSOSingleObject| { &mut m.owner },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "type_id",
                |m: &CMsgSOSingleObject| { &m.type_id },
                |m: &mut CMsgSOSingleObject| { &mut m.type_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "object_data",
                |m: &CMsgSOSingleObject| { &m.object_data },
                |m: &mut CMsgSOSingleObject| { &mut m.object_data },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "version",
                |m: &CMsgSOSingleObject| { &m.version },
                |m: &mut CMsgSOSingleObject| { &mut m.version },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgSOIDOwner>>(
                "owner_soid",
                |m: &CMsgSOSingleObject| { &m.owner_soid },
                |m: &mut CMsgSOSingleObject| { &mut m.owner_soid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "service_id",
                |m: &CMsgSOSingleObject| { &m.service_id },
                |m: &mut CMsgSOSingleObject| { &mut m.service_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSOSingleObject>(
                "CMsgSOSingleObject",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSOSingleObject {
        static instance: ::protobuf::rt::LazyV2<CMsgSOSingleObject> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSOSingleObject::new)
    }
}

impl ::protobuf::Clear for CMsgSOSingleObject {
    fn clear(&mut self) {
        self.owner = ::std::option::Option::None;
        self.type_id = ::std::option::Option::None;
        self.object_data.clear();
        self.version = ::std::option::Option::None;
        self.owner_soid.clear();
        self.service_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSOSingleObject {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSOSingleObject {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSOMultipleObjects {
    // message fields
    owner: ::std::option::Option<u64>,
    pub objects: ::protobuf::RepeatedField<CMsgSOMultipleObjects_SingleObject>,
    version: ::std::option::Option<u64>,
    pub owner_soid: ::protobuf::SingularPtrField<CMsgSOIDOwner>,
    service_id: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSOMultipleObjects {
    fn default() -> &'a CMsgSOMultipleObjects {
        <CMsgSOMultipleObjects as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSOMultipleObjects {
    pub fn new() -> CMsgSOMultipleObjects {
        ::std::default::Default::default()
    }

    // optional fixed64 owner = 1;


    pub fn get_owner(&self) -> u64 {
        self.owner.unwrap_or(0)
    }
    pub fn clear_owner(&mut self) {
        self.owner = ::std::option::Option::None;
    }

    pub fn has_owner(&self) -> bool {
        self.owner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner(&mut self, v: u64) {
        self.owner = ::std::option::Option::Some(v);
    }

    // repeated .CMsgSOMultipleObjects.SingleObject objects = 2;


    pub fn get_objects(&self) -> &[CMsgSOMultipleObjects_SingleObject] {
        &self.objects
    }
    pub fn clear_objects(&mut self) {
        self.objects.clear();
    }

    // Param is passed by value, moved
    pub fn set_objects(&mut self, v: ::protobuf::RepeatedField<CMsgSOMultipleObjects_SingleObject>) {
        self.objects = v;
    }

    // Mutable pointer to the field.
    pub fn mut_objects(&mut self) -> &mut ::protobuf::RepeatedField<CMsgSOMultipleObjects_SingleObject> {
        &mut self.objects
    }

    // Take field
    pub fn take_objects(&mut self) -> ::protobuf::RepeatedField<CMsgSOMultipleObjects_SingleObject> {
        ::std::mem::replace(&mut self.objects, ::protobuf::RepeatedField::new())
    }

    // optional fixed64 version = 3;


    pub fn get_version(&self) -> u64 {
        self.version.unwrap_or(0)
    }
    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u64) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional .CMsgSOIDOwner owner_soid = 6;


    pub fn get_owner_soid(&self) -> &CMsgSOIDOwner {
        self.owner_soid.as_ref().unwrap_or_else(|| <CMsgSOIDOwner as ::protobuf::Message>::default_instance())
    }
    pub fn clear_owner_soid(&mut self) {
        self.owner_soid.clear();
    }

    pub fn has_owner_soid(&self) -> bool {
        self.owner_soid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner_soid(&mut self, v: CMsgSOIDOwner) {
        self.owner_soid = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner_soid(&mut self) -> &mut CMsgSOIDOwner {
        if self.owner_soid.is_none() {
            self.owner_soid.set_default();
        }
        self.owner_soid.as_mut().unwrap()
    }

    // Take field
    pub fn take_owner_soid(&mut self) -> CMsgSOIDOwner {
        self.owner_soid.take().unwrap_or_else(|| CMsgSOIDOwner::new())
    }

    // optional uint32 service_id = 7;


    pub fn get_service_id(&self) -> u32 {
        self.service_id.unwrap_or(0)
    }
    pub fn clear_service_id(&mut self) {
        self.service_id = ::std::option::Option::None;
    }

    pub fn has_service_id(&self) -> bool {
        self.service_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_service_id(&mut self, v: u32) {
        self.service_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSOMultipleObjects {
    fn is_initialized(&self) -> bool {
        for v in &self.objects {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.owner_soid {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.owner = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.objects)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.version = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.owner_soid)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.service_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.owner {
            my_size += 9;
        }
        for value in &self.objects {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.version {
            my_size += 9;
        }
        if let Some(ref v) = self.owner_soid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.service_id {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.owner {
            os.write_fixed64(1, v)?;
        }
        for v in &self.objects {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.version {
            os.write_fixed64(3, v)?;
        }
        if let Some(ref v) = self.owner_soid.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.service_id {
            os.write_uint32(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSOMultipleObjects {
        CMsgSOMultipleObjects::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "owner",
                |m: &CMsgSOMultipleObjects| { &m.owner },
                |m: &mut CMsgSOMultipleObjects| { &mut m.owner },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgSOMultipleObjects_SingleObject>>(
                "objects",
                |m: &CMsgSOMultipleObjects| { &m.objects },
                |m: &mut CMsgSOMultipleObjects| { &mut m.objects },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "version",
                |m: &CMsgSOMultipleObjects| { &m.version },
                |m: &mut CMsgSOMultipleObjects| { &mut m.version },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgSOIDOwner>>(
                "owner_soid",
                |m: &CMsgSOMultipleObjects| { &m.owner_soid },
                |m: &mut CMsgSOMultipleObjects| { &mut m.owner_soid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "service_id",
                |m: &CMsgSOMultipleObjects| { &m.service_id },
                |m: &mut CMsgSOMultipleObjects| { &mut m.service_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSOMultipleObjects>(
                "CMsgSOMultipleObjects",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSOMultipleObjects {
        static instance: ::protobuf::rt::LazyV2<CMsgSOMultipleObjects> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSOMultipleObjects::new)
    }
}

impl ::protobuf::Clear for CMsgSOMultipleObjects {
    fn clear(&mut self) {
        self.owner = ::std::option::Option::None;
        self.objects.clear();
        self.version = ::std::option::Option::None;
        self.owner_soid.clear();
        self.service_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSOMultipleObjects {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSOMultipleObjects {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSOMultipleObjects_SingleObject {
    // message fields
    type_id: ::std::option::Option<i32>,
    object_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSOMultipleObjects_SingleObject {
    fn default() -> &'a CMsgSOMultipleObjects_SingleObject {
        <CMsgSOMultipleObjects_SingleObject as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSOMultipleObjects_SingleObject {
    pub fn new() -> CMsgSOMultipleObjects_SingleObject {
        ::std::default::Default::default()
    }

    // optional int32 type_id = 1;


    pub fn get_type_id(&self) -> i32 {
        self.type_id.unwrap_or(0)
    }
    pub fn clear_type_id(&mut self) {
        self.type_id = ::std::option::Option::None;
    }

    pub fn has_type_id(&self) -> bool {
        self.type_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type_id(&mut self, v: i32) {
        self.type_id = ::std::option::Option::Some(v);
    }

    // optional bytes object_data = 2;


    pub fn get_object_data(&self) -> &[u8] {
        match self.object_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_object_data(&mut self) {
        self.object_data.clear();
    }

    pub fn has_object_data(&self) -> bool {
        self.object_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_object_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.object_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_object_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.object_data.is_none() {
            self.object_data.set_default();
        }
        self.object_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_object_data(&mut self) -> ::std::vec::Vec<u8> {
        self.object_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgSOMultipleObjects_SingleObject {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.type_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.object_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.type_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.object_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.type_id {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.object_data.as_ref() {
            os.write_bytes(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSOMultipleObjects_SingleObject {
        CMsgSOMultipleObjects_SingleObject::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "type_id",
                |m: &CMsgSOMultipleObjects_SingleObject| { &m.type_id },
                |m: &mut CMsgSOMultipleObjects_SingleObject| { &mut m.type_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "object_data",
                |m: &CMsgSOMultipleObjects_SingleObject| { &m.object_data },
                |m: &mut CMsgSOMultipleObjects_SingleObject| { &mut m.object_data },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSOMultipleObjects_SingleObject>(
                "CMsgSOMultipleObjects.SingleObject",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSOMultipleObjects_SingleObject {
        static instance: ::protobuf::rt::LazyV2<CMsgSOMultipleObjects_SingleObject> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSOMultipleObjects_SingleObject::new)
    }
}

impl ::protobuf::Clear for CMsgSOMultipleObjects_SingleObject {
    fn clear(&mut self) {
        self.type_id = ::std::option::Option::None;
        self.object_data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSOMultipleObjects_SingleObject {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSOMultipleObjects_SingleObject {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSOCacheSubscribed {
    // message fields
    owner: ::std::option::Option<u64>,
    pub objects: ::protobuf::RepeatedField<CMsgSOCacheSubscribed_SubscribedType>,
    version: ::std::option::Option<u64>,
    pub owner_soid: ::protobuf::SingularPtrField<CMsgSOIDOwner>,
    service_id: ::std::option::Option<u32>,
    pub service_list: ::std::vec::Vec<u32>,
    sync_version: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSOCacheSubscribed {
    fn default() -> &'a CMsgSOCacheSubscribed {
        <CMsgSOCacheSubscribed as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSOCacheSubscribed {
    pub fn new() -> CMsgSOCacheSubscribed {
        ::std::default::Default::default()
    }

    // optional fixed64 owner = 1;


    pub fn get_owner(&self) -> u64 {
        self.owner.unwrap_or(0)
    }
    pub fn clear_owner(&mut self) {
        self.owner = ::std::option::Option::None;
    }

    pub fn has_owner(&self) -> bool {
        self.owner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner(&mut self, v: u64) {
        self.owner = ::std::option::Option::Some(v);
    }

    // repeated .CMsgSOCacheSubscribed.SubscribedType objects = 2;


    pub fn get_objects(&self) -> &[CMsgSOCacheSubscribed_SubscribedType] {
        &self.objects
    }
    pub fn clear_objects(&mut self) {
        self.objects.clear();
    }

    // Param is passed by value, moved
    pub fn set_objects(&mut self, v: ::protobuf::RepeatedField<CMsgSOCacheSubscribed_SubscribedType>) {
        self.objects = v;
    }

    // Mutable pointer to the field.
    pub fn mut_objects(&mut self) -> &mut ::protobuf::RepeatedField<CMsgSOCacheSubscribed_SubscribedType> {
        &mut self.objects
    }

    // Take field
    pub fn take_objects(&mut self) -> ::protobuf::RepeatedField<CMsgSOCacheSubscribed_SubscribedType> {
        ::std::mem::replace(&mut self.objects, ::protobuf::RepeatedField::new())
    }

    // optional fixed64 version = 3;


    pub fn get_version(&self) -> u64 {
        self.version.unwrap_or(0)
    }
    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u64) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional .CMsgSOIDOwner owner_soid = 4;


    pub fn get_owner_soid(&self) -> &CMsgSOIDOwner {
        self.owner_soid.as_ref().unwrap_or_else(|| <CMsgSOIDOwner as ::protobuf::Message>::default_instance())
    }
    pub fn clear_owner_soid(&mut self) {
        self.owner_soid.clear();
    }

    pub fn has_owner_soid(&self) -> bool {
        self.owner_soid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner_soid(&mut self, v: CMsgSOIDOwner) {
        self.owner_soid = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner_soid(&mut self) -> &mut CMsgSOIDOwner {
        if self.owner_soid.is_none() {
            self.owner_soid.set_default();
        }
        self.owner_soid.as_mut().unwrap()
    }

    // Take field
    pub fn take_owner_soid(&mut self) -> CMsgSOIDOwner {
        self.owner_soid.take().unwrap_or_else(|| CMsgSOIDOwner::new())
    }

    // optional uint32 service_id = 5;


    pub fn get_service_id(&self) -> u32 {
        self.service_id.unwrap_or(0)
    }
    pub fn clear_service_id(&mut self) {
        self.service_id = ::std::option::Option::None;
    }

    pub fn has_service_id(&self) -> bool {
        self.service_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_service_id(&mut self, v: u32) {
        self.service_id = ::std::option::Option::Some(v);
    }

    // repeated uint32 service_list = 6;


    pub fn get_service_list(&self) -> &[u32] {
        &self.service_list
    }
    pub fn clear_service_list(&mut self) {
        self.service_list.clear();
    }

    // Param is passed by value, moved
    pub fn set_service_list(&mut self, v: ::std::vec::Vec<u32>) {
        self.service_list = v;
    }

    // Mutable pointer to the field.
    pub fn mut_service_list(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.service_list
    }

    // Take field
    pub fn take_service_list(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.service_list, ::std::vec::Vec::new())
    }

    // optional fixed64 sync_version = 7;


    pub fn get_sync_version(&self) -> u64 {
        self.sync_version.unwrap_or(0)
    }
    pub fn clear_sync_version(&mut self) {
        self.sync_version = ::std::option::Option::None;
    }

    pub fn has_sync_version(&self) -> bool {
        self.sync_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sync_version(&mut self, v: u64) {
        self.sync_version = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSOCacheSubscribed {
    fn is_initialized(&self) -> bool {
        for v in &self.objects {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.owner_soid {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.owner = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.objects)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.version = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.owner_soid)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.service_id = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.service_list)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.sync_version = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.owner {
            my_size += 9;
        }
        for value in &self.objects {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.version {
            my_size += 9;
        }
        if let Some(ref v) = self.owner_soid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.service_id {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.service_list {
            my_size += ::protobuf::rt::value_size(6, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.sync_version {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.owner {
            os.write_fixed64(1, v)?;
        }
        for v in &self.objects {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.version {
            os.write_fixed64(3, v)?;
        }
        if let Some(ref v) = self.owner_soid.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.service_id {
            os.write_uint32(5, v)?;
        }
        for v in &self.service_list {
            os.write_uint32(6, *v)?;
        };
        if let Some(v) = self.sync_version {
            os.write_fixed64(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSOCacheSubscribed {
        CMsgSOCacheSubscribed::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "owner",
                |m: &CMsgSOCacheSubscribed| { &m.owner },
                |m: &mut CMsgSOCacheSubscribed| { &mut m.owner },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgSOCacheSubscribed_SubscribedType>>(
                "objects",
                |m: &CMsgSOCacheSubscribed| { &m.objects },
                |m: &mut CMsgSOCacheSubscribed| { &mut m.objects },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "version",
                |m: &CMsgSOCacheSubscribed| { &m.version },
                |m: &mut CMsgSOCacheSubscribed| { &mut m.version },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgSOIDOwner>>(
                "owner_soid",
                |m: &CMsgSOCacheSubscribed| { &m.owner_soid },
                |m: &mut CMsgSOCacheSubscribed| { &mut m.owner_soid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "service_id",
                |m: &CMsgSOCacheSubscribed| { &m.service_id },
                |m: &mut CMsgSOCacheSubscribed| { &mut m.service_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "service_list",
                |m: &CMsgSOCacheSubscribed| { &m.service_list },
                |m: &mut CMsgSOCacheSubscribed| { &mut m.service_list },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "sync_version",
                |m: &CMsgSOCacheSubscribed| { &m.sync_version },
                |m: &mut CMsgSOCacheSubscribed| { &mut m.sync_version },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSOCacheSubscribed>(
                "CMsgSOCacheSubscribed",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSOCacheSubscribed {
        static instance: ::protobuf::rt::LazyV2<CMsgSOCacheSubscribed> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSOCacheSubscribed::new)
    }
}

impl ::protobuf::Clear for CMsgSOCacheSubscribed {
    fn clear(&mut self) {
        self.owner = ::std::option::Option::None;
        self.objects.clear();
        self.version = ::std::option::Option::None;
        self.owner_soid.clear();
        self.service_id = ::std::option::Option::None;
        self.service_list.clear();
        self.sync_version = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSOCacheSubscribed {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSOCacheSubscribed {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSOCacheSubscribed_SubscribedType {
    // message fields
    type_id: ::std::option::Option<i32>,
    pub object_data: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSOCacheSubscribed_SubscribedType {
    fn default() -> &'a CMsgSOCacheSubscribed_SubscribedType {
        <CMsgSOCacheSubscribed_SubscribedType as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSOCacheSubscribed_SubscribedType {
    pub fn new() -> CMsgSOCacheSubscribed_SubscribedType {
        ::std::default::Default::default()
    }

    // optional int32 type_id = 1;


    pub fn get_type_id(&self) -> i32 {
        self.type_id.unwrap_or(0)
    }
    pub fn clear_type_id(&mut self) {
        self.type_id = ::std::option::Option::None;
    }

    pub fn has_type_id(&self) -> bool {
        self.type_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type_id(&mut self, v: i32) {
        self.type_id = ::std::option::Option::Some(v);
    }

    // repeated bytes object_data = 2;


    pub fn get_object_data(&self) -> &[::std::vec::Vec<u8>] {
        &self.object_data
    }
    pub fn clear_object_data(&mut self) {
        self.object_data.clear();
    }

    // Param is passed by value, moved
    pub fn set_object_data(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.object_data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_object_data(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.object_data
    }

    // Take field
    pub fn take_object_data(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.object_data, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgSOCacheSubscribed_SubscribedType {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.type_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.object_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.type_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.object_data {
            my_size += ::protobuf::rt::bytes_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.type_id {
            os.write_int32(1, v)?;
        }
        for v in &self.object_data {
            os.write_bytes(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSOCacheSubscribed_SubscribedType {
        CMsgSOCacheSubscribed_SubscribedType::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "type_id",
                |m: &CMsgSOCacheSubscribed_SubscribedType| { &m.type_id },
                |m: &mut CMsgSOCacheSubscribed_SubscribedType| { &mut m.type_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "object_data",
                |m: &CMsgSOCacheSubscribed_SubscribedType| { &m.object_data },
                |m: &mut CMsgSOCacheSubscribed_SubscribedType| { &mut m.object_data },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSOCacheSubscribed_SubscribedType>(
                "CMsgSOCacheSubscribed.SubscribedType",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSOCacheSubscribed_SubscribedType {
        static instance: ::protobuf::rt::LazyV2<CMsgSOCacheSubscribed_SubscribedType> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSOCacheSubscribed_SubscribedType::new)
    }
}

impl ::protobuf::Clear for CMsgSOCacheSubscribed_SubscribedType {
    fn clear(&mut self) {
        self.type_id = ::std::option::Option::None;
        self.object_data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSOCacheSubscribed_SubscribedType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSOCacheSubscribed_SubscribedType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSOCacheSubscribedUpToDate {
    // message fields
    version: ::std::option::Option<u64>,
    pub owner_soid: ::protobuf::SingularPtrField<CMsgSOIDOwner>,
    service_id: ::std::option::Option<u32>,
    pub service_list: ::std::vec::Vec<u32>,
    sync_version: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSOCacheSubscribedUpToDate {
    fn default() -> &'a CMsgSOCacheSubscribedUpToDate {
        <CMsgSOCacheSubscribedUpToDate as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSOCacheSubscribedUpToDate {
    pub fn new() -> CMsgSOCacheSubscribedUpToDate {
        ::std::default::Default::default()
    }

    // optional fixed64 version = 1;


    pub fn get_version(&self) -> u64 {
        self.version.unwrap_or(0)
    }
    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u64) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional .CMsgSOIDOwner owner_soid = 2;


    pub fn get_owner_soid(&self) -> &CMsgSOIDOwner {
        self.owner_soid.as_ref().unwrap_or_else(|| <CMsgSOIDOwner as ::protobuf::Message>::default_instance())
    }
    pub fn clear_owner_soid(&mut self) {
        self.owner_soid.clear();
    }

    pub fn has_owner_soid(&self) -> bool {
        self.owner_soid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner_soid(&mut self, v: CMsgSOIDOwner) {
        self.owner_soid = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner_soid(&mut self) -> &mut CMsgSOIDOwner {
        if self.owner_soid.is_none() {
            self.owner_soid.set_default();
        }
        self.owner_soid.as_mut().unwrap()
    }

    // Take field
    pub fn take_owner_soid(&mut self) -> CMsgSOIDOwner {
        self.owner_soid.take().unwrap_or_else(|| CMsgSOIDOwner::new())
    }

    // optional uint32 service_id = 3;


    pub fn get_service_id(&self) -> u32 {
        self.service_id.unwrap_or(0)
    }
    pub fn clear_service_id(&mut self) {
        self.service_id = ::std::option::Option::None;
    }

    pub fn has_service_id(&self) -> bool {
        self.service_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_service_id(&mut self, v: u32) {
        self.service_id = ::std::option::Option::Some(v);
    }

    // repeated uint32 service_list = 4;


    pub fn get_service_list(&self) -> &[u32] {
        &self.service_list
    }
    pub fn clear_service_list(&mut self) {
        self.service_list.clear();
    }

    // Param is passed by value, moved
    pub fn set_service_list(&mut self, v: ::std::vec::Vec<u32>) {
        self.service_list = v;
    }

    // Mutable pointer to the field.
    pub fn mut_service_list(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.service_list
    }

    // Take field
    pub fn take_service_list(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.service_list, ::std::vec::Vec::new())
    }

    // optional fixed64 sync_version = 5;


    pub fn get_sync_version(&self) -> u64 {
        self.sync_version.unwrap_or(0)
    }
    pub fn clear_sync_version(&mut self) {
        self.sync_version = ::std::option::Option::None;
    }

    pub fn has_sync_version(&self) -> bool {
        self.sync_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sync_version(&mut self, v: u64) {
        self.sync_version = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSOCacheSubscribedUpToDate {
    fn is_initialized(&self) -> bool {
        for v in &self.owner_soid {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.version = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.owner_soid)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.service_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.service_list)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.sync_version = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += 9;
        }
        if let Some(ref v) = self.owner_soid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.service_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.service_list {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.sync_version {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.version {
            os.write_fixed64(1, v)?;
        }
        if let Some(ref v) = self.owner_soid.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.service_id {
            os.write_uint32(3, v)?;
        }
        for v in &self.service_list {
            os.write_uint32(4, *v)?;
        };
        if let Some(v) = self.sync_version {
            os.write_fixed64(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSOCacheSubscribedUpToDate {
        CMsgSOCacheSubscribedUpToDate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "version",
                |m: &CMsgSOCacheSubscribedUpToDate| { &m.version },
                |m: &mut CMsgSOCacheSubscribedUpToDate| { &mut m.version },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgSOIDOwner>>(
                "owner_soid",
                |m: &CMsgSOCacheSubscribedUpToDate| { &m.owner_soid },
                |m: &mut CMsgSOCacheSubscribedUpToDate| { &mut m.owner_soid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "service_id",
                |m: &CMsgSOCacheSubscribedUpToDate| { &m.service_id },
                |m: &mut CMsgSOCacheSubscribedUpToDate| { &mut m.service_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "service_list",
                |m: &CMsgSOCacheSubscribedUpToDate| { &m.service_list },
                |m: &mut CMsgSOCacheSubscribedUpToDate| { &mut m.service_list },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "sync_version",
                |m: &CMsgSOCacheSubscribedUpToDate| { &m.sync_version },
                |m: &mut CMsgSOCacheSubscribedUpToDate| { &mut m.sync_version },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSOCacheSubscribedUpToDate>(
                "CMsgSOCacheSubscribedUpToDate",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSOCacheSubscribedUpToDate {
        static instance: ::protobuf::rt::LazyV2<CMsgSOCacheSubscribedUpToDate> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSOCacheSubscribedUpToDate::new)
    }
}

impl ::protobuf::Clear for CMsgSOCacheSubscribedUpToDate {
    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.owner_soid.clear();
        self.service_id = ::std::option::Option::None;
        self.service_list.clear();
        self.sync_version = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSOCacheSubscribedUpToDate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSOCacheSubscribedUpToDate {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSOCacheUnsubscribed {
    // message fields
    owner: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSOCacheUnsubscribed {
    fn default() -> &'a CMsgSOCacheUnsubscribed {
        <CMsgSOCacheUnsubscribed as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSOCacheUnsubscribed {
    pub fn new() -> CMsgSOCacheUnsubscribed {
        ::std::default::Default::default()
    }

    // optional fixed64 owner = 1;


    pub fn get_owner(&self) -> u64 {
        self.owner.unwrap_or(0)
    }
    pub fn clear_owner(&mut self) {
        self.owner = ::std::option::Option::None;
    }

    pub fn has_owner(&self) -> bool {
        self.owner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner(&mut self, v: u64) {
        self.owner = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSOCacheUnsubscribed {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.owner = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.owner {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.owner {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSOCacheUnsubscribed {
        CMsgSOCacheUnsubscribed::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "owner",
                |m: &CMsgSOCacheUnsubscribed| { &m.owner },
                |m: &mut CMsgSOCacheUnsubscribed| { &mut m.owner },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSOCacheUnsubscribed>(
                "CMsgSOCacheUnsubscribed",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSOCacheUnsubscribed {
        static instance: ::protobuf::rt::LazyV2<CMsgSOCacheUnsubscribed> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSOCacheUnsubscribed::new)
    }
}

impl ::protobuf::Clear for CMsgSOCacheUnsubscribed {
    fn clear(&mut self) {
        self.owner = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSOCacheUnsubscribed {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSOCacheUnsubscribed {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSOCacheSubscriptionCheck {
    // message fields
    owner: ::std::option::Option<u64>,
    version: ::std::option::Option<u64>,
    pub owner_soid: ::protobuf::SingularPtrField<CMsgSOIDOwner>,
    service_id: ::std::option::Option<u32>,
    pub service_list: ::std::vec::Vec<u32>,
    sync_version: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSOCacheSubscriptionCheck {
    fn default() -> &'a CMsgSOCacheSubscriptionCheck {
        <CMsgSOCacheSubscriptionCheck as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSOCacheSubscriptionCheck {
    pub fn new() -> CMsgSOCacheSubscriptionCheck {
        ::std::default::Default::default()
    }

    // optional fixed64 owner = 1;


    pub fn get_owner(&self) -> u64 {
        self.owner.unwrap_or(0)
    }
    pub fn clear_owner(&mut self) {
        self.owner = ::std::option::Option::None;
    }

    pub fn has_owner(&self) -> bool {
        self.owner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner(&mut self, v: u64) {
        self.owner = ::std::option::Option::Some(v);
    }

    // optional fixed64 version = 2;


    pub fn get_version(&self) -> u64 {
        self.version.unwrap_or(0)
    }
    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u64) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional .CMsgSOIDOwner owner_soid = 3;


    pub fn get_owner_soid(&self) -> &CMsgSOIDOwner {
        self.owner_soid.as_ref().unwrap_or_else(|| <CMsgSOIDOwner as ::protobuf::Message>::default_instance())
    }
    pub fn clear_owner_soid(&mut self) {
        self.owner_soid.clear();
    }

    pub fn has_owner_soid(&self) -> bool {
        self.owner_soid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner_soid(&mut self, v: CMsgSOIDOwner) {
        self.owner_soid = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner_soid(&mut self) -> &mut CMsgSOIDOwner {
        if self.owner_soid.is_none() {
            self.owner_soid.set_default();
        }
        self.owner_soid.as_mut().unwrap()
    }

    // Take field
    pub fn take_owner_soid(&mut self) -> CMsgSOIDOwner {
        self.owner_soid.take().unwrap_or_else(|| CMsgSOIDOwner::new())
    }

    // optional uint32 service_id = 4;


    pub fn get_service_id(&self) -> u32 {
        self.service_id.unwrap_or(0)
    }
    pub fn clear_service_id(&mut self) {
        self.service_id = ::std::option::Option::None;
    }

    pub fn has_service_id(&self) -> bool {
        self.service_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_service_id(&mut self, v: u32) {
        self.service_id = ::std::option::Option::Some(v);
    }

    // repeated uint32 service_list = 5;


    pub fn get_service_list(&self) -> &[u32] {
        &self.service_list
    }
    pub fn clear_service_list(&mut self) {
        self.service_list.clear();
    }

    // Param is passed by value, moved
    pub fn set_service_list(&mut self, v: ::std::vec::Vec<u32>) {
        self.service_list = v;
    }

    // Mutable pointer to the field.
    pub fn mut_service_list(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.service_list
    }

    // Take field
    pub fn take_service_list(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.service_list, ::std::vec::Vec::new())
    }

    // optional fixed64 sync_version = 6;


    pub fn get_sync_version(&self) -> u64 {
        self.sync_version.unwrap_or(0)
    }
    pub fn clear_sync_version(&mut self) {
        self.sync_version = ::std::option::Option::None;
    }

    pub fn has_sync_version(&self) -> bool {
        self.sync_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sync_version(&mut self, v: u64) {
        self.sync_version = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSOCacheSubscriptionCheck {
    fn is_initialized(&self) -> bool {
        for v in &self.owner_soid {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.owner = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.version = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.owner_soid)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.service_id = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.service_list)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.sync_version = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.owner {
            my_size += 9;
        }
        if let Some(v) = self.version {
            my_size += 9;
        }
        if let Some(ref v) = self.owner_soid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.service_id {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.service_list {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.sync_version {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.owner {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.version {
            os.write_fixed64(2, v)?;
        }
        if let Some(ref v) = self.owner_soid.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.service_id {
            os.write_uint32(4, v)?;
        }
        for v in &self.service_list {
            os.write_uint32(5, *v)?;
        };
        if let Some(v) = self.sync_version {
            os.write_fixed64(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSOCacheSubscriptionCheck {
        CMsgSOCacheSubscriptionCheck::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "owner",
                |m: &CMsgSOCacheSubscriptionCheck| { &m.owner },
                |m: &mut CMsgSOCacheSubscriptionCheck| { &mut m.owner },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "version",
                |m: &CMsgSOCacheSubscriptionCheck| { &m.version },
                |m: &mut CMsgSOCacheSubscriptionCheck| { &mut m.version },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgSOIDOwner>>(
                "owner_soid",
                |m: &CMsgSOCacheSubscriptionCheck| { &m.owner_soid },
                |m: &mut CMsgSOCacheSubscriptionCheck| { &mut m.owner_soid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "service_id",
                |m: &CMsgSOCacheSubscriptionCheck| { &m.service_id },
                |m: &mut CMsgSOCacheSubscriptionCheck| { &mut m.service_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "service_list",
                |m: &CMsgSOCacheSubscriptionCheck| { &m.service_list },
                |m: &mut CMsgSOCacheSubscriptionCheck| { &mut m.service_list },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "sync_version",
                |m: &CMsgSOCacheSubscriptionCheck| { &m.sync_version },
                |m: &mut CMsgSOCacheSubscriptionCheck| { &mut m.sync_version },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSOCacheSubscriptionCheck>(
                "CMsgSOCacheSubscriptionCheck",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSOCacheSubscriptionCheck {
        static instance: ::protobuf::rt::LazyV2<CMsgSOCacheSubscriptionCheck> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSOCacheSubscriptionCheck::new)
    }
}

impl ::protobuf::Clear for CMsgSOCacheSubscriptionCheck {
    fn clear(&mut self) {
        self.owner = ::std::option::Option::None;
        self.version = ::std::option::Option::None;
        self.owner_soid.clear();
        self.service_id = ::std::option::Option::None;
        self.service_list.clear();
        self.sync_version = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSOCacheSubscriptionCheck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSOCacheSubscriptionCheck {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSOCacheSubscriptionRefresh {
    // message fields
    owner: ::std::option::Option<u64>,
    pub owner_soid: ::protobuf::SingularPtrField<CMsgSOIDOwner>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSOCacheSubscriptionRefresh {
    fn default() -> &'a CMsgSOCacheSubscriptionRefresh {
        <CMsgSOCacheSubscriptionRefresh as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSOCacheSubscriptionRefresh {
    pub fn new() -> CMsgSOCacheSubscriptionRefresh {
        ::std::default::Default::default()
    }

    // optional fixed64 owner = 1;


    pub fn get_owner(&self) -> u64 {
        self.owner.unwrap_or(0)
    }
    pub fn clear_owner(&mut self) {
        self.owner = ::std::option::Option::None;
    }

    pub fn has_owner(&self) -> bool {
        self.owner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner(&mut self, v: u64) {
        self.owner = ::std::option::Option::Some(v);
    }

    // optional .CMsgSOIDOwner owner_soid = 2;


    pub fn get_owner_soid(&self) -> &CMsgSOIDOwner {
        self.owner_soid.as_ref().unwrap_or_else(|| <CMsgSOIDOwner as ::protobuf::Message>::default_instance())
    }
    pub fn clear_owner_soid(&mut self) {
        self.owner_soid.clear();
    }

    pub fn has_owner_soid(&self) -> bool {
        self.owner_soid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner_soid(&mut self, v: CMsgSOIDOwner) {
        self.owner_soid = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner_soid(&mut self) -> &mut CMsgSOIDOwner {
        if self.owner_soid.is_none() {
            self.owner_soid.set_default();
        }
        self.owner_soid.as_mut().unwrap()
    }

    // Take field
    pub fn take_owner_soid(&mut self) -> CMsgSOIDOwner {
        self.owner_soid.take().unwrap_or_else(|| CMsgSOIDOwner::new())
    }
}

impl ::protobuf::Message for CMsgSOCacheSubscriptionRefresh {
    fn is_initialized(&self) -> bool {
        for v in &self.owner_soid {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.owner = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.owner_soid)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.owner {
            my_size += 9;
        }
        if let Some(ref v) = self.owner_soid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.owner {
            os.write_fixed64(1, v)?;
        }
        if let Some(ref v) = self.owner_soid.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSOCacheSubscriptionRefresh {
        CMsgSOCacheSubscriptionRefresh::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "owner",
                |m: &CMsgSOCacheSubscriptionRefresh| { &m.owner },
                |m: &mut CMsgSOCacheSubscriptionRefresh| { &mut m.owner },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgSOIDOwner>>(
                "owner_soid",
                |m: &CMsgSOCacheSubscriptionRefresh| { &m.owner_soid },
                |m: &mut CMsgSOCacheSubscriptionRefresh| { &mut m.owner_soid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSOCacheSubscriptionRefresh>(
                "CMsgSOCacheSubscriptionRefresh",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSOCacheSubscriptionRefresh {
        static instance: ::protobuf::rt::LazyV2<CMsgSOCacheSubscriptionRefresh> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSOCacheSubscriptionRefresh::new)
    }
}

impl ::protobuf::Clear for CMsgSOCacheSubscriptionRefresh {
    fn clear(&mut self) {
        self.owner = ::std::option::Option::None;
        self.owner_soid.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSOCacheSubscriptionRefresh {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSOCacheSubscriptionRefresh {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSOCacheVersion {
    // message fields
    version: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSOCacheVersion {
    fn default() -> &'a CMsgSOCacheVersion {
        <CMsgSOCacheVersion as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSOCacheVersion {
    pub fn new() -> CMsgSOCacheVersion {
        ::std::default::Default::default()
    }

    // optional fixed64 version = 1;


    pub fn get_version(&self) -> u64 {
        self.version.unwrap_or(0)
    }
    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u64) {
        self.version = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSOCacheVersion {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.version = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.version {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSOCacheVersion {
        CMsgSOCacheVersion::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "version",
                |m: &CMsgSOCacheVersion| { &m.version },
                |m: &mut CMsgSOCacheVersion| { &mut m.version },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSOCacheVersion>(
                "CMsgSOCacheVersion",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSOCacheVersion {
        static instance: ::protobuf::rt::LazyV2<CMsgSOCacheVersion> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSOCacheVersion::new)
    }
}

impl ::protobuf::Clear for CMsgSOCacheVersion {
    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSOCacheVersion {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSOCacheVersion {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCMultiplexMessage {
    // message fields
    msgtype: ::std::option::Option<u32>,
    payload: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub steamids: ::std::vec::Vec<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCMultiplexMessage {
    fn default() -> &'a CMsgGCMultiplexMessage {
        <CMsgGCMultiplexMessage as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCMultiplexMessage {
    pub fn new() -> CMsgGCMultiplexMessage {
        ::std::default::Default::default()
    }

    // optional uint32 msgtype = 1;


    pub fn get_msgtype(&self) -> u32 {
        self.msgtype.unwrap_or(0)
    }
    pub fn clear_msgtype(&mut self) {
        self.msgtype = ::std::option::Option::None;
    }

    pub fn has_msgtype(&self) -> bool {
        self.msgtype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msgtype(&mut self, v: u32) {
        self.msgtype = ::std::option::Option::Some(v);
    }

    // optional bytes payload = 2;


    pub fn get_payload(&self) -> &[u8] {
        match self.payload.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_payload(&mut self) {
        self.payload.clear();
    }

    pub fn has_payload(&self) -> bool {
        self.payload.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payload(&mut self, v: ::std::vec::Vec<u8>) {
        self.payload = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payload(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.payload.is_none() {
            self.payload.set_default();
        }
        self.payload.as_mut().unwrap()
    }

    // Take field
    pub fn take_payload(&mut self) -> ::std::vec::Vec<u8> {
        self.payload.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // repeated fixed64 steamids = 3;


    pub fn get_steamids(&self) -> &[u64] {
        &self.steamids
    }
    pub fn clear_steamids(&mut self) {
        self.steamids.clear();
    }

    // Param is passed by value, moved
    pub fn set_steamids(&mut self, v: ::std::vec::Vec<u64>) {
        self.steamids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_steamids(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.steamids
    }

    // Take field
    pub fn take_steamids(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.steamids, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgGCMultiplexMessage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.msgtype = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.payload)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_fixed64_into(wire_type, is, &mut self.steamids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.msgtype {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.payload.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += 9 * self.steamids.len() as u32;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.msgtype {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.payload.as_ref() {
            os.write_bytes(2, &v)?;
        }
        for v in &self.steamids {
            os.write_fixed64(3, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCMultiplexMessage {
        CMsgGCMultiplexMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "msgtype",
                |m: &CMsgGCMultiplexMessage| { &m.msgtype },
                |m: &mut CMsgGCMultiplexMessage| { &mut m.msgtype },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "payload",
                |m: &CMsgGCMultiplexMessage| { &m.payload },
                |m: &mut CMsgGCMultiplexMessage| { &mut m.payload },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steamids",
                |m: &CMsgGCMultiplexMessage| { &m.steamids },
                |m: &mut CMsgGCMultiplexMessage| { &mut m.steamids },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCMultiplexMessage>(
                "CMsgGCMultiplexMessage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCMultiplexMessage {
        static instance: ::protobuf::rt::LazyV2<CMsgGCMultiplexMessage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCMultiplexMessage::new)
    }
}

impl ::protobuf::Clear for CMsgGCMultiplexMessage {
    fn clear(&mut self) {
        self.msgtype = ::std::option::Option::None;
        self.payload.clear();
        self.steamids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCMultiplexMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCMultiplexMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CGCToGCMsgMasterAck {
    // message fields
    dir_index: ::std::option::Option<u32>,
    machine_name: ::protobuf::SingularField<::std::string::String>,
    process_name: ::protobuf::SingularField<::std::string::String>,
    pub type_instances: ::std::vec::Vec<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CGCToGCMsgMasterAck {
    fn default() -> &'a CGCToGCMsgMasterAck {
        <CGCToGCMsgMasterAck as ::protobuf::Message>::default_instance()
    }
}

impl CGCToGCMsgMasterAck {
    pub fn new() -> CGCToGCMsgMasterAck {
        ::std::default::Default::default()
    }

    // optional uint32 dir_index = 1;


    pub fn get_dir_index(&self) -> u32 {
        self.dir_index.unwrap_or(0)
    }
    pub fn clear_dir_index(&mut self) {
        self.dir_index = ::std::option::Option::None;
    }

    pub fn has_dir_index(&self) -> bool {
        self.dir_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dir_index(&mut self, v: u32) {
        self.dir_index = ::std::option::Option::Some(v);
    }

    // optional string machine_name = 3;


    pub fn get_machine_name(&self) -> &str {
        match self.machine_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_machine_name(&mut self) {
        self.machine_name.clear();
    }

    pub fn has_machine_name(&self) -> bool {
        self.machine_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_machine_name(&mut self, v: ::std::string::String) {
        self.machine_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_machine_name(&mut self) -> &mut ::std::string::String {
        if self.machine_name.is_none() {
            self.machine_name.set_default();
        }
        self.machine_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_machine_name(&mut self) -> ::std::string::String {
        self.machine_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string process_name = 4;


    pub fn get_process_name(&self) -> &str {
        match self.process_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_process_name(&mut self) {
        self.process_name.clear();
    }

    pub fn has_process_name(&self) -> bool {
        self.process_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_process_name(&mut self, v: ::std::string::String) {
        self.process_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_process_name(&mut self) -> &mut ::std::string::String {
        if self.process_name.is_none() {
            self.process_name.set_default();
        }
        self.process_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_process_name(&mut self) -> ::std::string::String {
        self.process_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated uint32 type_instances = 5;


    pub fn get_type_instances(&self) -> &[u32] {
        &self.type_instances
    }
    pub fn clear_type_instances(&mut self) {
        self.type_instances.clear();
    }

    // Param is passed by value, moved
    pub fn set_type_instances(&mut self, v: ::std::vec::Vec<u32>) {
        self.type_instances = v;
    }

    // Mutable pointer to the field.
    pub fn mut_type_instances(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.type_instances
    }

    // Take field
    pub fn take_type_instances(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.type_instances, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CGCToGCMsgMasterAck {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.dir_index = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.machine_name)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.process_name)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.type_instances)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.dir_index {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.machine_name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.process_name.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        for value in &self.type_instances {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.dir_index {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.machine_name.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.process_name.as_ref() {
            os.write_string(4, &v)?;
        }
        for v in &self.type_instances {
            os.write_uint32(5, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CGCToGCMsgMasterAck {
        CGCToGCMsgMasterAck::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "dir_index",
                |m: &CGCToGCMsgMasterAck| { &m.dir_index },
                |m: &mut CGCToGCMsgMasterAck| { &mut m.dir_index },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "machine_name",
                |m: &CGCToGCMsgMasterAck| { &m.machine_name },
                |m: &mut CGCToGCMsgMasterAck| { &mut m.machine_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "process_name",
                |m: &CGCToGCMsgMasterAck| { &m.process_name },
                |m: &mut CGCToGCMsgMasterAck| { &mut m.process_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "type_instances",
                |m: &CGCToGCMsgMasterAck| { &m.type_instances },
                |m: &mut CGCToGCMsgMasterAck| { &mut m.type_instances },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CGCToGCMsgMasterAck>(
                "CGCToGCMsgMasterAck",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CGCToGCMsgMasterAck {
        static instance: ::protobuf::rt::LazyV2<CGCToGCMsgMasterAck> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CGCToGCMsgMasterAck::new)
    }
}

impl ::protobuf::Clear for CGCToGCMsgMasterAck {
    fn clear(&mut self) {
        self.dir_index = ::std::option::Option::None;
        self.machine_name.clear();
        self.process_name.clear();
        self.type_instances.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CGCToGCMsgMasterAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CGCToGCMsgMasterAck {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CGCToGCMsgMasterAck_Response {
    // message fields
    eresult: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CGCToGCMsgMasterAck_Response {
    fn default() -> &'a CGCToGCMsgMasterAck_Response {
        <CGCToGCMsgMasterAck_Response as ::protobuf::Message>::default_instance()
    }
}

impl CGCToGCMsgMasterAck_Response {
    pub fn new() -> CGCToGCMsgMasterAck_Response {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;


    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }
    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CGCToGCMsgMasterAck_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CGCToGCMsgMasterAck_Response {
        CGCToGCMsgMasterAck_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "eresult",
                |m: &CGCToGCMsgMasterAck_Response| { &m.eresult },
                |m: &mut CGCToGCMsgMasterAck_Response| { &mut m.eresult },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CGCToGCMsgMasterAck_Response>(
                "CGCToGCMsgMasterAck_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CGCToGCMsgMasterAck_Response {
        static instance: ::protobuf::rt::LazyV2<CGCToGCMsgMasterAck_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CGCToGCMsgMasterAck_Response::new)
    }
}

impl ::protobuf::Clear for CGCToGCMsgMasterAck_Response {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CGCToGCMsgMasterAck_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CGCToGCMsgMasterAck_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CGCToGCMsgMasterStartupComplete {
    // message fields
    pub gc_info: ::protobuf::RepeatedField<CGCToGCMsgMasterStartupComplete_GCInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CGCToGCMsgMasterStartupComplete {
    fn default() -> &'a CGCToGCMsgMasterStartupComplete {
        <CGCToGCMsgMasterStartupComplete as ::protobuf::Message>::default_instance()
    }
}

impl CGCToGCMsgMasterStartupComplete {
    pub fn new() -> CGCToGCMsgMasterStartupComplete {
        ::std::default::Default::default()
    }

    // repeated .CGCToGCMsgMasterStartupComplete.GCInfo gc_info = 1;


    pub fn get_gc_info(&self) -> &[CGCToGCMsgMasterStartupComplete_GCInfo] {
        &self.gc_info
    }
    pub fn clear_gc_info(&mut self) {
        self.gc_info.clear();
    }

    // Param is passed by value, moved
    pub fn set_gc_info(&mut self, v: ::protobuf::RepeatedField<CGCToGCMsgMasterStartupComplete_GCInfo>) {
        self.gc_info = v;
    }

    // Mutable pointer to the field.
    pub fn mut_gc_info(&mut self) -> &mut ::protobuf::RepeatedField<CGCToGCMsgMasterStartupComplete_GCInfo> {
        &mut self.gc_info
    }

    // Take field
    pub fn take_gc_info(&mut self) -> ::protobuf::RepeatedField<CGCToGCMsgMasterStartupComplete_GCInfo> {
        ::std::mem::replace(&mut self.gc_info, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CGCToGCMsgMasterStartupComplete {
    fn is_initialized(&self) -> bool {
        for v in &self.gc_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.gc_info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.gc_info {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.gc_info {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CGCToGCMsgMasterStartupComplete {
        CGCToGCMsgMasterStartupComplete::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CGCToGCMsgMasterStartupComplete_GCInfo>>(
                "gc_info",
                |m: &CGCToGCMsgMasterStartupComplete| { &m.gc_info },
                |m: &mut CGCToGCMsgMasterStartupComplete| { &mut m.gc_info },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CGCToGCMsgMasterStartupComplete>(
                "CGCToGCMsgMasterStartupComplete",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CGCToGCMsgMasterStartupComplete {
        static instance: ::protobuf::rt::LazyV2<CGCToGCMsgMasterStartupComplete> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CGCToGCMsgMasterStartupComplete::new)
    }
}

impl ::protobuf::Clear for CGCToGCMsgMasterStartupComplete {
    fn clear(&mut self) {
        self.gc_info.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CGCToGCMsgMasterStartupComplete {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CGCToGCMsgMasterStartupComplete {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CGCToGCMsgMasterStartupComplete_GCInfo {
    // message fields
    dir_index: ::std::option::Option<u32>,
    machine_name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CGCToGCMsgMasterStartupComplete_GCInfo {
    fn default() -> &'a CGCToGCMsgMasterStartupComplete_GCInfo {
        <CGCToGCMsgMasterStartupComplete_GCInfo as ::protobuf::Message>::default_instance()
    }
}

impl CGCToGCMsgMasterStartupComplete_GCInfo {
    pub fn new() -> CGCToGCMsgMasterStartupComplete_GCInfo {
        ::std::default::Default::default()
    }

    // optional uint32 dir_index = 1;


    pub fn get_dir_index(&self) -> u32 {
        self.dir_index.unwrap_or(0)
    }
    pub fn clear_dir_index(&mut self) {
        self.dir_index = ::std::option::Option::None;
    }

    pub fn has_dir_index(&self) -> bool {
        self.dir_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dir_index(&mut self, v: u32) {
        self.dir_index = ::std::option::Option::Some(v);
    }

    // optional string machine_name = 2;


    pub fn get_machine_name(&self) -> &str {
        match self.machine_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_machine_name(&mut self) {
        self.machine_name.clear();
    }

    pub fn has_machine_name(&self) -> bool {
        self.machine_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_machine_name(&mut self, v: ::std::string::String) {
        self.machine_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_machine_name(&mut self) -> &mut ::std::string::String {
        if self.machine_name.is_none() {
            self.machine_name.set_default();
        }
        self.machine_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_machine_name(&mut self) -> ::std::string::String {
        self.machine_name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CGCToGCMsgMasterStartupComplete_GCInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.dir_index = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.machine_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.dir_index {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.machine_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.dir_index {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.machine_name.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CGCToGCMsgMasterStartupComplete_GCInfo {
        CGCToGCMsgMasterStartupComplete_GCInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "dir_index",
                |m: &CGCToGCMsgMasterStartupComplete_GCInfo| { &m.dir_index },
                |m: &mut CGCToGCMsgMasterStartupComplete_GCInfo| { &mut m.dir_index },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "machine_name",
                |m: &CGCToGCMsgMasterStartupComplete_GCInfo| { &m.machine_name },
                |m: &mut CGCToGCMsgMasterStartupComplete_GCInfo| { &mut m.machine_name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CGCToGCMsgMasterStartupComplete_GCInfo>(
                "CGCToGCMsgMasterStartupComplete.GCInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CGCToGCMsgMasterStartupComplete_GCInfo {
        static instance: ::protobuf::rt::LazyV2<CGCToGCMsgMasterStartupComplete_GCInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CGCToGCMsgMasterStartupComplete_GCInfo::new)
    }
}

impl ::protobuf::Clear for CGCToGCMsgMasterStartupComplete_GCInfo {
    fn clear(&mut self) {
        self.dir_index = ::std::option::Option::None;
        self.machine_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CGCToGCMsgMasterStartupComplete_GCInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CGCToGCMsgMasterStartupComplete_GCInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CGCToGCMsgRouted {
    // message fields
    msg_type: ::std::option::Option<u32>,
    sender_id: ::std::option::Option<u64>,
    net_message: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CGCToGCMsgRouted {
    fn default() -> &'a CGCToGCMsgRouted {
        <CGCToGCMsgRouted as ::protobuf::Message>::default_instance()
    }
}

impl CGCToGCMsgRouted {
    pub fn new() -> CGCToGCMsgRouted {
        ::std::default::Default::default()
    }

    // optional uint32 msg_type = 1;


    pub fn get_msg_type(&self) -> u32 {
        self.msg_type.unwrap_or(0)
    }
    pub fn clear_msg_type(&mut self) {
        self.msg_type = ::std::option::Option::None;
    }

    pub fn has_msg_type(&self) -> bool {
        self.msg_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msg_type(&mut self, v: u32) {
        self.msg_type = ::std::option::Option::Some(v);
    }

    // optional fixed64 sender_id = 2;


    pub fn get_sender_id(&self) -> u64 {
        self.sender_id.unwrap_or(0)
    }
    pub fn clear_sender_id(&mut self) {
        self.sender_id = ::std::option::Option::None;
    }

    pub fn has_sender_id(&self) -> bool {
        self.sender_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sender_id(&mut self, v: u64) {
        self.sender_id = ::std::option::Option::Some(v);
    }

    // optional bytes net_message = 3;


    pub fn get_net_message(&self) -> &[u8] {
        match self.net_message.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_net_message(&mut self) {
        self.net_message.clear();
    }

    pub fn has_net_message(&self) -> bool {
        self.net_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_net_message(&mut self, v: ::std::vec::Vec<u8>) {
        self.net_message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_net_message(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.net_message.is_none() {
            self.net_message.set_default();
        }
        self.net_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_net_message(&mut self) -> ::std::vec::Vec<u8> {
        self.net_message.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CGCToGCMsgRouted {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.msg_type = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.sender_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.net_message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.msg_type {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.sender_id {
            my_size += 9;
        }
        if let Some(ref v) = self.net_message.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.msg_type {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.sender_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(ref v) = self.net_message.as_ref() {
            os.write_bytes(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CGCToGCMsgRouted {
        CGCToGCMsgRouted::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "msg_type",
                |m: &CGCToGCMsgRouted| { &m.msg_type },
                |m: &mut CGCToGCMsgRouted| { &mut m.msg_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "sender_id",
                |m: &CGCToGCMsgRouted| { &m.sender_id },
                |m: &mut CGCToGCMsgRouted| { &mut m.sender_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "net_message",
                |m: &CGCToGCMsgRouted| { &m.net_message },
                |m: &mut CGCToGCMsgRouted| { &mut m.net_message },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CGCToGCMsgRouted>(
                "CGCToGCMsgRouted",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CGCToGCMsgRouted {
        static instance: ::protobuf::rt::LazyV2<CGCToGCMsgRouted> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CGCToGCMsgRouted::new)
    }
}

impl ::protobuf::Clear for CGCToGCMsgRouted {
    fn clear(&mut self) {
        self.msg_type = ::std::option::Option::None;
        self.sender_id = ::std::option::Option::None;
        self.net_message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CGCToGCMsgRouted {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CGCToGCMsgRouted {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CGCToGCMsgRoutedReply {
    // message fields
    msg_type: ::std::option::Option<u32>,
    net_message: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CGCToGCMsgRoutedReply {
    fn default() -> &'a CGCToGCMsgRoutedReply {
        <CGCToGCMsgRoutedReply as ::protobuf::Message>::default_instance()
    }
}

impl CGCToGCMsgRoutedReply {
    pub fn new() -> CGCToGCMsgRoutedReply {
        ::std::default::Default::default()
    }

    // optional uint32 msg_type = 1;


    pub fn get_msg_type(&self) -> u32 {
        self.msg_type.unwrap_or(0)
    }
    pub fn clear_msg_type(&mut self) {
        self.msg_type = ::std::option::Option::None;
    }

    pub fn has_msg_type(&self) -> bool {
        self.msg_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msg_type(&mut self, v: u32) {
        self.msg_type = ::std::option::Option::Some(v);
    }

    // optional bytes net_message = 2;


    pub fn get_net_message(&self) -> &[u8] {
        match self.net_message.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_net_message(&mut self) {
        self.net_message.clear();
    }

    pub fn has_net_message(&self) -> bool {
        self.net_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_net_message(&mut self, v: ::std::vec::Vec<u8>) {
        self.net_message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_net_message(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.net_message.is_none() {
            self.net_message.set_default();
        }
        self.net_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_net_message(&mut self) -> ::std::vec::Vec<u8> {
        self.net_message.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CGCToGCMsgRoutedReply {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.msg_type = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.net_message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.msg_type {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.net_message.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.msg_type {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.net_message.as_ref() {
            os.write_bytes(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CGCToGCMsgRoutedReply {
        CGCToGCMsgRoutedReply::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "msg_type",
                |m: &CGCToGCMsgRoutedReply| { &m.msg_type },
                |m: &mut CGCToGCMsgRoutedReply| { &mut m.msg_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "net_message",
                |m: &CGCToGCMsgRoutedReply| { &m.net_message },
                |m: &mut CGCToGCMsgRoutedReply| { &mut m.net_message },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CGCToGCMsgRoutedReply>(
                "CGCToGCMsgRoutedReply",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CGCToGCMsgRoutedReply {
        static instance: ::protobuf::rt::LazyV2<CGCToGCMsgRoutedReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CGCToGCMsgRoutedReply::new)
    }
}

impl ::protobuf::Clear for CGCToGCMsgRoutedReply {
    fn clear(&mut self) {
        self.msg_type = ::std::option::Option::None;
        self.net_message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CGCToGCMsgRoutedReply {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CGCToGCMsgRoutedReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCUpdateSubGCSessionInfo {
    // message fields
    pub updates: ::protobuf::RepeatedField<CMsgGCUpdateSubGCSessionInfo_CMsgUpdate>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCUpdateSubGCSessionInfo {
    fn default() -> &'a CMsgGCUpdateSubGCSessionInfo {
        <CMsgGCUpdateSubGCSessionInfo as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCUpdateSubGCSessionInfo {
    pub fn new() -> CMsgGCUpdateSubGCSessionInfo {
        ::std::default::Default::default()
    }

    // repeated .CMsgGCUpdateSubGCSessionInfo.CMsgUpdate updates = 1;


    pub fn get_updates(&self) -> &[CMsgGCUpdateSubGCSessionInfo_CMsgUpdate] {
        &self.updates
    }
    pub fn clear_updates(&mut self) {
        self.updates.clear();
    }

    // Param is passed by value, moved
    pub fn set_updates(&mut self, v: ::protobuf::RepeatedField<CMsgGCUpdateSubGCSessionInfo_CMsgUpdate>) {
        self.updates = v;
    }

    // Mutable pointer to the field.
    pub fn mut_updates(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGCUpdateSubGCSessionInfo_CMsgUpdate> {
        &mut self.updates
    }

    // Take field
    pub fn take_updates(&mut self) -> ::protobuf::RepeatedField<CMsgGCUpdateSubGCSessionInfo_CMsgUpdate> {
        ::std::mem::replace(&mut self.updates, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgGCUpdateSubGCSessionInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.updates {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.updates)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.updates {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.updates {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCUpdateSubGCSessionInfo {
        CMsgGCUpdateSubGCSessionInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCUpdateSubGCSessionInfo_CMsgUpdate>>(
                "updates",
                |m: &CMsgGCUpdateSubGCSessionInfo| { &m.updates },
                |m: &mut CMsgGCUpdateSubGCSessionInfo| { &mut m.updates },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCUpdateSubGCSessionInfo>(
                "CMsgGCUpdateSubGCSessionInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCUpdateSubGCSessionInfo {
        static instance: ::protobuf::rt::LazyV2<CMsgGCUpdateSubGCSessionInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCUpdateSubGCSessionInfo::new)
    }
}

impl ::protobuf::Clear for CMsgGCUpdateSubGCSessionInfo {
    fn clear(&mut self) {
        self.updates.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCUpdateSubGCSessionInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCUpdateSubGCSessionInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCUpdateSubGCSessionInfo_CMsgUpdate {
    // message fields
    steamid: ::std::option::Option<u64>,
    ip: ::std::option::Option<u32>,
    trusted: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCUpdateSubGCSessionInfo_CMsgUpdate {
    fn default() -> &'a CMsgGCUpdateSubGCSessionInfo_CMsgUpdate {
        <CMsgGCUpdateSubGCSessionInfo_CMsgUpdate as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCUpdateSubGCSessionInfo_CMsgUpdate {
    pub fn new() -> CMsgGCUpdateSubGCSessionInfo_CMsgUpdate {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;


    pub fn get_steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }
    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional fixed32 ip = 2;


    pub fn get_ip(&self) -> u32 {
        self.ip.unwrap_or(0)
    }
    pub fn clear_ip(&mut self) {
        self.ip = ::std::option::Option::None;
    }

    pub fn has_ip(&self) -> bool {
        self.ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ip(&mut self, v: u32) {
        self.ip = ::std::option::Option::Some(v);
    }

    // optional bool trusted = 3;


    pub fn get_trusted(&self) -> bool {
        self.trusted.unwrap_or(false)
    }
    pub fn clear_trusted(&mut self) {
        self.trusted = ::std::option::Option::None;
    }

    pub fn has_trusted(&self) -> bool {
        self.trusted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trusted(&mut self, v: bool) {
        self.trusted = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCUpdateSubGCSessionInfo_CMsgUpdate {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.ip = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.trusted = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 9;
        }
        if let Some(v) = self.ip {
            my_size += 5;
        }
        if let Some(v) = self.trusted {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.ip {
            os.write_fixed32(2, v)?;
        }
        if let Some(v) = self.trusted {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCUpdateSubGCSessionInfo_CMsgUpdate {
        CMsgGCUpdateSubGCSessionInfo_CMsgUpdate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steamid",
                |m: &CMsgGCUpdateSubGCSessionInfo_CMsgUpdate| { &m.steamid },
                |m: &mut CMsgGCUpdateSubGCSessionInfo_CMsgUpdate| { &mut m.steamid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "ip",
                |m: &CMsgGCUpdateSubGCSessionInfo_CMsgUpdate| { &m.ip },
                |m: &mut CMsgGCUpdateSubGCSessionInfo_CMsgUpdate| { &mut m.ip },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "trusted",
                |m: &CMsgGCUpdateSubGCSessionInfo_CMsgUpdate| { &m.trusted },
                |m: &mut CMsgGCUpdateSubGCSessionInfo_CMsgUpdate| { &mut m.trusted },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCUpdateSubGCSessionInfo_CMsgUpdate>(
                "CMsgGCUpdateSubGCSessionInfo.CMsgUpdate",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCUpdateSubGCSessionInfo_CMsgUpdate {
        static instance: ::protobuf::rt::LazyV2<CMsgGCUpdateSubGCSessionInfo_CMsgUpdate> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCUpdateSubGCSessionInfo_CMsgUpdate::new)
    }
}

impl ::protobuf::Clear for CMsgGCUpdateSubGCSessionInfo_CMsgUpdate {
    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.ip = ::std::option::Option::None;
        self.trusted = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCUpdateSubGCSessionInfo_CMsgUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCUpdateSubGCSessionInfo_CMsgUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCRequestSubGCSessionInfo {
    // message fields
    steamid: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCRequestSubGCSessionInfo {
    fn default() -> &'a CMsgGCRequestSubGCSessionInfo {
        <CMsgGCRequestSubGCSessionInfo as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCRequestSubGCSessionInfo {
    pub fn new() -> CMsgGCRequestSubGCSessionInfo {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;


    pub fn get_steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }
    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCRequestSubGCSessionInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCRequestSubGCSessionInfo {
        CMsgGCRequestSubGCSessionInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steamid",
                |m: &CMsgGCRequestSubGCSessionInfo| { &m.steamid },
                |m: &mut CMsgGCRequestSubGCSessionInfo| { &mut m.steamid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCRequestSubGCSessionInfo>(
                "CMsgGCRequestSubGCSessionInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCRequestSubGCSessionInfo {
        static instance: ::protobuf::rt::LazyV2<CMsgGCRequestSubGCSessionInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCRequestSubGCSessionInfo::new)
    }
}

impl ::protobuf::Clear for CMsgGCRequestSubGCSessionInfo {
    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCRequestSubGCSessionInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCRequestSubGCSessionInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCRequestSubGCSessionInfoResponse {
    // message fields
    ip: ::std::option::Option<u32>,
    trusted: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCRequestSubGCSessionInfoResponse {
    fn default() -> &'a CMsgGCRequestSubGCSessionInfoResponse {
        <CMsgGCRequestSubGCSessionInfoResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCRequestSubGCSessionInfoResponse {
    pub fn new() -> CMsgGCRequestSubGCSessionInfoResponse {
        ::std::default::Default::default()
    }

    // optional fixed32 ip = 1;


    pub fn get_ip(&self) -> u32 {
        self.ip.unwrap_or(0)
    }
    pub fn clear_ip(&mut self) {
        self.ip = ::std::option::Option::None;
    }

    pub fn has_ip(&self) -> bool {
        self.ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ip(&mut self, v: u32) {
        self.ip = ::std::option::Option::Some(v);
    }

    // optional bool trusted = 2;


    pub fn get_trusted(&self) -> bool {
        self.trusted.unwrap_or(false)
    }
    pub fn clear_trusted(&mut self) {
        self.trusted = ::std::option::Option::None;
    }

    pub fn has_trusted(&self) -> bool {
        self.trusted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trusted(&mut self, v: bool) {
        self.trusted = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCRequestSubGCSessionInfoResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.ip = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.trusted = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.ip {
            my_size += 5;
        }
        if let Some(v) = self.trusted {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.ip {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.trusted {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCRequestSubGCSessionInfoResponse {
        CMsgGCRequestSubGCSessionInfoResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "ip",
                |m: &CMsgGCRequestSubGCSessionInfoResponse| { &m.ip },
                |m: &mut CMsgGCRequestSubGCSessionInfoResponse| { &mut m.ip },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "trusted",
                |m: &CMsgGCRequestSubGCSessionInfoResponse| { &m.trusted },
                |m: &mut CMsgGCRequestSubGCSessionInfoResponse| { &mut m.trusted },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCRequestSubGCSessionInfoResponse>(
                "CMsgGCRequestSubGCSessionInfoResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCRequestSubGCSessionInfoResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgGCRequestSubGCSessionInfoResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCRequestSubGCSessionInfoResponse::new)
    }
}

impl ::protobuf::Clear for CMsgGCRequestSubGCSessionInfoResponse {
    fn clear(&mut self) {
        self.ip = ::std::option::Option::None;
        self.trusted = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCRequestSubGCSessionInfoResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCRequestSubGCSessionInfoResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToGCIncrementRecruitmentLevel {
    // message fields
    steamid: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCIncrementRecruitmentLevel {
    fn default() -> &'a CMsgGCToGCIncrementRecruitmentLevel {
        <CMsgGCToGCIncrementRecruitmentLevel as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCIncrementRecruitmentLevel {
    pub fn new() -> CMsgGCToGCIncrementRecruitmentLevel {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;


    pub fn get_steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }
    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCToGCIncrementRecruitmentLevel {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCToGCIncrementRecruitmentLevel {
        CMsgGCToGCIncrementRecruitmentLevel::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steamid",
                |m: &CMsgGCToGCIncrementRecruitmentLevel| { &m.steamid },
                |m: &mut CMsgGCToGCIncrementRecruitmentLevel| { &mut m.steamid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCToGCIncrementRecruitmentLevel>(
                "CMsgGCToGCIncrementRecruitmentLevel",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCToGCIncrementRecruitmentLevel {
        static instance: ::protobuf::rt::LazyV2<CMsgGCToGCIncrementRecruitmentLevel> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCToGCIncrementRecruitmentLevel::new)
    }
}

impl ::protobuf::Clear for CMsgGCToGCIncrementRecruitmentLevel {
    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToGCIncrementRecruitmentLevel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCIncrementRecruitmentLevel {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSOCacheHaveVersion {
    // message fields
    pub soid: ::protobuf::SingularPtrField<CMsgSOIDOwner>,
    version: ::std::option::Option<u64>,
    service_id: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSOCacheHaveVersion {
    fn default() -> &'a CMsgSOCacheHaveVersion {
        <CMsgSOCacheHaveVersion as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSOCacheHaveVersion {
    pub fn new() -> CMsgSOCacheHaveVersion {
        ::std::default::Default::default()
    }

    // optional .CMsgSOIDOwner soid = 1;


    pub fn get_soid(&self) -> &CMsgSOIDOwner {
        self.soid.as_ref().unwrap_or_else(|| <CMsgSOIDOwner as ::protobuf::Message>::default_instance())
    }
    pub fn clear_soid(&mut self) {
        self.soid.clear();
    }

    pub fn has_soid(&self) -> bool {
        self.soid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_soid(&mut self, v: CMsgSOIDOwner) {
        self.soid = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_soid(&mut self) -> &mut CMsgSOIDOwner {
        if self.soid.is_none() {
            self.soid.set_default();
        }
        self.soid.as_mut().unwrap()
    }

    // Take field
    pub fn take_soid(&mut self) -> CMsgSOIDOwner {
        self.soid.take().unwrap_or_else(|| CMsgSOIDOwner::new())
    }

    // optional fixed64 version = 2;


    pub fn get_version(&self) -> u64 {
        self.version.unwrap_or(0)
    }
    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u64) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional uint32 service_id = 3;


    pub fn get_service_id(&self) -> u32 {
        self.service_id.unwrap_or(0)
    }
    pub fn clear_service_id(&mut self) {
        self.service_id = ::std::option::Option::None;
    }

    pub fn has_service_id(&self) -> bool {
        self.service_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_service_id(&mut self, v: u32) {
        self.service_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSOCacheHaveVersion {
    fn is_initialized(&self) -> bool {
        for v in &self.soid {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.soid)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.version = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.service_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.soid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.version {
            my_size += 9;
        }
        if let Some(v) = self.service_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.soid.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.version {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.service_id {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSOCacheHaveVersion {
        CMsgSOCacheHaveVersion::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgSOIDOwner>>(
                "soid",
                |m: &CMsgSOCacheHaveVersion| { &m.soid },
                |m: &mut CMsgSOCacheHaveVersion| { &mut m.soid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "version",
                |m: &CMsgSOCacheHaveVersion| { &m.version },
                |m: &mut CMsgSOCacheHaveVersion| { &mut m.version },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "service_id",
                |m: &CMsgSOCacheHaveVersion| { &m.service_id },
                |m: &mut CMsgSOCacheHaveVersion| { &mut m.service_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSOCacheHaveVersion>(
                "CMsgSOCacheHaveVersion",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSOCacheHaveVersion {
        static instance: ::protobuf::rt::LazyV2<CMsgSOCacheHaveVersion> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSOCacheHaveVersion::new)
    }
}

impl ::protobuf::Clear for CMsgSOCacheHaveVersion {
    fn clear(&mut self) {
        self.soid.clear();
        self.version = ::std::option::Option::None;
        self.service_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSOCacheHaveVersion {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSOCacheHaveVersion {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgConnectionStatus {
    // message fields
    status: ::std::option::Option<GCConnectionStatus>,
    client_session_need: ::std::option::Option<u32>,
    queue_position: ::std::option::Option<i32>,
    queue_size: ::std::option::Option<i32>,
    wait_seconds: ::std::option::Option<i32>,
    estimated_wait_seconds_remaining: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgConnectionStatus {
    fn default() -> &'a CMsgConnectionStatus {
        <CMsgConnectionStatus as ::protobuf::Message>::default_instance()
    }
}

impl CMsgConnectionStatus {
    pub fn new() -> CMsgConnectionStatus {
        ::std::default::Default::default()
    }

    // optional .GCConnectionStatus status = 1;


    pub fn get_status(&self) -> GCConnectionStatus {
        self.status.unwrap_or(GCConnectionStatus::GCConnectionStatus_HAVE_SESSION)
    }
    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: GCConnectionStatus) {
        self.status = ::std::option::Option::Some(v);
    }

    // optional uint32 client_session_need = 2;


    pub fn get_client_session_need(&self) -> u32 {
        self.client_session_need.unwrap_or(0)
    }
    pub fn clear_client_session_need(&mut self) {
        self.client_session_need = ::std::option::Option::None;
    }

    pub fn has_client_session_need(&self) -> bool {
        self.client_session_need.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_session_need(&mut self, v: u32) {
        self.client_session_need = ::std::option::Option::Some(v);
    }

    // optional int32 queue_position = 3;


    pub fn get_queue_position(&self) -> i32 {
        self.queue_position.unwrap_or(0)
    }
    pub fn clear_queue_position(&mut self) {
        self.queue_position = ::std::option::Option::None;
    }

    pub fn has_queue_position(&self) -> bool {
        self.queue_position.is_some()
    }

    // Param is passed by value, moved
    pub fn set_queue_position(&mut self, v: i32) {
        self.queue_position = ::std::option::Option::Some(v);
    }

    // optional int32 queue_size = 4;


    pub fn get_queue_size(&self) -> i32 {
        self.queue_size.unwrap_or(0)
    }
    pub fn clear_queue_size(&mut self) {
        self.queue_size = ::std::option::Option::None;
    }

    pub fn has_queue_size(&self) -> bool {
        self.queue_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_queue_size(&mut self, v: i32) {
        self.queue_size = ::std::option::Option::Some(v);
    }

    // optional int32 wait_seconds = 5;


    pub fn get_wait_seconds(&self) -> i32 {
        self.wait_seconds.unwrap_or(0)
    }
    pub fn clear_wait_seconds(&mut self) {
        self.wait_seconds = ::std::option::Option::None;
    }

    pub fn has_wait_seconds(&self) -> bool {
        self.wait_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wait_seconds(&mut self, v: i32) {
        self.wait_seconds = ::std::option::Option::Some(v);
    }

    // optional int32 estimated_wait_seconds_remaining = 6;


    pub fn get_estimated_wait_seconds_remaining(&self) -> i32 {
        self.estimated_wait_seconds_remaining.unwrap_or(0)
    }
    pub fn clear_estimated_wait_seconds_remaining(&mut self) {
        self.estimated_wait_seconds_remaining = ::std::option::Option::None;
    }

    pub fn has_estimated_wait_seconds_remaining(&self) -> bool {
        self.estimated_wait_seconds_remaining.is_some()
    }

    // Param is passed by value, moved
    pub fn set_estimated_wait_seconds_remaining(&mut self, v: i32) {
        self.estimated_wait_seconds_remaining = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgConnectionStatus {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.status, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.client_session_need = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.queue_position = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.queue_size = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.wait_seconds = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.estimated_wait_seconds_remaining = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.client_session_need {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.queue_position {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.queue_size {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.wait_seconds {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.estimated_wait_seconds_remaining {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.status {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.client_session_need {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.queue_position {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.queue_size {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.wait_seconds {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.estimated_wait_seconds_remaining {
            os.write_int32(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgConnectionStatus {
        CMsgConnectionStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<GCConnectionStatus>>(
                "status",
                |m: &CMsgConnectionStatus| { &m.status },
                |m: &mut CMsgConnectionStatus| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "client_session_need",
                |m: &CMsgConnectionStatus| { &m.client_session_need },
                |m: &mut CMsgConnectionStatus| { &mut m.client_session_need },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "queue_position",
                |m: &CMsgConnectionStatus| { &m.queue_position },
                |m: &mut CMsgConnectionStatus| { &mut m.queue_position },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "queue_size",
                |m: &CMsgConnectionStatus| { &m.queue_size },
                |m: &mut CMsgConnectionStatus| { &mut m.queue_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "wait_seconds",
                |m: &CMsgConnectionStatus| { &m.wait_seconds },
                |m: &mut CMsgConnectionStatus| { &mut m.wait_seconds },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "estimated_wait_seconds_remaining",
                |m: &CMsgConnectionStatus| { &m.estimated_wait_seconds_remaining },
                |m: &mut CMsgConnectionStatus| { &mut m.estimated_wait_seconds_remaining },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgConnectionStatus>(
                "CMsgConnectionStatus",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgConnectionStatus {
        static instance: ::protobuf::rt::LazyV2<CMsgConnectionStatus> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgConnectionStatus::new)
    }
}

impl ::protobuf::Clear for CMsgConnectionStatus {
    fn clear(&mut self) {
        self.status = ::std::option::Option::None;
        self.client_session_need = ::std::option::Option::None;
        self.queue_position = ::std::option::Option::None;
        self.queue_size = ::std::option::Option::None;
        self.wait_seconds = ::std::option::Option::None;
        self.estimated_wait_seconds_remaining = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgConnectionStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgConnectionStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToGCSOCacheSubscribe {
    // message fields
    subscriber: ::std::option::Option<u64>,
    subscribe_to: ::std::option::Option<u64>,
    sync_version: ::std::option::Option<u64>,
    pub have_versions: ::protobuf::RepeatedField<CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCSOCacheSubscribe {
    fn default() -> &'a CMsgGCToGCSOCacheSubscribe {
        <CMsgGCToGCSOCacheSubscribe as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCSOCacheSubscribe {
    pub fn new() -> CMsgGCToGCSOCacheSubscribe {
        ::std::default::Default::default()
    }

    // optional fixed64 subscriber = 1;


    pub fn get_subscriber(&self) -> u64 {
        self.subscriber.unwrap_or(0)
    }
    pub fn clear_subscriber(&mut self) {
        self.subscriber = ::std::option::Option::None;
    }

    pub fn has_subscriber(&self) -> bool {
        self.subscriber.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subscriber(&mut self, v: u64) {
        self.subscriber = ::std::option::Option::Some(v);
    }

    // optional fixed64 subscribe_to = 2;


    pub fn get_subscribe_to(&self) -> u64 {
        self.subscribe_to.unwrap_or(0)
    }
    pub fn clear_subscribe_to(&mut self) {
        self.subscribe_to = ::std::option::Option::None;
    }

    pub fn has_subscribe_to(&self) -> bool {
        self.subscribe_to.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subscribe_to(&mut self, v: u64) {
        self.subscribe_to = ::std::option::Option::Some(v);
    }

    // optional fixed64 sync_version = 3;


    pub fn get_sync_version(&self) -> u64 {
        self.sync_version.unwrap_or(0)
    }
    pub fn clear_sync_version(&mut self) {
        self.sync_version = ::std::option::Option::None;
    }

    pub fn has_sync_version(&self) -> bool {
        self.sync_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sync_version(&mut self, v: u64) {
        self.sync_version = ::std::option::Option::Some(v);
    }

    // repeated .CMsgGCToGCSOCacheSubscribe.CMsgHaveVersions have_versions = 4;


    pub fn get_have_versions(&self) -> &[CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions] {
        &self.have_versions
    }
    pub fn clear_have_versions(&mut self) {
        self.have_versions.clear();
    }

    // Param is passed by value, moved
    pub fn set_have_versions(&mut self, v: ::protobuf::RepeatedField<CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions>) {
        self.have_versions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_have_versions(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions> {
        &mut self.have_versions
    }

    // Take field
    pub fn take_have_versions(&mut self) -> ::protobuf::RepeatedField<CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions> {
        ::std::mem::replace(&mut self.have_versions, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgGCToGCSOCacheSubscribe {
    fn is_initialized(&self) -> bool {
        for v in &self.have_versions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.subscriber = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.subscribe_to = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.sync_version = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.have_versions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.subscriber {
            my_size += 9;
        }
        if let Some(v) = self.subscribe_to {
            my_size += 9;
        }
        if let Some(v) = self.sync_version {
            my_size += 9;
        }
        for value in &self.have_versions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.subscriber {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.subscribe_to {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.sync_version {
            os.write_fixed64(3, v)?;
        }
        for v in &self.have_versions {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCToGCSOCacheSubscribe {
        CMsgGCToGCSOCacheSubscribe::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "subscriber",
                |m: &CMsgGCToGCSOCacheSubscribe| { &m.subscriber },
                |m: &mut CMsgGCToGCSOCacheSubscribe| { &mut m.subscriber },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "subscribe_to",
                |m: &CMsgGCToGCSOCacheSubscribe| { &m.subscribe_to },
                |m: &mut CMsgGCToGCSOCacheSubscribe| { &mut m.subscribe_to },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "sync_version",
                |m: &CMsgGCToGCSOCacheSubscribe| { &m.sync_version },
                |m: &mut CMsgGCToGCSOCacheSubscribe| { &mut m.sync_version },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions>>(
                "have_versions",
                |m: &CMsgGCToGCSOCacheSubscribe| { &m.have_versions },
                |m: &mut CMsgGCToGCSOCacheSubscribe| { &mut m.have_versions },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCToGCSOCacheSubscribe>(
                "CMsgGCToGCSOCacheSubscribe",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCToGCSOCacheSubscribe {
        static instance: ::protobuf::rt::LazyV2<CMsgGCToGCSOCacheSubscribe> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCToGCSOCacheSubscribe::new)
    }
}

impl ::protobuf::Clear for CMsgGCToGCSOCacheSubscribe {
    fn clear(&mut self) {
        self.subscriber = ::std::option::Option::None;
        self.subscribe_to = ::std::option::Option::None;
        self.sync_version = ::std::option::Option::None;
        self.have_versions.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToGCSOCacheSubscribe {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCSOCacheSubscribe {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions {
    // message fields
    service_id: ::std::option::Option<u32>,
    version: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions {
    fn default() -> &'a CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions {
        <CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions {
    pub fn new() -> CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions {
        ::std::default::Default::default()
    }

    // optional uint32 service_id = 1;


    pub fn get_service_id(&self) -> u32 {
        self.service_id.unwrap_or(0)
    }
    pub fn clear_service_id(&mut self) {
        self.service_id = ::std::option::Option::None;
    }

    pub fn has_service_id(&self) -> bool {
        self.service_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_service_id(&mut self, v: u32) {
        self.service_id = ::std::option::Option::Some(v);
    }

    // optional uint64 version = 2;


    pub fn get_version(&self) -> u64 {
        self.version.unwrap_or(0)
    }
    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u64) {
        self.version = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.service_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.version = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.service_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.service_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.version {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions {
        CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "service_id",
                |m: &CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions| { &m.service_id },
                |m: &mut CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions| { &mut m.service_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "version",
                |m: &CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions| { &m.version },
                |m: &mut CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions| { &mut m.version },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions>(
                "CMsgGCToGCSOCacheSubscribe.CMsgHaveVersions",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions {
        static instance: ::protobuf::rt::LazyV2<CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions::new)
    }
}

impl ::protobuf::Clear for CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions {
    fn clear(&mut self) {
        self.service_id = ::std::option::Option::None;
        self.version = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCSOCacheSubscribe_CMsgHaveVersions {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCToGCSOCacheUnsubscribe {
    // message fields
    subscriber: ::std::option::Option<u64>,
    unsubscribe_from: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCSOCacheUnsubscribe {
    fn default() -> &'a CMsgGCToGCSOCacheUnsubscribe {
        <CMsgGCToGCSOCacheUnsubscribe as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCSOCacheUnsubscribe {
    pub fn new() -> CMsgGCToGCSOCacheUnsubscribe {
        ::std::default::Default::default()
    }

    // optional fixed64 subscriber = 1;


    pub fn get_subscriber(&self) -> u64 {
        self.subscriber.unwrap_or(0)
    }
    pub fn clear_subscriber(&mut self) {
        self.subscriber = ::std::option::Option::None;
    }

    pub fn has_subscriber(&self) -> bool {
        self.subscriber.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subscriber(&mut self, v: u64) {
        self.subscriber = ::std::option::Option::Some(v);
    }

    // optional fixed64 unsubscribe_from = 2;


    pub fn get_unsubscribe_from(&self) -> u64 {
        self.unsubscribe_from.unwrap_or(0)
    }
    pub fn clear_unsubscribe_from(&mut self) {
        self.unsubscribe_from = ::std::option::Option::None;
    }

    pub fn has_unsubscribe_from(&self) -> bool {
        self.unsubscribe_from.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unsubscribe_from(&mut self, v: u64) {
        self.unsubscribe_from = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCToGCSOCacheUnsubscribe {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.subscriber = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.unsubscribe_from = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.subscriber {
            my_size += 9;
        }
        if let Some(v) = self.unsubscribe_from {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.subscriber {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.unsubscribe_from {
            os.write_fixed64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCToGCSOCacheUnsubscribe {
        CMsgGCToGCSOCacheUnsubscribe::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "subscriber",
                |m: &CMsgGCToGCSOCacheUnsubscribe| { &m.subscriber },
                |m: &mut CMsgGCToGCSOCacheUnsubscribe| { &mut m.subscriber },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "unsubscribe_from",
                |m: &CMsgGCToGCSOCacheUnsubscribe| { &m.unsubscribe_from },
                |m: &mut CMsgGCToGCSOCacheUnsubscribe| { &mut m.unsubscribe_from },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCToGCSOCacheUnsubscribe>(
                "CMsgGCToGCSOCacheUnsubscribe",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCToGCSOCacheUnsubscribe {
        static instance: ::protobuf::rt::LazyV2<CMsgGCToGCSOCacheUnsubscribe> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCToGCSOCacheUnsubscribe::new)
    }
}

impl ::protobuf::Clear for CMsgGCToGCSOCacheUnsubscribe {
    fn clear(&mut self) {
        self.subscriber = ::std::option::Option::None;
        self.unsubscribe_from = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCToGCSOCacheUnsubscribe {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCSOCacheUnsubscribe {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCClientPing {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCClientPing {
    fn default() -> &'a CMsgGCClientPing {
        <CMsgGCClientPing as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCClientPing {
    pub fn new() -> CMsgGCClientPing {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgGCClientPing {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCClientPing {
        CMsgGCClientPing::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCClientPing>(
                "CMsgGCClientPing",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCClientPing {
        static instance: ::protobuf::rt::LazyV2<CMsgGCClientPing> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCClientPing::new)
    }
}

impl ::protobuf::Clear for CMsgGCClientPing {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCClientPing {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCClientPing {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PartnerAccountType {
    PARTNER_NONE = 0,
    PARTNER_PERFECT_WORLD = 1,
    PARTNER_NEXON = 2,
}

impl ::protobuf::ProtobufEnum for PartnerAccountType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PartnerAccountType> {
        match value {
            0 => ::std::option::Option::Some(PartnerAccountType::PARTNER_NONE),
            1 => ::std::option::Option::Some(PartnerAccountType::PARTNER_PERFECT_WORLD),
            2 => ::std::option::Option::Some(PartnerAccountType::PARTNER_NEXON),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PartnerAccountType] = &[
            PartnerAccountType::PARTNER_NONE,
            PartnerAccountType::PARTNER_PERFECT_WORLD,
            PartnerAccountType::PARTNER_NEXON,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<PartnerAccountType>("PartnerAccountType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for PartnerAccountType {
}

impl ::std::default::Default for PartnerAccountType {
    fn default() -> Self {
        PartnerAccountType::PARTNER_NONE
    }
}

impl ::protobuf::reflect::ProtobufValue for PartnerAccountType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum GCConnectionStatus {
    GCConnectionStatus_HAVE_SESSION = 0,
    GCConnectionStatus_GC_GOING_DOWN = 1,
    GCConnectionStatus_NO_SESSION = 2,
    GCConnectionStatus_NO_SESSION_IN_LOGON_QUEUE = 3,
    GCConnectionStatus_NO_STEAM = 4,
    GCConnectionStatus_SUSPENDED = 5,
}

impl ::protobuf::ProtobufEnum for GCConnectionStatus {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<GCConnectionStatus> {
        match value {
            0 => ::std::option::Option::Some(GCConnectionStatus::GCConnectionStatus_HAVE_SESSION),
            1 => ::std::option::Option::Some(GCConnectionStatus::GCConnectionStatus_GC_GOING_DOWN),
            2 => ::std::option::Option::Some(GCConnectionStatus::GCConnectionStatus_NO_SESSION),
            3 => ::std::option::Option::Some(GCConnectionStatus::GCConnectionStatus_NO_SESSION_IN_LOGON_QUEUE),
            4 => ::std::option::Option::Some(GCConnectionStatus::GCConnectionStatus_NO_STEAM),
            5 => ::std::option::Option::Some(GCConnectionStatus::GCConnectionStatus_SUSPENDED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [GCConnectionStatus] = &[
            GCConnectionStatus::GCConnectionStatus_HAVE_SESSION,
            GCConnectionStatus::GCConnectionStatus_GC_GOING_DOWN,
            GCConnectionStatus::GCConnectionStatus_NO_SESSION,
            GCConnectionStatus::GCConnectionStatus_NO_SESSION_IN_LOGON_QUEUE,
            GCConnectionStatus::GCConnectionStatus_NO_STEAM,
            GCConnectionStatus::GCConnectionStatus_SUSPENDED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<GCConnectionStatus>("GCConnectionStatus", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for GCConnectionStatus {
}

impl ::std::default::Default for GCConnectionStatus {
    fn default() -> Self {
        GCConnectionStatus::GCConnectionStatus_HAVE_SESSION
    }
}

impl ::protobuf::reflect::ProtobufValue for GCConnectionStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x16gcsdk_gcmessages.proto\x1a\x13steammessages.proto\"3\n\rCMsgSOIDOw\
    ner\x12\x12\n\x04type\x18\x01\x20\x01(\rR\x04type\x12\x0e\n\x02id\x18\
    \x02\x20\x01(\x04R\x02id\"\xcc\x01\n\x12CMsgSOSingleObject\x12\x14\n\x05\
    owner\x18\x01\x20\x01(\x06R\x05owner\x12\x17\n\x07type_id\x18\x02\x20\
    \x01(\x05R\x06typeId\x12\x1f\n\x0bobject_data\x18\x03\x20\x01(\x0cR\nobj\
    ectData\x12\x18\n\x07version\x18\x04\x20\x01(\x06R\x07version\x12-\n\now\
    ner_soid\x18\x05\x20\x01(\x0b2\x0e.CMsgSOIDOwnerR\townerSoid\x12\x1d\n\n\
    service_id\x18\x06\x20\x01(\rR\tserviceId\"\x9e\x02\n\x15CMsgSOMultipleO\
    bjects\x12\x14\n\x05owner\x18\x01\x20\x01(\x06R\x05owner\x12=\n\x07objec\
    ts\x18\x02\x20\x03(\x0b2#.CMsgSOMultipleObjects.SingleObjectR\x07objects\
    \x12\x18\n\x07version\x18\x03\x20\x01(\x06R\x07version\x12-\n\nowner_soi\
    d\x18\x06\x20\x01(\x0b2\x0e.CMsgSOIDOwnerR\townerSoid\x12\x1d\n\nservice\
    _id\x18\x07\x20\x01(\rR\tserviceId\x1aH\n\x0cSingleObject\x12\x17\n\x07t\
    ype_id\x18\x01\x20\x01(\x05R\x06typeId\x12\x1f\n\x0bobject_data\x18\x02\
    \x20\x01(\x0cR\nobjectData\"\xe8\x02\n\x15CMsgSOCacheSubscribed\x12\x14\
    \n\x05owner\x18\x01\x20\x01(\x06R\x05owner\x12?\n\x07objects\x18\x02\x20\
    \x03(\x0b2%.CMsgSOCacheSubscribed.SubscribedTypeR\x07objects\x12\x18\n\
    \x07version\x18\x03\x20\x01(\x06R\x07version\x12-\n\nowner_soid\x18\x04\
    \x20\x01(\x0b2\x0e.CMsgSOIDOwnerR\townerSoid\x12\x1d\n\nservice_id\x18\
    \x05\x20\x01(\rR\tserviceId\x12!\n\x0cservice_list\x18\x06\x20\x03(\rR\
    \x0bserviceList\x12!\n\x0csync_version\x18\x07\x20\x01(\x06R\x0bsyncVers\
    ion\x1aJ\n\x0eSubscribedType\x12\x17\n\x07type_id\x18\x01\x20\x01(\x05R\
    \x06typeId\x12\x1f\n\x0bobject_data\x18\x02\x20\x03(\x0cR\nobjectData\"\
    \xcd\x01\n\x1dCMsgSOCacheSubscribedUpToDate\x12\x18\n\x07version\x18\x01\
    \x20\x01(\x06R\x07version\x12-\n\nowner_soid\x18\x02\x20\x01(\x0b2\x0e.C\
    MsgSOIDOwnerR\townerSoid\x12\x1d\n\nservice_id\x18\x03\x20\x01(\rR\tserv\
    iceId\x12!\n\x0cservice_list\x18\x04\x20\x03(\rR\x0bserviceList\x12!\n\
    \x0csync_version\x18\x05\x20\x01(\x06R\x0bsyncVersion\"/\n\x17CMsgSOCach\
    eUnsubscribed\x12\x14\n\x05owner\x18\x01\x20\x01(\x06R\x05owner\"\xe2\
    \x01\n\x1cCMsgSOCacheSubscriptionCheck\x12\x14\n\x05owner\x18\x01\x20\
    \x01(\x06R\x05owner\x12\x18\n\x07version\x18\x02\x20\x01(\x06R\x07versio\
    n\x12-\n\nowner_soid\x18\x03\x20\x01(\x0b2\x0e.CMsgSOIDOwnerR\townerSoid\
    \x12\x1d\n\nservice_id\x18\x04\x20\x01(\rR\tserviceId\x12!\n\x0cservice_\
    list\x18\x05\x20\x03(\rR\x0bserviceList\x12!\n\x0csync_version\x18\x06\
    \x20\x01(\x06R\x0bsyncVersion\"e\n\x1eCMsgSOCacheSubscriptionRefresh\x12\
    \x14\n\x05owner\x18\x01\x20\x01(\x06R\x05owner\x12-\n\nowner_soid\x18\
    \x02\x20\x01(\x0b2\x0e.CMsgSOIDOwnerR\townerSoid\".\n\x12CMsgSOCacheVers\
    ion\x12\x18\n\x07version\x18\x01\x20\x01(\x06R\x07version\"h\n\x16CMsgGC\
    MultiplexMessage\x12\x18\n\x07msgtype\x18\x01\x20\x01(\rR\x07msgtype\x12\
    \x18\n\x07payload\x18\x02\x20\x01(\x0cR\x07payload\x12\x1a\n\x08steamids\
    \x18\x03\x20\x03(\x06R\x08steamids\"\x9f\x01\n\x13CGCToGCMsgMasterAck\
    \x12\x1b\n\tdir_index\x18\x01\x20\x01(\rR\x08dirIndex\x12!\n\x0cmachine_\
    name\x18\x03\x20\x01(\tR\x0bmachineName\x12!\n\x0cprocess_name\x18\x04\
    \x20\x01(\tR\x0bprocessName\x12%\n\x0etype_instances\x18\x05\x20\x03(\rR\
    \rtypeInstances\";\n\x1cCGCToGCMsgMasterAck_Response\x12\x1b\n\x07eresul\
    t\x18\x01\x20\x01(\x05:\x012R\x07eresult\"\xad\x01\n\x1fCGCToGCMsgMaster\
    StartupComplete\x12@\n\x07gc_info\x18\x01\x20\x03(\x0b2'.CGCToGCMsgMaste\
    rStartupComplete.GCInfoR\x06gcInfo\x1aH\n\x06GCInfo\x12\x1b\n\tdir_index\
    \x18\x01\x20\x01(\rR\x08dirIndex\x12!\n\x0cmachine_name\x18\x02\x20\x01(\
    \tR\x0bmachineName\"k\n\x10CGCToGCMsgRouted\x12\x19\n\x08msg_type\x18\
    \x01\x20\x01(\rR\x07msgType\x12\x1b\n\tsender_id\x18\x02\x20\x01(\x06R\
    \x08senderId\x12\x1f\n\x0bnet_message\x18\x03\x20\x01(\x0cR\nnetMessage\
    \"S\n\x15CGCToGCMsgRoutedReply\x12\x19\n\x08msg_type\x18\x01\x20\x01(\rR\
    \x07msgType\x12\x1f\n\x0bnet_message\x18\x02\x20\x01(\x0cR\nnetMessage\"\
    \xb4\x01\n\x1cCMsgGCUpdateSubGCSessionInfo\x12B\n\x07updates\x18\x01\x20\
    \x03(\x0b2(.CMsgGCUpdateSubGCSessionInfo.CMsgUpdateR\x07updates\x1aP\n\n\
    CMsgUpdate\x12\x18\n\x07steamid\x18\x01\x20\x01(\x06R\x07steamid\x12\x0e\
    \n\x02ip\x18\x02\x20\x01(\x07R\x02ip\x12\x18\n\x07trusted\x18\x03\x20\
    \x01(\x08R\x07trusted\"9\n\x1dCMsgGCRequestSubGCSessionInfo\x12\x18\n\
    \x07steamid\x18\x01\x20\x01(\x06R\x07steamid\"Q\n%CMsgGCRequestSubGCSess\
    ionInfoResponse\x12\x0e\n\x02ip\x18\x01\x20\x01(\x07R\x02ip\x12\x18\n\
    \x07trusted\x18\x02\x20\x01(\x08R\x07trusted\"?\n#CMsgGCToGCIncrementRec\
    ruitmentLevel\x12\x18\n\x07steamid\x18\x01\x20\x01(\x06R\x07steamid\"u\n\
    \x16CMsgSOCacheHaveVersion\x12\"\n\x04soid\x18\x01\x20\x01(\x0b2\x0e.CMs\
    gSOIDOwnerR\x04soid\x12\x18\n\x07version\x18\x02\x20\x01(\x06R\x07versio\
    n\x12\x1d\n\nservice_id\x18\x03\x20\x01(\rR\tserviceId\"\xc6\x02\n\x14CM\
    sgConnectionStatus\x12L\n\x06status\x18\x01\x20\x01(\x0e2\x13.GCConnecti\
    onStatus:\x1fGCConnectionStatus_HAVE_SESSIONR\x06status\x12.\n\x13client\
    _session_need\x18\x02\x20\x01(\rR\x11clientSessionNeed\x12%\n\x0equeue_p\
    osition\x18\x03\x20\x01(\x05R\rqueuePosition\x12\x1d\n\nqueue_size\x18\
    \x04\x20\x01(\x05R\tqueueSize\x12!\n\x0cwait_seconds\x18\x05\x20\x01(\
    \x05R\x0bwaitSeconds\x12G\n\x20estimated_wait_seconds_remaining\x18\x06\
    \x20\x01(\x05R\x1destimatedWaitSecondsRemaining\"\xa2\x02\n\x1aCMsgGCToG\
    CSOCacheSubscribe\x12\x1e\n\nsubscriber\x18\x01\x20\x01(\x06R\nsubscribe\
    r\x12!\n\x0csubscribe_to\x18\x02\x20\x01(\x06R\x0bsubscribeTo\x12!\n\x0c\
    sync_version\x18\x03\x20\x01(\x06R\x0bsyncVersion\x12Q\n\rhave_versions\
    \x18\x04\x20\x03(\x0b2,.CMsgGCToGCSOCacheSubscribe.CMsgHaveVersionsR\x0c\
    haveVersions\x1aK\n\x10CMsgHaveVersions\x12\x1d\n\nservice_id\x18\x01\
    \x20\x01(\rR\tserviceId\x12\x18\n\x07version\x18\x02\x20\x01(\x04R\x07ve\
    rsion\"i\n\x1cCMsgGCToGCSOCacheUnsubscribe\x12\x1e\n\nsubscriber\x18\x01\
    \x20\x01(\x06R\nsubscriber\x12)\n\x10unsubscribe_from\x18\x02\x20\x01(\
    \x06R\x0funsubscribeFrom\"\x12\n\x10CMsgGCClientPing*T\n\x12PartnerAccou\
    ntType\x12\x10\n\x0cPARTNER_NONE\x10\0\x12\x19\n\x15PARTNER_PERFECT_WORL\
    D\x10\x01\x12\x11\n\rPARTNER_NEXON\x10\x02*\xf7\x01\n\x12GCConnectionSta\
    tus\x12#\n\x1fGCConnectionStatus_HAVE_SESSION\x10\0\x12$\n\x20GCConnecti\
    onStatus_GC_GOING_DOWN\x10\x01\x12!\n\x1dGCConnectionStatus_NO_SESSION\
    \x10\x02\x120\n,GCConnectionStatus_NO_SESSION_IN_LOGON_QUEUE\x10\x03\x12\
    \x1f\n\x1bGCConnectionStatus_NO_STEAM\x10\x04\x12\x20\n\x1cGCConnectionS\
    tatus_SUSPENDED\x10\x05B\x05H\x01\x80\x01\0J\x817\n\x07\x12\x05\0\0\xb9\
    \x01\x01\n\t\n\x02\x03\0\x12\x03\0\x07\x1c\n\x08\n\x01\x08\x12\x03\x02\0\
    \x1c\n\t\n\x02\x08\t\x12\x03\x02\0\x1c\n\x08\n\x01\x08\x12\x03\x03\0#\n\
    \t\n\x02\x08\x10\x12\x03\x03\0#\n\n\n\x02\x05\0\x12\x04\x05\0\t\x01\n\n\
    \n\x03\x05\0\x01\x12\x03\x05\x05\x17\n\x0b\n\x04\x05\0\x02\0\x12\x03\x06\
    \x08\x19\n\x0c\n\x05\x05\0\x02\0\x01\x12\x03\x06\x08\x14\n\x0c\n\x05\x05\
    \0\x02\0\x02\x12\x03\x06\x17\x18\n\x0b\n\x04\x05\0\x02\x01\x12\x03\x07\
    \x08\"\n\x0c\n\x05\x05\0\x02\x01\x01\x12\x03\x07\x08\x1d\n\x0c\n\x05\x05\
    \0\x02\x01\x02\x12\x03\x07\x20!\n\x0b\n\x04\x05\0\x02\x02\x12\x03\x08\
    \x08\x1a\n\x0c\n\x05\x05\0\x02\x02\x01\x12\x03\x08\x08\x15\n\x0c\n\x05\
    \x05\0\x02\x02\x02\x12\x03\x08\x18\x19\n\n\n\x02\x05\x01\x12\x04\x0b\0\
    \x12\x01\n\n\n\x03\x05\x01\x01\x12\x03\x0b\x05\x17\n\x0b\n\x04\x05\x01\
    \x02\0\x12\x03\x0c\x08,\n\x0c\n\x05\x05\x01\x02\0\x01\x12\x03\x0c\x08'\n\
    \x0c\n\x05\x05\x01\x02\0\x02\x12\x03\x0c*+\n\x0b\n\x04\x05\x01\x02\x01\
    \x12\x03\r\x08-\n\x0c\n\x05\x05\x01\x02\x01\x01\x12\x03\r\x08(\n\x0c\n\
    \x05\x05\x01\x02\x01\x02\x12\x03\r+,\n\x0b\n\x04\x05\x01\x02\x02\x12\x03\
    \x0e\x08*\n\x0c\n\x05\x05\x01\x02\x02\x01\x12\x03\x0e\x08%\n\x0c\n\x05\
    \x05\x01\x02\x02\x02\x12\x03\x0e()\n\x0b\n\x04\x05\x01\x02\x03\x12\x03\
    \x0f\x089\n\x0c\n\x05\x05\x01\x02\x03\x01\x12\x03\x0f\x084\n\x0c\n\x05\
    \x05\x01\x02\x03\x02\x12\x03\x0f78\n\x0b\n\x04\x05\x01\x02\x04\x12\x03\
    \x10\x08(\n\x0c\n\x05\x05\x01\x02\x04\x01\x12\x03\x10\x08#\n\x0c\n\x05\
    \x05\x01\x02\x04\x02\x12\x03\x10&'\n\x0b\n\x04\x05\x01\x02\x05\x12\x03\
    \x11\x08)\n\x0c\n\x05\x05\x01\x02\x05\x01\x12\x03\x11\x08$\n\x0c\n\x05\
    \x05\x01\x02\x05\x02\x12\x03\x11'(\n\n\n\x02\x04\0\x12\x04\x14\0\x17\x01\
    \n\n\n\x03\x04\0\x01\x12\x03\x14\x08\x15\n\x0b\n\x04\x04\0\x02\0\x12\x03\
    \x15\x08!\n\x0c\n\x05\x04\0\x02\0\x04\x12\x03\x15\x08\x10\n\x0c\n\x05\
    \x04\0\x02\0\x05\x12\x03\x15\x11\x17\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03\
    \x15\x18\x1c\n\x0c\n\x05\x04\0\x02\0\x03\x12\x03\x15\x1f\x20\n\x0b\n\x04\
    \x04\0\x02\x01\x12\x03\x16\x08\x1f\n\x0c\n\x05\x04\0\x02\x01\x04\x12\x03\
    \x16\x08\x10\n\x0c\n\x05\x04\0\x02\x01\x05\x12\x03\x16\x11\x17\n\x0c\n\
    \x05\x04\0\x02\x01\x01\x12\x03\x16\x18\x1a\n\x0c\n\x05\x04\0\x02\x01\x03\
    \x12\x03\x16\x1d\x1e\n\n\n\x02\x04\x01\x12\x04\x19\0\x20\x01\n\n\n\x03\
    \x04\x01\x01\x12\x03\x19\x08\x1a\n\x0b\n\x04\x04\x01\x02\0\x12\x03\x1a\
    \x08#\n\x0c\n\x05\x04\x01\x02\0\x04\x12\x03\x1a\x08\x10\n\x0c\n\x05\x04\
    \x01\x02\0\x05\x12\x03\x1a\x11\x18\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03\
    \x1a\x19\x1e\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03\x1a!\"\n\x0b\n\x04\
    \x04\x01\x02\x01\x12\x03\x1b\x08#\n\x0c\n\x05\x04\x01\x02\x01\x04\x12\
    \x03\x1b\x08\x10\n\x0c\n\x05\x04\x01\x02\x01\x05\x12\x03\x1b\x11\x16\n\
    \x0c\n\x05\x04\x01\x02\x01\x01\x12\x03\x1b\x17\x1e\n\x0c\n\x05\x04\x01\
    \x02\x01\x03\x12\x03\x1b!\"\n\x0b\n\x04\x04\x01\x02\x02\x12\x03\x1c\x08'\
    \n\x0c\n\x05\x04\x01\x02\x02\x04\x12\x03\x1c\x08\x10\n\x0c\n\x05\x04\x01\
    \x02\x02\x05\x12\x03\x1c\x11\x16\n\x0c\n\x05\x04\x01\x02\x02\x01\x12\x03\
    \x1c\x17\"\n\x0c\n\x05\x04\x01\x02\x02\x03\x12\x03\x1c%&\n\x0b\n\x04\x04\
    \x01\x02\x03\x12\x03\x1d\x08%\n\x0c\n\x05\x04\x01\x02\x03\x04\x12\x03\
    \x1d\x08\x10\n\x0c\n\x05\x04\x01\x02\x03\x05\x12\x03\x1d\x11\x18\n\x0c\n\
    \x05\x04\x01\x02\x03\x01\x12\x03\x1d\x19\x20\n\x0c\n\x05\x04\x01\x02\x03\
    \x03\x12\x03\x1d#$\n\x0b\n\x04\x04\x01\x02\x04\x12\x03\x1e\x08/\n\x0c\n\
    \x05\x04\x01\x02\x04\x04\x12\x03\x1e\x08\x10\n\x0c\n\x05\x04\x01\x02\x04\
    \x06\x12\x03\x1e\x11\x1f\n\x0c\n\x05\x04\x01\x02\x04\x01\x12\x03\x1e\x20\
    *\n\x0c\n\x05\x04\x01\x02\x04\x03\x12\x03\x1e-.\n\x0b\n\x04\x04\x01\x02\
    \x05\x12\x03\x1f\x08'\n\x0c\n\x05\x04\x01\x02\x05\x04\x12\x03\x1f\x08\
    \x10\n\x0c\n\x05\x04\x01\x02\x05\x05\x12\x03\x1f\x11\x17\n\x0c\n\x05\x04\
    \x01\x02\x05\x01\x12\x03\x1f\x18\"\n\x0c\n\x05\x04\x01\x02\x05\x03\x12\
    \x03\x1f%&\n\n\n\x02\x04\x02\x12\x04\"\0-\x01\n\n\n\x03\x04\x02\x01\x12\
    \x03\"\x08\x1d\n\x0c\n\x04\x04\x02\x03\0\x12\x04#\x08&\t\n\x0c\n\x05\x04\
    \x02\x03\0\x01\x12\x03#\x10\x1c\n\r\n\x06\x04\x02\x03\0\x02\0\x12\x03$\
    \x10+\n\x0e\n\x07\x04\x02\x03\0\x02\0\x04\x12\x03$\x10\x18\n\x0e\n\x07\
    \x04\x02\x03\0\x02\0\x05\x12\x03$\x19\x1e\n\x0e\n\x07\x04\x02\x03\0\x02\
    \0\x01\x12\x03$\x1f&\n\x0e\n\x07\x04\x02\x03\0\x02\0\x03\x12\x03$)*\n\r\
    \n\x06\x04\x02\x03\0\x02\x01\x12\x03%\x10/\n\x0e\n\x07\x04\x02\x03\0\x02\
    \x01\x04\x12\x03%\x10\x18\n\x0e\n\x07\x04\x02\x03\0\x02\x01\x05\x12\x03%\
    \x19\x1e\n\x0e\n\x07\x04\x02\x03\0\x02\x01\x01\x12\x03%\x1f*\n\x0e\n\x07\
    \x04\x02\x03\0\x02\x01\x03\x12\x03%-.\n\x0b\n\x04\x04\x02\x02\0\x12\x03(\
    \x08#\n\x0c\n\x05\x04\x02\x02\0\x04\x12\x03(\x08\x10\n\x0c\n\x05\x04\x02\
    \x02\0\x05\x12\x03(\x11\x18\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x03(\x19\
    \x1e\n\x0c\n\x05\x04\x02\x02\0\x03\x12\x03(!\"\n\x0b\n\x04\x04\x02\x02\
    \x01\x12\x03)\x08A\n\x0c\n\x05\x04\x02\x02\x01\x04\x12\x03)\x08\x10\n\
    \x0c\n\x05\x04\x02\x02\x01\x06\x12\x03)\x114\n\x0c\n\x05\x04\x02\x02\x01\
    \x01\x12\x03)5<\n\x0c\n\x05\x04\x02\x02\x01\x03\x12\x03)?@\n\x0b\n\x04\
    \x04\x02\x02\x02\x12\x03*\x08%\n\x0c\n\x05\x04\x02\x02\x02\x04\x12\x03*\
    \x08\x10\n\x0c\n\x05\x04\x02\x02\x02\x05\x12\x03*\x11\x18\n\x0c\n\x05\
    \x04\x02\x02\x02\x01\x12\x03*\x19\x20\n\x0c\n\x05\x04\x02\x02\x02\x03\
    \x12\x03*#$\n\x0b\n\x04\x04\x02\x02\x03\x12\x03+\x08/\n\x0c\n\x05\x04\
    \x02\x02\x03\x04\x12\x03+\x08\x10\n\x0c\n\x05\x04\x02\x02\x03\x06\x12\
    \x03+\x11\x1f\n\x0c\n\x05\x04\x02\x02\x03\x01\x12\x03+\x20*\n\x0c\n\x05\
    \x04\x02\x02\x03\x03\x12\x03+-.\n\x0b\n\x04\x04\x02\x02\x04\x12\x03,\x08\
    '\n\x0c\n\x05\x04\x02\x02\x04\x04\x12\x03,\x08\x10\n\x0c\n\x05\x04\x02\
    \x02\x04\x05\x12\x03,\x11\x17\n\x0c\n\x05\x04\x02\x02\x04\x01\x12\x03,\
    \x18\"\n\x0c\n\x05\x04\x02\x02\x04\x03\x12\x03,%&\n\n\n\x02\x04\x03\x12\
    \x04/\0<\x01\n\n\n\x03\x04\x03\x01\x12\x03/\x08\x1d\n\x0c\n\x04\x04\x03\
    \x03\0\x12\x040\x083\t\n\x0c\n\x05\x04\x03\x03\0\x01\x12\x030\x10\x1e\n\
    \r\n\x06\x04\x03\x03\0\x02\0\x12\x031\x10+\n\x0e\n\x07\x04\x03\x03\0\x02\
    \0\x04\x12\x031\x10\x18\n\x0e\n\x07\x04\x03\x03\0\x02\0\x05\x12\x031\x19\
    \x1e\n\x0e\n\x07\x04\x03\x03\0\x02\0\x01\x12\x031\x1f&\n\x0e\n\x07\x04\
    \x03\x03\0\x02\0\x03\x12\x031)*\n\r\n\x06\x04\x03\x03\0\x02\x01\x12\x032\
    \x10/\n\x0e\n\x07\x04\x03\x03\0\x02\x01\x04\x12\x032\x10\x18\n\x0e\n\x07\
    \x04\x03\x03\0\x02\x01\x05\x12\x032\x19\x1e\n\x0e\n\x07\x04\x03\x03\0\
    \x02\x01\x01\x12\x032\x1f*\n\x0e\n\x07\x04\x03\x03\0\x02\x01\x03\x12\x03\
    2-.\n\x0b\n\x04\x04\x03\x02\0\x12\x035\x08#\n\x0c\n\x05\x04\x03\x02\0\
    \x04\x12\x035\x08\x10\n\x0c\n\x05\x04\x03\x02\0\x05\x12\x035\x11\x18\n\
    \x0c\n\x05\x04\x03\x02\0\x01\x12\x035\x19\x1e\n\x0c\n\x05\x04\x03\x02\0\
    \x03\x12\x035!\"\n\x0b\n\x04\x04\x03\x02\x01\x12\x036\x08C\n\x0c\n\x05\
    \x04\x03\x02\x01\x04\x12\x036\x08\x10\n\x0c\n\x05\x04\x03\x02\x01\x06\
    \x12\x036\x116\n\x0c\n\x05\x04\x03\x02\x01\x01\x12\x0367>\n\x0c\n\x05\
    \x04\x03\x02\x01\x03\x12\x036AB\n\x0b\n\x04\x04\x03\x02\x02\x12\x037\x08\
    %\n\x0c\n\x05\x04\x03\x02\x02\x04\x12\x037\x08\x10\n\x0c\n\x05\x04\x03\
    \x02\x02\x05\x12\x037\x11\x18\n\x0c\n\x05\x04\x03\x02\x02\x01\x12\x037\
    \x19\x20\n\x0c\n\x05\x04\x03\x02\x02\x03\x12\x037#$\n\x0b\n\x04\x04\x03\
    \x02\x03\x12\x038\x08/\n\x0c\n\x05\x04\x03\x02\x03\x04\x12\x038\x08\x10\
    \n\x0c\n\x05\x04\x03\x02\x03\x06\x12\x038\x11\x1f\n\x0c\n\x05\x04\x03\
    \x02\x03\x01\x12\x038\x20*\n\x0c\n\x05\x04\x03\x02\x03\x03\x12\x038-.\n\
    \x0b\n\x04\x04\x03\x02\x04\x12\x039\x08'\n\x0c\n\x05\x04\x03\x02\x04\x04\
    \x12\x039\x08\x10\n\x0c\n\x05\x04\x03\x02\x04\x05\x12\x039\x11\x17\n\x0c\
    \n\x05\x04\x03\x02\x04\x01\x12\x039\x18\"\n\x0c\n\x05\x04\x03\x02\x04\
    \x03\x12\x039%&\n\x0b\n\x04\x04\x03\x02\x05\x12\x03:\x08)\n\x0c\n\x05\
    \x04\x03\x02\x05\x04\x12\x03:\x08\x10\n\x0c\n\x05\x04\x03\x02\x05\x05\
    \x12\x03:\x11\x17\n\x0c\n\x05\x04\x03\x02\x05\x01\x12\x03:\x18$\n\x0c\n\
    \x05\x04\x03\x02\x05\x03\x12\x03:'(\n\x0b\n\x04\x04\x03\x02\x06\x12\x03;\
    \x08*\n\x0c\n\x05\x04\x03\x02\x06\x04\x12\x03;\x08\x10\n\x0c\n\x05\x04\
    \x03\x02\x06\x05\x12\x03;\x11\x18\n\x0c\n\x05\x04\x03\x02\x06\x01\x12\
    \x03;\x19%\n\x0c\n\x05\x04\x03\x02\x06\x03\x12\x03;()\n\n\n\x02\x04\x04\
    \x12\x04>\0D\x01\n\n\n\x03\x04\x04\x01\x12\x03>\x08%\n\x0b\n\x04\x04\x04\
    \x02\0\x12\x03?\x08%\n\x0c\n\x05\x04\x04\x02\0\x04\x12\x03?\x08\x10\n\
    \x0c\n\x05\x04\x04\x02\0\x05\x12\x03?\x11\x18\n\x0c\n\x05\x04\x04\x02\0\
    \x01\x12\x03?\x19\x20\n\x0c\n\x05\x04\x04\x02\0\x03\x12\x03?#$\n\x0b\n\
    \x04\x04\x04\x02\x01\x12\x03@\x08/\n\x0c\n\x05\x04\x04\x02\x01\x04\x12\
    \x03@\x08\x10\n\x0c\n\x05\x04\x04\x02\x01\x06\x12\x03@\x11\x1f\n\x0c\n\
    \x05\x04\x04\x02\x01\x01\x12\x03@\x20*\n\x0c\n\x05\x04\x04\x02\x01\x03\
    \x12\x03@-.\n\x0b\n\x04\x04\x04\x02\x02\x12\x03A\x08'\n\x0c\n\x05\x04\
    \x04\x02\x02\x04\x12\x03A\x08\x10\n\x0c\n\x05\x04\x04\x02\x02\x05\x12\
    \x03A\x11\x17\n\x0c\n\x05\x04\x04\x02\x02\x01\x12\x03A\x18\"\n\x0c\n\x05\
    \x04\x04\x02\x02\x03\x12\x03A%&\n\x0b\n\x04\x04\x04\x02\x03\x12\x03B\x08\
    )\n\x0c\n\x05\x04\x04\x02\x03\x04\x12\x03B\x08\x10\n\x0c\n\x05\x04\x04\
    \x02\x03\x05\x12\x03B\x11\x17\n\x0c\n\x05\x04\x04\x02\x03\x01\x12\x03B\
    \x18$\n\x0c\n\x05\x04\x04\x02\x03\x03\x12\x03B'(\n\x0b\n\x04\x04\x04\x02\
    \x04\x12\x03C\x08*\n\x0c\n\x05\x04\x04\x02\x04\x04\x12\x03C\x08\x10\n\
    \x0c\n\x05\x04\x04\x02\x04\x05\x12\x03C\x11\x18\n\x0c\n\x05\x04\x04\x02\
    \x04\x01\x12\x03C\x19%\n\x0c\n\x05\x04\x04\x02\x04\x03\x12\x03C()\n\n\n\
    \x02\x04\x05\x12\x04F\0H\x01\n\n\n\x03\x04\x05\x01\x12\x03F\x08\x1f\n\
    \x0b\n\x04\x04\x05\x02\0\x12\x03G\x08#\n\x0c\n\x05\x04\x05\x02\0\x04\x12\
    \x03G\x08\x10\n\x0c\n\x05\x04\x05\x02\0\x05\x12\x03G\x11\x18\n\x0c\n\x05\
    \x04\x05\x02\0\x01\x12\x03G\x19\x1e\n\x0c\n\x05\x04\x05\x02\0\x03\x12\
    \x03G!\"\n\n\n\x02\x04\x06\x12\x04J\0Q\x01\n\n\n\x03\x04\x06\x01\x12\x03\
    J\x08$\n\x0b\n\x04\x04\x06\x02\0\x12\x03K\x08#\n\x0c\n\x05\x04\x06\x02\0\
    \x04\x12\x03K\x08\x10\n\x0c\n\x05\x04\x06\x02\0\x05\x12\x03K\x11\x18\n\
    \x0c\n\x05\x04\x06\x02\0\x01\x12\x03K\x19\x1e\n\x0c\n\x05\x04\x06\x02\0\
    \x03\x12\x03K!\"\n\x0b\n\x04\x04\x06\x02\x01\x12\x03L\x08%\n\x0c\n\x05\
    \x04\x06\x02\x01\x04\x12\x03L\x08\x10\n\x0c\n\x05\x04\x06\x02\x01\x05\
    \x12\x03L\x11\x18\n\x0c\n\x05\x04\x06\x02\x01\x01\x12\x03L\x19\x20\n\x0c\
    \n\x05\x04\x06\x02\x01\x03\x12\x03L#$\n\x0b\n\x04\x04\x06\x02\x02\x12\
    \x03M\x08/\n\x0c\n\x05\x04\x06\x02\x02\x04\x12\x03M\x08\x10\n\x0c\n\x05\
    \x04\x06\x02\x02\x06\x12\x03M\x11\x1f\n\x0c\n\x05\x04\x06\x02\x02\x01\
    \x12\x03M\x20*\n\x0c\n\x05\x04\x06\x02\x02\x03\x12\x03M-.\n\x0b\n\x04\
    \x04\x06\x02\x03\x12\x03N\x08'\n\x0c\n\x05\x04\x06\x02\x03\x04\x12\x03N\
    \x08\x10\n\x0c\n\x05\x04\x06\x02\x03\x05\x12\x03N\x11\x17\n\x0c\n\x05\
    \x04\x06\x02\x03\x01\x12\x03N\x18\"\n\x0c\n\x05\x04\x06\x02\x03\x03\x12\
    \x03N%&\n\x0b\n\x04\x04\x06\x02\x04\x12\x03O\x08)\n\x0c\n\x05\x04\x06\
    \x02\x04\x04\x12\x03O\x08\x10\n\x0c\n\x05\x04\x06\x02\x04\x05\x12\x03O\
    \x11\x17\n\x0c\n\x05\x04\x06\x02\x04\x01\x12\x03O\x18$\n\x0c\n\x05\x04\
    \x06\x02\x04\x03\x12\x03O'(\n\x0b\n\x04\x04\x06\x02\x05\x12\x03P\x08*\n\
    \x0c\n\x05\x04\x06\x02\x05\x04\x12\x03P\x08\x10\n\x0c\n\x05\x04\x06\x02\
    \x05\x05\x12\x03P\x11\x18\n\x0c\n\x05\x04\x06\x02\x05\x01\x12\x03P\x19%\
    \n\x0c\n\x05\x04\x06\x02\x05\x03\x12\x03P()\n\n\n\x02\x04\x07\x12\x04S\0\
    V\x01\n\n\n\x03\x04\x07\x01\x12\x03S\x08&\n\x0b\n\x04\x04\x07\x02\0\x12\
    \x03T\x08#\n\x0c\n\x05\x04\x07\x02\0\x04\x12\x03T\x08\x10\n\x0c\n\x05\
    \x04\x07\x02\0\x05\x12\x03T\x11\x18\n\x0c\n\x05\x04\x07\x02\0\x01\x12\
    \x03T\x19\x1e\n\x0c\n\x05\x04\x07\x02\0\x03\x12\x03T!\"\n\x0b\n\x04\x04\
    \x07\x02\x01\x12\x03U\x08/\n\x0c\n\x05\x04\x07\x02\x01\x04\x12\x03U\x08\
    \x10\n\x0c\n\x05\x04\x07\x02\x01\x06\x12\x03U\x11\x1f\n\x0c\n\x05\x04\
    \x07\x02\x01\x01\x12\x03U\x20*\n\x0c\n\x05\x04\x07\x02\x01\x03\x12\x03U-\
    .\n\n\n\x02\x04\x08\x12\x04X\0Z\x01\n\n\n\x03\x04\x08\x01\x12\x03X\x08\
    \x1a\n\x0b\n\x04\x04\x08\x02\0\x12\x03Y\x08%\n\x0c\n\x05\x04\x08\x02\0\
    \x04\x12\x03Y\x08\x10\n\x0c\n\x05\x04\x08\x02\0\x05\x12\x03Y\x11\x18\n\
    \x0c\n\x05\x04\x08\x02\0\x01\x12\x03Y\x19\x20\n\x0c\n\x05\x04\x08\x02\0\
    \x03\x12\x03Y#$\n\n\n\x02\x04\t\x12\x04\\\0`\x01\n\n\n\x03\x04\t\x01\x12\
    \x03\\\x08\x1e\n\x0b\n\x04\x04\t\x02\0\x12\x03]\x08$\n\x0c\n\x05\x04\t\
    \x02\0\x04\x12\x03]\x08\x10\n\x0c\n\x05\x04\t\x02\0\x05\x12\x03]\x11\x17\
    \n\x0c\n\x05\x04\t\x02\0\x01\x12\x03]\x18\x1f\n\x0c\n\x05\x04\t\x02\0\
    \x03\x12\x03]\"#\n\x0b\n\x04\x04\t\x02\x01\x12\x03^\x08#\n\x0c\n\x05\x04\
    \t\x02\x01\x04\x12\x03^\x08\x10\n\x0c\n\x05\x04\t\x02\x01\x05\x12\x03^\
    \x11\x16\n\x0c\n\x05\x04\t\x02\x01\x01\x12\x03^\x17\x1e\n\x0c\n\x05\x04\
    \t\x02\x01\x03\x12\x03^!\"\n\x0b\n\x04\x04\t\x02\x02\x12\x03_\x08&\n\x0c\
    \n\x05\x04\t\x02\x02\x04\x12\x03_\x08\x10\n\x0c\n\x05\x04\t\x02\x02\x05\
    \x12\x03_\x11\x18\n\x0c\n\x05\x04\t\x02\x02\x01\x12\x03_\x19!\n\x0c\n\
    \x05\x04\t\x02\x02\x03\x12\x03_$%\n\n\n\x02\x04\n\x12\x04b\0g\x01\n\n\n\
    \x03\x04\n\x01\x12\x03b\x08\x1b\n\x0b\n\x04\x04\n\x02\0\x12\x03c\x08&\n\
    \x0c\n\x05\x04\n\x02\0\x04\x12\x03c\x08\x10\n\x0c\n\x05\x04\n\x02\0\x05\
    \x12\x03c\x11\x17\n\x0c\n\x05\x04\n\x02\0\x01\x12\x03c\x18!\n\x0c\n\x05\
    \x04\n\x02\0\x03\x12\x03c$%\n\x0b\n\x04\x04\n\x02\x01\x12\x03d\x08)\n\
    \x0c\n\x05\x04\n\x02\x01\x04\x12\x03d\x08\x10\n\x0c\n\x05\x04\n\x02\x01\
    \x05\x12\x03d\x11\x17\n\x0c\n\x05\x04\n\x02\x01\x01\x12\x03d\x18$\n\x0c\
    \n\x05\x04\n\x02\x01\x03\x12\x03d'(\n\x0b\n\x04\x04\n\x02\x02\x12\x03e\
    \x08)\n\x0c\n\x05\x04\n\x02\x02\x04\x12\x03e\x08\x10\n\x0c\n\x05\x04\n\
    \x02\x02\x05\x12\x03e\x11\x17\n\x0c\n\x05\x04\n\x02\x02\x01\x12\x03e\x18\
    $\n\x0c\n\x05\x04\n\x02\x02\x03\x12\x03e'(\n\x0b\n\x04\x04\n\x02\x03\x12\
    \x03f\x08+\n\x0c\n\x05\x04\n\x02\x03\x04\x12\x03f\x08\x10\n\x0c\n\x05\
    \x04\n\x02\x03\x05\x12\x03f\x11\x17\n\x0c\n\x05\x04\n\x02\x03\x01\x12\
    \x03f\x18&\n\x0c\n\x05\x04\n\x02\x03\x03\x12\x03f)*\n\n\n\x02\x04\x0b\
    \x12\x04i\0k\x01\n\n\n\x03\x04\x0b\x01\x12\x03i\x08$\n\x0b\n\x04\x04\x0b\
    \x02\0\x12\x03j\x081\n\x0c\n\x05\x04\x0b\x02\0\x04\x12\x03j\x08\x10\n\
    \x0c\n\x05\x04\x0b\x02\0\x05\x12\x03j\x11\x16\n\x0c\n\x05\x04\x0b\x02\0\
    \x01\x12\x03j\x17\x1e\n\x0c\n\x05\x04\x0b\x02\0\x03\x12\x03j!\"\n\x0c\n\
    \x05\x04\x0b\x02\0\x08\x12\x03j#0\n\x0c\n\x05\x04\x0b\x02\0\x07\x12\x03j\
    ./\n\n\n\x02\x04\x0c\x12\x04m\0t\x01\n\n\n\x03\x04\x0c\x01\x12\x03m\x08'\
    \n\x0c\n\x04\x04\x0c\x03\0\x12\x04n\x08q\t\n\x0c\n\x05\x04\x0c\x03\0\x01\
    \x12\x03n\x10\x16\n\r\n\x06\x04\x0c\x03\0\x02\0\x12\x03o\x10.\n\x0e\n\
    \x07\x04\x0c\x03\0\x02\0\x04\x12\x03o\x10\x18\n\x0e\n\x07\x04\x0c\x03\0\
    \x02\0\x05\x12\x03o\x19\x1f\n\x0e\n\x07\x04\x0c\x03\0\x02\0\x01\x12\x03o\
    \x20)\n\x0e\n\x07\x04\x0c\x03\0\x02\0\x03\x12\x03o,-\n\r\n\x06\x04\x0c\
    \x03\0\x02\x01\x12\x03p\x101\n\x0e\n\x07\x04\x0c\x03\0\x02\x01\x04\x12\
    \x03p\x10\x18\n\x0e\n\x07\x04\x0c\x03\0\x02\x01\x05\x12\x03p\x19\x1f\n\
    \x0e\n\x07\x04\x0c\x03\0\x02\x01\x01\x12\x03p\x20,\n\x0e\n\x07\x04\x0c\
    \x03\0\x02\x01\x03\x12\x03p/0\n\x0b\n\x04\x04\x0c\x02\0\x12\x03s\x08E\n\
    \x0c\n\x05\x04\x0c\x02\0\x04\x12\x03s\x08\x10\n\x0c\n\x05\x04\x0c\x02\0\
    \x06\x12\x03s\x118\n\x0c\n\x05\x04\x0c\x02\0\x01\x12\x03s9@\n\x0c\n\x05\
    \x04\x0c\x02\0\x03\x12\x03sCD\n\n\n\x02\x04\r\x12\x04v\0z\x01\n\n\n\x03\
    \x04\r\x01\x12\x03v\x08\x18\n\x0b\n\x04\x04\r\x02\0\x12\x03w\x08%\n\x0c\
    \n\x05\x04\r\x02\0\x04\x12\x03w\x08\x10\n\x0c\n\x05\x04\r\x02\0\x05\x12\
    \x03w\x11\x17\n\x0c\n\x05\x04\r\x02\0\x01\x12\x03w\x18\x20\n\x0c\n\x05\
    \x04\r\x02\0\x03\x12\x03w#$\n\x0b\n\x04\x04\r\x02\x01\x12\x03x\x08'\n\
    \x0c\n\x05\x04\r\x02\x01\x04\x12\x03x\x08\x10\n\x0c\n\x05\x04\r\x02\x01\
    \x05\x12\x03x\x11\x18\n\x0c\n\x05\x04\r\x02\x01\x01\x12\x03x\x19\"\n\x0c\
    \n\x05\x04\r\x02\x01\x03\x12\x03x%&\n\x0b\n\x04\x04\r\x02\x02\x12\x03y\
    \x08'\n\x0c\n\x05\x04\r\x02\x02\x04\x12\x03y\x08\x10\n\x0c\n\x05\x04\r\
    \x02\x02\x05\x12\x03y\x11\x16\n\x0c\n\x05\x04\r\x02\x02\x01\x12\x03y\x17\
    \"\n\x0c\n\x05\x04\r\x02\x02\x03\x12\x03y%&\n\n\n\x02\x04\x0e\x12\x04|\0\
    \x7f\x01\n\n\n\x03\x04\x0e\x01\x12\x03|\x08\x1d\n\x0b\n\x04\x04\x0e\x02\
    \0\x12\x03}\x08%\n\x0c\n\x05\x04\x0e\x02\0\x04\x12\x03}\x08\x10\n\x0c\n\
    \x05\x04\x0e\x02\0\x05\x12\x03}\x11\x17\n\x0c\n\x05\x04\x0e\x02\0\x01\
    \x12\x03}\x18\x20\n\x0c\n\x05\x04\x0e\x02\0\x03\x12\x03}#$\n\x0b\n\x04\
    \x04\x0e\x02\x01\x12\x03~\x08'\n\x0c\n\x05\x04\x0e\x02\x01\x04\x12\x03~\
    \x08\x10\n\x0c\n\x05\x04\x0e\x02\x01\x05\x12\x03~\x11\x16\n\x0c\n\x05\
    \x04\x0e\x02\x01\x01\x12\x03~\x17\"\n\x0c\n\x05\x04\x0e\x02\x01\x03\x12\
    \x03~%&\n\x0c\n\x02\x04\x0f\x12\x06\x81\x01\0\x89\x01\x01\n\x0b\n\x03\
    \x04\x0f\x01\x12\x04\x81\x01\x08$\n\x0e\n\x04\x04\x0f\x03\0\x12\x06\x82\
    \x01\x08\x86\x01\t\n\r\n\x05\x04\x0f\x03\0\x01\x12\x04\x82\x01\x10\x1a\n\
    \x0e\n\x06\x04\x0f\x03\0\x02\0\x12\x04\x83\x01\x10-\n\x0f\n\x07\x04\x0f\
    \x03\0\x02\0\x04\x12\x04\x83\x01\x10\x18\n\x0f\n\x07\x04\x0f\x03\0\x02\0\
    \x05\x12\x04\x83\x01\x19\x20\n\x0f\n\x07\x04\x0f\x03\0\x02\0\x01\x12\x04\
    \x83\x01!(\n\x0f\n\x07\x04\x0f\x03\0\x02\0\x03\x12\x04\x83\x01+,\n\x0e\n\
    \x06\x04\x0f\x03\0\x02\x01\x12\x04\x84\x01\x10(\n\x0f\n\x07\x04\x0f\x03\
    \0\x02\x01\x04\x12\x04\x84\x01\x10\x18\n\x0f\n\x07\x04\x0f\x03\0\x02\x01\
    \x05\x12\x04\x84\x01\x19\x20\n\x0f\n\x07\x04\x0f\x03\0\x02\x01\x01\x12\
    \x04\x84\x01!#\n\x0f\n\x07\x04\x0f\x03\0\x02\x01\x03\x12\x04\x84\x01&'\n\
    \x0e\n\x06\x04\x0f\x03\0\x02\x02\x12\x04\x85\x01\x10*\n\x0f\n\x07\x04\
    \x0f\x03\0\x02\x02\x04\x12\x04\x85\x01\x10\x18\n\x0f\n\x07\x04\x0f\x03\0\
    \x02\x02\x05\x12\x04\x85\x01\x19\x1d\n\x0f\n\x07\x04\x0f\x03\0\x02\x02\
    \x01\x12\x04\x85\x01\x1e%\n\x0f\n\x07\x04\x0f\x03\0\x02\x02\x03\x12\x04\
    \x85\x01()\n\x0c\n\x04\x04\x0f\x02\0\x12\x04\x88\x01\x08F\n\r\n\x05\x04\
    \x0f\x02\0\x04\x12\x04\x88\x01\x08\x10\n\r\n\x05\x04\x0f\x02\0\x06\x12\
    \x04\x88\x01\x119\n\r\n\x05\x04\x0f\x02\0\x01\x12\x04\x88\x01:A\n\r\n\
    \x05\x04\x0f\x02\0\x03\x12\x04\x88\x01DE\n\x0c\n\x02\x04\x10\x12\x06\x8b\
    \x01\0\x8d\x01\x01\n\x0b\n\x03\x04\x10\x01\x12\x04\x8b\x01\x08%\n\x0c\n\
    \x04\x04\x10\x02\0\x12\x04\x8c\x01\x08%\n\r\n\x05\x04\x10\x02\0\x04\x12\
    \x04\x8c\x01\x08\x10\n\r\n\x05\x04\x10\x02\0\x05\x12\x04\x8c\x01\x11\x18\
    \n\r\n\x05\x04\x10\x02\0\x01\x12\x04\x8c\x01\x19\x20\n\r\n\x05\x04\x10\
    \x02\0\x03\x12\x04\x8c\x01#$\n\x0c\n\x02\x04\x11\x12\x06\x8f\x01\0\x92\
    \x01\x01\n\x0b\n\x03\x04\x11\x01\x12\x04\x8f\x01\x08-\n\x0c\n\x04\x04\
    \x11\x02\0\x12\x04\x90\x01\x08\x20\n\r\n\x05\x04\x11\x02\0\x04\x12\x04\
    \x90\x01\x08\x10\n\r\n\x05\x04\x11\x02\0\x05\x12\x04\x90\x01\x11\x18\n\r\
    \n\x05\x04\x11\x02\0\x01\x12\x04\x90\x01\x19\x1b\n\r\n\x05\x04\x11\x02\0\
    \x03\x12\x04\x90\x01\x1e\x1f\n\x0c\n\x04\x04\x11\x02\x01\x12\x04\x91\x01\
    \x08\"\n\r\n\x05\x04\x11\x02\x01\x04\x12\x04\x91\x01\x08\x10\n\r\n\x05\
    \x04\x11\x02\x01\x05\x12\x04\x91\x01\x11\x15\n\r\n\x05\x04\x11\x02\x01\
    \x01\x12\x04\x91\x01\x16\x1d\n\r\n\x05\x04\x11\x02\x01\x03\x12\x04\x91\
    \x01\x20!\n\x0c\n\x02\x04\x12\x12\x06\x94\x01\0\x96\x01\x01\n\x0b\n\x03\
    \x04\x12\x01\x12\x04\x94\x01\x08+\n\x0c\n\x04\x04\x12\x02\0\x12\x04\x95\
    \x01\x08%\n\r\n\x05\x04\x12\x02\0\x04\x12\x04\x95\x01\x08\x10\n\r\n\x05\
    \x04\x12\x02\0\x05\x12\x04\x95\x01\x11\x18\n\r\n\x05\x04\x12\x02\0\x01\
    \x12\x04\x95\x01\x19\x20\n\r\n\x05\x04\x12\x02\0\x03\x12\x04\x95\x01#$\n\
    \x0c\n\x02\x04\x13\x12\x06\x98\x01\0\x9c\x01\x01\n\x0b\n\x03\x04\x13\x01\
    \x12\x04\x98\x01\x08\x1e\n\x0c\n\x04\x04\x13\x02\0\x12\x04\x99\x01\x08)\
    \n\r\n\x05\x04\x13\x02\0\x04\x12\x04\x99\x01\x08\x10\n\r\n\x05\x04\x13\
    \x02\0\x06\x12\x04\x99\x01\x11\x1f\n\r\n\x05\x04\x13\x02\0\x01\x12\x04\
    \x99\x01\x20$\n\r\n\x05\x04\x13\x02\0\x03\x12\x04\x99\x01'(\n\x0c\n\x04\
    \x04\x13\x02\x01\x12\x04\x9a\x01\x08%\n\r\n\x05\x04\x13\x02\x01\x04\x12\
    \x04\x9a\x01\x08\x10\n\r\n\x05\x04\x13\x02\x01\x05\x12\x04\x9a\x01\x11\
    \x18\n\r\n\x05\x04\x13\x02\x01\x01\x12\x04\x9a\x01\x19\x20\n\r\n\x05\x04\
    \x13\x02\x01\x03\x12\x04\x9a\x01#$\n\x0c\n\x04\x04\x13\x02\x02\x12\x04\
    \x9b\x01\x08'\n\r\n\x05\x04\x13\x02\x02\x04\x12\x04\x9b\x01\x08\x10\n\r\
    \n\x05\x04\x13\x02\x02\x05\x12\x04\x9b\x01\x11\x17\n\r\n\x05\x04\x13\x02\
    \x02\x01\x12\x04\x9b\x01\x18\"\n\r\n\x05\x04\x13\x02\x02\x03\x12\x04\x9b\
    \x01%&\n\x0c\n\x02\x04\x14\x12\x06\x9e\x01\0\xa5\x01\x01\n\x0b\n\x03\x04\
    \x14\x01\x12\x04\x9e\x01\x08\x1c\n\x0c\n\x04\x04\x14\x02\0\x12\x04\x9f\
    \x01\x08\\\n\r\n\x05\x04\x14\x02\0\x04\x12\x04\x9f\x01\x08\x10\n\r\n\x05\
    \x04\x14\x02\0\x06\x12\x04\x9f\x01\x11$\n\r\n\x05\x04\x14\x02\0\x01\x12\
    \x04\x9f\x01%+\n\r\n\x05\x04\x14\x02\0\x03\x12\x04\x9f\x01./\n\r\n\x05\
    \x04\x14\x02\0\x08\x12\x04\x9f\x010[\n\r\n\x05\x04\x14\x02\0\x07\x12\x04\
    \x9f\x01;Z\n\x0c\n\x04\x04\x14\x02\x01\x12\x04\xa0\x01\x080\n\r\n\x05\
    \x04\x14\x02\x01\x04\x12\x04\xa0\x01\x08\x10\n\r\n\x05\x04\x14\x02\x01\
    \x05\x12\x04\xa0\x01\x11\x17\n\r\n\x05\x04\x14\x02\x01\x01\x12\x04\xa0\
    \x01\x18+\n\r\n\x05\x04\x14\x02\x01\x03\x12\x04\xa0\x01./\n\x0c\n\x04\
    \x04\x14\x02\x02\x12\x04\xa1\x01\x08*\n\r\n\x05\x04\x14\x02\x02\x04\x12\
    \x04\xa1\x01\x08\x10\n\r\n\x05\x04\x14\x02\x02\x05\x12\x04\xa1\x01\x11\
    \x16\n\r\n\x05\x04\x14\x02\x02\x01\x12\x04\xa1\x01\x17%\n\r\n\x05\x04\
    \x14\x02\x02\x03\x12\x04\xa1\x01()\n\x0c\n\x04\x04\x14\x02\x03\x12\x04\
    \xa2\x01\x08&\n\r\n\x05\x04\x14\x02\x03\x04\x12\x04\xa2\x01\x08\x10\n\r\
    \n\x05\x04\x14\x02\x03\x05\x12\x04\xa2\x01\x11\x16\n\r\n\x05\x04\x14\x02\
    \x03\x01\x12\x04\xa2\x01\x17!\n\r\n\x05\x04\x14\x02\x03\x03\x12\x04\xa2\
    \x01$%\n\x0c\n\x04\x04\x14\x02\x04\x12\x04\xa3\x01\x08(\n\r\n\x05\x04\
    \x14\x02\x04\x04\x12\x04\xa3\x01\x08\x10\n\r\n\x05\x04\x14\x02\x04\x05\
    \x12\x04\xa3\x01\x11\x16\n\r\n\x05\x04\x14\x02\x04\x01\x12\x04\xa3\x01\
    \x17#\n\r\n\x05\x04\x14\x02\x04\x03\x12\x04\xa3\x01&'\n\x0c\n\x04\x04\
    \x14\x02\x05\x12\x04\xa4\x01\x08<\n\r\n\x05\x04\x14\x02\x05\x04\x12\x04\
    \xa4\x01\x08\x10\n\r\n\x05\x04\x14\x02\x05\x05\x12\x04\xa4\x01\x11\x16\n\
    \r\n\x05\x04\x14\x02\x05\x01\x12\x04\xa4\x01\x177\n\r\n\x05\x04\x14\x02\
    \x05\x03\x12\x04\xa4\x01:;\n\x0c\n\x02\x04\x15\x12\x06\xa7\x01\0\xb1\x01\
    \x01\n\x0b\n\x03\x04\x15\x01\x12\x04\xa7\x01\x08\"\n\x0e\n\x04\x04\x15\
    \x03\0\x12\x06\xa8\x01\x08\xab\x01\t\n\r\n\x05\x04\x15\x03\0\x01\x12\x04\
    \xa8\x01\x10\x20\n\x0e\n\x06\x04\x15\x03\0\x02\0\x12\x04\xa9\x01\x10/\n\
    \x0f\n\x07\x04\x15\x03\0\x02\0\x04\x12\x04\xa9\x01\x10\x18\n\x0f\n\x07\
    \x04\x15\x03\0\x02\0\x05\x12\x04\xa9\x01\x19\x1f\n\x0f\n\x07\x04\x15\x03\
    \0\x02\0\x01\x12\x04\xa9\x01\x20*\n\x0f\n\x07\x04\x15\x03\0\x02\0\x03\
    \x12\x04\xa9\x01-.\n\x0e\n\x06\x04\x15\x03\0\x02\x01\x12\x04\xaa\x01\x10\
    ,\n\x0f\n\x07\x04\x15\x03\0\x02\x01\x04\x12\x04\xaa\x01\x10\x18\n\x0f\n\
    \x07\x04\x15\x03\0\x02\x01\x05\x12\x04\xaa\x01\x19\x1f\n\x0f\n\x07\x04\
    \x15\x03\0\x02\x01\x01\x12\x04\xaa\x01\x20'\n\x0f\n\x07\x04\x15\x03\0\
    \x02\x01\x03\x12\x04\xaa\x01*+\n\x0c\n\x04\x04\x15\x02\0\x12\x04\xad\x01\
    \x08(\n\r\n\x05\x04\x15\x02\0\x04\x12\x04\xad\x01\x08\x10\n\r\n\x05\x04\
    \x15\x02\0\x05\x12\x04\xad\x01\x11\x18\n\r\n\x05\x04\x15\x02\0\x01\x12\
    \x04\xad\x01\x19#\n\r\n\x05\x04\x15\x02\0\x03\x12\x04\xad\x01&'\n\x0c\n\
    \x04\x04\x15\x02\x01\x12\x04\xae\x01\x08*\n\r\n\x05\x04\x15\x02\x01\x04\
    \x12\x04\xae\x01\x08\x10\n\r\n\x05\x04\x15\x02\x01\x05\x12\x04\xae\x01\
    \x11\x18\n\r\n\x05\x04\x15\x02\x01\x01\x12\x04\xae\x01\x19%\n\r\n\x05\
    \x04\x15\x02\x01\x03\x12\x04\xae\x01()\n\x0c\n\x04\x04\x15\x02\x02\x12\
    \x04\xaf\x01\x08*\n\r\n\x05\x04\x15\x02\x02\x04\x12\x04\xaf\x01\x08\x10\
    \n\r\n\x05\x04\x15\x02\x02\x05\x12\x04\xaf\x01\x11\x18\n\r\n\x05\x04\x15\
    \x02\x02\x01\x12\x04\xaf\x01\x19%\n\r\n\x05\x04\x15\x02\x02\x03\x12\x04\
    \xaf\x01()\n\x0c\n\x04\x04\x15\x02\x03\x12\x04\xb0\x01\x08P\n\r\n\x05\
    \x04\x15\x02\x03\x04\x12\x04\xb0\x01\x08\x10\n\r\n\x05\x04\x15\x02\x03\
    \x06\x12\x04\xb0\x01\x11=\n\r\n\x05\x04\x15\x02\x03\x01\x12\x04\xb0\x01>\
    K\n\r\n\x05\x04\x15\x02\x03\x03\x12\x04\xb0\x01NO\n\x0c\n\x02\x04\x16\
    \x12\x06\xb3\x01\0\xb6\x01\x01\n\x0b\n\x03\x04\x16\x01\x12\x04\xb3\x01\
    \x08$\n\x0c\n\x04\x04\x16\x02\0\x12\x04\xb4\x01\x08(\n\r\n\x05\x04\x16\
    \x02\0\x04\x12\x04\xb4\x01\x08\x10\n\r\n\x05\x04\x16\x02\0\x05\x12\x04\
    \xb4\x01\x11\x18\n\r\n\x05\x04\x16\x02\0\x01\x12\x04\xb4\x01\x19#\n\r\n\
    \x05\x04\x16\x02\0\x03\x12\x04\xb4\x01&'\n\x0c\n\x04\x04\x16\x02\x01\x12\
    \x04\xb5\x01\x08.\n\r\n\x05\x04\x16\x02\x01\x04\x12\x04\xb5\x01\x08\x10\
    \n\r\n\x05\x04\x16\x02\x01\x05\x12\x04\xb5\x01\x11\x18\n\r\n\x05\x04\x16\
    \x02\x01\x01\x12\x04\xb5\x01\x19)\n\r\n\x05\x04\x16\x02\x01\x03\x12\x04\
    \xb5\x01,-\n\x0c\n\x02\x04\x17\x12\x06\xb8\x01\0\xb9\x01\x01\n\x0b\n\x03\
    \x04\x17\x01\x12\x04\xb8\x01\x08\x18\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
