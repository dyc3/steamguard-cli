// This file is generated by rust-protobuf 2.24.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `tf_proto_def_messages.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_24_1;

#[derive(PartialEq,Clone,Default)]
pub struct CMsgFieldID {
    // message fields
    pub field: ::protobuf::RepeatedField<CMsgFieldID_CMsgField>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgFieldID {
    fn default() -> &'a CMsgFieldID {
        <CMsgFieldID as ::protobuf::Message>::default_instance()
    }
}

impl CMsgFieldID {
    pub fn new() -> CMsgFieldID {
        ::std::default::Default::default()
    }

    // repeated .CMsgFieldID.CMsgField field = 1;


    pub fn get_field(&self) -> &[CMsgFieldID_CMsgField] {
        &self.field
    }
    pub fn clear_field(&mut self) {
        self.field.clear();
    }

    // Param is passed by value, moved
    pub fn set_field(&mut self, v: ::protobuf::RepeatedField<CMsgFieldID_CMsgField>) {
        self.field = v;
    }

    // Mutable pointer to the field.
    pub fn mut_field(&mut self) -> &mut ::protobuf::RepeatedField<CMsgFieldID_CMsgField> {
        &mut self.field
    }

    // Take field
    pub fn take_field(&mut self) -> ::protobuf::RepeatedField<CMsgFieldID_CMsgField> {
        ::std::mem::replace(&mut self.field, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgFieldID {
    fn is_initialized(&self) -> bool {
        for v in &self.field {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.field)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.field {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.field {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgFieldID {
        CMsgFieldID::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgFieldID_CMsgField>>(
                "field",
                |m: &CMsgFieldID| { &m.field },
                |m: &mut CMsgFieldID| { &mut m.field },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgFieldID>(
                "CMsgFieldID",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgFieldID {
        static instance: ::protobuf::rt::LazyV2<CMsgFieldID> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgFieldID::new)
    }
}

impl ::protobuf::Clear for CMsgFieldID {
    fn clear(&mut self) {
        self.field.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgFieldID {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgFieldID {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgFieldID_CMsgField {
    // message fields
    field_number: ::std::option::Option<u32>,
    repeated_index: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgFieldID_CMsgField {
    fn default() -> &'a CMsgFieldID_CMsgField {
        <CMsgFieldID_CMsgField as ::protobuf::Message>::default_instance()
    }
}

impl CMsgFieldID_CMsgField {
    pub fn new() -> CMsgFieldID_CMsgField {
        ::std::default::Default::default()
    }

    // optional uint32 field_number = 1;


    pub fn get_field_number(&self) -> u32 {
        self.field_number.unwrap_or(0)
    }
    pub fn clear_field_number(&mut self) {
        self.field_number = ::std::option::Option::None;
    }

    pub fn has_field_number(&self) -> bool {
        self.field_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_number(&mut self, v: u32) {
        self.field_number = ::std::option::Option::Some(v);
    }

    // optional uint32 repeated_index = 2;


    pub fn get_repeated_index(&self) -> u32 {
        self.repeated_index.unwrap_or(0)
    }
    pub fn clear_repeated_index(&mut self) {
        self.repeated_index = ::std::option::Option::None;
    }

    pub fn has_repeated_index(&self) -> bool {
        self.repeated_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_repeated_index(&mut self, v: u32) {
        self.repeated_index = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgFieldID_CMsgField {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.field_number = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.repeated_index = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_number {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.repeated_index {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_number {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.repeated_index {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgFieldID_CMsgField {
        CMsgFieldID_CMsgField::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "field_number",
                |m: &CMsgFieldID_CMsgField| { &m.field_number },
                |m: &mut CMsgFieldID_CMsgField| { &mut m.field_number },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "repeated_index",
                |m: &CMsgFieldID_CMsgField| { &m.repeated_index },
                |m: &mut CMsgFieldID_CMsgField| { &mut m.repeated_index },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgFieldID_CMsgField>(
                "CMsgFieldID.CMsgField",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgFieldID_CMsgField {
        static instance: ::protobuf::rt::LazyV2<CMsgFieldID_CMsgField> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgFieldID_CMsgField::new)
    }
}

impl ::protobuf::Clear for CMsgFieldID_CMsgField {
    fn clear(&mut self) {
        self.field_number = ::std::option::Option::None;
        self.repeated_index = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgFieldID_CMsgField {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgFieldID_CMsgField {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgUniversalFieldID {
    // message fields
    source_type: ::std::option::Option<EValueDefinitionSource>,
    pub defining_obj_id: ::protobuf::SingularPtrField<CMsgProtoDefID>,
    pub field_id: ::protobuf::SingularPtrField<CMsgFieldID>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgUniversalFieldID {
    fn default() -> &'a CMsgUniversalFieldID {
        <CMsgUniversalFieldID as ::protobuf::Message>::default_instance()
    }
}

impl CMsgUniversalFieldID {
    pub fn new() -> CMsgUniversalFieldID {
        ::std::default::Default::default()
    }

    // optional .EValueDefinitionSource source_type = 1;


    pub fn get_source_type(&self) -> EValueDefinitionSource {
        self.source_type.unwrap_or(EValueDefinitionSource::REFERENCE_DEFINES)
    }
    pub fn clear_source_type(&mut self) {
        self.source_type = ::std::option::Option::None;
    }

    pub fn has_source_type(&self) -> bool {
        self.source_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source_type(&mut self, v: EValueDefinitionSource) {
        self.source_type = ::std::option::Option::Some(v);
    }

    // optional .CMsgProtoDefID defining_obj_id = 2;


    pub fn get_defining_obj_id(&self) -> &CMsgProtoDefID {
        self.defining_obj_id.as_ref().unwrap_or_else(|| <CMsgProtoDefID as ::protobuf::Message>::default_instance())
    }
    pub fn clear_defining_obj_id(&mut self) {
        self.defining_obj_id.clear();
    }

    pub fn has_defining_obj_id(&self) -> bool {
        self.defining_obj_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_defining_obj_id(&mut self, v: CMsgProtoDefID) {
        self.defining_obj_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_defining_obj_id(&mut self) -> &mut CMsgProtoDefID {
        if self.defining_obj_id.is_none() {
            self.defining_obj_id.set_default();
        }
        self.defining_obj_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_defining_obj_id(&mut self) -> CMsgProtoDefID {
        self.defining_obj_id.take().unwrap_or_else(|| CMsgProtoDefID::new())
    }

    // optional .CMsgFieldID field_id = 3;


    pub fn get_field_id(&self) -> &CMsgFieldID {
        self.field_id.as_ref().unwrap_or_else(|| <CMsgFieldID as ::protobuf::Message>::default_instance())
    }
    pub fn clear_field_id(&mut self) {
        self.field_id.clear();
    }

    pub fn has_field_id(&self) -> bool {
        self.field_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_id(&mut self, v: CMsgFieldID) {
        self.field_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_id(&mut self) -> &mut CMsgFieldID {
        if self.field_id.is_none() {
            self.field_id.set_default();
        }
        self.field_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_field_id(&mut self) -> CMsgFieldID {
        self.field_id.take().unwrap_or_else(|| CMsgFieldID::new())
    }
}

impl ::protobuf::Message for CMsgUniversalFieldID {
    fn is_initialized(&self) -> bool {
        for v in &self.defining_obj_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.field_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.source_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.defining_obj_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.field_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.source_type {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(ref v) = self.defining_obj_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.field_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.source_type {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.defining_obj_id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.field_id.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgUniversalFieldID {
        CMsgUniversalFieldID::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EValueDefinitionSource>>(
                "source_type",
                |m: &CMsgUniversalFieldID| { &m.source_type },
                |m: &mut CMsgUniversalFieldID| { &mut m.source_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgProtoDefID>>(
                "defining_obj_id",
                |m: &CMsgUniversalFieldID| { &m.defining_obj_id },
                |m: &mut CMsgUniversalFieldID| { &mut m.defining_obj_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgFieldID>>(
                "field_id",
                |m: &CMsgUniversalFieldID| { &m.field_id },
                |m: &mut CMsgUniversalFieldID| { &mut m.field_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgUniversalFieldID>(
                "CMsgUniversalFieldID",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgUniversalFieldID {
        static instance: ::protobuf::rt::LazyV2<CMsgUniversalFieldID> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgUniversalFieldID::new)
    }
}

impl ::protobuf::Clear for CMsgUniversalFieldID {
    fn clear(&mut self) {
        self.source_type = ::std::option::Option::None;
        self.defining_obj_id.clear();
        self.field_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgUniversalFieldID {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgUniversalFieldID {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgVariableDefinition {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    inherit: ::std::option::Option<bool>,
    value: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgVariableDefinition {
    fn default() -> &'a CMsgVariableDefinition {
        <CMsgVariableDefinition as ::protobuf::Message>::default_instance()
    }
}

impl CMsgVariableDefinition {
    pub fn new() -> CMsgVariableDefinition {
        ::std::default::Default::default()
    }

    // optional string name = 1;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool inherit = 2;


    pub fn get_inherit(&self) -> bool {
        self.inherit.unwrap_or(true)
    }
    pub fn clear_inherit(&mut self) {
        self.inherit = ::std::option::Option::None;
    }

    pub fn has_inherit(&self) -> bool {
        self.inherit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inherit(&mut self, v: bool) {
        self.inherit = ::std::option::Option::Some(v);
    }

    // optional string value = 3;


    pub fn get_value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgVariableDefinition {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.inherit = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.inherit {
            my_size += 2;
        }
        if let Some(ref v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.inherit {
            os.write_bool(2, v)?;
        }
        if let Some(ref v) = self.value.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgVariableDefinition {
        CMsgVariableDefinition::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &CMsgVariableDefinition| { &m.name },
                |m: &mut CMsgVariableDefinition| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "inherit",
                |m: &CMsgVariableDefinition| { &m.inherit },
                |m: &mut CMsgVariableDefinition| { &mut m.inherit },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "value",
                |m: &CMsgVariableDefinition| { &m.value },
                |m: &mut CMsgVariableDefinition| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgVariableDefinition>(
                "CMsgVariableDefinition",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgVariableDefinition {
        static instance: ::protobuf::rt::LazyV2<CMsgVariableDefinition> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgVariableDefinition::new)
    }
}

impl ::protobuf::Clear for CMsgVariableDefinition {
    fn clear(&mut self) {
        self.name.clear();
        self.inherit = ::std::option::Option::None;
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgVariableDefinition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgVariableDefinition {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgProtoDefHeader {
    // message fields
    defindex: ::std::option::Option<u32>,
    name: ::protobuf::SingularField<::std::string::String>,
    pub prefabs: ::protobuf::RepeatedField<CMsgProtoDefID>,
    pub tags: ::protobuf::RepeatedField<::std::string::String>,
    prefab_only: ::std::option::Option<bool>,
    pub variables: ::protobuf::RepeatedField<CMsgVariableDefinition>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgProtoDefHeader {
    fn default() -> &'a CMsgProtoDefHeader {
        <CMsgProtoDefHeader as ::protobuf::Message>::default_instance()
    }
}

impl CMsgProtoDefHeader {
    pub fn new() -> CMsgProtoDefHeader {
        ::std::default::Default::default()
    }

    // required uint32 defindex = 1;


    pub fn get_defindex(&self) -> u32 {
        self.defindex.unwrap_or(0)
    }
    pub fn clear_defindex(&mut self) {
        self.defindex = ::std::option::Option::None;
    }

    pub fn has_defindex(&self) -> bool {
        self.defindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_defindex(&mut self, v: u32) {
        self.defindex = ::std::option::Option::Some(v);
    }

    // optional string name = 2;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .CMsgProtoDefID prefabs = 3;


    pub fn get_prefabs(&self) -> &[CMsgProtoDefID] {
        &self.prefabs
    }
    pub fn clear_prefabs(&mut self) {
        self.prefabs.clear();
    }

    // Param is passed by value, moved
    pub fn set_prefabs(&mut self, v: ::protobuf::RepeatedField<CMsgProtoDefID>) {
        self.prefabs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_prefabs(&mut self) -> &mut ::protobuf::RepeatedField<CMsgProtoDefID> {
        &mut self.prefabs
    }

    // Take field
    pub fn take_prefabs(&mut self) -> ::protobuf::RepeatedField<CMsgProtoDefID> {
        ::std::mem::replace(&mut self.prefabs, ::protobuf::RepeatedField::new())
    }

    // repeated string tags = 4;


    pub fn get_tags(&self) -> &[::std::string::String] {
        &self.tags
    }
    pub fn clear_tags(&mut self) {
        self.tags.clear();
    }

    // Param is passed by value, moved
    pub fn set_tags(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.tags = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tags(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.tags
    }

    // Take field
    pub fn take_tags(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.tags, ::protobuf::RepeatedField::new())
    }

    // optional bool prefab_only = 5;


    pub fn get_prefab_only(&self) -> bool {
        self.prefab_only.unwrap_or(false)
    }
    pub fn clear_prefab_only(&mut self) {
        self.prefab_only = ::std::option::Option::None;
    }

    pub fn has_prefab_only(&self) -> bool {
        self.prefab_only.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prefab_only(&mut self, v: bool) {
        self.prefab_only = ::std::option::Option::Some(v);
    }

    // repeated .CMsgVariableDefinition variables = 6;


    pub fn get_variables(&self) -> &[CMsgVariableDefinition] {
        &self.variables
    }
    pub fn clear_variables(&mut self) {
        self.variables.clear();
    }

    // Param is passed by value, moved
    pub fn set_variables(&mut self, v: ::protobuf::RepeatedField<CMsgVariableDefinition>) {
        self.variables = v;
    }

    // Mutable pointer to the field.
    pub fn mut_variables(&mut self) -> &mut ::protobuf::RepeatedField<CMsgVariableDefinition> {
        &mut self.variables
    }

    // Take field
    pub fn take_variables(&mut self) -> ::protobuf::RepeatedField<CMsgVariableDefinition> {
        ::std::mem::replace(&mut self.variables, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgProtoDefHeader {
    fn is_initialized(&self) -> bool {
        if self.defindex.is_none() {
            return false;
        }
        for v in &self.prefabs {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.variables {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.defindex = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.prefabs)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.tags)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.prefab_only = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.variables)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.defindex {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.prefabs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.tags {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        if let Some(v) = self.prefab_only {
            my_size += 2;
        }
        for value in &self.variables {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.defindex {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(2, &v)?;
        }
        for v in &self.prefabs {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.tags {
            os.write_string(4, &v)?;
        };
        if let Some(v) = self.prefab_only {
            os.write_bool(5, v)?;
        }
        for v in &self.variables {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgProtoDefHeader {
        CMsgProtoDefHeader::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "defindex",
                |m: &CMsgProtoDefHeader| { &m.defindex },
                |m: &mut CMsgProtoDefHeader| { &mut m.defindex },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &CMsgProtoDefHeader| { &m.name },
                |m: &mut CMsgProtoDefHeader| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgProtoDefID>>(
                "prefabs",
                |m: &CMsgProtoDefHeader| { &m.prefabs },
                |m: &mut CMsgProtoDefHeader| { &mut m.prefabs },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "tags",
                |m: &CMsgProtoDefHeader| { &m.tags },
                |m: &mut CMsgProtoDefHeader| { &mut m.tags },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "prefab_only",
                |m: &CMsgProtoDefHeader| { &m.prefab_only },
                |m: &mut CMsgProtoDefHeader| { &mut m.prefab_only },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgVariableDefinition>>(
                "variables",
                |m: &CMsgProtoDefHeader| { &m.variables },
                |m: &mut CMsgProtoDefHeader| { &mut m.variables },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgProtoDefHeader>(
                "CMsgProtoDefHeader",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgProtoDefHeader {
        static instance: ::protobuf::rt::LazyV2<CMsgProtoDefHeader> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgProtoDefHeader::new)
    }
}

impl ::protobuf::Clear for CMsgProtoDefHeader {
    fn clear(&mut self) {
        self.defindex = ::std::option::Option::None;
        self.name.clear();
        self.prefabs.clear();
        self.tags.clear();
        self.prefab_only = ::std::option::Option::None;
        self.variables.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgProtoDefHeader {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgProtoDefHeader {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgValidTypes {
    // message fields
    pub types: ::std::vec::Vec<ProtoDefTypes>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgValidTypes {
    fn default() -> &'a CMsgValidTypes {
        <CMsgValidTypes as ::protobuf::Message>::default_instance()
    }
}

impl CMsgValidTypes {
    pub fn new() -> CMsgValidTypes {
        ::std::default::Default::default()
    }

    // repeated .ProtoDefTypes types = 1;


    pub fn get_types(&self) -> &[ProtoDefTypes] {
        &self.types
    }
    pub fn clear_types(&mut self) {
        self.types.clear();
    }

    // Param is passed by value, moved
    pub fn set_types(&mut self, v: ::std::vec::Vec<ProtoDefTypes>) {
        self.types = v;
    }

    // Mutable pointer to the field.
    pub fn mut_types(&mut self) -> &mut ::std::vec::Vec<ProtoDefTypes> {
        &mut self.types
    }

    // Take field
    pub fn take_types(&mut self) -> ::std::vec::Vec<ProtoDefTypes> {
        ::std::mem::replace(&mut self.types, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgValidTypes {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.types, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.types {
            my_size += ::protobuf::rt::enum_size(1, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.types {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(v))?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgValidTypes {
        CMsgValidTypes::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ProtoDefTypes>>(
                "types",
                |m: &CMsgValidTypes| { &m.types },
                |m: &mut CMsgValidTypes| { &mut m.types },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgValidTypes>(
                "CMsgValidTypes",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgValidTypes {
        static instance: ::protobuf::rt::LazyV2<CMsgValidTypes> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgValidTypes::new)
    }
}

impl ::protobuf::Clear for CMsgValidTypes {
    fn clear(&mut self) {
        self.types.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgValidTypes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgValidTypes {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgProtoDefID {
    // message fields
    defindex: ::std::option::Option<u32>,
    field_type: ::std::option::Option<ProtoDefTypes>,
    // message oneof groups
    pub instance: ::std::option::Option<CMsgProtoDefID_oneof_instance>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgProtoDefID {
    fn default() -> &'a CMsgProtoDefID {
        <CMsgProtoDefID as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum CMsgProtoDefID_oneof_instance {
    instance_def_type_quest_map_node(CMsgQuestMapNodeDef),
    instance_def_type_quest_theme(CMsgQuestTheme),
    instance_def_type_quest_map_region(CMsgQuestMapRegionDef),
    instance_def_type_quest(CMsgQuestDef),
    instance_def_type_quest_objective(CMsgQuestObjectiveDef),
    instance_def_type_paintkit_variables(CMsgPaintKit_Variables),
    instance_def_type_paintkit_operation(CMsgPaintKit_Operation),
    instance_def_type_paintkit_item_definition(CMsgPaintKit_ItemDefinition),
    instance_def_type_paintkit_definition(CMsgPaintKit_Definition),
    instance_def_type_header_only(CMsgHeaderOnly),
}

impl CMsgProtoDefID {
    pub fn new() -> CMsgProtoDefID {
        ::std::default::Default::default()
    }

    // optional uint32 defindex = 1;


    pub fn get_defindex(&self) -> u32 {
        self.defindex.unwrap_or(0)
    }
    pub fn clear_defindex(&mut self) {
        self.defindex = ::std::option::Option::None;
    }

    pub fn has_defindex(&self) -> bool {
        self.defindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_defindex(&mut self, v: u32) {
        self.defindex = ::std::option::Option::Some(v);
    }

    // optional .ProtoDefTypes type = 2;


    pub fn get_field_type(&self) -> ProtoDefTypes {
        self.field_type.unwrap_or(ProtoDefTypes::DEF_TYPE_QUEST_MAP_NODE)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ProtoDefTypes) {
        self.field_type = ::std::option::Option::Some(v);
    }

    // optional .CMsgQuestMapNodeDef instance_def_type_quest_map_node = 3;


    pub fn get_instance_def_type_quest_map_node(&self) -> &CMsgQuestMapNodeDef {
        match self.instance {
            ::std::option::Option::Some(CMsgProtoDefID_oneof_instance::instance_def_type_quest_map_node(ref v)) => v,
            _ => <CMsgQuestMapNodeDef as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_instance_def_type_quest_map_node(&mut self) {
        self.instance = ::std::option::Option::None;
    }

    pub fn has_instance_def_type_quest_map_node(&self) -> bool {
        match self.instance {
            ::std::option::Option::Some(CMsgProtoDefID_oneof_instance::instance_def_type_quest_map_node(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_instance_def_type_quest_map_node(&mut self, v: CMsgQuestMapNodeDef) {
        self.instance = ::std::option::Option::Some(CMsgProtoDefID_oneof_instance::instance_def_type_quest_map_node(v))
    }

    // Mutable pointer to the field.
    pub fn mut_instance_def_type_quest_map_node(&mut self) -> &mut CMsgQuestMapNodeDef {
        if let ::std::option::Option::Some(CMsgProtoDefID_oneof_instance::instance_def_type_quest_map_node(_)) = self.instance {
        } else {
            self.instance = ::std::option::Option::Some(CMsgProtoDefID_oneof_instance::instance_def_type_quest_map_node(CMsgQuestMapNodeDef::new()));
        }
        match self.instance {
            ::std::option::Option::Some(CMsgProtoDefID_oneof_instance::instance_def_type_quest_map_node(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_instance_def_type_quest_map_node(&mut self) -> CMsgQuestMapNodeDef {
        if self.has_instance_def_type_quest_map_node() {
            match self.instance.take() {
                ::std::option::Option::Some(CMsgProtoDefID_oneof_instance::instance_def_type_quest_map_node(v)) => v,
                _ => panic!(),
            }
        } else {
            CMsgQuestMapNodeDef::new()
        }
    }

    // optional .CMsgQuestTheme instance_def_type_quest_theme = 5;


    pub fn get_instance_def_type_quest_theme(&self) -> &CMsgQuestTheme {
        match self.instance {
            ::std::option::Option::Some(CMsgProtoDefID_oneof_instance::instance_def_type_quest_theme(ref v)) => v,
            _ => <CMsgQuestTheme as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_instance_def_type_quest_theme(&mut self) {
        self.instance = ::std::option::Option::None;
    }

    pub fn has_instance_def_type_quest_theme(&self) -> bool {
        match self.instance {
            ::std::option::Option::Some(CMsgProtoDefID_oneof_instance::instance_def_type_quest_theme(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_instance_def_type_quest_theme(&mut self, v: CMsgQuestTheme) {
        self.instance = ::std::option::Option::Some(CMsgProtoDefID_oneof_instance::instance_def_type_quest_theme(v))
    }

    // Mutable pointer to the field.
    pub fn mut_instance_def_type_quest_theme(&mut self) -> &mut CMsgQuestTheme {
        if let ::std::option::Option::Some(CMsgProtoDefID_oneof_instance::instance_def_type_quest_theme(_)) = self.instance {
        } else {
            self.instance = ::std::option::Option::Some(CMsgProtoDefID_oneof_instance::instance_def_type_quest_theme(CMsgQuestTheme::new()));
        }
        match self.instance {
            ::std::option::Option::Some(CMsgProtoDefID_oneof_instance::instance_def_type_quest_theme(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_instance_def_type_quest_theme(&mut self) -> CMsgQuestTheme {
        if self.has_instance_def_type_quest_theme() {
            match self.instance.take() {
                ::std::option::Option::Some(CMsgProtoDefID_oneof_instance::instance_def_type_quest_theme(v)) => v,
                _ => panic!(),
            }
        } else {
            CMsgQuestTheme::new()
        }
    }

    // optional .CMsgQuestMapRegionDef instance_def_type_quest_map_region = 6;


    pub fn get_instance_def_type_quest_map_region(&self) -> &CMsgQuestMapRegionDef {
        match self.instance {
            ::std::option::Option::Some(CMsgProtoDefID_oneof_instance::instance_def_type_quest_map_region(ref v)) => v,
            _ => <CMsgQuestMapRegionDef as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_instance_def_type_quest_map_region(&mut self) {
        self.instance = ::std::option::Option::None;
    }

    pub fn has_instance_def_type_quest_map_region(&self) -> bool {
        match self.instance {
            ::std::option::Option::Some(CMsgProtoDefID_oneof_instance::instance_def_type_quest_map_region(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_instance_def_type_quest_map_region(&mut self, v: CMsgQuestMapRegionDef) {
        self.instance = ::std::option::Option::Some(CMsgProtoDefID_oneof_instance::instance_def_type_quest_map_region(v))
    }

    // Mutable pointer to the field.
    pub fn mut_instance_def_type_quest_map_region(&mut self) -> &mut CMsgQuestMapRegionDef {
        if let ::std::option::Option::Some(CMsgProtoDefID_oneof_instance::instance_def_type_quest_map_region(_)) = self.instance {
        } else {
            self.instance = ::std::option::Option::Some(CMsgProtoDefID_oneof_instance::instance_def_type_quest_map_region(CMsgQuestMapRegionDef::new()));
        }
        match self.instance {
            ::std::option::Option::Some(CMsgProtoDefID_oneof_instance::instance_def_type_quest_map_region(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_instance_def_type_quest_map_region(&mut self) -> CMsgQuestMapRegionDef {
        if self.has_instance_def_type_quest_map_region() {
            match self.instance.take() {
                ::std::option::Option::Some(CMsgProtoDefID_oneof_instance::instance_def_type_quest_map_region(v)) => v,
                _ => panic!(),
            }
        } else {
            CMsgQuestMapRegionDef::new()
        }
    }

    // optional .CMsgQuestDef instance_def_type_quest = 7;


    pub fn get_instance_def_type_quest(&self) -> &CMsgQuestDef {
        match self.instance {
            ::std::option::Option::Some(CMsgProtoDefID_oneof_instance::instance_def_type_quest(ref v)) => v,
            _ => <CMsgQuestDef as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_instance_def_type_quest(&mut self) {
        self.instance = ::std::option::Option::None;
    }

    pub fn has_instance_def_type_quest(&self) -> bool {
        match self.instance {
            ::std::option::Option::Some(CMsgProtoDefID_oneof_instance::instance_def_type_quest(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_instance_def_type_quest(&mut self, v: CMsgQuestDef) {
        self.instance = ::std::option::Option::Some(CMsgProtoDefID_oneof_instance::instance_def_type_quest(v))
    }

    // Mutable pointer to the field.
    pub fn mut_instance_def_type_quest(&mut self) -> &mut CMsgQuestDef {
        if let ::std::option::Option::Some(CMsgProtoDefID_oneof_instance::instance_def_type_quest(_)) = self.instance {
        } else {
            self.instance = ::std::option::Option::Some(CMsgProtoDefID_oneof_instance::instance_def_type_quest(CMsgQuestDef::new()));
        }
        match self.instance {
            ::std::option::Option::Some(CMsgProtoDefID_oneof_instance::instance_def_type_quest(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_instance_def_type_quest(&mut self) -> CMsgQuestDef {
        if self.has_instance_def_type_quest() {
            match self.instance.take() {
                ::std::option::Option::Some(CMsgProtoDefID_oneof_instance::instance_def_type_quest(v)) => v,
                _ => panic!(),
            }
        } else {
            CMsgQuestDef::new()
        }
    }

    // optional .CMsgQuestObjectiveDef instance_def_type_quest_objective = 8;


    pub fn get_instance_def_type_quest_objective(&self) -> &CMsgQuestObjectiveDef {
        match self.instance {
            ::std::option::Option::Some(CMsgProtoDefID_oneof_instance::instance_def_type_quest_objective(ref v)) => v,
            _ => <CMsgQuestObjectiveDef as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_instance_def_type_quest_objective(&mut self) {
        self.instance = ::std::option::Option::None;
    }

    pub fn has_instance_def_type_quest_objective(&self) -> bool {
        match self.instance {
            ::std::option::Option::Some(CMsgProtoDefID_oneof_instance::instance_def_type_quest_objective(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_instance_def_type_quest_objective(&mut self, v: CMsgQuestObjectiveDef) {
        self.instance = ::std::option::Option::Some(CMsgProtoDefID_oneof_instance::instance_def_type_quest_objective(v))
    }

    // Mutable pointer to the field.
    pub fn mut_instance_def_type_quest_objective(&mut self) -> &mut CMsgQuestObjectiveDef {
        if let ::std::option::Option::Some(CMsgProtoDefID_oneof_instance::instance_def_type_quest_objective(_)) = self.instance {
        } else {
            self.instance = ::std::option::Option::Some(CMsgProtoDefID_oneof_instance::instance_def_type_quest_objective(CMsgQuestObjectiveDef::new()));
        }
        match self.instance {
            ::std::option::Option::Some(CMsgProtoDefID_oneof_instance::instance_def_type_quest_objective(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_instance_def_type_quest_objective(&mut self) -> CMsgQuestObjectiveDef {
        if self.has_instance_def_type_quest_objective() {
            match self.instance.take() {
                ::std::option::Option::Some(CMsgProtoDefID_oneof_instance::instance_def_type_quest_objective(v)) => v,
                _ => panic!(),
            }
        } else {
            CMsgQuestObjectiveDef::new()
        }
    }

    // optional .CMsgPaintKit_Variables instance_def_type_paintkit_variables = 9;


    pub fn get_instance_def_type_paintkit_variables(&self) -> &CMsgPaintKit_Variables {
        match self.instance {
            ::std::option::Option::Some(CMsgProtoDefID_oneof_instance::instance_def_type_paintkit_variables(ref v)) => v,
            _ => <CMsgPaintKit_Variables as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_instance_def_type_paintkit_variables(&mut self) {
        self.instance = ::std::option::Option::None;
    }

    pub fn has_instance_def_type_paintkit_variables(&self) -> bool {
        match self.instance {
            ::std::option::Option::Some(CMsgProtoDefID_oneof_instance::instance_def_type_paintkit_variables(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_instance_def_type_paintkit_variables(&mut self, v: CMsgPaintKit_Variables) {
        self.instance = ::std::option::Option::Some(CMsgProtoDefID_oneof_instance::instance_def_type_paintkit_variables(v))
    }

    // Mutable pointer to the field.
    pub fn mut_instance_def_type_paintkit_variables(&mut self) -> &mut CMsgPaintKit_Variables {
        if let ::std::option::Option::Some(CMsgProtoDefID_oneof_instance::instance_def_type_paintkit_variables(_)) = self.instance {
        } else {
            self.instance = ::std::option::Option::Some(CMsgProtoDefID_oneof_instance::instance_def_type_paintkit_variables(CMsgPaintKit_Variables::new()));
        }
        match self.instance {
            ::std::option::Option::Some(CMsgProtoDefID_oneof_instance::instance_def_type_paintkit_variables(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_instance_def_type_paintkit_variables(&mut self) -> CMsgPaintKit_Variables {
        if self.has_instance_def_type_paintkit_variables() {
            match self.instance.take() {
                ::std::option::Option::Some(CMsgProtoDefID_oneof_instance::instance_def_type_paintkit_variables(v)) => v,
                _ => panic!(),
            }
        } else {
            CMsgPaintKit_Variables::new()
        }
    }

    // optional .CMsgPaintKit_Operation instance_def_type_paintkit_operation = 10;


    pub fn get_instance_def_type_paintkit_operation(&self) -> &CMsgPaintKit_Operation {
        match self.instance {
            ::std::option::Option::Some(CMsgProtoDefID_oneof_instance::instance_def_type_paintkit_operation(ref v)) => v,
            _ => <CMsgPaintKit_Operation as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_instance_def_type_paintkit_operation(&mut self) {
        self.instance = ::std::option::Option::None;
    }

    pub fn has_instance_def_type_paintkit_operation(&self) -> bool {
        match self.instance {
            ::std::option::Option::Some(CMsgProtoDefID_oneof_instance::instance_def_type_paintkit_operation(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_instance_def_type_paintkit_operation(&mut self, v: CMsgPaintKit_Operation) {
        self.instance = ::std::option::Option::Some(CMsgProtoDefID_oneof_instance::instance_def_type_paintkit_operation(v))
    }

    // Mutable pointer to the field.
    pub fn mut_instance_def_type_paintkit_operation(&mut self) -> &mut CMsgPaintKit_Operation {
        if let ::std::option::Option::Some(CMsgProtoDefID_oneof_instance::instance_def_type_paintkit_operation(_)) = self.instance {
        } else {
            self.instance = ::std::option::Option::Some(CMsgProtoDefID_oneof_instance::instance_def_type_paintkit_operation(CMsgPaintKit_Operation::new()));
        }
        match self.instance {
            ::std::option::Option::Some(CMsgProtoDefID_oneof_instance::instance_def_type_paintkit_operation(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_instance_def_type_paintkit_operation(&mut self) -> CMsgPaintKit_Operation {
        if self.has_instance_def_type_paintkit_operation() {
            match self.instance.take() {
                ::std::option::Option::Some(CMsgProtoDefID_oneof_instance::instance_def_type_paintkit_operation(v)) => v,
                _ => panic!(),
            }
        } else {
            CMsgPaintKit_Operation::new()
        }
    }

    // optional .CMsgPaintKit_ItemDefinition instance_def_type_paintkit_item_definition = 11;


    pub fn get_instance_def_type_paintkit_item_definition(&self) -> &CMsgPaintKit_ItemDefinition {
        match self.instance {
            ::std::option::Option::Some(CMsgProtoDefID_oneof_instance::instance_def_type_paintkit_item_definition(ref v)) => v,
            _ => <CMsgPaintKit_ItemDefinition as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_instance_def_type_paintkit_item_definition(&mut self) {
        self.instance = ::std::option::Option::None;
    }

    pub fn has_instance_def_type_paintkit_item_definition(&self) -> bool {
        match self.instance {
            ::std::option::Option::Some(CMsgProtoDefID_oneof_instance::instance_def_type_paintkit_item_definition(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_instance_def_type_paintkit_item_definition(&mut self, v: CMsgPaintKit_ItemDefinition) {
        self.instance = ::std::option::Option::Some(CMsgProtoDefID_oneof_instance::instance_def_type_paintkit_item_definition(v))
    }

    // Mutable pointer to the field.
    pub fn mut_instance_def_type_paintkit_item_definition(&mut self) -> &mut CMsgPaintKit_ItemDefinition {
        if let ::std::option::Option::Some(CMsgProtoDefID_oneof_instance::instance_def_type_paintkit_item_definition(_)) = self.instance {
        } else {
            self.instance = ::std::option::Option::Some(CMsgProtoDefID_oneof_instance::instance_def_type_paintkit_item_definition(CMsgPaintKit_ItemDefinition::new()));
        }
        match self.instance {
            ::std::option::Option::Some(CMsgProtoDefID_oneof_instance::instance_def_type_paintkit_item_definition(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_instance_def_type_paintkit_item_definition(&mut self) -> CMsgPaintKit_ItemDefinition {
        if self.has_instance_def_type_paintkit_item_definition() {
            match self.instance.take() {
                ::std::option::Option::Some(CMsgProtoDefID_oneof_instance::instance_def_type_paintkit_item_definition(v)) => v,
                _ => panic!(),
            }
        } else {
            CMsgPaintKit_ItemDefinition::new()
        }
    }

    // optional .CMsgPaintKit_Definition instance_def_type_paintkit_definition = 12;


    pub fn get_instance_def_type_paintkit_definition(&self) -> &CMsgPaintKit_Definition {
        match self.instance {
            ::std::option::Option::Some(CMsgProtoDefID_oneof_instance::instance_def_type_paintkit_definition(ref v)) => v,
            _ => <CMsgPaintKit_Definition as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_instance_def_type_paintkit_definition(&mut self) {
        self.instance = ::std::option::Option::None;
    }

    pub fn has_instance_def_type_paintkit_definition(&self) -> bool {
        match self.instance {
            ::std::option::Option::Some(CMsgProtoDefID_oneof_instance::instance_def_type_paintkit_definition(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_instance_def_type_paintkit_definition(&mut self, v: CMsgPaintKit_Definition) {
        self.instance = ::std::option::Option::Some(CMsgProtoDefID_oneof_instance::instance_def_type_paintkit_definition(v))
    }

    // Mutable pointer to the field.
    pub fn mut_instance_def_type_paintkit_definition(&mut self) -> &mut CMsgPaintKit_Definition {
        if let ::std::option::Option::Some(CMsgProtoDefID_oneof_instance::instance_def_type_paintkit_definition(_)) = self.instance {
        } else {
            self.instance = ::std::option::Option::Some(CMsgProtoDefID_oneof_instance::instance_def_type_paintkit_definition(CMsgPaintKit_Definition::new()));
        }
        match self.instance {
            ::std::option::Option::Some(CMsgProtoDefID_oneof_instance::instance_def_type_paintkit_definition(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_instance_def_type_paintkit_definition(&mut self) -> CMsgPaintKit_Definition {
        if self.has_instance_def_type_paintkit_definition() {
            match self.instance.take() {
                ::std::option::Option::Some(CMsgProtoDefID_oneof_instance::instance_def_type_paintkit_definition(v)) => v,
                _ => panic!(),
            }
        } else {
            CMsgPaintKit_Definition::new()
        }
    }

    // optional .CMsgHeaderOnly instance_def_type_header_only = 13;


    pub fn get_instance_def_type_header_only(&self) -> &CMsgHeaderOnly {
        match self.instance {
            ::std::option::Option::Some(CMsgProtoDefID_oneof_instance::instance_def_type_header_only(ref v)) => v,
            _ => <CMsgHeaderOnly as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_instance_def_type_header_only(&mut self) {
        self.instance = ::std::option::Option::None;
    }

    pub fn has_instance_def_type_header_only(&self) -> bool {
        match self.instance {
            ::std::option::Option::Some(CMsgProtoDefID_oneof_instance::instance_def_type_header_only(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_instance_def_type_header_only(&mut self, v: CMsgHeaderOnly) {
        self.instance = ::std::option::Option::Some(CMsgProtoDefID_oneof_instance::instance_def_type_header_only(v))
    }

    // Mutable pointer to the field.
    pub fn mut_instance_def_type_header_only(&mut self) -> &mut CMsgHeaderOnly {
        if let ::std::option::Option::Some(CMsgProtoDefID_oneof_instance::instance_def_type_header_only(_)) = self.instance {
        } else {
            self.instance = ::std::option::Option::Some(CMsgProtoDefID_oneof_instance::instance_def_type_header_only(CMsgHeaderOnly::new()));
        }
        match self.instance {
            ::std::option::Option::Some(CMsgProtoDefID_oneof_instance::instance_def_type_header_only(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_instance_def_type_header_only(&mut self) -> CMsgHeaderOnly {
        if self.has_instance_def_type_header_only() {
            match self.instance.take() {
                ::std::option::Option::Some(CMsgProtoDefID_oneof_instance::instance_def_type_header_only(v)) => v,
                _ => panic!(),
            }
        } else {
            CMsgHeaderOnly::new()
        }
    }
}

impl ::protobuf::Message for CMsgProtoDefID {
    fn is_initialized(&self) -> bool {
        if let Some(CMsgProtoDefID_oneof_instance::instance_def_type_quest_map_node(ref v)) = self.instance {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(CMsgProtoDefID_oneof_instance::instance_def_type_quest_theme(ref v)) = self.instance {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(CMsgProtoDefID_oneof_instance::instance_def_type_quest_map_region(ref v)) = self.instance {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(CMsgProtoDefID_oneof_instance::instance_def_type_quest(ref v)) = self.instance {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(CMsgProtoDefID_oneof_instance::instance_def_type_quest_objective(ref v)) = self.instance {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(CMsgProtoDefID_oneof_instance::instance_def_type_paintkit_variables(ref v)) = self.instance {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(CMsgProtoDefID_oneof_instance::instance_def_type_paintkit_operation(ref v)) = self.instance {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(CMsgProtoDefID_oneof_instance::instance_def_type_paintkit_item_definition(ref v)) = self.instance {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(CMsgProtoDefID_oneof_instance::instance_def_type_paintkit_definition(ref v)) = self.instance {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(CMsgProtoDefID_oneof_instance::instance_def_type_header_only(ref v)) = self.instance {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.defindex = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 2, &mut self.unknown_fields)?
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.instance = ::std::option::Option::Some(CMsgProtoDefID_oneof_instance::instance_def_type_quest_map_node(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.instance = ::std::option::Option::Some(CMsgProtoDefID_oneof_instance::instance_def_type_quest_theme(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.instance = ::std::option::Option::Some(CMsgProtoDefID_oneof_instance::instance_def_type_quest_map_region(is.read_message()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.instance = ::std::option::Option::Some(CMsgProtoDefID_oneof_instance::instance_def_type_quest(is.read_message()?));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.instance = ::std::option::Option::Some(CMsgProtoDefID_oneof_instance::instance_def_type_quest_objective(is.read_message()?));
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.instance = ::std::option::Option::Some(CMsgProtoDefID_oneof_instance::instance_def_type_paintkit_variables(is.read_message()?));
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.instance = ::std::option::Option::Some(CMsgProtoDefID_oneof_instance::instance_def_type_paintkit_operation(is.read_message()?));
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.instance = ::std::option::Option::Some(CMsgProtoDefID_oneof_instance::instance_def_type_paintkit_item_definition(is.read_message()?));
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.instance = ::std::option::Option::Some(CMsgProtoDefID_oneof_instance::instance_def_type_paintkit_definition(is.read_message()?));
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.instance = ::std::option::Option::Some(CMsgProtoDefID_oneof_instance::instance_def_type_header_only(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.defindex {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        if let ::std::option::Option::Some(ref v) = self.instance {
            match v {
                &CMsgProtoDefID_oneof_instance::instance_def_type_quest_map_node(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &CMsgProtoDefID_oneof_instance::instance_def_type_quest_theme(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &CMsgProtoDefID_oneof_instance::instance_def_type_quest_map_region(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &CMsgProtoDefID_oneof_instance::instance_def_type_quest(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &CMsgProtoDefID_oneof_instance::instance_def_type_quest_objective(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &CMsgProtoDefID_oneof_instance::instance_def_type_paintkit_variables(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &CMsgProtoDefID_oneof_instance::instance_def_type_paintkit_operation(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &CMsgProtoDefID_oneof_instance::instance_def_type_paintkit_item_definition(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &CMsgProtoDefID_oneof_instance::instance_def_type_paintkit_definition(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &CMsgProtoDefID_oneof_instance::instance_def_type_header_only(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.defindex {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.field_type {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let ::std::option::Option::Some(ref v) = self.instance {
            match v {
                &CMsgProtoDefID_oneof_instance::instance_def_type_quest_map_node(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &CMsgProtoDefID_oneof_instance::instance_def_type_quest_theme(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &CMsgProtoDefID_oneof_instance::instance_def_type_quest_map_region(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &CMsgProtoDefID_oneof_instance::instance_def_type_quest(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &CMsgProtoDefID_oneof_instance::instance_def_type_quest_objective(ref v) => {
                    os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &CMsgProtoDefID_oneof_instance::instance_def_type_paintkit_variables(ref v) => {
                    os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &CMsgProtoDefID_oneof_instance::instance_def_type_paintkit_operation(ref v) => {
                    os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &CMsgProtoDefID_oneof_instance::instance_def_type_paintkit_item_definition(ref v) => {
                    os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &CMsgProtoDefID_oneof_instance::instance_def_type_paintkit_definition(ref v) => {
                    os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &CMsgProtoDefID_oneof_instance::instance_def_type_header_only(ref v) => {
                    os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgProtoDefID {
        CMsgProtoDefID::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "defindex",
                |m: &CMsgProtoDefID| { &m.defindex },
                |m: &mut CMsgProtoDefID| { &mut m.defindex },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ProtoDefTypes>>(
                "type",
                |m: &CMsgProtoDefID| { &m.field_type },
                |m: &mut CMsgProtoDefID| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, CMsgQuestMapNodeDef>(
                "instance_def_type_quest_map_node",
                CMsgProtoDefID::has_instance_def_type_quest_map_node,
                CMsgProtoDefID::get_instance_def_type_quest_map_node,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, CMsgQuestTheme>(
                "instance_def_type_quest_theme",
                CMsgProtoDefID::has_instance_def_type_quest_theme,
                CMsgProtoDefID::get_instance_def_type_quest_theme,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, CMsgQuestMapRegionDef>(
                "instance_def_type_quest_map_region",
                CMsgProtoDefID::has_instance_def_type_quest_map_region,
                CMsgProtoDefID::get_instance_def_type_quest_map_region,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, CMsgQuestDef>(
                "instance_def_type_quest",
                CMsgProtoDefID::has_instance_def_type_quest,
                CMsgProtoDefID::get_instance_def_type_quest,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, CMsgQuestObjectiveDef>(
                "instance_def_type_quest_objective",
                CMsgProtoDefID::has_instance_def_type_quest_objective,
                CMsgProtoDefID::get_instance_def_type_quest_objective,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, CMsgPaintKit_Variables>(
                "instance_def_type_paintkit_variables",
                CMsgProtoDefID::has_instance_def_type_paintkit_variables,
                CMsgProtoDefID::get_instance_def_type_paintkit_variables,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, CMsgPaintKit_Operation>(
                "instance_def_type_paintkit_operation",
                CMsgProtoDefID::has_instance_def_type_paintkit_operation,
                CMsgProtoDefID::get_instance_def_type_paintkit_operation,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, CMsgPaintKit_ItemDefinition>(
                "instance_def_type_paintkit_item_definition",
                CMsgProtoDefID::has_instance_def_type_paintkit_item_definition,
                CMsgProtoDefID::get_instance_def_type_paintkit_item_definition,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, CMsgPaintKit_Definition>(
                "instance_def_type_paintkit_definition",
                CMsgProtoDefID::has_instance_def_type_paintkit_definition,
                CMsgProtoDefID::get_instance_def_type_paintkit_definition,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, CMsgHeaderOnly>(
                "instance_def_type_header_only",
                CMsgProtoDefID::has_instance_def_type_header_only,
                CMsgProtoDefID::get_instance_def_type_header_only,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgProtoDefID>(
                "CMsgProtoDefID",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgProtoDefID {
        static instance: ::protobuf::rt::LazyV2<CMsgProtoDefID> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgProtoDefID::new)
    }
}

impl ::protobuf::Clear for CMsgProtoDefID {
    fn clear(&mut self) {
        self.defindex = ::std::option::Option::None;
        self.field_type = ::std::option::Option::None;
        self.instance = ::std::option::Option::None;
        self.instance = ::std::option::Option::None;
        self.instance = ::std::option::Option::None;
        self.instance = ::std::option::Option::None;
        self.instance = ::std::option::Option::None;
        self.instance = ::std::option::Option::None;
        self.instance = ::std::option::Option::None;
        self.instance = ::std::option::Option::None;
        self.instance = ::std::option::Option::None;
        self.instance = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgProtoDefID {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgProtoDefID {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgQuestObjectiveDef {
    // message fields
    pub header: ::protobuf::SingularPtrField<CMsgProtoDefHeader>,
    loc_desctoken: ::protobuf::SingularField<::std::string::String>,
    points: ::std::option::Option<u32>,
    conditions_defindex: ::std::option::Option<u32>,
    pub map: ::protobuf::RepeatedField<::std::string::String>,
    pub game_mode: ::std::vec::Vec<CMsgQuestObjectiveDef_ETF2GameModes>,
    team: ::std::option::Option<CMsgQuestObjectiveDef_ETF2Team>,
    pub condition_vars: ::protobuf::RepeatedField<CMsgVarField>,
    pub classes_vars: ::protobuf::RepeatedField<CMsgVarField>,
    pub conditions: ::std::vec::Vec<CMsgQuestObjectiveDef_ETF2Conditions>,
    condition_logic: ::std::option::Option<LogicalOperation>,
    pub item_name: ::protobuf::RepeatedField<::std::string::String>,
    item_logic: ::std::option::Option<LogicalOperation>,
    jump_state: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgQuestObjectiveDef {
    fn default() -> &'a CMsgQuestObjectiveDef {
        <CMsgQuestObjectiveDef as ::protobuf::Message>::default_instance()
    }
}

impl CMsgQuestObjectiveDef {
    pub fn new() -> CMsgQuestObjectiveDef {
        ::std::default::Default::default()
    }

    // required .CMsgProtoDefHeader header = 1;


    pub fn get_header(&self) -> &CMsgProtoDefHeader {
        self.header.as_ref().unwrap_or_else(|| <CMsgProtoDefHeader as ::protobuf::Message>::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: CMsgProtoDefHeader) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut CMsgProtoDefHeader {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> CMsgProtoDefHeader {
        self.header.take().unwrap_or_else(|| CMsgProtoDefHeader::new())
    }

    // optional string loc_desctoken = 2;


    pub fn get_loc_desctoken(&self) -> &str {
        match self.loc_desctoken.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_loc_desctoken(&mut self) {
        self.loc_desctoken.clear();
    }

    pub fn has_loc_desctoken(&self) -> bool {
        self.loc_desctoken.is_some()
    }

    // Param is passed by value, moved
    pub fn set_loc_desctoken(&mut self, v: ::std::string::String) {
        self.loc_desctoken = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_loc_desctoken(&mut self) -> &mut ::std::string::String {
        if self.loc_desctoken.is_none() {
            self.loc_desctoken.set_default();
        }
        self.loc_desctoken.as_mut().unwrap()
    }

    // Take field
    pub fn take_loc_desctoken(&mut self) -> ::std::string::String {
        self.loc_desctoken.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 points = 3;


    pub fn get_points(&self) -> u32 {
        self.points.unwrap_or(0)
    }
    pub fn clear_points(&mut self) {
        self.points = ::std::option::Option::None;
    }

    pub fn has_points(&self) -> bool {
        self.points.is_some()
    }

    // Param is passed by value, moved
    pub fn set_points(&mut self, v: u32) {
        self.points = ::std::option::Option::Some(v);
    }

    // optional uint32 conditions_defindex = 5;


    pub fn get_conditions_defindex(&self) -> u32 {
        self.conditions_defindex.unwrap_or(0)
    }
    pub fn clear_conditions_defindex(&mut self) {
        self.conditions_defindex = ::std::option::Option::None;
    }

    pub fn has_conditions_defindex(&self) -> bool {
        self.conditions_defindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_conditions_defindex(&mut self, v: u32) {
        self.conditions_defindex = ::std::option::Option::Some(v);
    }

    // repeated string map = 8;


    pub fn get_map(&self) -> &[::std::string::String] {
        &self.map
    }
    pub fn clear_map(&mut self) {
        self.map.clear();
    }

    // Param is passed by value, moved
    pub fn set_map(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.map = v;
    }

    // Mutable pointer to the field.
    pub fn mut_map(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.map
    }

    // Take field
    pub fn take_map(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.map, ::protobuf::RepeatedField::new())
    }

    // repeated .CMsgQuestObjectiveDef.ETF2GameModes game_mode = 9;


    pub fn get_game_mode(&self) -> &[CMsgQuestObjectiveDef_ETF2GameModes] {
        &self.game_mode
    }
    pub fn clear_game_mode(&mut self) {
        self.game_mode.clear();
    }

    // Param is passed by value, moved
    pub fn set_game_mode(&mut self, v: ::std::vec::Vec<CMsgQuestObjectiveDef_ETF2GameModes>) {
        self.game_mode = v;
    }

    // Mutable pointer to the field.
    pub fn mut_game_mode(&mut self) -> &mut ::std::vec::Vec<CMsgQuestObjectiveDef_ETF2GameModes> {
        &mut self.game_mode
    }

    // Take field
    pub fn take_game_mode(&mut self) -> ::std::vec::Vec<CMsgQuestObjectiveDef_ETF2GameModes> {
        ::std::mem::replace(&mut self.game_mode, ::std::vec::Vec::new())
    }

    // optional .CMsgQuestObjectiveDef.ETF2Team team = 10;


    pub fn get_team(&self) -> CMsgQuestObjectiveDef_ETF2Team {
        self.team.unwrap_or(CMsgQuestObjectiveDef_ETF2Team::TF_TEAM_RED)
    }
    pub fn clear_team(&mut self) {
        self.team = ::std::option::Option::None;
    }

    pub fn has_team(&self) -> bool {
        self.team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team(&mut self, v: CMsgQuestObjectiveDef_ETF2Team) {
        self.team = ::std::option::Option::Some(v);
    }

    // repeated .CMsgVarField condition_vars = 11;


    pub fn get_condition_vars(&self) -> &[CMsgVarField] {
        &self.condition_vars
    }
    pub fn clear_condition_vars(&mut self) {
        self.condition_vars.clear();
    }

    // Param is passed by value, moved
    pub fn set_condition_vars(&mut self, v: ::protobuf::RepeatedField<CMsgVarField>) {
        self.condition_vars = v;
    }

    // Mutable pointer to the field.
    pub fn mut_condition_vars(&mut self) -> &mut ::protobuf::RepeatedField<CMsgVarField> {
        &mut self.condition_vars
    }

    // Take field
    pub fn take_condition_vars(&mut self) -> ::protobuf::RepeatedField<CMsgVarField> {
        ::std::mem::replace(&mut self.condition_vars, ::protobuf::RepeatedField::new())
    }

    // repeated .CMsgVarField classes_vars = 12;


    pub fn get_classes_vars(&self) -> &[CMsgVarField] {
        &self.classes_vars
    }
    pub fn clear_classes_vars(&mut self) {
        self.classes_vars.clear();
    }

    // Param is passed by value, moved
    pub fn set_classes_vars(&mut self, v: ::protobuf::RepeatedField<CMsgVarField>) {
        self.classes_vars = v;
    }

    // Mutable pointer to the field.
    pub fn mut_classes_vars(&mut self) -> &mut ::protobuf::RepeatedField<CMsgVarField> {
        &mut self.classes_vars
    }

    // Take field
    pub fn take_classes_vars(&mut self) -> ::protobuf::RepeatedField<CMsgVarField> {
        ::std::mem::replace(&mut self.classes_vars, ::protobuf::RepeatedField::new())
    }

    // repeated .CMsgQuestObjectiveDef.ETF2Conditions conditions = 13;


    pub fn get_conditions(&self) -> &[CMsgQuestObjectiveDef_ETF2Conditions] {
        &self.conditions
    }
    pub fn clear_conditions(&mut self) {
        self.conditions.clear();
    }

    // Param is passed by value, moved
    pub fn set_conditions(&mut self, v: ::std::vec::Vec<CMsgQuestObjectiveDef_ETF2Conditions>) {
        self.conditions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_conditions(&mut self) -> &mut ::std::vec::Vec<CMsgQuestObjectiveDef_ETF2Conditions> {
        &mut self.conditions
    }

    // Take field
    pub fn take_conditions(&mut self) -> ::std::vec::Vec<CMsgQuestObjectiveDef_ETF2Conditions> {
        ::std::mem::replace(&mut self.conditions, ::std::vec::Vec::new())
    }

    // optional .LogicalOperation condition_logic = 14;


    pub fn get_condition_logic(&self) -> LogicalOperation {
        self.condition_logic.unwrap_or(LogicalOperation::AND)
    }
    pub fn clear_condition_logic(&mut self) {
        self.condition_logic = ::std::option::Option::None;
    }

    pub fn has_condition_logic(&self) -> bool {
        self.condition_logic.is_some()
    }

    // Param is passed by value, moved
    pub fn set_condition_logic(&mut self, v: LogicalOperation) {
        self.condition_logic = ::std::option::Option::Some(v);
    }

    // repeated string item_name = 15;


    pub fn get_item_name(&self) -> &[::std::string::String] {
        &self.item_name
    }
    pub fn clear_item_name(&mut self) {
        self.item_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_item_name(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.item_name = v;
    }

    // Mutable pointer to the field.
    pub fn mut_item_name(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.item_name
    }

    // Take field
    pub fn take_item_name(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.item_name, ::protobuf::RepeatedField::new())
    }

    // optional .LogicalOperation item_logic = 16;


    pub fn get_item_logic(&self) -> LogicalOperation {
        self.item_logic.unwrap_or(LogicalOperation::AND)
    }
    pub fn clear_item_logic(&mut self) {
        self.item_logic = ::std::option::Option::None;
    }

    pub fn has_item_logic(&self) -> bool {
        self.item_logic.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_logic(&mut self, v: LogicalOperation) {
        self.item_logic = ::std::option::Option::Some(v);
    }

    // optional uint32 jump_state = 17;


    pub fn get_jump_state(&self) -> u32 {
        self.jump_state.unwrap_or(0)
    }
    pub fn clear_jump_state(&mut self) {
        self.jump_state = ::std::option::Option::None;
    }

    pub fn has_jump_state(&self) -> bool {
        self.jump_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_jump_state(&mut self, v: u32) {
        self.jump_state = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgQuestObjectiveDef {
    fn is_initialized(&self) -> bool {
        if self.header.is_none() {
            return false;
        }
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.condition_vars {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.classes_vars {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.loc_desctoken)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.points = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.conditions_defindex = ::std::option::Option::Some(tmp);
                },
                8 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.map)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.game_mode, 9, &mut self.unknown_fields)?
                },
                10 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.team, 10, &mut self.unknown_fields)?
                },
                11 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.condition_vars)?;
                },
                12 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.classes_vars)?;
                },
                13 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.conditions, 13, &mut self.unknown_fields)?
                },
                14 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.condition_logic, 14, &mut self.unknown_fields)?
                },
                15 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.item_name)?;
                },
                16 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.item_logic, 16, &mut self.unknown_fields)?
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.jump_state = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.loc_desctoken.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.points {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.conditions_defindex {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.map {
            my_size += ::protobuf::rt::string_size(8, &value);
        };
        for value in &self.game_mode {
            my_size += ::protobuf::rt::enum_size(9, *value);
        };
        if let Some(v) = self.team {
            my_size += ::protobuf::rt::enum_size(10, v);
        }
        for value in &self.condition_vars {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.classes_vars {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.conditions {
            my_size += ::protobuf::rt::enum_size(13, *value);
        };
        if let Some(v) = self.condition_logic {
            my_size += ::protobuf::rt::enum_size(14, v);
        }
        for value in &self.item_name {
            my_size += ::protobuf::rt::string_size(15, &value);
        };
        if let Some(v) = self.item_logic {
            my_size += ::protobuf::rt::enum_size(16, v);
        }
        if let Some(v) = self.jump_state {
            my_size += ::protobuf::rt::value_size(17, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.loc_desctoken.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.points {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.conditions_defindex {
            os.write_uint32(5, v)?;
        }
        for v in &self.map {
            os.write_string(8, &v)?;
        };
        for v in &self.game_mode {
            os.write_enum(9, ::protobuf::ProtobufEnum::value(v))?;
        };
        if let Some(v) = self.team {
            os.write_enum(10, ::protobuf::ProtobufEnum::value(&v))?;
        }
        for v in &self.condition_vars {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.classes_vars {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.conditions {
            os.write_enum(13, ::protobuf::ProtobufEnum::value(v))?;
        };
        if let Some(v) = self.condition_logic {
            os.write_enum(14, ::protobuf::ProtobufEnum::value(&v))?;
        }
        for v in &self.item_name {
            os.write_string(15, &v)?;
        };
        if let Some(v) = self.item_logic {
            os.write_enum(16, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.jump_state {
            os.write_uint32(17, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgQuestObjectiveDef {
        CMsgQuestObjectiveDef::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgProtoDefHeader>>(
                "header",
                |m: &CMsgQuestObjectiveDef| { &m.header },
                |m: &mut CMsgQuestObjectiveDef| { &mut m.header },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "loc_desctoken",
                |m: &CMsgQuestObjectiveDef| { &m.loc_desctoken },
                |m: &mut CMsgQuestObjectiveDef| { &mut m.loc_desctoken },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "points",
                |m: &CMsgQuestObjectiveDef| { &m.points },
                |m: &mut CMsgQuestObjectiveDef| { &mut m.points },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "conditions_defindex",
                |m: &CMsgQuestObjectiveDef| { &m.conditions_defindex },
                |m: &mut CMsgQuestObjectiveDef| { &mut m.conditions_defindex },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "map",
                |m: &CMsgQuestObjectiveDef| { &m.map },
                |m: &mut CMsgQuestObjectiveDef| { &mut m.map },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CMsgQuestObjectiveDef_ETF2GameModes>>(
                "game_mode",
                |m: &CMsgQuestObjectiveDef| { &m.game_mode },
                |m: &mut CMsgQuestObjectiveDef| { &mut m.game_mode },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CMsgQuestObjectiveDef_ETF2Team>>(
                "team",
                |m: &CMsgQuestObjectiveDef| { &m.team },
                |m: &mut CMsgQuestObjectiveDef| { &mut m.team },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgVarField>>(
                "condition_vars",
                |m: &CMsgQuestObjectiveDef| { &m.condition_vars },
                |m: &mut CMsgQuestObjectiveDef| { &mut m.condition_vars },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgVarField>>(
                "classes_vars",
                |m: &CMsgQuestObjectiveDef| { &m.classes_vars },
                |m: &mut CMsgQuestObjectiveDef| { &mut m.classes_vars },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CMsgQuestObjectiveDef_ETF2Conditions>>(
                "conditions",
                |m: &CMsgQuestObjectiveDef| { &m.conditions },
                |m: &mut CMsgQuestObjectiveDef| { &mut m.conditions },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<LogicalOperation>>(
                "condition_logic",
                |m: &CMsgQuestObjectiveDef| { &m.condition_logic },
                |m: &mut CMsgQuestObjectiveDef| { &mut m.condition_logic },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "item_name",
                |m: &CMsgQuestObjectiveDef| { &m.item_name },
                |m: &mut CMsgQuestObjectiveDef| { &mut m.item_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<LogicalOperation>>(
                "item_logic",
                |m: &CMsgQuestObjectiveDef| { &m.item_logic },
                |m: &mut CMsgQuestObjectiveDef| { &mut m.item_logic },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "jump_state",
                |m: &CMsgQuestObjectiveDef| { &m.jump_state },
                |m: &mut CMsgQuestObjectiveDef| { &mut m.jump_state },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgQuestObjectiveDef>(
                "CMsgQuestObjectiveDef",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgQuestObjectiveDef {
        static instance: ::protobuf::rt::LazyV2<CMsgQuestObjectiveDef> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgQuestObjectiveDef::new)
    }
}

impl ::protobuf::Clear for CMsgQuestObjectiveDef {
    fn clear(&mut self) {
        self.header.clear();
        self.loc_desctoken.clear();
        self.points = ::std::option::Option::None;
        self.conditions_defindex = ::std::option::Option::None;
        self.map.clear();
        self.game_mode.clear();
        self.team = ::std::option::Option::None;
        self.condition_vars.clear();
        self.classes_vars.clear();
        self.conditions.clear();
        self.condition_logic = ::std::option::Option::None;
        self.item_name.clear();
        self.item_logic = ::std::option::Option::None;
        self.jump_state = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgQuestObjectiveDef {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgQuestObjectiveDef {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgQuestObjectiveDef_ETF2GameModes {
    kGameCategory_Escort = 0,
    kGameCategory_CTF = 1,
    kGameCategory_AttackDefense = 2,
    kGameCategory_Koth = 3,
    kGameCategory_CP = 4,
    kGameCategory_EscortRace = 5,
    kGameCategory_EventMix = 6,
    kGameCategory_SD = 7,
    kGameCategory_Quickplay = 8,
    kGameCategory_Event247 = 9,
    kGameCategory_Arena = 10,
    kGameCategory_RobotDestruction = 11,
    kGameCategory_Powerup = 12,
    kGameCategory_Featured = 13,
    kGameCategory_Passtime = 14,
    kGameCategory_Community_Update = 15,
    kGameCategory_Misc = 16,
    kGameCategory_Competitive_6v6 = 17,
    kGameCategory_Other = 18,
    kGameCategory_Halloween = 19,
}

impl ::protobuf::ProtobufEnum for CMsgQuestObjectiveDef_ETF2GameModes {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgQuestObjectiveDef_ETF2GameModes> {
        match value {
            0 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2GameModes::kGameCategory_Escort),
            1 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2GameModes::kGameCategory_CTF),
            2 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2GameModes::kGameCategory_AttackDefense),
            3 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2GameModes::kGameCategory_Koth),
            4 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2GameModes::kGameCategory_CP),
            5 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2GameModes::kGameCategory_EscortRace),
            6 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2GameModes::kGameCategory_EventMix),
            7 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2GameModes::kGameCategory_SD),
            8 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2GameModes::kGameCategory_Quickplay),
            9 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2GameModes::kGameCategory_Event247),
            10 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2GameModes::kGameCategory_Arena),
            11 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2GameModes::kGameCategory_RobotDestruction),
            12 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2GameModes::kGameCategory_Powerup),
            13 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2GameModes::kGameCategory_Featured),
            14 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2GameModes::kGameCategory_Passtime),
            15 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2GameModes::kGameCategory_Community_Update),
            16 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2GameModes::kGameCategory_Misc),
            17 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2GameModes::kGameCategory_Competitive_6v6),
            18 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2GameModes::kGameCategory_Other),
            19 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2GameModes::kGameCategory_Halloween),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgQuestObjectiveDef_ETF2GameModes] = &[
            CMsgQuestObjectiveDef_ETF2GameModes::kGameCategory_Escort,
            CMsgQuestObjectiveDef_ETF2GameModes::kGameCategory_CTF,
            CMsgQuestObjectiveDef_ETF2GameModes::kGameCategory_AttackDefense,
            CMsgQuestObjectiveDef_ETF2GameModes::kGameCategory_Koth,
            CMsgQuestObjectiveDef_ETF2GameModes::kGameCategory_CP,
            CMsgQuestObjectiveDef_ETF2GameModes::kGameCategory_EscortRace,
            CMsgQuestObjectiveDef_ETF2GameModes::kGameCategory_EventMix,
            CMsgQuestObjectiveDef_ETF2GameModes::kGameCategory_SD,
            CMsgQuestObjectiveDef_ETF2GameModes::kGameCategory_Quickplay,
            CMsgQuestObjectiveDef_ETF2GameModes::kGameCategory_Event247,
            CMsgQuestObjectiveDef_ETF2GameModes::kGameCategory_Arena,
            CMsgQuestObjectiveDef_ETF2GameModes::kGameCategory_RobotDestruction,
            CMsgQuestObjectiveDef_ETF2GameModes::kGameCategory_Powerup,
            CMsgQuestObjectiveDef_ETF2GameModes::kGameCategory_Featured,
            CMsgQuestObjectiveDef_ETF2GameModes::kGameCategory_Passtime,
            CMsgQuestObjectiveDef_ETF2GameModes::kGameCategory_Community_Update,
            CMsgQuestObjectiveDef_ETF2GameModes::kGameCategory_Misc,
            CMsgQuestObjectiveDef_ETF2GameModes::kGameCategory_Competitive_6v6,
            CMsgQuestObjectiveDef_ETF2GameModes::kGameCategory_Other,
            CMsgQuestObjectiveDef_ETF2GameModes::kGameCategory_Halloween,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<CMsgQuestObjectiveDef_ETF2GameModes>("CMsgQuestObjectiveDef.ETF2GameModes", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for CMsgQuestObjectiveDef_ETF2GameModes {
}

impl ::std::default::Default for CMsgQuestObjectiveDef_ETF2GameModes {
    fn default() -> Self {
        CMsgQuestObjectiveDef_ETF2GameModes::kGameCategory_Escort
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgQuestObjectiveDef_ETF2GameModes {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgQuestObjectiveDef_ETF2Conditions {
    TF_COND_AIMING = 0,
    TF_COND_ZOOMED = 1,
    TF_COND_DISGUISING = 2,
    TF_COND_DISGUISED = 3,
    TF_COND_STEALTHED = 4,
    TF_COND_INVULNERABLE = 5,
    TF_COND_TELEPORTED = 6,
    TF_COND_TAUNTING = 7,
    TF_COND_INVULNERABLE_WEARINGOFF = 8,
    TF_COND_STEALTHED_BLINK = 9,
    TF_COND_SELECTED_TO_TELEPORT = 10,
    TF_COND_CRITBOOSTED = 11,
    TF_COND_TMPDAMAGEBONUS = 12,
    TF_COND_FEIGN_DEATH = 13,
    TF_COND_PHASE = 14,
    TF_COND_STUNNED = 15,
    TF_COND_OFFENSEBUFF = 16,
    TF_COND_SHIELD_CHARGE = 17,
    TF_COND_DEMO_BUFF = 18,
    TF_COND_ENERGY_BUFF = 19,
    TF_COND_RADIUSHEAL = 20,
    TF_COND_HEALTH_BUFF = 21,
    TF_COND_BURNING = 22,
    TF_COND_HEALTH_OVERHEALED = 23,
    TF_COND_URINE = 24,
    TF_COND_BLEEDING = 25,
    TF_COND_DEFENSEBUFF = 26,
    TF_COND_MAD_MILK = 27,
    TF_COND_MEGAHEAL = 28,
    TF_COND_REGENONDAMAGEBUFF = 29,
    TF_COND_MARKEDFORDEATH = 30,
    TF_COND_NOHEALINGDAMAGEBUFF = 31,
    TF_COND_SPEED_BOOST = 32,
    TF_COND_CRITBOOSTED_PUMPKIN = 33,
    TF_COND_CRITBOOSTED_USER_BUFF = 34,
    TF_COND_CRITBOOSTED_DEMO_CHARGE = 35,
    TF_COND_SODAPOPPER_HYPE = 36,
    TF_COND_CRITBOOSTED_FIRST_BLOOD = 37,
    TF_COND_CRITBOOSTED_BONUS_TIME = 38,
    TF_COND_CRITBOOSTED_CTF_CAPTURE = 39,
    TF_COND_CRITBOOSTED_ON_KILL = 40,
    TF_COND_CANNOT_SWITCH_FROM_MELEE = 41,
    TF_COND_DEFENSEBUFF_NO_CRIT_BLOCK = 42,
    TF_COND_REPROGRAMMED = 43,
    TF_COND_CRITBOOSTED_RAGE_BUFF = 44,
    TF_COND_DEFENSEBUFF_HIGH = 45,
    TF_COND_SNIPERCHARGE_RAGE_BUFF = 46,
    TF_COND_DISGUISE_WEARINGOFF = 47,
    TF_COND_MARKEDFORDEATH_SILENT = 48,
    TF_COND_DISGUISED_AS_DISPENSER = 49,
    TF_COND_SAPPED = 50,
    TF_COND_INVULNERABLE_HIDE_UNLESS_DAMAGED = 51,
    TF_COND_INVULNERABLE_USER_BUFF = 52,
    TF_COND_HALLOWEEN_BOMB_HEAD = 53,
    TF_COND_HALLOWEEN_THRILLER = 54,
    TF_COND_RADIUSHEAL_ON_DAMAGE = 55,
    TF_COND_CRITBOOSTED_CARD_EFFECT = 56,
    TF_COND_INVULNERABLE_CARD_EFFECT = 57,
    TF_COND_MEDIGUN_UBER_BULLET_RESIST = 58,
    TF_COND_MEDIGUN_UBER_BLAST_RESIST = 59,
    TF_COND_MEDIGUN_UBER_FIRE_RESIST = 60,
    TF_COND_MEDIGUN_SMALL_BULLET_RESIST = 61,
    TF_COND_MEDIGUN_SMALL_BLAST_RESIST = 62,
    TF_COND_MEDIGUN_SMALL_FIRE_RESIST = 63,
    TF_COND_STEALTHED_USER_BUFF = 64,
    TF_COND_MEDIGUN_DEBUFF = 65,
    TF_COND_STEALTHED_USER_BUFF_FADING = 66,
    TF_COND_BULLET_IMMUNE = 67,
    TF_COND_BLAST_IMMUNE = 68,
    TF_COND_FIRE_IMMUNE = 69,
    TF_COND_PREVENT_DEATH = 70,
    TF_COND_MVM_BOT_STUN_RADIOWAVE = 71,
    TF_COND_HALLOWEEN_SPEED_BOOST = 72,
    TF_COND_HALLOWEEN_QUICK_HEAL = 73,
    TF_COND_HALLOWEEN_GIANT = 74,
    TF_COND_HALLOWEEN_TINY = 75,
    TF_COND_HALLOWEEN_IN_HELL = 76,
    TF_COND_HALLOWEEN_GHOST_MODE = 77,
    TF_COND_MINICRITBOOSTED_ON_KILL = 78,
    TF_COND_OBSCURED_SMOKE = 79,
    TF_COND_PARACHUTE_ACTIVE = 80,
    TF_COND_BLASTJUMPING = 81,
    TF_COND_HALLOWEEN_KART = 82,
    TF_COND_HALLOWEEN_KART_DASH = 83,
    TF_COND_BALLOON_HEAD = 84,
    TF_COND_MELEE_ONLY = 85,
    TF_COND_SWIMMING_CURSE = 86,
    TF_COND_FREEZE_INPUT = 87,
    TF_COND_HALLOWEEN_KART_CAGE = 88,
    TF_COND_DONOTUSE_0 = 89,
    TF_COND_RUNE_STRENGTH = 90,
    TF_COND_RUNE_HASTE = 91,
    TF_COND_RUNE_REGEN = 92,
    TF_COND_RUNE_RESIST = 93,
    TF_COND_RUNE_VAMPIRE = 94,
    TF_COND_RUNE_REFLECT = 95,
    TF_COND_RUNE_PRECISION = 96,
    TF_COND_RUNE_AGILITY = 97,
    TF_COND_GRAPPLINGHOOK = 98,
    TF_COND_GRAPPLINGHOOK_SAFEFALL = 99,
    TF_COND_GRAPPLINGHOOK_LATCHED = 100,
    TF_COND_GRAPPLINGHOOK_BLEEDING = 101,
    TF_COND_AFTERBURN_IMMUNE = 102,
    TF_COND_RUNE_KNOCKOUT = 103,
    TF_COND_RUNE_IMBALANCE = 104,
    TF_COND_CRITBOOSTED_RUNE_TEMP = 105,
    TF_COND_PASSTIME_INTERCEPTION = 106,
    TF_COND_SWIMMING_NO_EFFECTS = 107,
    TF_COND_PURGATORY = 108,
    TF_COND_RUNE_KING = 109,
    TF_COND_RUNE_PLAGUE = 110,
    TF_COND_RUNE_SUPERNOVA = 111,
    TF_COND_PLAGUE = 112,
    TF_COND_KING_BUFFED = 113,
    TF_COND_TEAM_GLOWS = 114,
    TF_COND_KNOCKED_INTO_AIR = 115,
    TF_COND_COMPETITIVE_WINNER = 116,
    TF_COND_COMPETITIVE_LOSER = 117,
    TF_COND_HEALING_DEBUFF = 118,
    TF_COND_PASSTIME_PENALTY_DEBUFF = 119,
    TF_COND_PARACHUTE_DEPLOYED = 120,
    TF_COND_NO_COMBAT_SPEED_BOOST = 121,
    TF_COND_TRANQ_SPY_BOOST = 122,
    TF_COND_TRANQ_MARKED = 123,
    TF_COND_ROCKETPACK = 126,
    TF_COND_ROCKETPACK_PASSENGER = 127,
    TF_COND_STEALTHED_PHASE = 128,
    TF_COND_CLIP_OVERLOAD = 129,
    TF_COND_SPY_CLASS_STEAL = 130,
    TF_COND_GAS = 131,
}

impl ::protobuf::ProtobufEnum for CMsgQuestObjectiveDef_ETF2Conditions {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgQuestObjectiveDef_ETF2Conditions> {
        match value {
            0 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_AIMING),
            1 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_ZOOMED),
            2 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_DISGUISING),
            3 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_DISGUISED),
            4 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_STEALTHED),
            5 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_INVULNERABLE),
            6 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_TELEPORTED),
            7 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_TAUNTING),
            8 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_INVULNERABLE_WEARINGOFF),
            9 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_STEALTHED_BLINK),
            10 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_SELECTED_TO_TELEPORT),
            11 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_CRITBOOSTED),
            12 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_TMPDAMAGEBONUS),
            13 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_FEIGN_DEATH),
            14 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_PHASE),
            15 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_STUNNED),
            16 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_OFFENSEBUFF),
            17 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_SHIELD_CHARGE),
            18 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_DEMO_BUFF),
            19 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_ENERGY_BUFF),
            20 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_RADIUSHEAL),
            21 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_HEALTH_BUFF),
            22 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_BURNING),
            23 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_HEALTH_OVERHEALED),
            24 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_URINE),
            25 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_BLEEDING),
            26 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_DEFENSEBUFF),
            27 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_MAD_MILK),
            28 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_MEGAHEAL),
            29 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_REGENONDAMAGEBUFF),
            30 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_MARKEDFORDEATH),
            31 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_NOHEALINGDAMAGEBUFF),
            32 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_SPEED_BOOST),
            33 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_CRITBOOSTED_PUMPKIN),
            34 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_CRITBOOSTED_USER_BUFF),
            35 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_CRITBOOSTED_DEMO_CHARGE),
            36 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_SODAPOPPER_HYPE),
            37 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_CRITBOOSTED_FIRST_BLOOD),
            38 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_CRITBOOSTED_BONUS_TIME),
            39 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_CRITBOOSTED_CTF_CAPTURE),
            40 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_CRITBOOSTED_ON_KILL),
            41 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_CANNOT_SWITCH_FROM_MELEE),
            42 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_DEFENSEBUFF_NO_CRIT_BLOCK),
            43 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_REPROGRAMMED),
            44 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_CRITBOOSTED_RAGE_BUFF),
            45 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_DEFENSEBUFF_HIGH),
            46 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_SNIPERCHARGE_RAGE_BUFF),
            47 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_DISGUISE_WEARINGOFF),
            48 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_MARKEDFORDEATH_SILENT),
            49 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_DISGUISED_AS_DISPENSER),
            50 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_SAPPED),
            51 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_INVULNERABLE_HIDE_UNLESS_DAMAGED),
            52 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_INVULNERABLE_USER_BUFF),
            53 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_HALLOWEEN_BOMB_HEAD),
            54 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_HALLOWEEN_THRILLER),
            55 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_RADIUSHEAL_ON_DAMAGE),
            56 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_CRITBOOSTED_CARD_EFFECT),
            57 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_INVULNERABLE_CARD_EFFECT),
            58 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_MEDIGUN_UBER_BULLET_RESIST),
            59 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_MEDIGUN_UBER_BLAST_RESIST),
            60 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_MEDIGUN_UBER_FIRE_RESIST),
            61 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_MEDIGUN_SMALL_BULLET_RESIST),
            62 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_MEDIGUN_SMALL_BLAST_RESIST),
            63 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_MEDIGUN_SMALL_FIRE_RESIST),
            64 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_STEALTHED_USER_BUFF),
            65 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_MEDIGUN_DEBUFF),
            66 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_STEALTHED_USER_BUFF_FADING),
            67 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_BULLET_IMMUNE),
            68 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_BLAST_IMMUNE),
            69 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_FIRE_IMMUNE),
            70 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_PREVENT_DEATH),
            71 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_MVM_BOT_STUN_RADIOWAVE),
            72 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_HALLOWEEN_SPEED_BOOST),
            73 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_HALLOWEEN_QUICK_HEAL),
            74 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_HALLOWEEN_GIANT),
            75 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_HALLOWEEN_TINY),
            76 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_HALLOWEEN_IN_HELL),
            77 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_HALLOWEEN_GHOST_MODE),
            78 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_MINICRITBOOSTED_ON_KILL),
            79 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_OBSCURED_SMOKE),
            80 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_PARACHUTE_ACTIVE),
            81 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_BLASTJUMPING),
            82 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_HALLOWEEN_KART),
            83 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_HALLOWEEN_KART_DASH),
            84 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_BALLOON_HEAD),
            85 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_MELEE_ONLY),
            86 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_SWIMMING_CURSE),
            87 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_FREEZE_INPUT),
            88 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_HALLOWEEN_KART_CAGE),
            89 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_DONOTUSE_0),
            90 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_RUNE_STRENGTH),
            91 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_RUNE_HASTE),
            92 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_RUNE_REGEN),
            93 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_RUNE_RESIST),
            94 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_RUNE_VAMPIRE),
            95 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_RUNE_REFLECT),
            96 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_RUNE_PRECISION),
            97 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_RUNE_AGILITY),
            98 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_GRAPPLINGHOOK),
            99 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_GRAPPLINGHOOK_SAFEFALL),
            100 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_GRAPPLINGHOOK_LATCHED),
            101 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_GRAPPLINGHOOK_BLEEDING),
            102 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_AFTERBURN_IMMUNE),
            103 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_RUNE_KNOCKOUT),
            104 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_RUNE_IMBALANCE),
            105 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_CRITBOOSTED_RUNE_TEMP),
            106 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_PASSTIME_INTERCEPTION),
            107 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_SWIMMING_NO_EFFECTS),
            108 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_PURGATORY),
            109 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_RUNE_KING),
            110 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_RUNE_PLAGUE),
            111 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_RUNE_SUPERNOVA),
            112 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_PLAGUE),
            113 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_KING_BUFFED),
            114 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_TEAM_GLOWS),
            115 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_KNOCKED_INTO_AIR),
            116 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_COMPETITIVE_WINNER),
            117 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_COMPETITIVE_LOSER),
            118 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_HEALING_DEBUFF),
            119 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_PASSTIME_PENALTY_DEBUFF),
            120 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_PARACHUTE_DEPLOYED),
            121 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_NO_COMBAT_SPEED_BOOST),
            122 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_TRANQ_SPY_BOOST),
            123 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_TRANQ_MARKED),
            126 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_ROCKETPACK),
            127 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_ROCKETPACK_PASSENGER),
            128 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_STEALTHED_PHASE),
            129 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_CLIP_OVERLOAD),
            130 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_SPY_CLASS_STEAL),
            131 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_GAS),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgQuestObjectiveDef_ETF2Conditions] = &[
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_AIMING,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_ZOOMED,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_DISGUISING,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_DISGUISED,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_STEALTHED,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_INVULNERABLE,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_TELEPORTED,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_TAUNTING,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_INVULNERABLE_WEARINGOFF,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_STEALTHED_BLINK,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_SELECTED_TO_TELEPORT,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_CRITBOOSTED,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_TMPDAMAGEBONUS,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_FEIGN_DEATH,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_PHASE,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_STUNNED,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_OFFENSEBUFF,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_SHIELD_CHARGE,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_DEMO_BUFF,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_ENERGY_BUFF,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_RADIUSHEAL,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_HEALTH_BUFF,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_BURNING,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_HEALTH_OVERHEALED,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_URINE,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_BLEEDING,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_DEFENSEBUFF,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_MAD_MILK,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_MEGAHEAL,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_REGENONDAMAGEBUFF,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_MARKEDFORDEATH,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_NOHEALINGDAMAGEBUFF,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_SPEED_BOOST,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_CRITBOOSTED_PUMPKIN,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_CRITBOOSTED_USER_BUFF,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_CRITBOOSTED_DEMO_CHARGE,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_SODAPOPPER_HYPE,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_CRITBOOSTED_FIRST_BLOOD,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_CRITBOOSTED_BONUS_TIME,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_CRITBOOSTED_CTF_CAPTURE,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_CRITBOOSTED_ON_KILL,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_CANNOT_SWITCH_FROM_MELEE,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_DEFENSEBUFF_NO_CRIT_BLOCK,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_REPROGRAMMED,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_CRITBOOSTED_RAGE_BUFF,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_DEFENSEBUFF_HIGH,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_SNIPERCHARGE_RAGE_BUFF,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_DISGUISE_WEARINGOFF,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_MARKEDFORDEATH_SILENT,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_DISGUISED_AS_DISPENSER,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_SAPPED,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_INVULNERABLE_HIDE_UNLESS_DAMAGED,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_INVULNERABLE_USER_BUFF,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_HALLOWEEN_BOMB_HEAD,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_HALLOWEEN_THRILLER,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_RADIUSHEAL_ON_DAMAGE,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_CRITBOOSTED_CARD_EFFECT,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_INVULNERABLE_CARD_EFFECT,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_MEDIGUN_UBER_BULLET_RESIST,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_MEDIGUN_UBER_BLAST_RESIST,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_MEDIGUN_UBER_FIRE_RESIST,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_MEDIGUN_SMALL_BULLET_RESIST,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_MEDIGUN_SMALL_BLAST_RESIST,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_MEDIGUN_SMALL_FIRE_RESIST,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_STEALTHED_USER_BUFF,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_MEDIGUN_DEBUFF,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_STEALTHED_USER_BUFF_FADING,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_BULLET_IMMUNE,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_BLAST_IMMUNE,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_FIRE_IMMUNE,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_PREVENT_DEATH,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_MVM_BOT_STUN_RADIOWAVE,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_HALLOWEEN_SPEED_BOOST,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_HALLOWEEN_QUICK_HEAL,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_HALLOWEEN_GIANT,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_HALLOWEEN_TINY,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_HALLOWEEN_IN_HELL,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_HALLOWEEN_GHOST_MODE,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_MINICRITBOOSTED_ON_KILL,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_OBSCURED_SMOKE,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_PARACHUTE_ACTIVE,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_BLASTJUMPING,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_HALLOWEEN_KART,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_HALLOWEEN_KART_DASH,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_BALLOON_HEAD,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_MELEE_ONLY,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_SWIMMING_CURSE,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_FREEZE_INPUT,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_HALLOWEEN_KART_CAGE,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_DONOTUSE_0,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_RUNE_STRENGTH,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_RUNE_HASTE,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_RUNE_REGEN,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_RUNE_RESIST,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_RUNE_VAMPIRE,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_RUNE_REFLECT,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_RUNE_PRECISION,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_RUNE_AGILITY,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_GRAPPLINGHOOK,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_GRAPPLINGHOOK_SAFEFALL,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_GRAPPLINGHOOK_LATCHED,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_GRAPPLINGHOOK_BLEEDING,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_AFTERBURN_IMMUNE,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_RUNE_KNOCKOUT,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_RUNE_IMBALANCE,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_CRITBOOSTED_RUNE_TEMP,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_PASSTIME_INTERCEPTION,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_SWIMMING_NO_EFFECTS,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_PURGATORY,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_RUNE_KING,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_RUNE_PLAGUE,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_RUNE_SUPERNOVA,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_PLAGUE,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_KING_BUFFED,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_TEAM_GLOWS,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_KNOCKED_INTO_AIR,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_COMPETITIVE_WINNER,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_COMPETITIVE_LOSER,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_HEALING_DEBUFF,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_PASSTIME_PENALTY_DEBUFF,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_PARACHUTE_DEPLOYED,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_NO_COMBAT_SPEED_BOOST,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_TRANQ_SPY_BOOST,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_TRANQ_MARKED,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_ROCKETPACK,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_ROCKETPACK_PASSENGER,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_STEALTHED_PHASE,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_CLIP_OVERLOAD,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_SPY_CLASS_STEAL,
            CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_GAS,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<CMsgQuestObjectiveDef_ETF2Conditions>("CMsgQuestObjectiveDef.ETF2Conditions", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for CMsgQuestObjectiveDef_ETF2Conditions {
}

impl ::std::default::Default for CMsgQuestObjectiveDef_ETF2Conditions {
    fn default() -> Self {
        CMsgQuestObjectiveDef_ETF2Conditions::TF_COND_AIMING
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgQuestObjectiveDef_ETF2Conditions {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CMsgQuestObjectiveDef_ETF2Team {
    TF_TEAM_RED = 2,
    TF_TEAM_BLUE = 3,
}

impl ::protobuf::ProtobufEnum for CMsgQuestObjectiveDef_ETF2Team {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgQuestObjectiveDef_ETF2Team> {
        match value {
            2 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Team::TF_TEAM_RED),
            3 => ::std::option::Option::Some(CMsgQuestObjectiveDef_ETF2Team::TF_TEAM_BLUE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CMsgQuestObjectiveDef_ETF2Team] = &[
            CMsgQuestObjectiveDef_ETF2Team::TF_TEAM_RED,
            CMsgQuestObjectiveDef_ETF2Team::TF_TEAM_BLUE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<CMsgQuestObjectiveDef_ETF2Team>("CMsgQuestObjectiveDef.ETF2Team", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for CMsgQuestObjectiveDef_ETF2Team {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for CMsgQuestObjectiveDef_ETF2Team {
    fn default() -> Self {
        CMsgQuestObjectiveDef_ETF2Team::TF_TEAM_RED
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgQuestObjectiveDef_ETF2Team {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgQuestDef {
    // message fields
    pub header: ::protobuf::SingularPtrField<CMsgProtoDefHeader>,
    max_points_0: ::std::option::Option<u32>,
    max_points_1: ::std::option::Option<u32>,
    max_points_2: ::std::option::Option<u32>,
    name_loctoken: ::protobuf::SingularField<::std::string::String>,
    operation: ::protobuf::SingularField<::std::string::String>,
    pub mm_criteria: ::protobuf::SingularPtrField<CMsgQuestDef_MMCriteria>,
    node_image: ::protobuf::SingularField<::std::string::String>,
    icon_image: ::protobuf::SingularField<::std::string::String>,
    pub theme: ::protobuf::SingularPtrField<CMsgProtoDefID>,
    pub loaner_names: ::protobuf::RepeatedField<::std::string::String>,
    pub objectives: ::protobuf::RepeatedField<CMsgQuestDef_ObjectiveInstance>,
    pub map: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgQuestDef {
    fn default() -> &'a CMsgQuestDef {
        <CMsgQuestDef as ::protobuf::Message>::default_instance()
    }
}

impl CMsgQuestDef {
    pub fn new() -> CMsgQuestDef {
        ::std::default::Default::default()
    }

    // required .CMsgProtoDefHeader header = 1;


    pub fn get_header(&self) -> &CMsgProtoDefHeader {
        self.header.as_ref().unwrap_or_else(|| <CMsgProtoDefHeader as ::protobuf::Message>::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: CMsgProtoDefHeader) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut CMsgProtoDefHeader {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> CMsgProtoDefHeader {
        self.header.take().unwrap_or_else(|| CMsgProtoDefHeader::new())
    }

    // optional uint32 max_points_0 = 2;


    pub fn get_max_points_0(&self) -> u32 {
        self.max_points_0.unwrap_or(0)
    }
    pub fn clear_max_points_0(&mut self) {
        self.max_points_0 = ::std::option::Option::None;
    }

    pub fn has_max_points_0(&self) -> bool {
        self.max_points_0.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_points_0(&mut self, v: u32) {
        self.max_points_0 = ::std::option::Option::Some(v);
    }

    // optional uint32 max_points_1 = 3;


    pub fn get_max_points_1(&self) -> u32 {
        self.max_points_1.unwrap_or(0)
    }
    pub fn clear_max_points_1(&mut self) {
        self.max_points_1 = ::std::option::Option::None;
    }

    pub fn has_max_points_1(&self) -> bool {
        self.max_points_1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_points_1(&mut self, v: u32) {
        self.max_points_1 = ::std::option::Option::Some(v);
    }

    // optional uint32 max_points_2 = 4;


    pub fn get_max_points_2(&self) -> u32 {
        self.max_points_2.unwrap_or(0)
    }
    pub fn clear_max_points_2(&mut self) {
        self.max_points_2 = ::std::option::Option::None;
    }

    pub fn has_max_points_2(&self) -> bool {
        self.max_points_2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_points_2(&mut self, v: u32) {
        self.max_points_2 = ::std::option::Option::Some(v);
    }

    // optional string name_loctoken = 5;


    pub fn get_name_loctoken(&self) -> &str {
        match self.name_loctoken.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name_loctoken(&mut self) {
        self.name_loctoken.clear();
    }

    pub fn has_name_loctoken(&self) -> bool {
        self.name_loctoken.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name_loctoken(&mut self, v: ::std::string::String) {
        self.name_loctoken = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name_loctoken(&mut self) -> &mut ::std::string::String {
        if self.name_loctoken.is_none() {
            self.name_loctoken.set_default();
        }
        self.name_loctoken.as_mut().unwrap()
    }

    // Take field
    pub fn take_name_loctoken(&mut self) -> ::std::string::String {
        self.name_loctoken.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string operation = 7;


    pub fn get_operation(&self) -> &str {
        match self.operation.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_operation(&mut self) {
        self.operation.clear();
    }

    pub fn has_operation(&self) -> bool {
        self.operation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_operation(&mut self, v: ::std::string::String) {
        self.operation = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_operation(&mut self) -> &mut ::std::string::String {
        if self.operation.is_none() {
            self.operation.set_default();
        }
        self.operation.as_mut().unwrap()
    }

    // Take field
    pub fn take_operation(&mut self) -> ::std::string::String {
        self.operation.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .CMsgQuestDef.MMCriteria mm_criteria = 8;


    pub fn get_mm_criteria(&self) -> &CMsgQuestDef_MMCriteria {
        self.mm_criteria.as_ref().unwrap_or_else(|| <CMsgQuestDef_MMCriteria as ::protobuf::Message>::default_instance())
    }
    pub fn clear_mm_criteria(&mut self) {
        self.mm_criteria.clear();
    }

    pub fn has_mm_criteria(&self) -> bool {
        self.mm_criteria.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mm_criteria(&mut self, v: CMsgQuestDef_MMCriteria) {
        self.mm_criteria = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mm_criteria(&mut self) -> &mut CMsgQuestDef_MMCriteria {
        if self.mm_criteria.is_none() {
            self.mm_criteria.set_default();
        }
        self.mm_criteria.as_mut().unwrap()
    }

    // Take field
    pub fn take_mm_criteria(&mut self) -> CMsgQuestDef_MMCriteria {
        self.mm_criteria.take().unwrap_or_else(|| CMsgQuestDef_MMCriteria::new())
    }

    // optional string node_image = 12;


    pub fn get_node_image(&self) -> &str {
        match self.node_image.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_node_image(&mut self) {
        self.node_image.clear();
    }

    pub fn has_node_image(&self) -> bool {
        self.node_image.is_some()
    }

    // Param is passed by value, moved
    pub fn set_node_image(&mut self, v: ::std::string::String) {
        self.node_image = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_node_image(&mut self) -> &mut ::std::string::String {
        if self.node_image.is_none() {
            self.node_image.set_default();
        }
        self.node_image.as_mut().unwrap()
    }

    // Take field
    pub fn take_node_image(&mut self) -> ::std::string::String {
        self.node_image.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string icon_image = 13;


    pub fn get_icon_image(&self) -> &str {
        match self.icon_image.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_icon_image(&mut self) {
        self.icon_image.clear();
    }

    pub fn has_icon_image(&self) -> bool {
        self.icon_image.is_some()
    }

    // Param is passed by value, moved
    pub fn set_icon_image(&mut self, v: ::std::string::String) {
        self.icon_image = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_icon_image(&mut self) -> &mut ::std::string::String {
        if self.icon_image.is_none() {
            self.icon_image.set_default();
        }
        self.icon_image.as_mut().unwrap()
    }

    // Take field
    pub fn take_icon_image(&mut self) -> ::std::string::String {
        self.icon_image.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .CMsgProtoDefID theme = 14;


    pub fn get_theme(&self) -> &CMsgProtoDefID {
        self.theme.as_ref().unwrap_or_else(|| <CMsgProtoDefID as ::protobuf::Message>::default_instance())
    }
    pub fn clear_theme(&mut self) {
        self.theme.clear();
    }

    pub fn has_theme(&self) -> bool {
        self.theme.is_some()
    }

    // Param is passed by value, moved
    pub fn set_theme(&mut self, v: CMsgProtoDefID) {
        self.theme = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_theme(&mut self) -> &mut CMsgProtoDefID {
        if self.theme.is_none() {
            self.theme.set_default();
        }
        self.theme.as_mut().unwrap()
    }

    // Take field
    pub fn take_theme(&mut self) -> CMsgProtoDefID {
        self.theme.take().unwrap_or_else(|| CMsgProtoDefID::new())
    }

    // repeated string loaner_names = 15;


    pub fn get_loaner_names(&self) -> &[::std::string::String] {
        &self.loaner_names
    }
    pub fn clear_loaner_names(&mut self) {
        self.loaner_names.clear();
    }

    // Param is passed by value, moved
    pub fn set_loaner_names(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.loaner_names = v;
    }

    // Mutable pointer to the field.
    pub fn mut_loaner_names(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.loaner_names
    }

    // Take field
    pub fn take_loaner_names(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.loaner_names, ::protobuf::RepeatedField::new())
    }

    // repeated .CMsgQuestDef.ObjectiveInstance objectives = 16;


    pub fn get_objectives(&self) -> &[CMsgQuestDef_ObjectiveInstance] {
        &self.objectives
    }
    pub fn clear_objectives(&mut self) {
        self.objectives.clear();
    }

    // Param is passed by value, moved
    pub fn set_objectives(&mut self, v: ::protobuf::RepeatedField<CMsgQuestDef_ObjectiveInstance>) {
        self.objectives = v;
    }

    // Mutable pointer to the field.
    pub fn mut_objectives(&mut self) -> &mut ::protobuf::RepeatedField<CMsgQuestDef_ObjectiveInstance> {
        &mut self.objectives
    }

    // Take field
    pub fn take_objectives(&mut self) -> ::protobuf::RepeatedField<CMsgQuestDef_ObjectiveInstance> {
        ::std::mem::replace(&mut self.objectives, ::protobuf::RepeatedField::new())
    }

    // repeated string map = 17;


    pub fn get_map(&self) -> &[::std::string::String] {
        &self.map
    }
    pub fn clear_map(&mut self) {
        self.map.clear();
    }

    // Param is passed by value, moved
    pub fn set_map(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.map = v;
    }

    // Mutable pointer to the field.
    pub fn mut_map(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.map
    }

    // Take field
    pub fn take_map(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.map, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgQuestDef {
    fn is_initialized(&self) -> bool {
        if self.header.is_none() {
            return false;
        }
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.mm_criteria {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.theme {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.objectives {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.max_points_0 = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.max_points_1 = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.max_points_2 = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name_loctoken)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.operation)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.mm_criteria)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.node_image)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.icon_image)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.theme)?;
                },
                15 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.loaner_names)?;
                },
                16 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.objectives)?;
                },
                17 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.map)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.max_points_0 {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.max_points_1 {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.max_points_2 {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.name_loctoken.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.operation.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(ref v) = self.mm_criteria.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.node_image.as_ref() {
            my_size += ::protobuf::rt::string_size(12, &v);
        }
        if let Some(ref v) = self.icon_image.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        if let Some(ref v) = self.theme.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.loaner_names {
            my_size += ::protobuf::rt::string_size(15, &value);
        };
        for value in &self.objectives {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.map {
            my_size += ::protobuf::rt::string_size(17, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.max_points_0 {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.max_points_1 {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.max_points_2 {
            os.write_uint32(4, v)?;
        }
        if let Some(ref v) = self.name_loctoken.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.operation.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(ref v) = self.mm_criteria.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.node_image.as_ref() {
            os.write_string(12, &v)?;
        }
        if let Some(ref v) = self.icon_image.as_ref() {
            os.write_string(13, &v)?;
        }
        if let Some(ref v) = self.theme.as_ref() {
            os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.loaner_names {
            os.write_string(15, &v)?;
        };
        for v in &self.objectives {
            os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.map {
            os.write_string(17, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgQuestDef {
        CMsgQuestDef::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgProtoDefHeader>>(
                "header",
                |m: &CMsgQuestDef| { &m.header },
                |m: &mut CMsgQuestDef| { &mut m.header },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "max_points_0",
                |m: &CMsgQuestDef| { &m.max_points_0 },
                |m: &mut CMsgQuestDef| { &mut m.max_points_0 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "max_points_1",
                |m: &CMsgQuestDef| { &m.max_points_1 },
                |m: &mut CMsgQuestDef| { &mut m.max_points_1 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "max_points_2",
                |m: &CMsgQuestDef| { &m.max_points_2 },
                |m: &mut CMsgQuestDef| { &mut m.max_points_2 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name_loctoken",
                |m: &CMsgQuestDef| { &m.name_loctoken },
                |m: &mut CMsgQuestDef| { &mut m.name_loctoken },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "operation",
                |m: &CMsgQuestDef| { &m.operation },
                |m: &mut CMsgQuestDef| { &mut m.operation },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgQuestDef_MMCriteria>>(
                "mm_criteria",
                |m: &CMsgQuestDef| { &m.mm_criteria },
                |m: &mut CMsgQuestDef| { &mut m.mm_criteria },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "node_image",
                |m: &CMsgQuestDef| { &m.node_image },
                |m: &mut CMsgQuestDef| { &mut m.node_image },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "icon_image",
                |m: &CMsgQuestDef| { &m.icon_image },
                |m: &mut CMsgQuestDef| { &mut m.icon_image },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgProtoDefID>>(
                "theme",
                |m: &CMsgQuestDef| { &m.theme },
                |m: &mut CMsgQuestDef| { &mut m.theme },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "loaner_names",
                |m: &CMsgQuestDef| { &m.loaner_names },
                |m: &mut CMsgQuestDef| { &mut m.loaner_names },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgQuestDef_ObjectiveInstance>>(
                "objectives",
                |m: &CMsgQuestDef| { &m.objectives },
                |m: &mut CMsgQuestDef| { &mut m.objectives },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "map",
                |m: &CMsgQuestDef| { &m.map },
                |m: &mut CMsgQuestDef| { &mut m.map },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgQuestDef>(
                "CMsgQuestDef",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgQuestDef {
        static instance: ::protobuf::rt::LazyV2<CMsgQuestDef> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgQuestDef::new)
    }
}

impl ::protobuf::Clear for CMsgQuestDef {
    fn clear(&mut self) {
        self.header.clear();
        self.max_points_0 = ::std::option::Option::None;
        self.max_points_1 = ::std::option::Option::None;
        self.max_points_2 = ::std::option::Option::None;
        self.name_loctoken.clear();
        self.operation.clear();
        self.mm_criteria.clear();
        self.node_image.clear();
        self.icon_image.clear();
        self.theme.clear();
        self.loaner_names.clear();
        self.objectives.clear();
        self.map.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgQuestDef {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgQuestDef {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgQuestDef_MMCriteria {
    // message fields
    group_name: ::protobuf::SingularField<::std::string::String>,
    category_name: ::protobuf::SingularField<::std::string::String>,
    map_name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgQuestDef_MMCriteria {
    fn default() -> &'a CMsgQuestDef_MMCriteria {
        <CMsgQuestDef_MMCriteria as ::protobuf::Message>::default_instance()
    }
}

impl CMsgQuestDef_MMCriteria {
    pub fn new() -> CMsgQuestDef_MMCriteria {
        ::std::default::Default::default()
    }

    // optional string group_name = 1;


    pub fn get_group_name(&self) -> &str {
        match self.group_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_group_name(&mut self) {
        self.group_name.clear();
    }

    pub fn has_group_name(&self) -> bool {
        self.group_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_group_name(&mut self, v: ::std::string::String) {
        self.group_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_group_name(&mut self) -> &mut ::std::string::String {
        if self.group_name.is_none() {
            self.group_name.set_default();
        }
        self.group_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_group_name(&mut self) -> ::std::string::String {
        self.group_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string category_name = 2;


    pub fn get_category_name(&self) -> &str {
        match self.category_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_category_name(&mut self) {
        self.category_name.clear();
    }

    pub fn has_category_name(&self) -> bool {
        self.category_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_category_name(&mut self, v: ::std::string::String) {
        self.category_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_category_name(&mut self) -> &mut ::std::string::String {
        if self.category_name.is_none() {
            self.category_name.set_default();
        }
        self.category_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_category_name(&mut self) -> ::std::string::String {
        self.category_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string map_name = 3;


    pub fn get_map_name(&self) -> &str {
        match self.map_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_map_name(&mut self) {
        self.map_name.clear();
    }

    pub fn has_map_name(&self) -> bool {
        self.map_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map_name(&mut self, v: ::std::string::String) {
        self.map_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_map_name(&mut self) -> &mut ::std::string::String {
        if self.map_name.is_none() {
            self.map_name.set_default();
        }
        self.map_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_map_name(&mut self) -> ::std::string::String {
        self.map_name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgQuestDef_MMCriteria {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.group_name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.category_name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.map_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.group_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.category_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.map_name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.group_name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.category_name.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.map_name.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgQuestDef_MMCriteria {
        CMsgQuestDef_MMCriteria::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "group_name",
                |m: &CMsgQuestDef_MMCriteria| { &m.group_name },
                |m: &mut CMsgQuestDef_MMCriteria| { &mut m.group_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "category_name",
                |m: &CMsgQuestDef_MMCriteria| { &m.category_name },
                |m: &mut CMsgQuestDef_MMCriteria| { &mut m.category_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "map_name",
                |m: &CMsgQuestDef_MMCriteria| { &m.map_name },
                |m: &mut CMsgQuestDef_MMCriteria| { &mut m.map_name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgQuestDef_MMCriteria>(
                "CMsgQuestDef.MMCriteria",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgQuestDef_MMCriteria {
        static instance: ::protobuf::rt::LazyV2<CMsgQuestDef_MMCriteria> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgQuestDef_MMCriteria::new)
    }
}

impl ::protobuf::Clear for CMsgQuestDef_MMCriteria {
    fn clear(&mut self) {
        self.group_name.clear();
        self.category_name.clear();
        self.map_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgQuestDef_MMCriteria {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgQuestDef_MMCriteria {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgQuestDef_ObjectiveInstance {
    // message fields
    pub objective: ::protobuf::SingularPtrField<CMsgProtoDefID>,
    point_type: ::std::option::Option<EQuestPoints>,
    point_value: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgQuestDef_ObjectiveInstance {
    fn default() -> &'a CMsgQuestDef_ObjectiveInstance {
        <CMsgQuestDef_ObjectiveInstance as ::protobuf::Message>::default_instance()
    }
}

impl CMsgQuestDef_ObjectiveInstance {
    pub fn new() -> CMsgQuestDef_ObjectiveInstance {
        ::std::default::Default::default()
    }

    // optional .CMsgProtoDefID objective = 1;


    pub fn get_objective(&self) -> &CMsgProtoDefID {
        self.objective.as_ref().unwrap_or_else(|| <CMsgProtoDefID as ::protobuf::Message>::default_instance())
    }
    pub fn clear_objective(&mut self) {
        self.objective.clear();
    }

    pub fn has_objective(&self) -> bool {
        self.objective.is_some()
    }

    // Param is passed by value, moved
    pub fn set_objective(&mut self, v: CMsgProtoDefID) {
        self.objective = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_objective(&mut self) -> &mut CMsgProtoDefID {
        if self.objective.is_none() {
            self.objective.set_default();
        }
        self.objective.as_mut().unwrap()
    }

    // Take field
    pub fn take_objective(&mut self) -> CMsgProtoDefID {
        self.objective.take().unwrap_or_else(|| CMsgProtoDefID::new())
    }

    // optional .EQuestPoints point_type = 2;


    pub fn get_point_type(&self) -> EQuestPoints {
        self.point_type.unwrap_or(EQuestPoints::QUEST_POINTS_NOVICE)
    }
    pub fn clear_point_type(&mut self) {
        self.point_type = ::std::option::Option::None;
    }

    pub fn has_point_type(&self) -> bool {
        self.point_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_point_type(&mut self, v: EQuestPoints) {
        self.point_type = ::std::option::Option::Some(v);
    }

    // optional uint32 point_value = 3;


    pub fn get_point_value(&self) -> u32 {
        self.point_value.unwrap_or(0)
    }
    pub fn clear_point_value(&mut self) {
        self.point_value = ::std::option::Option::None;
    }

    pub fn has_point_value(&self) -> bool {
        self.point_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_point_value(&mut self, v: u32) {
        self.point_value = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgQuestDef_ObjectiveInstance {
    fn is_initialized(&self) -> bool {
        for v in &self.objective {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.objective)?;
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.point_type, 2, &mut self.unknown_fields)?
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.point_value = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.objective.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.point_type {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        if let Some(v) = self.point_value {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.objective.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.point_type {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.point_value {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgQuestDef_ObjectiveInstance {
        CMsgQuestDef_ObjectiveInstance::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgProtoDefID>>(
                "objective",
                |m: &CMsgQuestDef_ObjectiveInstance| { &m.objective },
                |m: &mut CMsgQuestDef_ObjectiveInstance| { &mut m.objective },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EQuestPoints>>(
                "point_type",
                |m: &CMsgQuestDef_ObjectiveInstance| { &m.point_type },
                |m: &mut CMsgQuestDef_ObjectiveInstance| { &mut m.point_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "point_value",
                |m: &CMsgQuestDef_ObjectiveInstance| { &m.point_value },
                |m: &mut CMsgQuestDef_ObjectiveInstance| { &mut m.point_value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgQuestDef_ObjectiveInstance>(
                "CMsgQuestDef.ObjectiveInstance",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgQuestDef_ObjectiveInstance {
        static instance: ::protobuf::rt::LazyV2<CMsgQuestDef_ObjectiveInstance> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgQuestDef_ObjectiveInstance::new)
    }
}

impl ::protobuf::Clear for CMsgQuestDef_ObjectiveInstance {
    fn clear(&mut self) {
        self.objective.clear();
        self.point_type = ::std::option::Option::None;
        self.point_value = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgQuestDef_ObjectiveInstance {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgQuestDef_ObjectiveInstance {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgQuestMapStoreItem {
    // message fields
    pub header: ::protobuf::SingularPtrField<CMsgProtoDefHeader>,
    item_name: ::protobuf::SingularField<::std::string::String>,
    reward_lootlist_name: ::protobuf::SingularField<::std::string::String>,
    pub price: ::protobuf::SingularPtrField<CMsgVarField>,
    purchase_limit: ::std::option::Option<u32>,
    sort_group: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgQuestMapStoreItem {
    fn default() -> &'a CMsgQuestMapStoreItem {
        <CMsgQuestMapStoreItem as ::protobuf::Message>::default_instance()
    }
}

impl CMsgQuestMapStoreItem {
    pub fn new() -> CMsgQuestMapStoreItem {
        ::std::default::Default::default()
    }

    // required .CMsgProtoDefHeader header = 1;


    pub fn get_header(&self) -> &CMsgProtoDefHeader {
        self.header.as_ref().unwrap_or_else(|| <CMsgProtoDefHeader as ::protobuf::Message>::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: CMsgProtoDefHeader) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut CMsgProtoDefHeader {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> CMsgProtoDefHeader {
        self.header.take().unwrap_or_else(|| CMsgProtoDefHeader::new())
    }

    // optional string item_name = 2;


    pub fn get_item_name(&self) -> &str {
        match self.item_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_item_name(&mut self) {
        self.item_name.clear();
    }

    pub fn has_item_name(&self) -> bool {
        self.item_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_name(&mut self, v: ::std::string::String) {
        self.item_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_item_name(&mut self) -> &mut ::std::string::String {
        if self.item_name.is_none() {
            self.item_name.set_default();
        }
        self.item_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_item_name(&mut self) -> ::std::string::String {
        self.item_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string reward_lootlist_name = 6;


    pub fn get_reward_lootlist_name(&self) -> &str {
        match self.reward_lootlist_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_reward_lootlist_name(&mut self) {
        self.reward_lootlist_name.clear();
    }

    pub fn has_reward_lootlist_name(&self) -> bool {
        self.reward_lootlist_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reward_lootlist_name(&mut self, v: ::std::string::String) {
        self.reward_lootlist_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reward_lootlist_name(&mut self) -> &mut ::std::string::String {
        if self.reward_lootlist_name.is_none() {
            self.reward_lootlist_name.set_default();
        }
        self.reward_lootlist_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_reward_lootlist_name(&mut self) -> ::std::string::String {
        self.reward_lootlist_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .CMsgVarField price = 3;


    pub fn get_price(&self) -> &CMsgVarField {
        self.price.as_ref().unwrap_or_else(|| <CMsgVarField as ::protobuf::Message>::default_instance())
    }
    pub fn clear_price(&mut self) {
        self.price.clear();
    }

    pub fn has_price(&self) -> bool {
        self.price.is_some()
    }

    // Param is passed by value, moved
    pub fn set_price(&mut self, v: CMsgVarField) {
        self.price = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_price(&mut self) -> &mut CMsgVarField {
        if self.price.is_none() {
            self.price.set_default();
        }
        self.price.as_mut().unwrap()
    }

    // Take field
    pub fn take_price(&mut self) -> CMsgVarField {
        self.price.take().unwrap_or_else(|| CMsgVarField::new())
    }

    // optional uint32 purchase_limit = 4;


    pub fn get_purchase_limit(&self) -> u32 {
        self.purchase_limit.unwrap_or(0)
    }
    pub fn clear_purchase_limit(&mut self) {
        self.purchase_limit = ::std::option::Option::None;
    }

    pub fn has_purchase_limit(&self) -> bool {
        self.purchase_limit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_purchase_limit(&mut self, v: u32) {
        self.purchase_limit = ::std::option::Option::Some(v);
    }

    // optional uint32 sort_group = 5;


    pub fn get_sort_group(&self) -> u32 {
        self.sort_group.unwrap_or(0)
    }
    pub fn clear_sort_group(&mut self) {
        self.sort_group = ::std::option::Option::None;
    }

    pub fn has_sort_group(&self) -> bool {
        self.sort_group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sort_group(&mut self, v: u32) {
        self.sort_group = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgQuestMapStoreItem {
    fn is_initialized(&self) -> bool {
        if self.header.is_none() {
            return false;
        }
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.price {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.item_name)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.reward_lootlist_name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.price)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.purchase_limit = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.sort_group = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.item_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.reward_lootlist_name.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(ref v) = self.price.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.purchase_limit {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.sort_group {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.item_name.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.reward_lootlist_name.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(ref v) = self.price.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.purchase_limit {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.sort_group {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgQuestMapStoreItem {
        CMsgQuestMapStoreItem::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgProtoDefHeader>>(
                "header",
                |m: &CMsgQuestMapStoreItem| { &m.header },
                |m: &mut CMsgQuestMapStoreItem| { &mut m.header },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "item_name",
                |m: &CMsgQuestMapStoreItem| { &m.item_name },
                |m: &mut CMsgQuestMapStoreItem| { &mut m.item_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "reward_lootlist_name",
                |m: &CMsgQuestMapStoreItem| { &m.reward_lootlist_name },
                |m: &mut CMsgQuestMapStoreItem| { &mut m.reward_lootlist_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgVarField>>(
                "price",
                |m: &CMsgQuestMapStoreItem| { &m.price },
                |m: &mut CMsgQuestMapStoreItem| { &mut m.price },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "purchase_limit",
                |m: &CMsgQuestMapStoreItem| { &m.purchase_limit },
                |m: &mut CMsgQuestMapStoreItem| { &mut m.purchase_limit },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "sort_group",
                |m: &CMsgQuestMapStoreItem| { &m.sort_group },
                |m: &mut CMsgQuestMapStoreItem| { &mut m.sort_group },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgQuestMapStoreItem>(
                "CMsgQuestMapStoreItem",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgQuestMapStoreItem {
        static instance: ::protobuf::rt::LazyV2<CMsgQuestMapStoreItem> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgQuestMapStoreItem::new)
    }
}

impl ::protobuf::Clear for CMsgQuestMapStoreItem {
    fn clear(&mut self) {
        self.header.clear();
        self.item_name.clear();
        self.reward_lootlist_name.clear();
        self.price.clear();
        self.purchase_limit = ::std::option::Option::None;
        self.sort_group = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgQuestMapStoreItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgQuestMapStoreItem {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgQuestMapRegionDef {
    // message fields
    pub header: ::protobuf::SingularPtrField<CMsgProtoDefHeader>,
    name: ::protobuf::SingularField<::std::string::String>,
    resfile: ::protobuf::SingularField<::std::string::String>,
    pub links: ::protobuf::RepeatedField<CMsgQuestMapRegionDef_RegionLink>,
    pub return_link: ::protobuf::SingularPtrField<CMsgProtoDefID>,
    radio_freq: ::std::option::Option<f32>,
    zoom_scale: ::std::option::Option<f32>,
    pub star_type: ::protobuf::SingularPtrField<CMsgProtoDefID>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgQuestMapRegionDef {
    fn default() -> &'a CMsgQuestMapRegionDef {
        <CMsgQuestMapRegionDef as ::protobuf::Message>::default_instance()
    }
}

impl CMsgQuestMapRegionDef {
    pub fn new() -> CMsgQuestMapRegionDef {
        ::std::default::Default::default()
    }

    // required .CMsgProtoDefHeader header = 1;


    pub fn get_header(&self) -> &CMsgProtoDefHeader {
        self.header.as_ref().unwrap_or_else(|| <CMsgProtoDefHeader as ::protobuf::Message>::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: CMsgProtoDefHeader) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut CMsgProtoDefHeader {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> CMsgProtoDefHeader {
        self.header.take().unwrap_or_else(|| CMsgProtoDefHeader::new())
    }

    // optional string name = 2;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string resfile = 3;


    pub fn get_resfile(&self) -> &str {
        match self.resfile.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_resfile(&mut self) {
        self.resfile.clear();
    }

    pub fn has_resfile(&self) -> bool {
        self.resfile.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resfile(&mut self, v: ::std::string::String) {
        self.resfile = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resfile(&mut self) -> &mut ::std::string::String {
        if self.resfile.is_none() {
            self.resfile.set_default();
        }
        self.resfile.as_mut().unwrap()
    }

    // Take field
    pub fn take_resfile(&mut self) -> ::std::string::String {
        self.resfile.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .CMsgQuestMapRegionDef.RegionLink links = 4;


    pub fn get_links(&self) -> &[CMsgQuestMapRegionDef_RegionLink] {
        &self.links
    }
    pub fn clear_links(&mut self) {
        self.links.clear();
    }

    // Param is passed by value, moved
    pub fn set_links(&mut self, v: ::protobuf::RepeatedField<CMsgQuestMapRegionDef_RegionLink>) {
        self.links = v;
    }

    // Mutable pointer to the field.
    pub fn mut_links(&mut self) -> &mut ::protobuf::RepeatedField<CMsgQuestMapRegionDef_RegionLink> {
        &mut self.links
    }

    // Take field
    pub fn take_links(&mut self) -> ::protobuf::RepeatedField<CMsgQuestMapRegionDef_RegionLink> {
        ::std::mem::replace(&mut self.links, ::protobuf::RepeatedField::new())
    }

    // optional .CMsgProtoDefID return_link = 5;


    pub fn get_return_link(&self) -> &CMsgProtoDefID {
        self.return_link.as_ref().unwrap_or_else(|| <CMsgProtoDefID as ::protobuf::Message>::default_instance())
    }
    pub fn clear_return_link(&mut self) {
        self.return_link.clear();
    }

    pub fn has_return_link(&self) -> bool {
        self.return_link.is_some()
    }

    // Param is passed by value, moved
    pub fn set_return_link(&mut self, v: CMsgProtoDefID) {
        self.return_link = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_return_link(&mut self) -> &mut CMsgProtoDefID {
        if self.return_link.is_none() {
            self.return_link.set_default();
        }
        self.return_link.as_mut().unwrap()
    }

    // Take field
    pub fn take_return_link(&mut self) -> CMsgProtoDefID {
        self.return_link.take().unwrap_or_else(|| CMsgProtoDefID::new())
    }

    // optional float radio_freq = 6;


    pub fn get_radio_freq(&self) -> f32 {
        self.radio_freq.unwrap_or(0.)
    }
    pub fn clear_radio_freq(&mut self) {
        self.radio_freq = ::std::option::Option::None;
    }

    pub fn has_radio_freq(&self) -> bool {
        self.radio_freq.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radio_freq(&mut self, v: f32) {
        self.radio_freq = ::std::option::Option::Some(v);
    }

    // optional float zoom_scale = 7;


    pub fn get_zoom_scale(&self) -> f32 {
        self.zoom_scale.unwrap_or(0.)
    }
    pub fn clear_zoom_scale(&mut self) {
        self.zoom_scale = ::std::option::Option::None;
    }

    pub fn has_zoom_scale(&self) -> bool {
        self.zoom_scale.is_some()
    }

    // Param is passed by value, moved
    pub fn set_zoom_scale(&mut self, v: f32) {
        self.zoom_scale = ::std::option::Option::Some(v);
    }

    // optional .CMsgProtoDefID star_type = 8;


    pub fn get_star_type(&self) -> &CMsgProtoDefID {
        self.star_type.as_ref().unwrap_or_else(|| <CMsgProtoDefID as ::protobuf::Message>::default_instance())
    }
    pub fn clear_star_type(&mut self) {
        self.star_type.clear();
    }

    pub fn has_star_type(&self) -> bool {
        self.star_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_star_type(&mut self, v: CMsgProtoDefID) {
        self.star_type = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_star_type(&mut self) -> &mut CMsgProtoDefID {
        if self.star_type.is_none() {
            self.star_type.set_default();
        }
        self.star_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_star_type(&mut self) -> CMsgProtoDefID {
        self.star_type.take().unwrap_or_else(|| CMsgProtoDefID::new())
    }
}

impl ::protobuf::Message for CMsgQuestMapRegionDef {
    fn is_initialized(&self) -> bool {
        if self.header.is_none() {
            return false;
        }
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.links {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.return_link {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.star_type {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.resfile)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.links)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.return_link)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.radio_freq = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.zoom_scale = ::std::option::Option::Some(tmp);
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.star_type)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.resfile.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        for value in &self.links {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.return_link.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.radio_freq {
            my_size += 5;
        }
        if let Some(v) = self.zoom_scale {
            my_size += 5;
        }
        if let Some(ref v) = self.star_type.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.resfile.as_ref() {
            os.write_string(3, &v)?;
        }
        for v in &self.links {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.return_link.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.radio_freq {
            os.write_float(6, v)?;
        }
        if let Some(v) = self.zoom_scale {
            os.write_float(7, v)?;
        }
        if let Some(ref v) = self.star_type.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgQuestMapRegionDef {
        CMsgQuestMapRegionDef::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgProtoDefHeader>>(
                "header",
                |m: &CMsgQuestMapRegionDef| { &m.header },
                |m: &mut CMsgQuestMapRegionDef| { &mut m.header },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &CMsgQuestMapRegionDef| { &m.name },
                |m: &mut CMsgQuestMapRegionDef| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "resfile",
                |m: &CMsgQuestMapRegionDef| { &m.resfile },
                |m: &mut CMsgQuestMapRegionDef| { &mut m.resfile },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgQuestMapRegionDef_RegionLink>>(
                "links",
                |m: &CMsgQuestMapRegionDef| { &m.links },
                |m: &mut CMsgQuestMapRegionDef| { &mut m.links },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgProtoDefID>>(
                "return_link",
                |m: &CMsgQuestMapRegionDef| { &m.return_link },
                |m: &mut CMsgQuestMapRegionDef| { &mut m.return_link },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "radio_freq",
                |m: &CMsgQuestMapRegionDef| { &m.radio_freq },
                |m: &mut CMsgQuestMapRegionDef| { &mut m.radio_freq },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "zoom_scale",
                |m: &CMsgQuestMapRegionDef| { &m.zoom_scale },
                |m: &mut CMsgQuestMapRegionDef| { &mut m.zoom_scale },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgProtoDefID>>(
                "star_type",
                |m: &CMsgQuestMapRegionDef| { &m.star_type },
                |m: &mut CMsgQuestMapRegionDef| { &mut m.star_type },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgQuestMapRegionDef>(
                "CMsgQuestMapRegionDef",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgQuestMapRegionDef {
        static instance: ::protobuf::rt::LazyV2<CMsgQuestMapRegionDef> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgQuestMapRegionDef::new)
    }
}

impl ::protobuf::Clear for CMsgQuestMapRegionDef {
    fn clear(&mut self) {
        self.header.clear();
        self.name.clear();
        self.resfile.clear();
        self.links.clear();
        self.return_link.clear();
        self.radio_freq = ::std::option::Option::None;
        self.zoom_scale = ::std::option::Option::None;
        self.star_type.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgQuestMapRegionDef {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgQuestMapRegionDef {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgQuestMapRegionDef_RegionLink {
    // message fields
    pub target_region_defid: ::protobuf::SingularPtrField<CMsgProtoDefID>,
    xpos: ::std::option::Option<u32>,
    ypos: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgQuestMapRegionDef_RegionLink {
    fn default() -> &'a CMsgQuestMapRegionDef_RegionLink {
        <CMsgQuestMapRegionDef_RegionLink as ::protobuf::Message>::default_instance()
    }
}

impl CMsgQuestMapRegionDef_RegionLink {
    pub fn new() -> CMsgQuestMapRegionDef_RegionLink {
        ::std::default::Default::default()
    }

    // required .CMsgProtoDefID target_region_defid = 1;


    pub fn get_target_region_defid(&self) -> &CMsgProtoDefID {
        self.target_region_defid.as_ref().unwrap_or_else(|| <CMsgProtoDefID as ::protobuf::Message>::default_instance())
    }
    pub fn clear_target_region_defid(&mut self) {
        self.target_region_defid.clear();
    }

    pub fn has_target_region_defid(&self) -> bool {
        self.target_region_defid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_region_defid(&mut self, v: CMsgProtoDefID) {
        self.target_region_defid = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_target_region_defid(&mut self) -> &mut CMsgProtoDefID {
        if self.target_region_defid.is_none() {
            self.target_region_defid.set_default();
        }
        self.target_region_defid.as_mut().unwrap()
    }

    // Take field
    pub fn take_target_region_defid(&mut self) -> CMsgProtoDefID {
        self.target_region_defid.take().unwrap_or_else(|| CMsgProtoDefID::new())
    }

    // optional uint32 xpos = 2;


    pub fn get_xpos(&self) -> u32 {
        self.xpos.unwrap_or(0)
    }
    pub fn clear_xpos(&mut self) {
        self.xpos = ::std::option::Option::None;
    }

    pub fn has_xpos(&self) -> bool {
        self.xpos.is_some()
    }

    // Param is passed by value, moved
    pub fn set_xpos(&mut self, v: u32) {
        self.xpos = ::std::option::Option::Some(v);
    }

    // optional uint32 ypos = 3;


    pub fn get_ypos(&self) -> u32 {
        self.ypos.unwrap_or(0)
    }
    pub fn clear_ypos(&mut self) {
        self.ypos = ::std::option::Option::None;
    }

    pub fn has_ypos(&self) -> bool {
        self.ypos.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ypos(&mut self, v: u32) {
        self.ypos = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgQuestMapRegionDef_RegionLink {
    fn is_initialized(&self) -> bool {
        if self.target_region_defid.is_none() {
            return false;
        }
        for v in &self.target_region_defid {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.target_region_defid)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.xpos = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ypos = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.target_region_defid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.xpos {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ypos {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.target_region_defid.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.xpos {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.ypos {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgQuestMapRegionDef_RegionLink {
        CMsgQuestMapRegionDef_RegionLink::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgProtoDefID>>(
                "target_region_defid",
                |m: &CMsgQuestMapRegionDef_RegionLink| { &m.target_region_defid },
                |m: &mut CMsgQuestMapRegionDef_RegionLink| { &mut m.target_region_defid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "xpos",
                |m: &CMsgQuestMapRegionDef_RegionLink| { &m.xpos },
                |m: &mut CMsgQuestMapRegionDef_RegionLink| { &mut m.xpos },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ypos",
                |m: &CMsgQuestMapRegionDef_RegionLink| { &m.ypos },
                |m: &mut CMsgQuestMapRegionDef_RegionLink| { &mut m.ypos },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgQuestMapRegionDef_RegionLink>(
                "CMsgQuestMapRegionDef.RegionLink",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgQuestMapRegionDef_RegionLink {
        static instance: ::protobuf::rt::LazyV2<CMsgQuestMapRegionDef_RegionLink> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgQuestMapRegionDef_RegionLink::new)
    }
}

impl ::protobuf::Clear for CMsgQuestMapRegionDef_RegionLink {
    fn clear(&mut self) {
        self.target_region_defid.clear();
        self.xpos = ::std::option::Option::None;
        self.ypos = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgQuestMapRegionDef_RegionLink {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgQuestMapRegionDef_RegionLink {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgVarField {
    // message fields
    variable: ::protobuf::SingularField<::std::string::String>,
    // message oneof groups
    pub value: ::std::option::Option<CMsgVarField_oneof_value>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgVarField {
    fn default() -> &'a CMsgVarField {
        <CMsgVarField as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum CMsgVarField_oneof_value {
    float(f32),
    double(f64),
    uint32(u32),
    uint64(u64),
    sint32(i32),
    sint64(i64),
    bool(bool),
    string(::std::string::String),
}

impl CMsgVarField {
    pub fn new() -> CMsgVarField {
        ::std::default::Default::default()
    }

    // optional string variable = 1;


    pub fn get_variable(&self) -> &str {
        match self.variable.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_variable(&mut self) {
        self.variable.clear();
    }

    pub fn has_variable(&self) -> bool {
        self.variable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_variable(&mut self, v: ::std::string::String) {
        self.variable = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_variable(&mut self) -> &mut ::std::string::String {
        if self.variable.is_none() {
            self.variable.set_default();
        }
        self.variable.as_mut().unwrap()
    }

    // Take field
    pub fn take_variable(&mut self) -> ::std::string::String {
        self.variable.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional float float = 2;


    pub fn get_float(&self) -> f32 {
        match self.value {
            ::std::option::Option::Some(CMsgVarField_oneof_value::float(v)) => v,
            _ => 0.,
        }
    }
    pub fn clear_float(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_float(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(CMsgVarField_oneof_value::float(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_float(&mut self, v: f32) {
        self.value = ::std::option::Option::Some(CMsgVarField_oneof_value::float(v))
    }

    // optional double double = 3;


    pub fn get_double(&self) -> f64 {
        match self.value {
            ::std::option::Option::Some(CMsgVarField_oneof_value::double(v)) => v,
            _ => 0.,
        }
    }
    pub fn clear_double(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_double(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(CMsgVarField_oneof_value::double(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_double(&mut self, v: f64) {
        self.value = ::std::option::Option::Some(CMsgVarField_oneof_value::double(v))
    }

    // optional uint32 uint32 = 4;


    pub fn get_uint32(&self) -> u32 {
        match self.value {
            ::std::option::Option::Some(CMsgVarField_oneof_value::uint32(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_uint32(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_uint32(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(CMsgVarField_oneof_value::uint32(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_uint32(&mut self, v: u32) {
        self.value = ::std::option::Option::Some(CMsgVarField_oneof_value::uint32(v))
    }

    // optional uint64 uint64 = 5;


    pub fn get_uint64(&self) -> u64 {
        match self.value {
            ::std::option::Option::Some(CMsgVarField_oneof_value::uint64(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_uint64(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_uint64(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(CMsgVarField_oneof_value::uint64(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_uint64(&mut self, v: u64) {
        self.value = ::std::option::Option::Some(CMsgVarField_oneof_value::uint64(v))
    }

    // optional sint32 sint32 = 6;


    pub fn get_sint32(&self) -> i32 {
        match self.value {
            ::std::option::Option::Some(CMsgVarField_oneof_value::sint32(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_sint32(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_sint32(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(CMsgVarField_oneof_value::sint32(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sint32(&mut self, v: i32) {
        self.value = ::std::option::Option::Some(CMsgVarField_oneof_value::sint32(v))
    }

    // optional sint64 sint64 = 7;


    pub fn get_sint64(&self) -> i64 {
        match self.value {
            ::std::option::Option::Some(CMsgVarField_oneof_value::sint64(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_sint64(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_sint64(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(CMsgVarField_oneof_value::sint64(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sint64(&mut self, v: i64) {
        self.value = ::std::option::Option::Some(CMsgVarField_oneof_value::sint64(v))
    }

    // optional bool bool = 8;


    pub fn get_bool(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(CMsgVarField_oneof_value::bool(v)) => v,
            _ => false,
        }
    }
    pub fn clear_bool(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_bool(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(CMsgVarField_oneof_value::bool(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_bool(&mut self, v: bool) {
        self.value = ::std::option::Option::Some(CMsgVarField_oneof_value::bool(v))
    }

    // optional string string = 9;


    pub fn get_string(&self) -> &str {
        match self.value {
            ::std::option::Option::Some(CMsgVarField_oneof_value::string(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_string(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_string(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(CMsgVarField_oneof_value::string(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_string(&mut self, v: ::std::string::String) {
        self.value = ::std::option::Option::Some(CMsgVarField_oneof_value::string(v))
    }

    // Mutable pointer to the field.
    pub fn mut_string(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(CMsgVarField_oneof_value::string(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(CMsgVarField_oneof_value::string(::std::string::String::new()));
        }
        match self.value {
            ::std::option::Option::Some(CMsgVarField_oneof_value::string(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_string(&mut self) -> ::std::string::String {
        if self.has_string() {
            match self.value.take() {
                ::std::option::Option::Some(CMsgVarField_oneof_value::string(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }
}

impl ::protobuf::Message for CMsgVarField {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.variable)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(CMsgVarField_oneof_value::float(is.read_float()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(CMsgVarField_oneof_value::double(is.read_double()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(CMsgVarField_oneof_value::uint32(is.read_uint32()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(CMsgVarField_oneof_value::uint64(is.read_uint64()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(CMsgVarField_oneof_value::sint32(is.read_sint32()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(CMsgVarField_oneof_value::sint64(is.read_sint64()?));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(CMsgVarField_oneof_value::bool(is.read_bool()?));
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(CMsgVarField_oneof_value::string(is.read_string()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.variable.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &CMsgVarField_oneof_value::float(v) => {
                    my_size += 5;
                },
                &CMsgVarField_oneof_value::double(v) => {
                    my_size += 9;
                },
                &CMsgVarField_oneof_value::uint32(v) => {
                    my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
                },
                &CMsgVarField_oneof_value::uint64(v) => {
                    my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
                },
                &CMsgVarField_oneof_value::sint32(v) => {
                    my_size += ::protobuf::rt::value_varint_zigzag_size(6, v);
                },
                &CMsgVarField_oneof_value::sint64(v) => {
                    my_size += ::protobuf::rt::value_varint_zigzag_size(7, v);
                },
                &CMsgVarField_oneof_value::bool(v) => {
                    my_size += 2;
                },
                &CMsgVarField_oneof_value::string(ref v) => {
                    my_size += ::protobuf::rt::string_size(9, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.variable.as_ref() {
            os.write_string(1, &v)?;
        }
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &CMsgVarField_oneof_value::float(v) => {
                    os.write_float(2, v)?;
                },
                &CMsgVarField_oneof_value::double(v) => {
                    os.write_double(3, v)?;
                },
                &CMsgVarField_oneof_value::uint32(v) => {
                    os.write_uint32(4, v)?;
                },
                &CMsgVarField_oneof_value::uint64(v) => {
                    os.write_uint64(5, v)?;
                },
                &CMsgVarField_oneof_value::sint32(v) => {
                    os.write_sint32(6, v)?;
                },
                &CMsgVarField_oneof_value::sint64(v) => {
                    os.write_sint64(7, v)?;
                },
                &CMsgVarField_oneof_value::bool(v) => {
                    os.write_bool(8, v)?;
                },
                &CMsgVarField_oneof_value::string(ref v) => {
                    os.write_string(9, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgVarField {
        CMsgVarField::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "variable",
                |m: &CMsgVarField| { &m.variable },
                |m: &mut CMsgVarField| { &mut m.variable },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_f32_accessor::<_>(
                "float",
                CMsgVarField::has_float,
                CMsgVarField::get_float,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_f64_accessor::<_>(
                "double",
                CMsgVarField::has_double,
                CMsgVarField::get_double,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor::<_>(
                "uint32",
                CMsgVarField::has_uint32,
                CMsgVarField::get_uint32,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor::<_>(
                "uint64",
                CMsgVarField::has_uint64,
                CMsgVarField::get_uint64,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor::<_>(
                "sint32",
                CMsgVarField::has_sint32,
                CMsgVarField::get_sint32,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor::<_>(
                "sint64",
                CMsgVarField::has_sint64,
                CMsgVarField::get_sint64,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor::<_>(
                "bool",
                CMsgVarField::has_bool,
                CMsgVarField::get_bool,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "string",
                CMsgVarField::has_string,
                CMsgVarField::get_string,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgVarField>(
                "CMsgVarField",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgVarField {
        static instance: ::protobuf::rt::LazyV2<CMsgVarField> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgVarField::new)
    }
}

impl ::protobuf::Clear for CMsgVarField {
    fn clear(&mut self) {
        self.variable.clear();
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgVarField {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgVarField {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgQuestMapStarType {
    // message fields
    pub header: ::protobuf::SingularPtrField<CMsgProtoDefHeader>,
    name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgQuestMapStarType {
    fn default() -> &'a CMsgQuestMapStarType {
        <CMsgQuestMapStarType as ::protobuf::Message>::default_instance()
    }
}

impl CMsgQuestMapStarType {
    pub fn new() -> CMsgQuestMapStarType {
        ::std::default::Default::default()
    }

    // required .CMsgProtoDefHeader header = 1;


    pub fn get_header(&self) -> &CMsgProtoDefHeader {
        self.header.as_ref().unwrap_or_else(|| <CMsgProtoDefHeader as ::protobuf::Message>::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: CMsgProtoDefHeader) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut CMsgProtoDefHeader {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> CMsgProtoDefHeader {
        self.header.take().unwrap_or_else(|| CMsgProtoDefHeader::new())
    }

    // optional string name = 2;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgQuestMapStarType {
    fn is_initialized(&self) -> bool {
        if self.header.is_none() {
            return false;
        }
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgQuestMapStarType {
        CMsgQuestMapStarType::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgProtoDefHeader>>(
                "header",
                |m: &CMsgQuestMapStarType| { &m.header },
                |m: &mut CMsgQuestMapStarType| { &mut m.header },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &CMsgQuestMapStarType| { &m.name },
                |m: &mut CMsgQuestMapStarType| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgQuestMapStarType>(
                "CMsgQuestMapStarType",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgQuestMapStarType {
        static instance: ::protobuf::rt::LazyV2<CMsgQuestMapStarType> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgQuestMapStarType::new)
    }
}

impl ::protobuf::Clear for CMsgQuestMapStarType {
    fn clear(&mut self) {
        self.header.clear();
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgQuestMapStarType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgQuestMapStarType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgQuestMapNodeDef {
    // message fields
    pub header: ::protobuf::SingularPtrField<CMsgProtoDefHeader>,
    name_loctoken: ::protobuf::SingularField<::std::string::String>,
    x_pos: ::std::option::Option<f32>,
    y_pos: ::std::option::Option<f32>,
    pub condition: ::protobuf::SingularPtrField<CMsgQuestMapNodeCondition>,
    pub owning_region: ::protobuf::SingularPtrField<CMsgProtoDefID>,
    pub quest_options: ::protobuf::RepeatedField<CMsgProtoDefID>,
    associated_operation: ::protobuf::SingularField<::std::string::String>,
    reward_item_name: ::protobuf::SingularField<::std::string::String>,
    reward_lootlist_name: ::protobuf::SingularField<::std::string::String>,
    cash_reward: ::std::option::Option<ENodeCashReward>,
    pub star_type: ::protobuf::SingularPtrField<CMsgProtoDefID>,
    stars_to_unlock: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgQuestMapNodeDef {
    fn default() -> &'a CMsgQuestMapNodeDef {
        <CMsgQuestMapNodeDef as ::protobuf::Message>::default_instance()
    }
}

impl CMsgQuestMapNodeDef {
    pub fn new() -> CMsgQuestMapNodeDef {
        ::std::default::Default::default()
    }

    // required .CMsgProtoDefHeader header = 1;


    pub fn get_header(&self) -> &CMsgProtoDefHeader {
        self.header.as_ref().unwrap_or_else(|| <CMsgProtoDefHeader as ::protobuf::Message>::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: CMsgProtoDefHeader) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut CMsgProtoDefHeader {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> CMsgProtoDefHeader {
        self.header.take().unwrap_or_else(|| CMsgProtoDefHeader::new())
    }

    // optional string name_loctoken = 4;


    pub fn get_name_loctoken(&self) -> &str {
        match self.name_loctoken.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name_loctoken(&mut self) {
        self.name_loctoken.clear();
    }

    pub fn has_name_loctoken(&self) -> bool {
        self.name_loctoken.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name_loctoken(&mut self, v: ::std::string::String) {
        self.name_loctoken = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name_loctoken(&mut self) -> &mut ::std::string::String {
        if self.name_loctoken.is_none() {
            self.name_loctoken.set_default();
        }
        self.name_loctoken.as_mut().unwrap()
    }

    // Take field
    pub fn take_name_loctoken(&mut self) -> ::std::string::String {
        self.name_loctoken.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional float x_pos = 6;


    pub fn get_x_pos(&self) -> f32 {
        self.x_pos.unwrap_or(0.)
    }
    pub fn clear_x_pos(&mut self) {
        self.x_pos = ::std::option::Option::None;
    }

    pub fn has_x_pos(&self) -> bool {
        self.x_pos.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x_pos(&mut self, v: f32) {
        self.x_pos = ::std::option::Option::Some(v);
    }

    // optional float y_pos = 7;


    pub fn get_y_pos(&self) -> f32 {
        self.y_pos.unwrap_or(0.)
    }
    pub fn clear_y_pos(&mut self) {
        self.y_pos = ::std::option::Option::None;
    }

    pub fn has_y_pos(&self) -> bool {
        self.y_pos.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y_pos(&mut self, v: f32) {
        self.y_pos = ::std::option::Option::Some(v);
    }

    // optional .CMsgQuestMapNodeCondition condition = 9;


    pub fn get_condition(&self) -> &CMsgQuestMapNodeCondition {
        self.condition.as_ref().unwrap_or_else(|| <CMsgQuestMapNodeCondition as ::protobuf::Message>::default_instance())
    }
    pub fn clear_condition(&mut self) {
        self.condition.clear();
    }

    pub fn has_condition(&self) -> bool {
        self.condition.is_some()
    }

    // Param is passed by value, moved
    pub fn set_condition(&mut self, v: CMsgQuestMapNodeCondition) {
        self.condition = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_condition(&mut self) -> &mut CMsgQuestMapNodeCondition {
        if self.condition.is_none() {
            self.condition.set_default();
        }
        self.condition.as_mut().unwrap()
    }

    // Take field
    pub fn take_condition(&mut self) -> CMsgQuestMapNodeCondition {
        self.condition.take().unwrap_or_else(|| CMsgQuestMapNodeCondition::new())
    }

    // optional .CMsgProtoDefID owning_region = 10;


    pub fn get_owning_region(&self) -> &CMsgProtoDefID {
        self.owning_region.as_ref().unwrap_or_else(|| <CMsgProtoDefID as ::protobuf::Message>::default_instance())
    }
    pub fn clear_owning_region(&mut self) {
        self.owning_region.clear();
    }

    pub fn has_owning_region(&self) -> bool {
        self.owning_region.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owning_region(&mut self, v: CMsgProtoDefID) {
        self.owning_region = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owning_region(&mut self) -> &mut CMsgProtoDefID {
        if self.owning_region.is_none() {
            self.owning_region.set_default();
        }
        self.owning_region.as_mut().unwrap()
    }

    // Take field
    pub fn take_owning_region(&mut self) -> CMsgProtoDefID {
        self.owning_region.take().unwrap_or_else(|| CMsgProtoDefID::new())
    }

    // repeated .CMsgProtoDefID quest_options = 11;


    pub fn get_quest_options(&self) -> &[CMsgProtoDefID] {
        &self.quest_options
    }
    pub fn clear_quest_options(&mut self) {
        self.quest_options.clear();
    }

    // Param is passed by value, moved
    pub fn set_quest_options(&mut self, v: ::protobuf::RepeatedField<CMsgProtoDefID>) {
        self.quest_options = v;
    }

    // Mutable pointer to the field.
    pub fn mut_quest_options(&mut self) -> &mut ::protobuf::RepeatedField<CMsgProtoDefID> {
        &mut self.quest_options
    }

    // Take field
    pub fn take_quest_options(&mut self) -> ::protobuf::RepeatedField<CMsgProtoDefID> {
        ::std::mem::replace(&mut self.quest_options, ::protobuf::RepeatedField::new())
    }

    // optional string associated_operation = 16;


    pub fn get_associated_operation(&self) -> &str {
        match self.associated_operation.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_associated_operation(&mut self) {
        self.associated_operation.clear();
    }

    pub fn has_associated_operation(&self) -> bool {
        self.associated_operation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_associated_operation(&mut self, v: ::std::string::String) {
        self.associated_operation = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_associated_operation(&mut self) -> &mut ::std::string::String {
        if self.associated_operation.is_none() {
            self.associated_operation.set_default();
        }
        self.associated_operation.as_mut().unwrap()
    }

    // Take field
    pub fn take_associated_operation(&mut self) -> ::std::string::String {
        self.associated_operation.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string reward_item_name = 18;


    pub fn get_reward_item_name(&self) -> &str {
        match self.reward_item_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_reward_item_name(&mut self) {
        self.reward_item_name.clear();
    }

    pub fn has_reward_item_name(&self) -> bool {
        self.reward_item_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reward_item_name(&mut self, v: ::std::string::String) {
        self.reward_item_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reward_item_name(&mut self) -> &mut ::std::string::String {
        if self.reward_item_name.is_none() {
            self.reward_item_name.set_default();
        }
        self.reward_item_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_reward_item_name(&mut self) -> ::std::string::String {
        self.reward_item_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string reward_lootlist_name = 22;


    pub fn get_reward_lootlist_name(&self) -> &str {
        match self.reward_lootlist_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_reward_lootlist_name(&mut self) {
        self.reward_lootlist_name.clear();
    }

    pub fn has_reward_lootlist_name(&self) -> bool {
        self.reward_lootlist_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reward_lootlist_name(&mut self, v: ::std::string::String) {
        self.reward_lootlist_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reward_lootlist_name(&mut self) -> &mut ::std::string::String {
        if self.reward_lootlist_name.is_none() {
            self.reward_lootlist_name.set_default();
        }
        self.reward_lootlist_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_reward_lootlist_name(&mut self) -> ::std::string::String {
        self.reward_lootlist_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .ENodeCashReward cash_reward = 19;


    pub fn get_cash_reward(&self) -> ENodeCashReward {
        self.cash_reward.unwrap_or(ENodeCashReward::CASH_REWARD_NONE)
    }
    pub fn clear_cash_reward(&mut self) {
        self.cash_reward = ::std::option::Option::None;
    }

    pub fn has_cash_reward(&self) -> bool {
        self.cash_reward.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cash_reward(&mut self, v: ENodeCashReward) {
        self.cash_reward = ::std::option::Option::Some(v);
    }

    // optional .CMsgProtoDefID star_type = 20;


    pub fn get_star_type(&self) -> &CMsgProtoDefID {
        self.star_type.as_ref().unwrap_or_else(|| <CMsgProtoDefID as ::protobuf::Message>::default_instance())
    }
    pub fn clear_star_type(&mut self) {
        self.star_type.clear();
    }

    pub fn has_star_type(&self) -> bool {
        self.star_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_star_type(&mut self, v: CMsgProtoDefID) {
        self.star_type = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_star_type(&mut self) -> &mut CMsgProtoDefID {
        if self.star_type.is_none() {
            self.star_type.set_default();
        }
        self.star_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_star_type(&mut self) -> CMsgProtoDefID {
        self.star_type.take().unwrap_or_else(|| CMsgProtoDefID::new())
    }

    // optional uint32 stars_to_unlock = 21;


    pub fn get_stars_to_unlock(&self) -> u32 {
        self.stars_to_unlock.unwrap_or(1u32)
    }
    pub fn clear_stars_to_unlock(&mut self) {
        self.stars_to_unlock = ::std::option::Option::None;
    }

    pub fn has_stars_to_unlock(&self) -> bool {
        self.stars_to_unlock.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stars_to_unlock(&mut self, v: u32) {
        self.stars_to_unlock = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgQuestMapNodeDef {
    fn is_initialized(&self) -> bool {
        if self.header.is_none() {
            return false;
        }
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.condition {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.owning_region {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.quest_options {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.star_type {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name_loctoken)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.x_pos = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.y_pos = ::std::option::Option::Some(tmp);
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.condition)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.owning_region)?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.quest_options)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.associated_operation)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.reward_item_name)?;
                },
                22 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.reward_lootlist_name)?;
                },
                19 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.cash_reward, 19, &mut self.unknown_fields)?
                },
                20 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.star_type)?;
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.stars_to_unlock = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.name_loctoken.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.x_pos {
            my_size += 5;
        }
        if let Some(v) = self.y_pos {
            my_size += 5;
        }
        if let Some(ref v) = self.condition.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.owning_region.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.quest_options {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.associated_operation.as_ref() {
            my_size += ::protobuf::rt::string_size(16, &v);
        }
        if let Some(ref v) = self.reward_item_name.as_ref() {
            my_size += ::protobuf::rt::string_size(18, &v);
        }
        if let Some(ref v) = self.reward_lootlist_name.as_ref() {
            my_size += ::protobuf::rt::string_size(22, &v);
        }
        if let Some(v) = self.cash_reward {
            my_size += ::protobuf::rt::enum_size(19, v);
        }
        if let Some(ref v) = self.star_type.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.stars_to_unlock {
            my_size += ::protobuf::rt::value_size(21, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.name_loctoken.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(v) = self.x_pos {
            os.write_float(6, v)?;
        }
        if let Some(v) = self.y_pos {
            os.write_float(7, v)?;
        }
        if let Some(ref v) = self.condition.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.owning_region.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.quest_options {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.associated_operation.as_ref() {
            os.write_string(16, &v)?;
        }
        if let Some(ref v) = self.reward_item_name.as_ref() {
            os.write_string(18, &v)?;
        }
        if let Some(ref v) = self.reward_lootlist_name.as_ref() {
            os.write_string(22, &v)?;
        }
        if let Some(v) = self.cash_reward {
            os.write_enum(19, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.star_type.as_ref() {
            os.write_tag(20, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.stars_to_unlock {
            os.write_uint32(21, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgQuestMapNodeDef {
        CMsgQuestMapNodeDef::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgProtoDefHeader>>(
                "header",
                |m: &CMsgQuestMapNodeDef| { &m.header },
                |m: &mut CMsgQuestMapNodeDef| { &mut m.header },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name_loctoken",
                |m: &CMsgQuestMapNodeDef| { &m.name_loctoken },
                |m: &mut CMsgQuestMapNodeDef| { &mut m.name_loctoken },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "x_pos",
                |m: &CMsgQuestMapNodeDef| { &m.x_pos },
                |m: &mut CMsgQuestMapNodeDef| { &mut m.x_pos },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "y_pos",
                |m: &CMsgQuestMapNodeDef| { &m.y_pos },
                |m: &mut CMsgQuestMapNodeDef| { &mut m.y_pos },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgQuestMapNodeCondition>>(
                "condition",
                |m: &CMsgQuestMapNodeDef| { &m.condition },
                |m: &mut CMsgQuestMapNodeDef| { &mut m.condition },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgProtoDefID>>(
                "owning_region",
                |m: &CMsgQuestMapNodeDef| { &m.owning_region },
                |m: &mut CMsgQuestMapNodeDef| { &mut m.owning_region },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgProtoDefID>>(
                "quest_options",
                |m: &CMsgQuestMapNodeDef| { &m.quest_options },
                |m: &mut CMsgQuestMapNodeDef| { &mut m.quest_options },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "associated_operation",
                |m: &CMsgQuestMapNodeDef| { &m.associated_operation },
                |m: &mut CMsgQuestMapNodeDef| { &mut m.associated_operation },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "reward_item_name",
                |m: &CMsgQuestMapNodeDef| { &m.reward_item_name },
                |m: &mut CMsgQuestMapNodeDef| { &mut m.reward_item_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "reward_lootlist_name",
                |m: &CMsgQuestMapNodeDef| { &m.reward_lootlist_name },
                |m: &mut CMsgQuestMapNodeDef| { &mut m.reward_lootlist_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ENodeCashReward>>(
                "cash_reward",
                |m: &CMsgQuestMapNodeDef| { &m.cash_reward },
                |m: &mut CMsgQuestMapNodeDef| { &mut m.cash_reward },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgProtoDefID>>(
                "star_type",
                |m: &CMsgQuestMapNodeDef| { &m.star_type },
                |m: &mut CMsgQuestMapNodeDef| { &mut m.star_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "stars_to_unlock",
                |m: &CMsgQuestMapNodeDef| { &m.stars_to_unlock },
                |m: &mut CMsgQuestMapNodeDef| { &mut m.stars_to_unlock },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgQuestMapNodeDef>(
                "CMsgQuestMapNodeDef",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgQuestMapNodeDef {
        static instance: ::protobuf::rt::LazyV2<CMsgQuestMapNodeDef> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgQuestMapNodeDef::new)
    }
}

impl ::protobuf::Clear for CMsgQuestMapNodeDef {
    fn clear(&mut self) {
        self.header.clear();
        self.name_loctoken.clear();
        self.x_pos = ::std::option::Option::None;
        self.y_pos = ::std::option::Option::None;
        self.condition.clear();
        self.owning_region.clear();
        self.quest_options.clear();
        self.associated_operation.clear();
        self.reward_item_name.clear();
        self.reward_lootlist_name.clear();
        self.cash_reward = ::std::option::Option::None;
        self.star_type.clear();
        self.stars_to_unlock = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgQuestMapNodeDef {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgQuestMapNodeDef {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgPaintKit_Variables {
    // message fields
    pub header: ::protobuf::SingularPtrField<CMsgProtoDefHeader>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgPaintKit_Variables {
    fn default() -> &'a CMsgPaintKit_Variables {
        <CMsgPaintKit_Variables as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPaintKit_Variables {
    pub fn new() -> CMsgPaintKit_Variables {
        ::std::default::Default::default()
    }

    // required .CMsgProtoDefHeader header = 1;


    pub fn get_header(&self) -> &CMsgProtoDefHeader {
        self.header.as_ref().unwrap_or_else(|| <CMsgProtoDefHeader as ::protobuf::Message>::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: CMsgProtoDefHeader) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut CMsgProtoDefHeader {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> CMsgProtoDefHeader {
        self.header.take().unwrap_or_else(|| CMsgProtoDefHeader::new())
    }
}

impl ::protobuf::Message for CMsgPaintKit_Variables {
    fn is_initialized(&self) -> bool {
        if self.header.is_none() {
            return false;
        }
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgPaintKit_Variables {
        CMsgPaintKit_Variables::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgProtoDefHeader>>(
                "header",
                |m: &CMsgPaintKit_Variables| { &m.header },
                |m: &mut CMsgPaintKit_Variables| { &mut m.header },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgPaintKit_Variables>(
                "CMsgPaintKit_Variables",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgPaintKit_Variables {
        static instance: ::protobuf::rt::LazyV2<CMsgPaintKit_Variables> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgPaintKit_Variables::new)
    }
}

impl ::protobuf::Clear for CMsgPaintKit_Variables {
    fn clear(&mut self) {
        self.header.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgPaintKit_Variables {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPaintKit_Variables {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgPaintKit_Operation_TextureStage {
    // message fields
    pub texture: ::protobuf::SingularPtrField<CMsgVarField>,
    pub texture_red: ::protobuf::SingularPtrField<CMsgVarField>,
    pub texture_blue: ::protobuf::SingularPtrField<CMsgVarField>,
    pub adjust_black: ::protobuf::SingularPtrField<CMsgVarField>,
    pub adjust_offset: ::protobuf::SingularPtrField<CMsgVarField>,
    pub adjust_gamma: ::protobuf::SingularPtrField<CMsgVarField>,
    pub rotation: ::protobuf::SingularPtrField<CMsgVarField>,
    pub translate_u: ::protobuf::SingularPtrField<CMsgVarField>,
    pub translate_v: ::protobuf::SingularPtrField<CMsgVarField>,
    pub scale_uv: ::protobuf::SingularPtrField<CMsgVarField>,
    pub flip_u: ::protobuf::SingularPtrField<CMsgVarField>,
    pub flip_v: ::protobuf::SingularPtrField<CMsgVarField>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgPaintKit_Operation_TextureStage {
    fn default() -> &'a CMsgPaintKit_Operation_TextureStage {
        <CMsgPaintKit_Operation_TextureStage as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPaintKit_Operation_TextureStage {
    pub fn new() -> CMsgPaintKit_Operation_TextureStage {
        ::std::default::Default::default()
    }

    // optional .CMsgVarField texture = 1;


    pub fn get_texture(&self) -> &CMsgVarField {
        self.texture.as_ref().unwrap_or_else(|| <CMsgVarField as ::protobuf::Message>::default_instance())
    }
    pub fn clear_texture(&mut self) {
        self.texture.clear();
    }

    pub fn has_texture(&self) -> bool {
        self.texture.is_some()
    }

    // Param is passed by value, moved
    pub fn set_texture(&mut self, v: CMsgVarField) {
        self.texture = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_texture(&mut self) -> &mut CMsgVarField {
        if self.texture.is_none() {
            self.texture.set_default();
        }
        self.texture.as_mut().unwrap()
    }

    // Take field
    pub fn take_texture(&mut self) -> CMsgVarField {
        self.texture.take().unwrap_or_else(|| CMsgVarField::new())
    }

    // optional .CMsgVarField texture_red = 2;


    pub fn get_texture_red(&self) -> &CMsgVarField {
        self.texture_red.as_ref().unwrap_or_else(|| <CMsgVarField as ::protobuf::Message>::default_instance())
    }
    pub fn clear_texture_red(&mut self) {
        self.texture_red.clear();
    }

    pub fn has_texture_red(&self) -> bool {
        self.texture_red.is_some()
    }

    // Param is passed by value, moved
    pub fn set_texture_red(&mut self, v: CMsgVarField) {
        self.texture_red = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_texture_red(&mut self) -> &mut CMsgVarField {
        if self.texture_red.is_none() {
            self.texture_red.set_default();
        }
        self.texture_red.as_mut().unwrap()
    }

    // Take field
    pub fn take_texture_red(&mut self) -> CMsgVarField {
        self.texture_red.take().unwrap_or_else(|| CMsgVarField::new())
    }

    // optional .CMsgVarField texture_blue = 3;


    pub fn get_texture_blue(&self) -> &CMsgVarField {
        self.texture_blue.as_ref().unwrap_or_else(|| <CMsgVarField as ::protobuf::Message>::default_instance())
    }
    pub fn clear_texture_blue(&mut self) {
        self.texture_blue.clear();
    }

    pub fn has_texture_blue(&self) -> bool {
        self.texture_blue.is_some()
    }

    // Param is passed by value, moved
    pub fn set_texture_blue(&mut self, v: CMsgVarField) {
        self.texture_blue = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_texture_blue(&mut self) -> &mut CMsgVarField {
        if self.texture_blue.is_none() {
            self.texture_blue.set_default();
        }
        self.texture_blue.as_mut().unwrap()
    }

    // Take field
    pub fn take_texture_blue(&mut self) -> CMsgVarField {
        self.texture_blue.take().unwrap_or_else(|| CMsgVarField::new())
    }

    // optional .CMsgVarField adjust_black = 4;


    pub fn get_adjust_black(&self) -> &CMsgVarField {
        self.adjust_black.as_ref().unwrap_or_else(|| <CMsgVarField as ::protobuf::Message>::default_instance())
    }
    pub fn clear_adjust_black(&mut self) {
        self.adjust_black.clear();
    }

    pub fn has_adjust_black(&self) -> bool {
        self.adjust_black.is_some()
    }

    // Param is passed by value, moved
    pub fn set_adjust_black(&mut self, v: CMsgVarField) {
        self.adjust_black = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_adjust_black(&mut self) -> &mut CMsgVarField {
        if self.adjust_black.is_none() {
            self.adjust_black.set_default();
        }
        self.adjust_black.as_mut().unwrap()
    }

    // Take field
    pub fn take_adjust_black(&mut self) -> CMsgVarField {
        self.adjust_black.take().unwrap_or_else(|| CMsgVarField::new())
    }

    // optional .CMsgVarField adjust_offset = 5;


    pub fn get_adjust_offset(&self) -> &CMsgVarField {
        self.adjust_offset.as_ref().unwrap_or_else(|| <CMsgVarField as ::protobuf::Message>::default_instance())
    }
    pub fn clear_adjust_offset(&mut self) {
        self.adjust_offset.clear();
    }

    pub fn has_adjust_offset(&self) -> bool {
        self.adjust_offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_adjust_offset(&mut self, v: CMsgVarField) {
        self.adjust_offset = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_adjust_offset(&mut self) -> &mut CMsgVarField {
        if self.adjust_offset.is_none() {
            self.adjust_offset.set_default();
        }
        self.adjust_offset.as_mut().unwrap()
    }

    // Take field
    pub fn take_adjust_offset(&mut self) -> CMsgVarField {
        self.adjust_offset.take().unwrap_or_else(|| CMsgVarField::new())
    }

    // optional .CMsgVarField adjust_gamma = 6;


    pub fn get_adjust_gamma(&self) -> &CMsgVarField {
        self.adjust_gamma.as_ref().unwrap_or_else(|| <CMsgVarField as ::protobuf::Message>::default_instance())
    }
    pub fn clear_adjust_gamma(&mut self) {
        self.adjust_gamma.clear();
    }

    pub fn has_adjust_gamma(&self) -> bool {
        self.adjust_gamma.is_some()
    }

    // Param is passed by value, moved
    pub fn set_adjust_gamma(&mut self, v: CMsgVarField) {
        self.adjust_gamma = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_adjust_gamma(&mut self) -> &mut CMsgVarField {
        if self.adjust_gamma.is_none() {
            self.adjust_gamma.set_default();
        }
        self.adjust_gamma.as_mut().unwrap()
    }

    // Take field
    pub fn take_adjust_gamma(&mut self) -> CMsgVarField {
        self.adjust_gamma.take().unwrap_or_else(|| CMsgVarField::new())
    }

    // optional .CMsgVarField rotation = 7;


    pub fn get_rotation(&self) -> &CMsgVarField {
        self.rotation.as_ref().unwrap_or_else(|| <CMsgVarField as ::protobuf::Message>::default_instance())
    }
    pub fn clear_rotation(&mut self) {
        self.rotation.clear();
    }

    pub fn has_rotation(&self) -> bool {
        self.rotation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rotation(&mut self, v: CMsgVarField) {
        self.rotation = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rotation(&mut self) -> &mut CMsgVarField {
        if self.rotation.is_none() {
            self.rotation.set_default();
        }
        self.rotation.as_mut().unwrap()
    }

    // Take field
    pub fn take_rotation(&mut self) -> CMsgVarField {
        self.rotation.take().unwrap_or_else(|| CMsgVarField::new())
    }

    // optional .CMsgVarField translate_u = 8;


    pub fn get_translate_u(&self) -> &CMsgVarField {
        self.translate_u.as_ref().unwrap_or_else(|| <CMsgVarField as ::protobuf::Message>::default_instance())
    }
    pub fn clear_translate_u(&mut self) {
        self.translate_u.clear();
    }

    pub fn has_translate_u(&self) -> bool {
        self.translate_u.is_some()
    }

    // Param is passed by value, moved
    pub fn set_translate_u(&mut self, v: CMsgVarField) {
        self.translate_u = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_translate_u(&mut self) -> &mut CMsgVarField {
        if self.translate_u.is_none() {
            self.translate_u.set_default();
        }
        self.translate_u.as_mut().unwrap()
    }

    // Take field
    pub fn take_translate_u(&mut self) -> CMsgVarField {
        self.translate_u.take().unwrap_or_else(|| CMsgVarField::new())
    }

    // optional .CMsgVarField translate_v = 9;


    pub fn get_translate_v(&self) -> &CMsgVarField {
        self.translate_v.as_ref().unwrap_or_else(|| <CMsgVarField as ::protobuf::Message>::default_instance())
    }
    pub fn clear_translate_v(&mut self) {
        self.translate_v.clear();
    }

    pub fn has_translate_v(&self) -> bool {
        self.translate_v.is_some()
    }

    // Param is passed by value, moved
    pub fn set_translate_v(&mut self, v: CMsgVarField) {
        self.translate_v = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_translate_v(&mut self) -> &mut CMsgVarField {
        if self.translate_v.is_none() {
            self.translate_v.set_default();
        }
        self.translate_v.as_mut().unwrap()
    }

    // Take field
    pub fn take_translate_v(&mut self) -> CMsgVarField {
        self.translate_v.take().unwrap_or_else(|| CMsgVarField::new())
    }

    // optional .CMsgVarField scale_uv = 10;


    pub fn get_scale_uv(&self) -> &CMsgVarField {
        self.scale_uv.as_ref().unwrap_or_else(|| <CMsgVarField as ::protobuf::Message>::default_instance())
    }
    pub fn clear_scale_uv(&mut self) {
        self.scale_uv.clear();
    }

    pub fn has_scale_uv(&self) -> bool {
        self.scale_uv.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scale_uv(&mut self, v: CMsgVarField) {
        self.scale_uv = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_scale_uv(&mut self) -> &mut CMsgVarField {
        if self.scale_uv.is_none() {
            self.scale_uv.set_default();
        }
        self.scale_uv.as_mut().unwrap()
    }

    // Take field
    pub fn take_scale_uv(&mut self) -> CMsgVarField {
        self.scale_uv.take().unwrap_or_else(|| CMsgVarField::new())
    }

    // optional .CMsgVarField flip_u = 11;


    pub fn get_flip_u(&self) -> &CMsgVarField {
        self.flip_u.as_ref().unwrap_or_else(|| <CMsgVarField as ::protobuf::Message>::default_instance())
    }
    pub fn clear_flip_u(&mut self) {
        self.flip_u.clear();
    }

    pub fn has_flip_u(&self) -> bool {
        self.flip_u.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flip_u(&mut self, v: CMsgVarField) {
        self.flip_u = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_flip_u(&mut self) -> &mut CMsgVarField {
        if self.flip_u.is_none() {
            self.flip_u.set_default();
        }
        self.flip_u.as_mut().unwrap()
    }

    // Take field
    pub fn take_flip_u(&mut self) -> CMsgVarField {
        self.flip_u.take().unwrap_or_else(|| CMsgVarField::new())
    }

    // optional .CMsgVarField flip_v = 12;


    pub fn get_flip_v(&self) -> &CMsgVarField {
        self.flip_v.as_ref().unwrap_or_else(|| <CMsgVarField as ::protobuf::Message>::default_instance())
    }
    pub fn clear_flip_v(&mut self) {
        self.flip_v.clear();
    }

    pub fn has_flip_v(&self) -> bool {
        self.flip_v.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flip_v(&mut self, v: CMsgVarField) {
        self.flip_v = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_flip_v(&mut self) -> &mut CMsgVarField {
        if self.flip_v.is_none() {
            self.flip_v.set_default();
        }
        self.flip_v.as_mut().unwrap()
    }

    // Take field
    pub fn take_flip_v(&mut self) -> CMsgVarField {
        self.flip_v.take().unwrap_or_else(|| CMsgVarField::new())
    }
}

impl ::protobuf::Message for CMsgPaintKit_Operation_TextureStage {
    fn is_initialized(&self) -> bool {
        for v in &self.texture {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.texture_red {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.texture_blue {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.adjust_black {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.adjust_offset {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.adjust_gamma {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.rotation {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.translate_u {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.translate_v {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.scale_uv {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.flip_u {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.flip_v {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.texture)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.texture_red)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.texture_blue)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.adjust_black)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.adjust_offset)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.adjust_gamma)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.rotation)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.translate_u)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.translate_v)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.scale_uv)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.flip_u)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.flip_v)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.texture.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.texture_red.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.texture_blue.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.adjust_black.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.adjust_offset.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.adjust_gamma.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.rotation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.translate_u.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.translate_v.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.scale_uv.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.flip_u.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.flip_v.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.texture.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.texture_red.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.texture_blue.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.adjust_black.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.adjust_offset.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.adjust_gamma.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.rotation.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.translate_u.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.translate_v.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.scale_uv.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.flip_u.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.flip_v.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgPaintKit_Operation_TextureStage {
        CMsgPaintKit_Operation_TextureStage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgVarField>>(
                "texture",
                |m: &CMsgPaintKit_Operation_TextureStage| { &m.texture },
                |m: &mut CMsgPaintKit_Operation_TextureStage| { &mut m.texture },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgVarField>>(
                "texture_red",
                |m: &CMsgPaintKit_Operation_TextureStage| { &m.texture_red },
                |m: &mut CMsgPaintKit_Operation_TextureStage| { &mut m.texture_red },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgVarField>>(
                "texture_blue",
                |m: &CMsgPaintKit_Operation_TextureStage| { &m.texture_blue },
                |m: &mut CMsgPaintKit_Operation_TextureStage| { &mut m.texture_blue },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgVarField>>(
                "adjust_black",
                |m: &CMsgPaintKit_Operation_TextureStage| { &m.adjust_black },
                |m: &mut CMsgPaintKit_Operation_TextureStage| { &mut m.adjust_black },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgVarField>>(
                "adjust_offset",
                |m: &CMsgPaintKit_Operation_TextureStage| { &m.adjust_offset },
                |m: &mut CMsgPaintKit_Operation_TextureStage| { &mut m.adjust_offset },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgVarField>>(
                "adjust_gamma",
                |m: &CMsgPaintKit_Operation_TextureStage| { &m.adjust_gamma },
                |m: &mut CMsgPaintKit_Operation_TextureStage| { &mut m.adjust_gamma },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgVarField>>(
                "rotation",
                |m: &CMsgPaintKit_Operation_TextureStage| { &m.rotation },
                |m: &mut CMsgPaintKit_Operation_TextureStage| { &mut m.rotation },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgVarField>>(
                "translate_u",
                |m: &CMsgPaintKit_Operation_TextureStage| { &m.translate_u },
                |m: &mut CMsgPaintKit_Operation_TextureStage| { &mut m.translate_u },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgVarField>>(
                "translate_v",
                |m: &CMsgPaintKit_Operation_TextureStage| { &m.translate_v },
                |m: &mut CMsgPaintKit_Operation_TextureStage| { &mut m.translate_v },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgVarField>>(
                "scale_uv",
                |m: &CMsgPaintKit_Operation_TextureStage| { &m.scale_uv },
                |m: &mut CMsgPaintKit_Operation_TextureStage| { &mut m.scale_uv },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgVarField>>(
                "flip_u",
                |m: &CMsgPaintKit_Operation_TextureStage| { &m.flip_u },
                |m: &mut CMsgPaintKit_Operation_TextureStage| { &mut m.flip_u },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgVarField>>(
                "flip_v",
                |m: &CMsgPaintKit_Operation_TextureStage| { &m.flip_v },
                |m: &mut CMsgPaintKit_Operation_TextureStage| { &mut m.flip_v },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgPaintKit_Operation_TextureStage>(
                "CMsgPaintKit_Operation_TextureStage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgPaintKit_Operation_TextureStage {
        static instance: ::protobuf::rt::LazyV2<CMsgPaintKit_Operation_TextureStage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgPaintKit_Operation_TextureStage::new)
    }
}

impl ::protobuf::Clear for CMsgPaintKit_Operation_TextureStage {
    fn clear(&mut self) {
        self.texture.clear();
        self.texture_red.clear();
        self.texture_blue.clear();
        self.adjust_black.clear();
        self.adjust_offset.clear();
        self.adjust_gamma.clear();
        self.rotation.clear();
        self.translate_u.clear();
        self.translate_v.clear();
        self.scale_uv.clear();
        self.flip_u.clear();
        self.flip_v.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgPaintKit_Operation_TextureStage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPaintKit_Operation_TextureStage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgPaintKit_Operation_CombineStage {
    // message fields
    pub adjust_black: ::protobuf::SingularPtrField<CMsgVarField>,
    pub adjust_offset: ::protobuf::SingularPtrField<CMsgVarField>,
    pub adjust_gamma: ::protobuf::SingularPtrField<CMsgVarField>,
    pub rotation: ::protobuf::SingularPtrField<CMsgVarField>,
    pub translate_u: ::protobuf::SingularPtrField<CMsgVarField>,
    pub translate_v: ::protobuf::SingularPtrField<CMsgVarField>,
    pub scale_uv: ::protobuf::SingularPtrField<CMsgVarField>,
    pub flip_u: ::protobuf::SingularPtrField<CMsgVarField>,
    pub flip_v: ::protobuf::SingularPtrField<CMsgVarField>,
    pub operation_node: ::protobuf::RepeatedField<CMsgPaintKit_OperationNode>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgPaintKit_Operation_CombineStage {
    fn default() -> &'a CMsgPaintKit_Operation_CombineStage {
        <CMsgPaintKit_Operation_CombineStage as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPaintKit_Operation_CombineStage {
    pub fn new() -> CMsgPaintKit_Operation_CombineStage {
        ::std::default::Default::default()
    }

    // optional .CMsgVarField adjust_black = 1;


    pub fn get_adjust_black(&self) -> &CMsgVarField {
        self.adjust_black.as_ref().unwrap_or_else(|| <CMsgVarField as ::protobuf::Message>::default_instance())
    }
    pub fn clear_adjust_black(&mut self) {
        self.adjust_black.clear();
    }

    pub fn has_adjust_black(&self) -> bool {
        self.adjust_black.is_some()
    }

    // Param is passed by value, moved
    pub fn set_adjust_black(&mut self, v: CMsgVarField) {
        self.adjust_black = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_adjust_black(&mut self) -> &mut CMsgVarField {
        if self.adjust_black.is_none() {
            self.adjust_black.set_default();
        }
        self.adjust_black.as_mut().unwrap()
    }

    // Take field
    pub fn take_adjust_black(&mut self) -> CMsgVarField {
        self.adjust_black.take().unwrap_or_else(|| CMsgVarField::new())
    }

    // optional .CMsgVarField adjust_offset = 2;


    pub fn get_adjust_offset(&self) -> &CMsgVarField {
        self.adjust_offset.as_ref().unwrap_or_else(|| <CMsgVarField as ::protobuf::Message>::default_instance())
    }
    pub fn clear_adjust_offset(&mut self) {
        self.adjust_offset.clear();
    }

    pub fn has_adjust_offset(&self) -> bool {
        self.adjust_offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_adjust_offset(&mut self, v: CMsgVarField) {
        self.adjust_offset = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_adjust_offset(&mut self) -> &mut CMsgVarField {
        if self.adjust_offset.is_none() {
            self.adjust_offset.set_default();
        }
        self.adjust_offset.as_mut().unwrap()
    }

    // Take field
    pub fn take_adjust_offset(&mut self) -> CMsgVarField {
        self.adjust_offset.take().unwrap_or_else(|| CMsgVarField::new())
    }

    // optional .CMsgVarField adjust_gamma = 3;


    pub fn get_adjust_gamma(&self) -> &CMsgVarField {
        self.adjust_gamma.as_ref().unwrap_or_else(|| <CMsgVarField as ::protobuf::Message>::default_instance())
    }
    pub fn clear_adjust_gamma(&mut self) {
        self.adjust_gamma.clear();
    }

    pub fn has_adjust_gamma(&self) -> bool {
        self.adjust_gamma.is_some()
    }

    // Param is passed by value, moved
    pub fn set_adjust_gamma(&mut self, v: CMsgVarField) {
        self.adjust_gamma = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_adjust_gamma(&mut self) -> &mut CMsgVarField {
        if self.adjust_gamma.is_none() {
            self.adjust_gamma.set_default();
        }
        self.adjust_gamma.as_mut().unwrap()
    }

    // Take field
    pub fn take_adjust_gamma(&mut self) -> CMsgVarField {
        self.adjust_gamma.take().unwrap_or_else(|| CMsgVarField::new())
    }

    // optional .CMsgVarField rotation = 4;


    pub fn get_rotation(&self) -> &CMsgVarField {
        self.rotation.as_ref().unwrap_or_else(|| <CMsgVarField as ::protobuf::Message>::default_instance())
    }
    pub fn clear_rotation(&mut self) {
        self.rotation.clear();
    }

    pub fn has_rotation(&self) -> bool {
        self.rotation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rotation(&mut self, v: CMsgVarField) {
        self.rotation = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rotation(&mut self) -> &mut CMsgVarField {
        if self.rotation.is_none() {
            self.rotation.set_default();
        }
        self.rotation.as_mut().unwrap()
    }

    // Take field
    pub fn take_rotation(&mut self) -> CMsgVarField {
        self.rotation.take().unwrap_or_else(|| CMsgVarField::new())
    }

    // optional .CMsgVarField translate_u = 5;


    pub fn get_translate_u(&self) -> &CMsgVarField {
        self.translate_u.as_ref().unwrap_or_else(|| <CMsgVarField as ::protobuf::Message>::default_instance())
    }
    pub fn clear_translate_u(&mut self) {
        self.translate_u.clear();
    }

    pub fn has_translate_u(&self) -> bool {
        self.translate_u.is_some()
    }

    // Param is passed by value, moved
    pub fn set_translate_u(&mut self, v: CMsgVarField) {
        self.translate_u = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_translate_u(&mut self) -> &mut CMsgVarField {
        if self.translate_u.is_none() {
            self.translate_u.set_default();
        }
        self.translate_u.as_mut().unwrap()
    }

    // Take field
    pub fn take_translate_u(&mut self) -> CMsgVarField {
        self.translate_u.take().unwrap_or_else(|| CMsgVarField::new())
    }

    // optional .CMsgVarField translate_v = 6;


    pub fn get_translate_v(&self) -> &CMsgVarField {
        self.translate_v.as_ref().unwrap_or_else(|| <CMsgVarField as ::protobuf::Message>::default_instance())
    }
    pub fn clear_translate_v(&mut self) {
        self.translate_v.clear();
    }

    pub fn has_translate_v(&self) -> bool {
        self.translate_v.is_some()
    }

    // Param is passed by value, moved
    pub fn set_translate_v(&mut self, v: CMsgVarField) {
        self.translate_v = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_translate_v(&mut self) -> &mut CMsgVarField {
        if self.translate_v.is_none() {
            self.translate_v.set_default();
        }
        self.translate_v.as_mut().unwrap()
    }

    // Take field
    pub fn take_translate_v(&mut self) -> CMsgVarField {
        self.translate_v.take().unwrap_or_else(|| CMsgVarField::new())
    }

    // optional .CMsgVarField scale_uv = 7;


    pub fn get_scale_uv(&self) -> &CMsgVarField {
        self.scale_uv.as_ref().unwrap_or_else(|| <CMsgVarField as ::protobuf::Message>::default_instance())
    }
    pub fn clear_scale_uv(&mut self) {
        self.scale_uv.clear();
    }

    pub fn has_scale_uv(&self) -> bool {
        self.scale_uv.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scale_uv(&mut self, v: CMsgVarField) {
        self.scale_uv = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_scale_uv(&mut self) -> &mut CMsgVarField {
        if self.scale_uv.is_none() {
            self.scale_uv.set_default();
        }
        self.scale_uv.as_mut().unwrap()
    }

    // Take field
    pub fn take_scale_uv(&mut self) -> CMsgVarField {
        self.scale_uv.take().unwrap_or_else(|| CMsgVarField::new())
    }

    // optional .CMsgVarField flip_u = 8;


    pub fn get_flip_u(&self) -> &CMsgVarField {
        self.flip_u.as_ref().unwrap_or_else(|| <CMsgVarField as ::protobuf::Message>::default_instance())
    }
    pub fn clear_flip_u(&mut self) {
        self.flip_u.clear();
    }

    pub fn has_flip_u(&self) -> bool {
        self.flip_u.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flip_u(&mut self, v: CMsgVarField) {
        self.flip_u = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_flip_u(&mut self) -> &mut CMsgVarField {
        if self.flip_u.is_none() {
            self.flip_u.set_default();
        }
        self.flip_u.as_mut().unwrap()
    }

    // Take field
    pub fn take_flip_u(&mut self) -> CMsgVarField {
        self.flip_u.take().unwrap_or_else(|| CMsgVarField::new())
    }

    // optional .CMsgVarField flip_v = 9;


    pub fn get_flip_v(&self) -> &CMsgVarField {
        self.flip_v.as_ref().unwrap_or_else(|| <CMsgVarField as ::protobuf::Message>::default_instance())
    }
    pub fn clear_flip_v(&mut self) {
        self.flip_v.clear();
    }

    pub fn has_flip_v(&self) -> bool {
        self.flip_v.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flip_v(&mut self, v: CMsgVarField) {
        self.flip_v = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_flip_v(&mut self) -> &mut CMsgVarField {
        if self.flip_v.is_none() {
            self.flip_v.set_default();
        }
        self.flip_v.as_mut().unwrap()
    }

    // Take field
    pub fn take_flip_v(&mut self) -> CMsgVarField {
        self.flip_v.take().unwrap_or_else(|| CMsgVarField::new())
    }

    // repeated .CMsgPaintKit_OperationNode operation_node = 11;


    pub fn get_operation_node(&self) -> &[CMsgPaintKit_OperationNode] {
        &self.operation_node
    }
    pub fn clear_operation_node(&mut self) {
        self.operation_node.clear();
    }

    // Param is passed by value, moved
    pub fn set_operation_node(&mut self, v: ::protobuf::RepeatedField<CMsgPaintKit_OperationNode>) {
        self.operation_node = v;
    }

    // Mutable pointer to the field.
    pub fn mut_operation_node(&mut self) -> &mut ::protobuf::RepeatedField<CMsgPaintKit_OperationNode> {
        &mut self.operation_node
    }

    // Take field
    pub fn take_operation_node(&mut self) -> ::protobuf::RepeatedField<CMsgPaintKit_OperationNode> {
        ::std::mem::replace(&mut self.operation_node, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgPaintKit_Operation_CombineStage {
    fn is_initialized(&self) -> bool {
        for v in &self.adjust_black {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.adjust_offset {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.adjust_gamma {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.rotation {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.translate_u {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.translate_v {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.scale_uv {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.flip_u {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.flip_v {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.operation_node {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.adjust_black)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.adjust_offset)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.adjust_gamma)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.rotation)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.translate_u)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.translate_v)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.scale_uv)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.flip_u)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.flip_v)?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.operation_node)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.adjust_black.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.adjust_offset.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.adjust_gamma.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.rotation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.translate_u.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.translate_v.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.scale_uv.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.flip_u.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.flip_v.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.operation_node {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.adjust_black.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.adjust_offset.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.adjust_gamma.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.rotation.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.translate_u.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.translate_v.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.scale_uv.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.flip_u.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.flip_v.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.operation_node {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgPaintKit_Operation_CombineStage {
        CMsgPaintKit_Operation_CombineStage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgVarField>>(
                "adjust_black",
                |m: &CMsgPaintKit_Operation_CombineStage| { &m.adjust_black },
                |m: &mut CMsgPaintKit_Operation_CombineStage| { &mut m.adjust_black },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgVarField>>(
                "adjust_offset",
                |m: &CMsgPaintKit_Operation_CombineStage| { &m.adjust_offset },
                |m: &mut CMsgPaintKit_Operation_CombineStage| { &mut m.adjust_offset },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgVarField>>(
                "adjust_gamma",
                |m: &CMsgPaintKit_Operation_CombineStage| { &m.adjust_gamma },
                |m: &mut CMsgPaintKit_Operation_CombineStage| { &mut m.adjust_gamma },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgVarField>>(
                "rotation",
                |m: &CMsgPaintKit_Operation_CombineStage| { &m.rotation },
                |m: &mut CMsgPaintKit_Operation_CombineStage| { &mut m.rotation },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgVarField>>(
                "translate_u",
                |m: &CMsgPaintKit_Operation_CombineStage| { &m.translate_u },
                |m: &mut CMsgPaintKit_Operation_CombineStage| { &mut m.translate_u },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgVarField>>(
                "translate_v",
                |m: &CMsgPaintKit_Operation_CombineStage| { &m.translate_v },
                |m: &mut CMsgPaintKit_Operation_CombineStage| { &mut m.translate_v },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgVarField>>(
                "scale_uv",
                |m: &CMsgPaintKit_Operation_CombineStage| { &m.scale_uv },
                |m: &mut CMsgPaintKit_Operation_CombineStage| { &mut m.scale_uv },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgVarField>>(
                "flip_u",
                |m: &CMsgPaintKit_Operation_CombineStage| { &m.flip_u },
                |m: &mut CMsgPaintKit_Operation_CombineStage| { &mut m.flip_u },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgVarField>>(
                "flip_v",
                |m: &CMsgPaintKit_Operation_CombineStage| { &m.flip_v },
                |m: &mut CMsgPaintKit_Operation_CombineStage| { &mut m.flip_v },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgPaintKit_OperationNode>>(
                "operation_node",
                |m: &CMsgPaintKit_Operation_CombineStage| { &m.operation_node },
                |m: &mut CMsgPaintKit_Operation_CombineStage| { &mut m.operation_node },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgPaintKit_Operation_CombineStage>(
                "CMsgPaintKit_Operation_CombineStage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgPaintKit_Operation_CombineStage {
        static instance: ::protobuf::rt::LazyV2<CMsgPaintKit_Operation_CombineStage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgPaintKit_Operation_CombineStage::new)
    }
}

impl ::protobuf::Clear for CMsgPaintKit_Operation_CombineStage {
    fn clear(&mut self) {
        self.adjust_black.clear();
        self.adjust_offset.clear();
        self.adjust_gamma.clear();
        self.rotation.clear();
        self.translate_u.clear();
        self.translate_v.clear();
        self.scale_uv.clear();
        self.flip_u.clear();
        self.flip_v.clear();
        self.operation_node.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgPaintKit_Operation_CombineStage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPaintKit_Operation_CombineStage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgPaintKit_Operation_SelectStage {
    // message fields
    pub groups: ::protobuf::SingularPtrField<CMsgVarField>,
    pub select: ::protobuf::RepeatedField<CMsgVarField>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgPaintKit_Operation_SelectStage {
    fn default() -> &'a CMsgPaintKit_Operation_SelectStage {
        <CMsgPaintKit_Operation_SelectStage as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPaintKit_Operation_SelectStage {
    pub fn new() -> CMsgPaintKit_Operation_SelectStage {
        ::std::default::Default::default()
    }

    // optional .CMsgVarField groups = 1;


    pub fn get_groups(&self) -> &CMsgVarField {
        self.groups.as_ref().unwrap_or_else(|| <CMsgVarField as ::protobuf::Message>::default_instance())
    }
    pub fn clear_groups(&mut self) {
        self.groups.clear();
    }

    pub fn has_groups(&self) -> bool {
        self.groups.is_some()
    }

    // Param is passed by value, moved
    pub fn set_groups(&mut self, v: CMsgVarField) {
        self.groups = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_groups(&mut self) -> &mut CMsgVarField {
        if self.groups.is_none() {
            self.groups.set_default();
        }
        self.groups.as_mut().unwrap()
    }

    // Take field
    pub fn take_groups(&mut self) -> CMsgVarField {
        self.groups.take().unwrap_or_else(|| CMsgVarField::new())
    }

    // repeated .CMsgVarField select = 2;


    pub fn get_select(&self) -> &[CMsgVarField] {
        &self.select
    }
    pub fn clear_select(&mut self) {
        self.select.clear();
    }

    // Param is passed by value, moved
    pub fn set_select(&mut self, v: ::protobuf::RepeatedField<CMsgVarField>) {
        self.select = v;
    }

    // Mutable pointer to the field.
    pub fn mut_select(&mut self) -> &mut ::protobuf::RepeatedField<CMsgVarField> {
        &mut self.select
    }

    // Take field
    pub fn take_select(&mut self) -> ::protobuf::RepeatedField<CMsgVarField> {
        ::std::mem::replace(&mut self.select, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgPaintKit_Operation_SelectStage {
    fn is_initialized(&self) -> bool {
        for v in &self.groups {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.select {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.groups)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.select)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.groups.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.select {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.groups.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.select {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgPaintKit_Operation_SelectStage {
        CMsgPaintKit_Operation_SelectStage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgVarField>>(
                "groups",
                |m: &CMsgPaintKit_Operation_SelectStage| { &m.groups },
                |m: &mut CMsgPaintKit_Operation_SelectStage| { &mut m.groups },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgVarField>>(
                "select",
                |m: &CMsgPaintKit_Operation_SelectStage| { &m.select },
                |m: &mut CMsgPaintKit_Operation_SelectStage| { &mut m.select },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgPaintKit_Operation_SelectStage>(
                "CMsgPaintKit_Operation_SelectStage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgPaintKit_Operation_SelectStage {
        static instance: ::protobuf::rt::LazyV2<CMsgPaintKit_Operation_SelectStage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgPaintKit_Operation_SelectStage::new)
    }
}

impl ::protobuf::Clear for CMsgPaintKit_Operation_SelectStage {
    fn clear(&mut self) {
        self.groups.clear();
        self.select.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgPaintKit_Operation_SelectStage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPaintKit_Operation_SelectStage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgPaintKit_Operation_Sticker {
    // message fields
    pub base: ::protobuf::SingularPtrField<CMsgVarField>,
    pub weight: ::protobuf::SingularPtrField<CMsgVarField>,
    pub spec: ::protobuf::SingularPtrField<CMsgVarField>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgPaintKit_Operation_Sticker {
    fn default() -> &'a CMsgPaintKit_Operation_Sticker {
        <CMsgPaintKit_Operation_Sticker as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPaintKit_Operation_Sticker {
    pub fn new() -> CMsgPaintKit_Operation_Sticker {
        ::std::default::Default::default()
    }

    // optional .CMsgVarField base = 1;


    pub fn get_base(&self) -> &CMsgVarField {
        self.base.as_ref().unwrap_or_else(|| <CMsgVarField as ::protobuf::Message>::default_instance())
    }
    pub fn clear_base(&mut self) {
        self.base.clear();
    }

    pub fn has_base(&self) -> bool {
        self.base.is_some()
    }

    // Param is passed by value, moved
    pub fn set_base(&mut self, v: CMsgVarField) {
        self.base = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_base(&mut self) -> &mut CMsgVarField {
        if self.base.is_none() {
            self.base.set_default();
        }
        self.base.as_mut().unwrap()
    }

    // Take field
    pub fn take_base(&mut self) -> CMsgVarField {
        self.base.take().unwrap_or_else(|| CMsgVarField::new())
    }

    // optional .CMsgVarField weight = 2;


    pub fn get_weight(&self) -> &CMsgVarField {
        self.weight.as_ref().unwrap_or_else(|| <CMsgVarField as ::protobuf::Message>::default_instance())
    }
    pub fn clear_weight(&mut self) {
        self.weight.clear();
    }

    pub fn has_weight(&self) -> bool {
        self.weight.is_some()
    }

    // Param is passed by value, moved
    pub fn set_weight(&mut self, v: CMsgVarField) {
        self.weight = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_weight(&mut self) -> &mut CMsgVarField {
        if self.weight.is_none() {
            self.weight.set_default();
        }
        self.weight.as_mut().unwrap()
    }

    // Take field
    pub fn take_weight(&mut self) -> CMsgVarField {
        self.weight.take().unwrap_or_else(|| CMsgVarField::new())
    }

    // optional .CMsgVarField spec = 3;


    pub fn get_spec(&self) -> &CMsgVarField {
        self.spec.as_ref().unwrap_or_else(|| <CMsgVarField as ::protobuf::Message>::default_instance())
    }
    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: CMsgVarField) {
        self.spec = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut CMsgVarField {
        if self.spec.is_none() {
            self.spec.set_default();
        }
        self.spec.as_mut().unwrap()
    }

    // Take field
    pub fn take_spec(&mut self) -> CMsgVarField {
        self.spec.take().unwrap_or_else(|| CMsgVarField::new())
    }
}

impl ::protobuf::Message for CMsgPaintKit_Operation_Sticker {
    fn is_initialized(&self) -> bool {
        for v in &self.base {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.weight {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.spec {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.base)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.weight)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.spec)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.base.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.weight.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.base.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.weight.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.spec.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgPaintKit_Operation_Sticker {
        CMsgPaintKit_Operation_Sticker::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgVarField>>(
                "base",
                |m: &CMsgPaintKit_Operation_Sticker| { &m.base },
                |m: &mut CMsgPaintKit_Operation_Sticker| { &mut m.base },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgVarField>>(
                "weight",
                |m: &CMsgPaintKit_Operation_Sticker| { &m.weight },
                |m: &mut CMsgPaintKit_Operation_Sticker| { &mut m.weight },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgVarField>>(
                "spec",
                |m: &CMsgPaintKit_Operation_Sticker| { &m.spec },
                |m: &mut CMsgPaintKit_Operation_Sticker| { &mut m.spec },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgPaintKit_Operation_Sticker>(
                "CMsgPaintKit_Operation_Sticker",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgPaintKit_Operation_Sticker {
        static instance: ::protobuf::rt::LazyV2<CMsgPaintKit_Operation_Sticker> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgPaintKit_Operation_Sticker::new)
    }
}

impl ::protobuf::Clear for CMsgPaintKit_Operation_Sticker {
    fn clear(&mut self) {
        self.base.clear();
        self.weight.clear();
        self.spec.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgPaintKit_Operation_Sticker {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPaintKit_Operation_Sticker {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgPaintKit_Operation_StickerStage {
    // message fields
    pub sticker: ::protobuf::RepeatedField<CMsgPaintKit_Operation_Sticker>,
    pub dest_tl: ::protobuf::SingularPtrField<CMsgVarField>,
    pub dest_tr: ::protobuf::SingularPtrField<CMsgVarField>,
    pub dest_bl: ::protobuf::SingularPtrField<CMsgVarField>,
    pub adjust_black: ::protobuf::SingularPtrField<CMsgVarField>,
    pub adjust_offset: ::protobuf::SingularPtrField<CMsgVarField>,
    pub adjust_gamma: ::protobuf::SingularPtrField<CMsgVarField>,
    pub operation_node: ::protobuf::RepeatedField<CMsgPaintKit_OperationNode>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgPaintKit_Operation_StickerStage {
    fn default() -> &'a CMsgPaintKit_Operation_StickerStage {
        <CMsgPaintKit_Operation_StickerStage as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPaintKit_Operation_StickerStage {
    pub fn new() -> CMsgPaintKit_Operation_StickerStage {
        ::std::default::Default::default()
    }

    // repeated .CMsgPaintKit_Operation_Sticker sticker = 1;


    pub fn get_sticker(&self) -> &[CMsgPaintKit_Operation_Sticker] {
        &self.sticker
    }
    pub fn clear_sticker(&mut self) {
        self.sticker.clear();
    }

    // Param is passed by value, moved
    pub fn set_sticker(&mut self, v: ::protobuf::RepeatedField<CMsgPaintKit_Operation_Sticker>) {
        self.sticker = v;
    }

    // Mutable pointer to the field.
    pub fn mut_sticker(&mut self) -> &mut ::protobuf::RepeatedField<CMsgPaintKit_Operation_Sticker> {
        &mut self.sticker
    }

    // Take field
    pub fn take_sticker(&mut self) -> ::protobuf::RepeatedField<CMsgPaintKit_Operation_Sticker> {
        ::std::mem::replace(&mut self.sticker, ::protobuf::RepeatedField::new())
    }

    // optional .CMsgVarField dest_tl = 2;


    pub fn get_dest_tl(&self) -> &CMsgVarField {
        self.dest_tl.as_ref().unwrap_or_else(|| <CMsgVarField as ::protobuf::Message>::default_instance())
    }
    pub fn clear_dest_tl(&mut self) {
        self.dest_tl.clear();
    }

    pub fn has_dest_tl(&self) -> bool {
        self.dest_tl.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dest_tl(&mut self, v: CMsgVarField) {
        self.dest_tl = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dest_tl(&mut self) -> &mut CMsgVarField {
        if self.dest_tl.is_none() {
            self.dest_tl.set_default();
        }
        self.dest_tl.as_mut().unwrap()
    }

    // Take field
    pub fn take_dest_tl(&mut self) -> CMsgVarField {
        self.dest_tl.take().unwrap_or_else(|| CMsgVarField::new())
    }

    // optional .CMsgVarField dest_tr = 3;


    pub fn get_dest_tr(&self) -> &CMsgVarField {
        self.dest_tr.as_ref().unwrap_or_else(|| <CMsgVarField as ::protobuf::Message>::default_instance())
    }
    pub fn clear_dest_tr(&mut self) {
        self.dest_tr.clear();
    }

    pub fn has_dest_tr(&self) -> bool {
        self.dest_tr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dest_tr(&mut self, v: CMsgVarField) {
        self.dest_tr = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dest_tr(&mut self) -> &mut CMsgVarField {
        if self.dest_tr.is_none() {
            self.dest_tr.set_default();
        }
        self.dest_tr.as_mut().unwrap()
    }

    // Take field
    pub fn take_dest_tr(&mut self) -> CMsgVarField {
        self.dest_tr.take().unwrap_or_else(|| CMsgVarField::new())
    }

    // optional .CMsgVarField dest_bl = 4;


    pub fn get_dest_bl(&self) -> &CMsgVarField {
        self.dest_bl.as_ref().unwrap_or_else(|| <CMsgVarField as ::protobuf::Message>::default_instance())
    }
    pub fn clear_dest_bl(&mut self) {
        self.dest_bl.clear();
    }

    pub fn has_dest_bl(&self) -> bool {
        self.dest_bl.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dest_bl(&mut self, v: CMsgVarField) {
        self.dest_bl = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dest_bl(&mut self) -> &mut CMsgVarField {
        if self.dest_bl.is_none() {
            self.dest_bl.set_default();
        }
        self.dest_bl.as_mut().unwrap()
    }

    // Take field
    pub fn take_dest_bl(&mut self) -> CMsgVarField {
        self.dest_bl.take().unwrap_or_else(|| CMsgVarField::new())
    }

    // optional .CMsgVarField adjust_black = 5;


    pub fn get_adjust_black(&self) -> &CMsgVarField {
        self.adjust_black.as_ref().unwrap_or_else(|| <CMsgVarField as ::protobuf::Message>::default_instance())
    }
    pub fn clear_adjust_black(&mut self) {
        self.adjust_black.clear();
    }

    pub fn has_adjust_black(&self) -> bool {
        self.adjust_black.is_some()
    }

    // Param is passed by value, moved
    pub fn set_adjust_black(&mut self, v: CMsgVarField) {
        self.adjust_black = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_adjust_black(&mut self) -> &mut CMsgVarField {
        if self.adjust_black.is_none() {
            self.adjust_black.set_default();
        }
        self.adjust_black.as_mut().unwrap()
    }

    // Take field
    pub fn take_adjust_black(&mut self) -> CMsgVarField {
        self.adjust_black.take().unwrap_or_else(|| CMsgVarField::new())
    }

    // optional .CMsgVarField adjust_offset = 6;


    pub fn get_adjust_offset(&self) -> &CMsgVarField {
        self.adjust_offset.as_ref().unwrap_or_else(|| <CMsgVarField as ::protobuf::Message>::default_instance())
    }
    pub fn clear_adjust_offset(&mut self) {
        self.adjust_offset.clear();
    }

    pub fn has_adjust_offset(&self) -> bool {
        self.adjust_offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_adjust_offset(&mut self, v: CMsgVarField) {
        self.adjust_offset = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_adjust_offset(&mut self) -> &mut CMsgVarField {
        if self.adjust_offset.is_none() {
            self.adjust_offset.set_default();
        }
        self.adjust_offset.as_mut().unwrap()
    }

    // Take field
    pub fn take_adjust_offset(&mut self) -> CMsgVarField {
        self.adjust_offset.take().unwrap_or_else(|| CMsgVarField::new())
    }

    // optional .CMsgVarField adjust_gamma = 7;


    pub fn get_adjust_gamma(&self) -> &CMsgVarField {
        self.adjust_gamma.as_ref().unwrap_or_else(|| <CMsgVarField as ::protobuf::Message>::default_instance())
    }
    pub fn clear_adjust_gamma(&mut self) {
        self.adjust_gamma.clear();
    }

    pub fn has_adjust_gamma(&self) -> bool {
        self.adjust_gamma.is_some()
    }

    // Param is passed by value, moved
    pub fn set_adjust_gamma(&mut self, v: CMsgVarField) {
        self.adjust_gamma = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_adjust_gamma(&mut self) -> &mut CMsgVarField {
        if self.adjust_gamma.is_none() {
            self.adjust_gamma.set_default();
        }
        self.adjust_gamma.as_mut().unwrap()
    }

    // Take field
    pub fn take_adjust_gamma(&mut self) -> CMsgVarField {
        self.adjust_gamma.take().unwrap_or_else(|| CMsgVarField::new())
    }

    // repeated .CMsgPaintKit_OperationNode operation_node = 9;


    pub fn get_operation_node(&self) -> &[CMsgPaintKit_OperationNode] {
        &self.operation_node
    }
    pub fn clear_operation_node(&mut self) {
        self.operation_node.clear();
    }

    // Param is passed by value, moved
    pub fn set_operation_node(&mut self, v: ::protobuf::RepeatedField<CMsgPaintKit_OperationNode>) {
        self.operation_node = v;
    }

    // Mutable pointer to the field.
    pub fn mut_operation_node(&mut self) -> &mut ::protobuf::RepeatedField<CMsgPaintKit_OperationNode> {
        &mut self.operation_node
    }

    // Take field
    pub fn take_operation_node(&mut self) -> ::protobuf::RepeatedField<CMsgPaintKit_OperationNode> {
        ::std::mem::replace(&mut self.operation_node, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgPaintKit_Operation_StickerStage {
    fn is_initialized(&self) -> bool {
        for v in &self.sticker {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.dest_tl {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.dest_tr {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.dest_bl {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.adjust_black {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.adjust_offset {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.adjust_gamma {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.operation_node {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.sticker)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dest_tl)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dest_tr)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dest_bl)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.adjust_black)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.adjust_offset)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.adjust_gamma)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.operation_node)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.sticker {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.dest_tl.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.dest_tr.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.dest_bl.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.adjust_black.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.adjust_offset.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.adjust_gamma.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.operation_node {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.sticker {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.dest_tl.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.dest_tr.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.dest_bl.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.adjust_black.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.adjust_offset.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.adjust_gamma.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.operation_node {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgPaintKit_Operation_StickerStage {
        CMsgPaintKit_Operation_StickerStage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgPaintKit_Operation_Sticker>>(
                "sticker",
                |m: &CMsgPaintKit_Operation_StickerStage| { &m.sticker },
                |m: &mut CMsgPaintKit_Operation_StickerStage| { &mut m.sticker },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgVarField>>(
                "dest_tl",
                |m: &CMsgPaintKit_Operation_StickerStage| { &m.dest_tl },
                |m: &mut CMsgPaintKit_Operation_StickerStage| { &mut m.dest_tl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgVarField>>(
                "dest_tr",
                |m: &CMsgPaintKit_Operation_StickerStage| { &m.dest_tr },
                |m: &mut CMsgPaintKit_Operation_StickerStage| { &mut m.dest_tr },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgVarField>>(
                "dest_bl",
                |m: &CMsgPaintKit_Operation_StickerStage| { &m.dest_bl },
                |m: &mut CMsgPaintKit_Operation_StickerStage| { &mut m.dest_bl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgVarField>>(
                "adjust_black",
                |m: &CMsgPaintKit_Operation_StickerStage| { &m.adjust_black },
                |m: &mut CMsgPaintKit_Operation_StickerStage| { &mut m.adjust_black },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgVarField>>(
                "adjust_offset",
                |m: &CMsgPaintKit_Operation_StickerStage| { &m.adjust_offset },
                |m: &mut CMsgPaintKit_Operation_StickerStage| { &mut m.adjust_offset },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgVarField>>(
                "adjust_gamma",
                |m: &CMsgPaintKit_Operation_StickerStage| { &m.adjust_gamma },
                |m: &mut CMsgPaintKit_Operation_StickerStage| { &mut m.adjust_gamma },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgPaintKit_OperationNode>>(
                "operation_node",
                |m: &CMsgPaintKit_Operation_StickerStage| { &m.operation_node },
                |m: &mut CMsgPaintKit_Operation_StickerStage| { &mut m.operation_node },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgPaintKit_Operation_StickerStage>(
                "CMsgPaintKit_Operation_StickerStage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgPaintKit_Operation_StickerStage {
        static instance: ::protobuf::rt::LazyV2<CMsgPaintKit_Operation_StickerStage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgPaintKit_Operation_StickerStage::new)
    }
}

impl ::protobuf::Clear for CMsgPaintKit_Operation_StickerStage {
    fn clear(&mut self) {
        self.sticker.clear();
        self.dest_tl.clear();
        self.dest_tr.clear();
        self.dest_bl.clear();
        self.adjust_black.clear();
        self.adjust_offset.clear();
        self.adjust_gamma.clear();
        self.operation_node.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgPaintKit_Operation_StickerStage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPaintKit_Operation_StickerStage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgPaintKit_OperationStage {
    // message oneof groups
    pub stage: ::std::option::Option<CMsgPaintKit_OperationStage_oneof_stage>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgPaintKit_OperationStage {
    fn default() -> &'a CMsgPaintKit_OperationStage {
        <CMsgPaintKit_OperationStage as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum CMsgPaintKit_OperationStage_oneof_stage {
    texture_lookup(CMsgPaintKit_Operation_TextureStage),
    combine_add(CMsgPaintKit_Operation_CombineStage),
    combine_lerp(CMsgPaintKit_Operation_CombineStage),
    combine_multiply(CMsgPaintKit_Operation_CombineStage),
    select(CMsgPaintKit_Operation_SelectStage),
    apply_sticker(CMsgPaintKit_Operation_StickerStage),
}

impl CMsgPaintKit_OperationStage {
    pub fn new() -> CMsgPaintKit_OperationStage {
        ::std::default::Default::default()
    }

    // optional .CMsgPaintKit_Operation_TextureStage texture_lookup = 1;


    pub fn get_texture_lookup(&self) -> &CMsgPaintKit_Operation_TextureStage {
        match self.stage {
            ::std::option::Option::Some(CMsgPaintKit_OperationStage_oneof_stage::texture_lookup(ref v)) => v,
            _ => <CMsgPaintKit_Operation_TextureStage as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_texture_lookup(&mut self) {
        self.stage = ::std::option::Option::None;
    }

    pub fn has_texture_lookup(&self) -> bool {
        match self.stage {
            ::std::option::Option::Some(CMsgPaintKit_OperationStage_oneof_stage::texture_lookup(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_texture_lookup(&mut self, v: CMsgPaintKit_Operation_TextureStage) {
        self.stage = ::std::option::Option::Some(CMsgPaintKit_OperationStage_oneof_stage::texture_lookup(v))
    }

    // Mutable pointer to the field.
    pub fn mut_texture_lookup(&mut self) -> &mut CMsgPaintKit_Operation_TextureStage {
        if let ::std::option::Option::Some(CMsgPaintKit_OperationStage_oneof_stage::texture_lookup(_)) = self.stage {
        } else {
            self.stage = ::std::option::Option::Some(CMsgPaintKit_OperationStage_oneof_stage::texture_lookup(CMsgPaintKit_Operation_TextureStage::new()));
        }
        match self.stage {
            ::std::option::Option::Some(CMsgPaintKit_OperationStage_oneof_stage::texture_lookup(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_texture_lookup(&mut self) -> CMsgPaintKit_Operation_TextureStage {
        if self.has_texture_lookup() {
            match self.stage.take() {
                ::std::option::Option::Some(CMsgPaintKit_OperationStage_oneof_stage::texture_lookup(v)) => v,
                _ => panic!(),
            }
        } else {
            CMsgPaintKit_Operation_TextureStage::new()
        }
    }

    // optional .CMsgPaintKit_Operation_CombineStage combine_add = 2;


    pub fn get_combine_add(&self) -> &CMsgPaintKit_Operation_CombineStage {
        match self.stage {
            ::std::option::Option::Some(CMsgPaintKit_OperationStage_oneof_stage::combine_add(ref v)) => v,
            _ => <CMsgPaintKit_Operation_CombineStage as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_combine_add(&mut self) {
        self.stage = ::std::option::Option::None;
    }

    pub fn has_combine_add(&self) -> bool {
        match self.stage {
            ::std::option::Option::Some(CMsgPaintKit_OperationStage_oneof_stage::combine_add(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_combine_add(&mut self, v: CMsgPaintKit_Operation_CombineStage) {
        self.stage = ::std::option::Option::Some(CMsgPaintKit_OperationStage_oneof_stage::combine_add(v))
    }

    // Mutable pointer to the field.
    pub fn mut_combine_add(&mut self) -> &mut CMsgPaintKit_Operation_CombineStage {
        if let ::std::option::Option::Some(CMsgPaintKit_OperationStage_oneof_stage::combine_add(_)) = self.stage {
        } else {
            self.stage = ::std::option::Option::Some(CMsgPaintKit_OperationStage_oneof_stage::combine_add(CMsgPaintKit_Operation_CombineStage::new()));
        }
        match self.stage {
            ::std::option::Option::Some(CMsgPaintKit_OperationStage_oneof_stage::combine_add(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_combine_add(&mut self) -> CMsgPaintKit_Operation_CombineStage {
        if self.has_combine_add() {
            match self.stage.take() {
                ::std::option::Option::Some(CMsgPaintKit_OperationStage_oneof_stage::combine_add(v)) => v,
                _ => panic!(),
            }
        } else {
            CMsgPaintKit_Operation_CombineStage::new()
        }
    }

    // optional .CMsgPaintKit_Operation_CombineStage combine_lerp = 3;


    pub fn get_combine_lerp(&self) -> &CMsgPaintKit_Operation_CombineStage {
        match self.stage {
            ::std::option::Option::Some(CMsgPaintKit_OperationStage_oneof_stage::combine_lerp(ref v)) => v,
            _ => <CMsgPaintKit_Operation_CombineStage as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_combine_lerp(&mut self) {
        self.stage = ::std::option::Option::None;
    }

    pub fn has_combine_lerp(&self) -> bool {
        match self.stage {
            ::std::option::Option::Some(CMsgPaintKit_OperationStage_oneof_stage::combine_lerp(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_combine_lerp(&mut self, v: CMsgPaintKit_Operation_CombineStage) {
        self.stage = ::std::option::Option::Some(CMsgPaintKit_OperationStage_oneof_stage::combine_lerp(v))
    }

    // Mutable pointer to the field.
    pub fn mut_combine_lerp(&mut self) -> &mut CMsgPaintKit_Operation_CombineStage {
        if let ::std::option::Option::Some(CMsgPaintKit_OperationStage_oneof_stage::combine_lerp(_)) = self.stage {
        } else {
            self.stage = ::std::option::Option::Some(CMsgPaintKit_OperationStage_oneof_stage::combine_lerp(CMsgPaintKit_Operation_CombineStage::new()));
        }
        match self.stage {
            ::std::option::Option::Some(CMsgPaintKit_OperationStage_oneof_stage::combine_lerp(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_combine_lerp(&mut self) -> CMsgPaintKit_Operation_CombineStage {
        if self.has_combine_lerp() {
            match self.stage.take() {
                ::std::option::Option::Some(CMsgPaintKit_OperationStage_oneof_stage::combine_lerp(v)) => v,
                _ => panic!(),
            }
        } else {
            CMsgPaintKit_Operation_CombineStage::new()
        }
    }

    // optional .CMsgPaintKit_Operation_CombineStage combine_multiply = 4;


    pub fn get_combine_multiply(&self) -> &CMsgPaintKit_Operation_CombineStage {
        match self.stage {
            ::std::option::Option::Some(CMsgPaintKit_OperationStage_oneof_stage::combine_multiply(ref v)) => v,
            _ => <CMsgPaintKit_Operation_CombineStage as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_combine_multiply(&mut self) {
        self.stage = ::std::option::Option::None;
    }

    pub fn has_combine_multiply(&self) -> bool {
        match self.stage {
            ::std::option::Option::Some(CMsgPaintKit_OperationStage_oneof_stage::combine_multiply(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_combine_multiply(&mut self, v: CMsgPaintKit_Operation_CombineStage) {
        self.stage = ::std::option::Option::Some(CMsgPaintKit_OperationStage_oneof_stage::combine_multiply(v))
    }

    // Mutable pointer to the field.
    pub fn mut_combine_multiply(&mut self) -> &mut CMsgPaintKit_Operation_CombineStage {
        if let ::std::option::Option::Some(CMsgPaintKit_OperationStage_oneof_stage::combine_multiply(_)) = self.stage {
        } else {
            self.stage = ::std::option::Option::Some(CMsgPaintKit_OperationStage_oneof_stage::combine_multiply(CMsgPaintKit_Operation_CombineStage::new()));
        }
        match self.stage {
            ::std::option::Option::Some(CMsgPaintKit_OperationStage_oneof_stage::combine_multiply(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_combine_multiply(&mut self) -> CMsgPaintKit_Operation_CombineStage {
        if self.has_combine_multiply() {
            match self.stage.take() {
                ::std::option::Option::Some(CMsgPaintKit_OperationStage_oneof_stage::combine_multiply(v)) => v,
                _ => panic!(),
            }
        } else {
            CMsgPaintKit_Operation_CombineStage::new()
        }
    }

    // optional .CMsgPaintKit_Operation_SelectStage select = 5;


    pub fn get_select(&self) -> &CMsgPaintKit_Operation_SelectStage {
        match self.stage {
            ::std::option::Option::Some(CMsgPaintKit_OperationStage_oneof_stage::select(ref v)) => v,
            _ => <CMsgPaintKit_Operation_SelectStage as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_select(&mut self) {
        self.stage = ::std::option::Option::None;
    }

    pub fn has_select(&self) -> bool {
        match self.stage {
            ::std::option::Option::Some(CMsgPaintKit_OperationStage_oneof_stage::select(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_select(&mut self, v: CMsgPaintKit_Operation_SelectStage) {
        self.stage = ::std::option::Option::Some(CMsgPaintKit_OperationStage_oneof_stage::select(v))
    }

    // Mutable pointer to the field.
    pub fn mut_select(&mut self) -> &mut CMsgPaintKit_Operation_SelectStage {
        if let ::std::option::Option::Some(CMsgPaintKit_OperationStage_oneof_stage::select(_)) = self.stage {
        } else {
            self.stage = ::std::option::Option::Some(CMsgPaintKit_OperationStage_oneof_stage::select(CMsgPaintKit_Operation_SelectStage::new()));
        }
        match self.stage {
            ::std::option::Option::Some(CMsgPaintKit_OperationStage_oneof_stage::select(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_select(&mut self) -> CMsgPaintKit_Operation_SelectStage {
        if self.has_select() {
            match self.stage.take() {
                ::std::option::Option::Some(CMsgPaintKit_OperationStage_oneof_stage::select(v)) => v,
                _ => panic!(),
            }
        } else {
            CMsgPaintKit_Operation_SelectStage::new()
        }
    }

    // optional .CMsgPaintKit_Operation_StickerStage apply_sticker = 6;


    pub fn get_apply_sticker(&self) -> &CMsgPaintKit_Operation_StickerStage {
        match self.stage {
            ::std::option::Option::Some(CMsgPaintKit_OperationStage_oneof_stage::apply_sticker(ref v)) => v,
            _ => <CMsgPaintKit_Operation_StickerStage as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_apply_sticker(&mut self) {
        self.stage = ::std::option::Option::None;
    }

    pub fn has_apply_sticker(&self) -> bool {
        match self.stage {
            ::std::option::Option::Some(CMsgPaintKit_OperationStage_oneof_stage::apply_sticker(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_apply_sticker(&mut self, v: CMsgPaintKit_Operation_StickerStage) {
        self.stage = ::std::option::Option::Some(CMsgPaintKit_OperationStage_oneof_stage::apply_sticker(v))
    }

    // Mutable pointer to the field.
    pub fn mut_apply_sticker(&mut self) -> &mut CMsgPaintKit_Operation_StickerStage {
        if let ::std::option::Option::Some(CMsgPaintKit_OperationStage_oneof_stage::apply_sticker(_)) = self.stage {
        } else {
            self.stage = ::std::option::Option::Some(CMsgPaintKit_OperationStage_oneof_stage::apply_sticker(CMsgPaintKit_Operation_StickerStage::new()));
        }
        match self.stage {
            ::std::option::Option::Some(CMsgPaintKit_OperationStage_oneof_stage::apply_sticker(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_apply_sticker(&mut self) -> CMsgPaintKit_Operation_StickerStage {
        if self.has_apply_sticker() {
            match self.stage.take() {
                ::std::option::Option::Some(CMsgPaintKit_OperationStage_oneof_stage::apply_sticker(v)) => v,
                _ => panic!(),
            }
        } else {
            CMsgPaintKit_Operation_StickerStage::new()
        }
    }
}

impl ::protobuf::Message for CMsgPaintKit_OperationStage {
    fn is_initialized(&self) -> bool {
        if let Some(CMsgPaintKit_OperationStage_oneof_stage::texture_lookup(ref v)) = self.stage {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(CMsgPaintKit_OperationStage_oneof_stage::combine_add(ref v)) = self.stage {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(CMsgPaintKit_OperationStage_oneof_stage::combine_lerp(ref v)) = self.stage {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(CMsgPaintKit_OperationStage_oneof_stage::combine_multiply(ref v)) = self.stage {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(CMsgPaintKit_OperationStage_oneof_stage::select(ref v)) = self.stage {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(CMsgPaintKit_OperationStage_oneof_stage::apply_sticker(ref v)) = self.stage {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.stage = ::std::option::Option::Some(CMsgPaintKit_OperationStage_oneof_stage::texture_lookup(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.stage = ::std::option::Option::Some(CMsgPaintKit_OperationStage_oneof_stage::combine_add(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.stage = ::std::option::Option::Some(CMsgPaintKit_OperationStage_oneof_stage::combine_lerp(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.stage = ::std::option::Option::Some(CMsgPaintKit_OperationStage_oneof_stage::combine_multiply(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.stage = ::std::option::Option::Some(CMsgPaintKit_OperationStage_oneof_stage::select(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.stage = ::std::option::Option::Some(CMsgPaintKit_OperationStage_oneof_stage::apply_sticker(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.stage {
            match v {
                &CMsgPaintKit_OperationStage_oneof_stage::texture_lookup(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &CMsgPaintKit_OperationStage_oneof_stage::combine_add(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &CMsgPaintKit_OperationStage_oneof_stage::combine_lerp(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &CMsgPaintKit_OperationStage_oneof_stage::combine_multiply(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &CMsgPaintKit_OperationStage_oneof_stage::select(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &CMsgPaintKit_OperationStage_oneof_stage::apply_sticker(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.stage {
            match v {
                &CMsgPaintKit_OperationStage_oneof_stage::texture_lookup(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &CMsgPaintKit_OperationStage_oneof_stage::combine_add(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &CMsgPaintKit_OperationStage_oneof_stage::combine_lerp(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &CMsgPaintKit_OperationStage_oneof_stage::combine_multiply(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &CMsgPaintKit_OperationStage_oneof_stage::select(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &CMsgPaintKit_OperationStage_oneof_stage::apply_sticker(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgPaintKit_OperationStage {
        CMsgPaintKit_OperationStage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, CMsgPaintKit_Operation_TextureStage>(
                "texture_lookup",
                CMsgPaintKit_OperationStage::has_texture_lookup,
                CMsgPaintKit_OperationStage::get_texture_lookup,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, CMsgPaintKit_Operation_CombineStage>(
                "combine_add",
                CMsgPaintKit_OperationStage::has_combine_add,
                CMsgPaintKit_OperationStage::get_combine_add,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, CMsgPaintKit_Operation_CombineStage>(
                "combine_lerp",
                CMsgPaintKit_OperationStage::has_combine_lerp,
                CMsgPaintKit_OperationStage::get_combine_lerp,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, CMsgPaintKit_Operation_CombineStage>(
                "combine_multiply",
                CMsgPaintKit_OperationStage::has_combine_multiply,
                CMsgPaintKit_OperationStage::get_combine_multiply,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, CMsgPaintKit_Operation_SelectStage>(
                "select",
                CMsgPaintKit_OperationStage::has_select,
                CMsgPaintKit_OperationStage::get_select,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, CMsgPaintKit_Operation_StickerStage>(
                "apply_sticker",
                CMsgPaintKit_OperationStage::has_apply_sticker,
                CMsgPaintKit_OperationStage::get_apply_sticker,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgPaintKit_OperationStage>(
                "CMsgPaintKit_OperationStage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgPaintKit_OperationStage {
        static instance: ::protobuf::rt::LazyV2<CMsgPaintKit_OperationStage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgPaintKit_OperationStage::new)
    }
}

impl ::protobuf::Clear for CMsgPaintKit_OperationStage {
    fn clear(&mut self) {
        self.stage = ::std::option::Option::None;
        self.stage = ::std::option::Option::None;
        self.stage = ::std::option::Option::None;
        self.stage = ::std::option::Option::None;
        self.stage = ::std::option::Option::None;
        self.stage = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgPaintKit_OperationStage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPaintKit_OperationStage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgPaintKit_OperationNode {
    // message oneof groups
    pub node: ::std::option::Option<CMsgPaintKit_OperationNode_oneof_node>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgPaintKit_OperationNode {
    fn default() -> &'a CMsgPaintKit_OperationNode {
        <CMsgPaintKit_OperationNode as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum CMsgPaintKit_OperationNode_oneof_node {
    stage(CMsgPaintKit_OperationStage),
    operation_template(CMsgProtoDefID),
}

impl CMsgPaintKit_OperationNode {
    pub fn new() -> CMsgPaintKit_OperationNode {
        ::std::default::Default::default()
    }

    // optional .CMsgPaintKit_OperationStage stage = 1;


    pub fn get_stage(&self) -> &CMsgPaintKit_OperationStage {
        match self.node {
            ::std::option::Option::Some(CMsgPaintKit_OperationNode_oneof_node::stage(ref v)) => v,
            _ => <CMsgPaintKit_OperationStage as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_stage(&mut self) {
        self.node = ::std::option::Option::None;
    }

    pub fn has_stage(&self) -> bool {
        match self.node {
            ::std::option::Option::Some(CMsgPaintKit_OperationNode_oneof_node::stage(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_stage(&mut self, v: CMsgPaintKit_OperationStage) {
        self.node = ::std::option::Option::Some(CMsgPaintKit_OperationNode_oneof_node::stage(v))
    }

    // Mutable pointer to the field.
    pub fn mut_stage(&mut self) -> &mut CMsgPaintKit_OperationStage {
        if let ::std::option::Option::Some(CMsgPaintKit_OperationNode_oneof_node::stage(_)) = self.node {
        } else {
            self.node = ::std::option::Option::Some(CMsgPaintKit_OperationNode_oneof_node::stage(CMsgPaintKit_OperationStage::new()));
        }
        match self.node {
            ::std::option::Option::Some(CMsgPaintKit_OperationNode_oneof_node::stage(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_stage(&mut self) -> CMsgPaintKit_OperationStage {
        if self.has_stage() {
            match self.node.take() {
                ::std::option::Option::Some(CMsgPaintKit_OperationNode_oneof_node::stage(v)) => v,
                _ => panic!(),
            }
        } else {
            CMsgPaintKit_OperationStage::new()
        }
    }

    // optional .CMsgProtoDefID operation_template = 2;


    pub fn get_operation_template(&self) -> &CMsgProtoDefID {
        match self.node {
            ::std::option::Option::Some(CMsgPaintKit_OperationNode_oneof_node::operation_template(ref v)) => v,
            _ => <CMsgProtoDefID as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_operation_template(&mut self) {
        self.node = ::std::option::Option::None;
    }

    pub fn has_operation_template(&self) -> bool {
        match self.node {
            ::std::option::Option::Some(CMsgPaintKit_OperationNode_oneof_node::operation_template(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_operation_template(&mut self, v: CMsgProtoDefID) {
        self.node = ::std::option::Option::Some(CMsgPaintKit_OperationNode_oneof_node::operation_template(v))
    }

    // Mutable pointer to the field.
    pub fn mut_operation_template(&mut self) -> &mut CMsgProtoDefID {
        if let ::std::option::Option::Some(CMsgPaintKit_OperationNode_oneof_node::operation_template(_)) = self.node {
        } else {
            self.node = ::std::option::Option::Some(CMsgPaintKit_OperationNode_oneof_node::operation_template(CMsgProtoDefID::new()));
        }
        match self.node {
            ::std::option::Option::Some(CMsgPaintKit_OperationNode_oneof_node::operation_template(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_operation_template(&mut self) -> CMsgProtoDefID {
        if self.has_operation_template() {
            match self.node.take() {
                ::std::option::Option::Some(CMsgPaintKit_OperationNode_oneof_node::operation_template(v)) => v,
                _ => panic!(),
            }
        } else {
            CMsgProtoDefID::new()
        }
    }
}

impl ::protobuf::Message for CMsgPaintKit_OperationNode {
    fn is_initialized(&self) -> bool {
        if let Some(CMsgPaintKit_OperationNode_oneof_node::stage(ref v)) = self.node {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(CMsgPaintKit_OperationNode_oneof_node::operation_template(ref v)) = self.node {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.node = ::std::option::Option::Some(CMsgPaintKit_OperationNode_oneof_node::stage(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.node = ::std::option::Option::Some(CMsgPaintKit_OperationNode_oneof_node::operation_template(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.node {
            match v {
                &CMsgPaintKit_OperationNode_oneof_node::stage(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &CMsgPaintKit_OperationNode_oneof_node::operation_template(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.node {
            match v {
                &CMsgPaintKit_OperationNode_oneof_node::stage(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &CMsgPaintKit_OperationNode_oneof_node::operation_template(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgPaintKit_OperationNode {
        CMsgPaintKit_OperationNode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, CMsgPaintKit_OperationStage>(
                "stage",
                CMsgPaintKit_OperationNode::has_stage,
                CMsgPaintKit_OperationNode::get_stage,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, CMsgProtoDefID>(
                "operation_template",
                CMsgPaintKit_OperationNode::has_operation_template,
                CMsgPaintKit_OperationNode::get_operation_template,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgPaintKit_OperationNode>(
                "CMsgPaintKit_OperationNode",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgPaintKit_OperationNode {
        static instance: ::protobuf::rt::LazyV2<CMsgPaintKit_OperationNode> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgPaintKit_OperationNode::new)
    }
}

impl ::protobuf::Clear for CMsgPaintKit_OperationNode {
    fn clear(&mut self) {
        self.node = ::std::option::Option::None;
        self.node = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgPaintKit_OperationNode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPaintKit_OperationNode {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgPaintKit_Operation {
    // message fields
    pub header: ::protobuf::SingularPtrField<CMsgProtoDefHeader>,
    pub operation_node: ::protobuf::RepeatedField<CMsgPaintKit_OperationNode>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgPaintKit_Operation {
    fn default() -> &'a CMsgPaintKit_Operation {
        <CMsgPaintKit_Operation as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPaintKit_Operation {
    pub fn new() -> CMsgPaintKit_Operation {
        ::std::default::Default::default()
    }

    // required .CMsgProtoDefHeader header = 1;


    pub fn get_header(&self) -> &CMsgProtoDefHeader {
        self.header.as_ref().unwrap_or_else(|| <CMsgProtoDefHeader as ::protobuf::Message>::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: CMsgProtoDefHeader) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut CMsgProtoDefHeader {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> CMsgProtoDefHeader {
        self.header.take().unwrap_or_else(|| CMsgProtoDefHeader::new())
    }

    // repeated .CMsgPaintKit_OperationNode operation_node = 2;


    pub fn get_operation_node(&self) -> &[CMsgPaintKit_OperationNode] {
        &self.operation_node
    }
    pub fn clear_operation_node(&mut self) {
        self.operation_node.clear();
    }

    // Param is passed by value, moved
    pub fn set_operation_node(&mut self, v: ::protobuf::RepeatedField<CMsgPaintKit_OperationNode>) {
        self.operation_node = v;
    }

    // Mutable pointer to the field.
    pub fn mut_operation_node(&mut self) -> &mut ::protobuf::RepeatedField<CMsgPaintKit_OperationNode> {
        &mut self.operation_node
    }

    // Take field
    pub fn take_operation_node(&mut self) -> ::protobuf::RepeatedField<CMsgPaintKit_OperationNode> {
        ::std::mem::replace(&mut self.operation_node, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgPaintKit_Operation {
    fn is_initialized(&self) -> bool {
        if self.header.is_none() {
            return false;
        }
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.operation_node {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.operation_node)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.operation_node {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.operation_node {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgPaintKit_Operation {
        CMsgPaintKit_Operation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgProtoDefHeader>>(
                "header",
                |m: &CMsgPaintKit_Operation| { &m.header },
                |m: &mut CMsgPaintKit_Operation| { &mut m.header },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgPaintKit_OperationNode>>(
                "operation_node",
                |m: &CMsgPaintKit_Operation| { &m.operation_node },
                |m: &mut CMsgPaintKit_Operation| { &mut m.operation_node },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgPaintKit_Operation>(
                "CMsgPaintKit_Operation",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgPaintKit_Operation {
        static instance: ::protobuf::rt::LazyV2<CMsgPaintKit_Operation> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgPaintKit_Operation::new)
    }
}

impl ::protobuf::Clear for CMsgPaintKit_Operation {
    fn clear(&mut self) {
        self.header.clear();
        self.operation_node.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgPaintKit_Operation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPaintKit_Operation {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgPaintKit_ItemDefinition {
    // message fields
    pub header: ::protobuf::SingularPtrField<CMsgProtoDefHeader>,
    item_definition_index: ::std::option::Option<u32>,
    pub variable_template: ::protobuf::SingularPtrField<CMsgProtoDefID>,
    pub definition: ::protobuf::RepeatedField<CMsgPaintKit_ItemDefinition_Definition>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgPaintKit_ItemDefinition {
    fn default() -> &'a CMsgPaintKit_ItemDefinition {
        <CMsgPaintKit_ItemDefinition as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPaintKit_ItemDefinition {
    pub fn new() -> CMsgPaintKit_ItemDefinition {
        ::std::default::Default::default()
    }

    // required .CMsgProtoDefHeader header = 1;


    pub fn get_header(&self) -> &CMsgProtoDefHeader {
        self.header.as_ref().unwrap_or_else(|| <CMsgProtoDefHeader as ::protobuf::Message>::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: CMsgProtoDefHeader) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut CMsgProtoDefHeader {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> CMsgProtoDefHeader {
        self.header.take().unwrap_or_else(|| CMsgProtoDefHeader::new())
    }

    // required uint32 item_definition_index = 2;


    pub fn get_item_definition_index(&self) -> u32 {
        self.item_definition_index.unwrap_or(0)
    }
    pub fn clear_item_definition_index(&mut self) {
        self.item_definition_index = ::std::option::Option::None;
    }

    pub fn has_item_definition_index(&self) -> bool {
        self.item_definition_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_definition_index(&mut self, v: u32) {
        self.item_definition_index = ::std::option::Option::Some(v);
    }

    // optional .CMsgProtoDefID variable_template = 3;


    pub fn get_variable_template(&self) -> &CMsgProtoDefID {
        self.variable_template.as_ref().unwrap_or_else(|| <CMsgProtoDefID as ::protobuf::Message>::default_instance())
    }
    pub fn clear_variable_template(&mut self) {
        self.variable_template.clear();
    }

    pub fn has_variable_template(&self) -> bool {
        self.variable_template.is_some()
    }

    // Param is passed by value, moved
    pub fn set_variable_template(&mut self, v: CMsgProtoDefID) {
        self.variable_template = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_variable_template(&mut self) -> &mut CMsgProtoDefID {
        if self.variable_template.is_none() {
            self.variable_template.set_default();
        }
        self.variable_template.as_mut().unwrap()
    }

    // Take field
    pub fn take_variable_template(&mut self) -> CMsgProtoDefID {
        self.variable_template.take().unwrap_or_else(|| CMsgProtoDefID::new())
    }

    // repeated .CMsgPaintKit_ItemDefinition.Definition definition = 4;


    pub fn get_definition(&self) -> &[CMsgPaintKit_ItemDefinition_Definition] {
        &self.definition
    }
    pub fn clear_definition(&mut self) {
        self.definition.clear();
    }

    // Param is passed by value, moved
    pub fn set_definition(&mut self, v: ::protobuf::RepeatedField<CMsgPaintKit_ItemDefinition_Definition>) {
        self.definition = v;
    }

    // Mutable pointer to the field.
    pub fn mut_definition(&mut self) -> &mut ::protobuf::RepeatedField<CMsgPaintKit_ItemDefinition_Definition> {
        &mut self.definition
    }

    // Take field
    pub fn take_definition(&mut self) -> ::protobuf::RepeatedField<CMsgPaintKit_ItemDefinition_Definition> {
        ::std::mem::replace(&mut self.definition, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgPaintKit_ItemDefinition {
    fn is_initialized(&self) -> bool {
        if self.header.is_none() {
            return false;
        }
        if self.item_definition_index.is_none() {
            return false;
        }
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.variable_template {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.definition {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.item_definition_index = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.variable_template)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.definition)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.item_definition_index {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.variable_template.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.definition {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.item_definition_index {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.variable_template.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.definition {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgPaintKit_ItemDefinition {
        CMsgPaintKit_ItemDefinition::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgProtoDefHeader>>(
                "header",
                |m: &CMsgPaintKit_ItemDefinition| { &m.header },
                |m: &mut CMsgPaintKit_ItemDefinition| { &mut m.header },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "item_definition_index",
                |m: &CMsgPaintKit_ItemDefinition| { &m.item_definition_index },
                |m: &mut CMsgPaintKit_ItemDefinition| { &mut m.item_definition_index },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgProtoDefID>>(
                "variable_template",
                |m: &CMsgPaintKit_ItemDefinition| { &m.variable_template },
                |m: &mut CMsgPaintKit_ItemDefinition| { &mut m.variable_template },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgPaintKit_ItemDefinition_Definition>>(
                "definition",
                |m: &CMsgPaintKit_ItemDefinition| { &m.definition },
                |m: &mut CMsgPaintKit_ItemDefinition| { &mut m.definition },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgPaintKit_ItemDefinition>(
                "CMsgPaintKit_ItemDefinition",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgPaintKit_ItemDefinition {
        static instance: ::protobuf::rt::LazyV2<CMsgPaintKit_ItemDefinition> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgPaintKit_ItemDefinition::new)
    }
}

impl ::protobuf::Clear for CMsgPaintKit_ItemDefinition {
    fn clear(&mut self) {
        self.header.clear();
        self.item_definition_index = ::std::option::Option::None;
        self.variable_template.clear();
        self.definition.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgPaintKit_ItemDefinition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPaintKit_ItemDefinition {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgPaintKit_ItemDefinition_Definition {
    // message fields
    pub operation_template: ::protobuf::SingularPtrField<CMsgProtoDefID>,
    pub variable: ::protobuf::RepeatedField<CMsgVarField>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgPaintKit_ItemDefinition_Definition {
    fn default() -> &'a CMsgPaintKit_ItemDefinition_Definition {
        <CMsgPaintKit_ItemDefinition_Definition as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPaintKit_ItemDefinition_Definition {
    pub fn new() -> CMsgPaintKit_ItemDefinition_Definition {
        ::std::default::Default::default()
    }

    // optional .CMsgProtoDefID operation_template = 1;


    pub fn get_operation_template(&self) -> &CMsgProtoDefID {
        self.operation_template.as_ref().unwrap_or_else(|| <CMsgProtoDefID as ::protobuf::Message>::default_instance())
    }
    pub fn clear_operation_template(&mut self) {
        self.operation_template.clear();
    }

    pub fn has_operation_template(&self) -> bool {
        self.operation_template.is_some()
    }

    // Param is passed by value, moved
    pub fn set_operation_template(&mut self, v: CMsgProtoDefID) {
        self.operation_template = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_operation_template(&mut self) -> &mut CMsgProtoDefID {
        if self.operation_template.is_none() {
            self.operation_template.set_default();
        }
        self.operation_template.as_mut().unwrap()
    }

    // Take field
    pub fn take_operation_template(&mut self) -> CMsgProtoDefID {
        self.operation_template.take().unwrap_or_else(|| CMsgProtoDefID::new())
    }

    // repeated .CMsgVarField variable = 2;


    pub fn get_variable(&self) -> &[CMsgVarField] {
        &self.variable
    }
    pub fn clear_variable(&mut self) {
        self.variable.clear();
    }

    // Param is passed by value, moved
    pub fn set_variable(&mut self, v: ::protobuf::RepeatedField<CMsgVarField>) {
        self.variable = v;
    }

    // Mutable pointer to the field.
    pub fn mut_variable(&mut self) -> &mut ::protobuf::RepeatedField<CMsgVarField> {
        &mut self.variable
    }

    // Take field
    pub fn take_variable(&mut self) -> ::protobuf::RepeatedField<CMsgVarField> {
        ::std::mem::replace(&mut self.variable, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgPaintKit_ItemDefinition_Definition {
    fn is_initialized(&self) -> bool {
        for v in &self.operation_template {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.variable {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.operation_template)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.variable)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.operation_template.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.variable {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.operation_template.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.variable {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgPaintKit_ItemDefinition_Definition {
        CMsgPaintKit_ItemDefinition_Definition::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgProtoDefID>>(
                "operation_template",
                |m: &CMsgPaintKit_ItemDefinition_Definition| { &m.operation_template },
                |m: &mut CMsgPaintKit_ItemDefinition_Definition| { &mut m.operation_template },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgVarField>>(
                "variable",
                |m: &CMsgPaintKit_ItemDefinition_Definition| { &m.variable },
                |m: &mut CMsgPaintKit_ItemDefinition_Definition| { &mut m.variable },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgPaintKit_ItemDefinition_Definition>(
                "CMsgPaintKit_ItemDefinition.Definition",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgPaintKit_ItemDefinition_Definition {
        static instance: ::protobuf::rt::LazyV2<CMsgPaintKit_ItemDefinition_Definition> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgPaintKit_ItemDefinition_Definition::new)
    }
}

impl ::protobuf::Clear for CMsgPaintKit_ItemDefinition_Definition {
    fn clear(&mut self) {
        self.operation_template.clear();
        self.variable.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgPaintKit_ItemDefinition_Definition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPaintKit_ItemDefinition_Definition {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgPaintKit_Definition {
    // message fields
    pub header: ::protobuf::SingularPtrField<CMsgProtoDefHeader>,
    loc_desctoken: ::protobuf::SingularField<::std::string::String>,
    pub operation_template: ::protobuf::SingularPtrField<CMsgProtoDefID>,
    has_team_textures: ::std::option::Option<bool>,
    pub item: ::protobuf::RepeatedField<CMsgPaintKit_Definition_Item>,
    pub paintkit_tool: ::protobuf::SingularPtrField<CMsgPaintKit_Definition_Item>,
    pub flamethrower: ::protobuf::SingularPtrField<CMsgPaintKit_Definition_Item>,
    pub grenadelauncher: ::protobuf::SingularPtrField<CMsgPaintKit_Definition_Item>,
    pub knife: ::protobuf::SingularPtrField<CMsgPaintKit_Definition_Item>,
    pub medigun: ::protobuf::SingularPtrField<CMsgPaintKit_Definition_Item>,
    pub minigun: ::protobuf::SingularPtrField<CMsgPaintKit_Definition_Item>,
    pub pistol: ::protobuf::SingularPtrField<CMsgPaintKit_Definition_Item>,
    pub revolver: ::protobuf::SingularPtrField<CMsgPaintKit_Definition_Item>,
    pub rocketlauncher: ::protobuf::SingularPtrField<CMsgPaintKit_Definition_Item>,
    pub scattergun: ::protobuf::SingularPtrField<CMsgPaintKit_Definition_Item>,
    pub shotgun: ::protobuf::SingularPtrField<CMsgPaintKit_Definition_Item>,
    pub smg: ::protobuf::SingularPtrField<CMsgPaintKit_Definition_Item>,
    pub sniperrifle: ::protobuf::SingularPtrField<CMsgPaintKit_Definition_Item>,
    pub stickybomb_launcher: ::protobuf::SingularPtrField<CMsgPaintKit_Definition_Item>,
    pub ubersaw: ::protobuf::SingularPtrField<CMsgPaintKit_Definition_Item>,
    pub wrench: ::protobuf::SingularPtrField<CMsgPaintKit_Definition_Item>,
    pub amputator: ::protobuf::SingularPtrField<CMsgPaintKit_Definition_Item>,
    pub atom_launcher: ::protobuf::SingularPtrField<CMsgPaintKit_Definition_Item>,
    pub back_scratcher: ::protobuf::SingularPtrField<CMsgPaintKit_Definition_Item>,
    pub battleaxe: ::protobuf::SingularPtrField<CMsgPaintKit_Definition_Item>,
    pub bazaar_sniper: ::protobuf::SingularPtrField<CMsgPaintKit_Definition_Item>,
    pub blackbox: ::protobuf::SingularPtrField<CMsgPaintKit_Definition_Item>,
    pub claidheamohmor: ::protobuf::SingularPtrField<CMsgPaintKit_Definition_Item>,
    pub crusaders_crossbow: ::protobuf::SingularPtrField<CMsgPaintKit_Definition_Item>,
    pub degreaser: ::protobuf::SingularPtrField<CMsgPaintKit_Definition_Item>,
    pub demo_cannon: ::protobuf::SingularPtrField<CMsgPaintKit_Definition_Item>,
    pub demo_sultan_sword: ::protobuf::SingularPtrField<CMsgPaintKit_Definition_Item>,
    pub detonator: ::protobuf::SingularPtrField<CMsgPaintKit_Definition_Item>,
    pub gatling_gun: ::protobuf::SingularPtrField<CMsgPaintKit_Definition_Item>,
    pub holymackerel: ::protobuf::SingularPtrField<CMsgPaintKit_Definition_Item>,
    pub jag: ::protobuf::SingularPtrField<CMsgPaintKit_Definition_Item>,
    pub lochnload: ::protobuf::SingularPtrField<CMsgPaintKit_Definition_Item>,
    pub powerjack: ::protobuf::SingularPtrField<CMsgPaintKit_Definition_Item>,
    pub quadball: ::protobuf::SingularPtrField<CMsgPaintKit_Definition_Item>,
    pub reserve_shooter: ::protobuf::SingularPtrField<CMsgPaintKit_Definition_Item>,
    pub riding_crop: ::protobuf::SingularPtrField<CMsgPaintKit_Definition_Item>,
    pub russian_riot: ::protobuf::SingularPtrField<CMsgPaintKit_Definition_Item>,
    pub scimitar: ::protobuf::SingularPtrField<CMsgPaintKit_Definition_Item>,
    pub scorch_shot: ::protobuf::SingularPtrField<CMsgPaintKit_Definition_Item>,
    pub shortstop: ::protobuf::SingularPtrField<CMsgPaintKit_Definition_Item>,
    pub soda_popper: ::protobuf::SingularPtrField<CMsgPaintKit_Definition_Item>,
    pub tele_shotgun: ::protobuf::SingularPtrField<CMsgPaintKit_Definition_Item>,
    pub tomislav: ::protobuf::SingularPtrField<CMsgPaintKit_Definition_Item>,
    pub trenchgun: ::protobuf::SingularPtrField<CMsgPaintKit_Definition_Item>,
    pub winger_pistol: ::protobuf::SingularPtrField<CMsgPaintKit_Definition_Item>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgPaintKit_Definition {
    fn default() -> &'a CMsgPaintKit_Definition {
        <CMsgPaintKit_Definition as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPaintKit_Definition {
    pub fn new() -> CMsgPaintKit_Definition {
        ::std::default::Default::default()
    }

    // required .CMsgProtoDefHeader header = 1;


    pub fn get_header(&self) -> &CMsgProtoDefHeader {
        self.header.as_ref().unwrap_or_else(|| <CMsgProtoDefHeader as ::protobuf::Message>::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: CMsgProtoDefHeader) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut CMsgProtoDefHeader {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> CMsgProtoDefHeader {
        self.header.take().unwrap_or_else(|| CMsgProtoDefHeader::new())
    }

    // optional string loc_desctoken = 2;


    pub fn get_loc_desctoken(&self) -> &str {
        match self.loc_desctoken.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_loc_desctoken(&mut self) {
        self.loc_desctoken.clear();
    }

    pub fn has_loc_desctoken(&self) -> bool {
        self.loc_desctoken.is_some()
    }

    // Param is passed by value, moved
    pub fn set_loc_desctoken(&mut self, v: ::std::string::String) {
        self.loc_desctoken = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_loc_desctoken(&mut self) -> &mut ::std::string::String {
        if self.loc_desctoken.is_none() {
            self.loc_desctoken.set_default();
        }
        self.loc_desctoken.as_mut().unwrap()
    }

    // Take field
    pub fn take_loc_desctoken(&mut self) -> ::std::string::String {
        self.loc_desctoken.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .CMsgProtoDefID operation_template = 3;


    pub fn get_operation_template(&self) -> &CMsgProtoDefID {
        self.operation_template.as_ref().unwrap_or_else(|| <CMsgProtoDefID as ::protobuf::Message>::default_instance())
    }
    pub fn clear_operation_template(&mut self) {
        self.operation_template.clear();
    }

    pub fn has_operation_template(&self) -> bool {
        self.operation_template.is_some()
    }

    // Param is passed by value, moved
    pub fn set_operation_template(&mut self, v: CMsgProtoDefID) {
        self.operation_template = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_operation_template(&mut self) -> &mut CMsgProtoDefID {
        if self.operation_template.is_none() {
            self.operation_template.set_default();
        }
        self.operation_template.as_mut().unwrap()
    }

    // Take field
    pub fn take_operation_template(&mut self) -> CMsgProtoDefID {
        self.operation_template.take().unwrap_or_else(|| CMsgProtoDefID::new())
    }

    // optional bool has_team_textures = 4;


    pub fn get_has_team_textures(&self) -> bool {
        self.has_team_textures.unwrap_or(false)
    }
    pub fn clear_has_team_textures(&mut self) {
        self.has_team_textures = ::std::option::Option::None;
    }

    pub fn has_has_team_textures(&self) -> bool {
        self.has_team_textures.is_some()
    }

    // Param is passed by value, moved
    pub fn set_has_team_textures(&mut self, v: bool) {
        self.has_team_textures = ::std::option::Option::Some(v);
    }

    // repeated .CMsgPaintKit_Definition.Item item = 5;


    pub fn get_item(&self) -> &[CMsgPaintKit_Definition_Item] {
        &self.item
    }
    pub fn clear_item(&mut self) {
        self.item.clear();
    }

    // Param is passed by value, moved
    pub fn set_item(&mut self, v: ::protobuf::RepeatedField<CMsgPaintKit_Definition_Item>) {
        self.item = v;
    }

    // Mutable pointer to the field.
    pub fn mut_item(&mut self) -> &mut ::protobuf::RepeatedField<CMsgPaintKit_Definition_Item> {
        &mut self.item
    }

    // Take field
    pub fn take_item(&mut self) -> ::protobuf::RepeatedField<CMsgPaintKit_Definition_Item> {
        ::std::mem::replace(&mut self.item, ::protobuf::RepeatedField::new())
    }

    // optional .CMsgPaintKit_Definition.Item paintkit_tool = 6;


    pub fn get_paintkit_tool(&self) -> &CMsgPaintKit_Definition_Item {
        self.paintkit_tool.as_ref().unwrap_or_else(|| <CMsgPaintKit_Definition_Item as ::protobuf::Message>::default_instance())
    }
    pub fn clear_paintkit_tool(&mut self) {
        self.paintkit_tool.clear();
    }

    pub fn has_paintkit_tool(&self) -> bool {
        self.paintkit_tool.is_some()
    }

    // Param is passed by value, moved
    pub fn set_paintkit_tool(&mut self, v: CMsgPaintKit_Definition_Item) {
        self.paintkit_tool = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_paintkit_tool(&mut self) -> &mut CMsgPaintKit_Definition_Item {
        if self.paintkit_tool.is_none() {
            self.paintkit_tool.set_default();
        }
        self.paintkit_tool.as_mut().unwrap()
    }

    // Take field
    pub fn take_paintkit_tool(&mut self) -> CMsgPaintKit_Definition_Item {
        self.paintkit_tool.take().unwrap_or_else(|| CMsgPaintKit_Definition_Item::new())
    }

    // optional .CMsgPaintKit_Definition.Item flamethrower = 7;


    pub fn get_flamethrower(&self) -> &CMsgPaintKit_Definition_Item {
        self.flamethrower.as_ref().unwrap_or_else(|| <CMsgPaintKit_Definition_Item as ::protobuf::Message>::default_instance())
    }
    pub fn clear_flamethrower(&mut self) {
        self.flamethrower.clear();
    }

    pub fn has_flamethrower(&self) -> bool {
        self.flamethrower.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flamethrower(&mut self, v: CMsgPaintKit_Definition_Item) {
        self.flamethrower = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_flamethrower(&mut self) -> &mut CMsgPaintKit_Definition_Item {
        if self.flamethrower.is_none() {
            self.flamethrower.set_default();
        }
        self.flamethrower.as_mut().unwrap()
    }

    // Take field
    pub fn take_flamethrower(&mut self) -> CMsgPaintKit_Definition_Item {
        self.flamethrower.take().unwrap_or_else(|| CMsgPaintKit_Definition_Item::new())
    }

    // optional .CMsgPaintKit_Definition.Item grenadelauncher = 8;


    pub fn get_grenadelauncher(&self) -> &CMsgPaintKit_Definition_Item {
        self.grenadelauncher.as_ref().unwrap_or_else(|| <CMsgPaintKit_Definition_Item as ::protobuf::Message>::default_instance())
    }
    pub fn clear_grenadelauncher(&mut self) {
        self.grenadelauncher.clear();
    }

    pub fn has_grenadelauncher(&self) -> bool {
        self.grenadelauncher.is_some()
    }

    // Param is passed by value, moved
    pub fn set_grenadelauncher(&mut self, v: CMsgPaintKit_Definition_Item) {
        self.grenadelauncher = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_grenadelauncher(&mut self) -> &mut CMsgPaintKit_Definition_Item {
        if self.grenadelauncher.is_none() {
            self.grenadelauncher.set_default();
        }
        self.grenadelauncher.as_mut().unwrap()
    }

    // Take field
    pub fn take_grenadelauncher(&mut self) -> CMsgPaintKit_Definition_Item {
        self.grenadelauncher.take().unwrap_or_else(|| CMsgPaintKit_Definition_Item::new())
    }

    // optional .CMsgPaintKit_Definition.Item knife = 9;


    pub fn get_knife(&self) -> &CMsgPaintKit_Definition_Item {
        self.knife.as_ref().unwrap_or_else(|| <CMsgPaintKit_Definition_Item as ::protobuf::Message>::default_instance())
    }
    pub fn clear_knife(&mut self) {
        self.knife.clear();
    }

    pub fn has_knife(&self) -> bool {
        self.knife.is_some()
    }

    // Param is passed by value, moved
    pub fn set_knife(&mut self, v: CMsgPaintKit_Definition_Item) {
        self.knife = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_knife(&mut self) -> &mut CMsgPaintKit_Definition_Item {
        if self.knife.is_none() {
            self.knife.set_default();
        }
        self.knife.as_mut().unwrap()
    }

    // Take field
    pub fn take_knife(&mut self) -> CMsgPaintKit_Definition_Item {
        self.knife.take().unwrap_or_else(|| CMsgPaintKit_Definition_Item::new())
    }

    // optional .CMsgPaintKit_Definition.Item medigun = 10;


    pub fn get_medigun(&self) -> &CMsgPaintKit_Definition_Item {
        self.medigun.as_ref().unwrap_or_else(|| <CMsgPaintKit_Definition_Item as ::protobuf::Message>::default_instance())
    }
    pub fn clear_medigun(&mut self) {
        self.medigun.clear();
    }

    pub fn has_medigun(&self) -> bool {
        self.medigun.is_some()
    }

    // Param is passed by value, moved
    pub fn set_medigun(&mut self, v: CMsgPaintKit_Definition_Item) {
        self.medigun = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_medigun(&mut self) -> &mut CMsgPaintKit_Definition_Item {
        if self.medigun.is_none() {
            self.medigun.set_default();
        }
        self.medigun.as_mut().unwrap()
    }

    // Take field
    pub fn take_medigun(&mut self) -> CMsgPaintKit_Definition_Item {
        self.medigun.take().unwrap_or_else(|| CMsgPaintKit_Definition_Item::new())
    }

    // optional .CMsgPaintKit_Definition.Item minigun = 11;


    pub fn get_minigun(&self) -> &CMsgPaintKit_Definition_Item {
        self.minigun.as_ref().unwrap_or_else(|| <CMsgPaintKit_Definition_Item as ::protobuf::Message>::default_instance())
    }
    pub fn clear_minigun(&mut self) {
        self.minigun.clear();
    }

    pub fn has_minigun(&self) -> bool {
        self.minigun.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minigun(&mut self, v: CMsgPaintKit_Definition_Item) {
        self.minigun = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_minigun(&mut self) -> &mut CMsgPaintKit_Definition_Item {
        if self.minigun.is_none() {
            self.minigun.set_default();
        }
        self.minigun.as_mut().unwrap()
    }

    // Take field
    pub fn take_minigun(&mut self) -> CMsgPaintKit_Definition_Item {
        self.minigun.take().unwrap_or_else(|| CMsgPaintKit_Definition_Item::new())
    }

    // optional .CMsgPaintKit_Definition.Item pistol = 12;


    pub fn get_pistol(&self) -> &CMsgPaintKit_Definition_Item {
        self.pistol.as_ref().unwrap_or_else(|| <CMsgPaintKit_Definition_Item as ::protobuf::Message>::default_instance())
    }
    pub fn clear_pistol(&mut self) {
        self.pistol.clear();
    }

    pub fn has_pistol(&self) -> bool {
        self.pistol.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pistol(&mut self, v: CMsgPaintKit_Definition_Item) {
        self.pistol = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pistol(&mut self) -> &mut CMsgPaintKit_Definition_Item {
        if self.pistol.is_none() {
            self.pistol.set_default();
        }
        self.pistol.as_mut().unwrap()
    }

    // Take field
    pub fn take_pistol(&mut self) -> CMsgPaintKit_Definition_Item {
        self.pistol.take().unwrap_or_else(|| CMsgPaintKit_Definition_Item::new())
    }

    // optional .CMsgPaintKit_Definition.Item revolver = 13;


    pub fn get_revolver(&self) -> &CMsgPaintKit_Definition_Item {
        self.revolver.as_ref().unwrap_or_else(|| <CMsgPaintKit_Definition_Item as ::protobuf::Message>::default_instance())
    }
    pub fn clear_revolver(&mut self) {
        self.revolver.clear();
    }

    pub fn has_revolver(&self) -> bool {
        self.revolver.is_some()
    }

    // Param is passed by value, moved
    pub fn set_revolver(&mut self, v: CMsgPaintKit_Definition_Item) {
        self.revolver = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_revolver(&mut self) -> &mut CMsgPaintKit_Definition_Item {
        if self.revolver.is_none() {
            self.revolver.set_default();
        }
        self.revolver.as_mut().unwrap()
    }

    // Take field
    pub fn take_revolver(&mut self) -> CMsgPaintKit_Definition_Item {
        self.revolver.take().unwrap_or_else(|| CMsgPaintKit_Definition_Item::new())
    }

    // optional .CMsgPaintKit_Definition.Item rocketlauncher = 14;


    pub fn get_rocketlauncher(&self) -> &CMsgPaintKit_Definition_Item {
        self.rocketlauncher.as_ref().unwrap_or_else(|| <CMsgPaintKit_Definition_Item as ::protobuf::Message>::default_instance())
    }
    pub fn clear_rocketlauncher(&mut self) {
        self.rocketlauncher.clear();
    }

    pub fn has_rocketlauncher(&self) -> bool {
        self.rocketlauncher.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rocketlauncher(&mut self, v: CMsgPaintKit_Definition_Item) {
        self.rocketlauncher = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rocketlauncher(&mut self) -> &mut CMsgPaintKit_Definition_Item {
        if self.rocketlauncher.is_none() {
            self.rocketlauncher.set_default();
        }
        self.rocketlauncher.as_mut().unwrap()
    }

    // Take field
    pub fn take_rocketlauncher(&mut self) -> CMsgPaintKit_Definition_Item {
        self.rocketlauncher.take().unwrap_or_else(|| CMsgPaintKit_Definition_Item::new())
    }

    // optional .CMsgPaintKit_Definition.Item scattergun = 15;


    pub fn get_scattergun(&self) -> &CMsgPaintKit_Definition_Item {
        self.scattergun.as_ref().unwrap_or_else(|| <CMsgPaintKit_Definition_Item as ::protobuf::Message>::default_instance())
    }
    pub fn clear_scattergun(&mut self) {
        self.scattergun.clear();
    }

    pub fn has_scattergun(&self) -> bool {
        self.scattergun.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scattergun(&mut self, v: CMsgPaintKit_Definition_Item) {
        self.scattergun = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_scattergun(&mut self) -> &mut CMsgPaintKit_Definition_Item {
        if self.scattergun.is_none() {
            self.scattergun.set_default();
        }
        self.scattergun.as_mut().unwrap()
    }

    // Take field
    pub fn take_scattergun(&mut self) -> CMsgPaintKit_Definition_Item {
        self.scattergun.take().unwrap_or_else(|| CMsgPaintKit_Definition_Item::new())
    }

    // optional .CMsgPaintKit_Definition.Item shotgun = 16;


    pub fn get_shotgun(&self) -> &CMsgPaintKit_Definition_Item {
        self.shotgun.as_ref().unwrap_or_else(|| <CMsgPaintKit_Definition_Item as ::protobuf::Message>::default_instance())
    }
    pub fn clear_shotgun(&mut self) {
        self.shotgun.clear();
    }

    pub fn has_shotgun(&self) -> bool {
        self.shotgun.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shotgun(&mut self, v: CMsgPaintKit_Definition_Item) {
        self.shotgun = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_shotgun(&mut self) -> &mut CMsgPaintKit_Definition_Item {
        if self.shotgun.is_none() {
            self.shotgun.set_default();
        }
        self.shotgun.as_mut().unwrap()
    }

    // Take field
    pub fn take_shotgun(&mut self) -> CMsgPaintKit_Definition_Item {
        self.shotgun.take().unwrap_or_else(|| CMsgPaintKit_Definition_Item::new())
    }

    // optional .CMsgPaintKit_Definition.Item smg = 17;


    pub fn get_smg(&self) -> &CMsgPaintKit_Definition_Item {
        self.smg.as_ref().unwrap_or_else(|| <CMsgPaintKit_Definition_Item as ::protobuf::Message>::default_instance())
    }
    pub fn clear_smg(&mut self) {
        self.smg.clear();
    }

    pub fn has_smg(&self) -> bool {
        self.smg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_smg(&mut self, v: CMsgPaintKit_Definition_Item) {
        self.smg = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_smg(&mut self) -> &mut CMsgPaintKit_Definition_Item {
        if self.smg.is_none() {
            self.smg.set_default();
        }
        self.smg.as_mut().unwrap()
    }

    // Take field
    pub fn take_smg(&mut self) -> CMsgPaintKit_Definition_Item {
        self.smg.take().unwrap_or_else(|| CMsgPaintKit_Definition_Item::new())
    }

    // optional .CMsgPaintKit_Definition.Item sniperrifle = 18;


    pub fn get_sniperrifle(&self) -> &CMsgPaintKit_Definition_Item {
        self.sniperrifle.as_ref().unwrap_or_else(|| <CMsgPaintKit_Definition_Item as ::protobuf::Message>::default_instance())
    }
    pub fn clear_sniperrifle(&mut self) {
        self.sniperrifle.clear();
    }

    pub fn has_sniperrifle(&self) -> bool {
        self.sniperrifle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sniperrifle(&mut self, v: CMsgPaintKit_Definition_Item) {
        self.sniperrifle = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sniperrifle(&mut self) -> &mut CMsgPaintKit_Definition_Item {
        if self.sniperrifle.is_none() {
            self.sniperrifle.set_default();
        }
        self.sniperrifle.as_mut().unwrap()
    }

    // Take field
    pub fn take_sniperrifle(&mut self) -> CMsgPaintKit_Definition_Item {
        self.sniperrifle.take().unwrap_or_else(|| CMsgPaintKit_Definition_Item::new())
    }

    // optional .CMsgPaintKit_Definition.Item stickybomb_launcher = 19;


    pub fn get_stickybomb_launcher(&self) -> &CMsgPaintKit_Definition_Item {
        self.stickybomb_launcher.as_ref().unwrap_or_else(|| <CMsgPaintKit_Definition_Item as ::protobuf::Message>::default_instance())
    }
    pub fn clear_stickybomb_launcher(&mut self) {
        self.stickybomb_launcher.clear();
    }

    pub fn has_stickybomb_launcher(&self) -> bool {
        self.stickybomb_launcher.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stickybomb_launcher(&mut self, v: CMsgPaintKit_Definition_Item) {
        self.stickybomb_launcher = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stickybomb_launcher(&mut self) -> &mut CMsgPaintKit_Definition_Item {
        if self.stickybomb_launcher.is_none() {
            self.stickybomb_launcher.set_default();
        }
        self.stickybomb_launcher.as_mut().unwrap()
    }

    // Take field
    pub fn take_stickybomb_launcher(&mut self) -> CMsgPaintKit_Definition_Item {
        self.stickybomb_launcher.take().unwrap_or_else(|| CMsgPaintKit_Definition_Item::new())
    }

    // optional .CMsgPaintKit_Definition.Item ubersaw = 20;


    pub fn get_ubersaw(&self) -> &CMsgPaintKit_Definition_Item {
        self.ubersaw.as_ref().unwrap_or_else(|| <CMsgPaintKit_Definition_Item as ::protobuf::Message>::default_instance())
    }
    pub fn clear_ubersaw(&mut self) {
        self.ubersaw.clear();
    }

    pub fn has_ubersaw(&self) -> bool {
        self.ubersaw.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ubersaw(&mut self, v: CMsgPaintKit_Definition_Item) {
        self.ubersaw = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ubersaw(&mut self) -> &mut CMsgPaintKit_Definition_Item {
        if self.ubersaw.is_none() {
            self.ubersaw.set_default();
        }
        self.ubersaw.as_mut().unwrap()
    }

    // Take field
    pub fn take_ubersaw(&mut self) -> CMsgPaintKit_Definition_Item {
        self.ubersaw.take().unwrap_or_else(|| CMsgPaintKit_Definition_Item::new())
    }

    // optional .CMsgPaintKit_Definition.Item wrench = 21;


    pub fn get_wrench(&self) -> &CMsgPaintKit_Definition_Item {
        self.wrench.as_ref().unwrap_or_else(|| <CMsgPaintKit_Definition_Item as ::protobuf::Message>::default_instance())
    }
    pub fn clear_wrench(&mut self) {
        self.wrench.clear();
    }

    pub fn has_wrench(&self) -> bool {
        self.wrench.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wrench(&mut self, v: CMsgPaintKit_Definition_Item) {
        self.wrench = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_wrench(&mut self) -> &mut CMsgPaintKit_Definition_Item {
        if self.wrench.is_none() {
            self.wrench.set_default();
        }
        self.wrench.as_mut().unwrap()
    }

    // Take field
    pub fn take_wrench(&mut self) -> CMsgPaintKit_Definition_Item {
        self.wrench.take().unwrap_or_else(|| CMsgPaintKit_Definition_Item::new())
    }

    // optional .CMsgPaintKit_Definition.Item amputator = 22;


    pub fn get_amputator(&self) -> &CMsgPaintKit_Definition_Item {
        self.amputator.as_ref().unwrap_or_else(|| <CMsgPaintKit_Definition_Item as ::protobuf::Message>::default_instance())
    }
    pub fn clear_amputator(&mut self) {
        self.amputator.clear();
    }

    pub fn has_amputator(&self) -> bool {
        self.amputator.is_some()
    }

    // Param is passed by value, moved
    pub fn set_amputator(&mut self, v: CMsgPaintKit_Definition_Item) {
        self.amputator = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_amputator(&mut self) -> &mut CMsgPaintKit_Definition_Item {
        if self.amputator.is_none() {
            self.amputator.set_default();
        }
        self.amputator.as_mut().unwrap()
    }

    // Take field
    pub fn take_amputator(&mut self) -> CMsgPaintKit_Definition_Item {
        self.amputator.take().unwrap_or_else(|| CMsgPaintKit_Definition_Item::new())
    }

    // optional .CMsgPaintKit_Definition.Item atom_launcher = 23;


    pub fn get_atom_launcher(&self) -> &CMsgPaintKit_Definition_Item {
        self.atom_launcher.as_ref().unwrap_or_else(|| <CMsgPaintKit_Definition_Item as ::protobuf::Message>::default_instance())
    }
    pub fn clear_atom_launcher(&mut self) {
        self.atom_launcher.clear();
    }

    pub fn has_atom_launcher(&self) -> bool {
        self.atom_launcher.is_some()
    }

    // Param is passed by value, moved
    pub fn set_atom_launcher(&mut self, v: CMsgPaintKit_Definition_Item) {
        self.atom_launcher = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_atom_launcher(&mut self) -> &mut CMsgPaintKit_Definition_Item {
        if self.atom_launcher.is_none() {
            self.atom_launcher.set_default();
        }
        self.atom_launcher.as_mut().unwrap()
    }

    // Take field
    pub fn take_atom_launcher(&mut self) -> CMsgPaintKit_Definition_Item {
        self.atom_launcher.take().unwrap_or_else(|| CMsgPaintKit_Definition_Item::new())
    }

    // optional .CMsgPaintKit_Definition.Item back_scratcher = 24;


    pub fn get_back_scratcher(&self) -> &CMsgPaintKit_Definition_Item {
        self.back_scratcher.as_ref().unwrap_or_else(|| <CMsgPaintKit_Definition_Item as ::protobuf::Message>::default_instance())
    }
    pub fn clear_back_scratcher(&mut self) {
        self.back_scratcher.clear();
    }

    pub fn has_back_scratcher(&self) -> bool {
        self.back_scratcher.is_some()
    }

    // Param is passed by value, moved
    pub fn set_back_scratcher(&mut self, v: CMsgPaintKit_Definition_Item) {
        self.back_scratcher = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_back_scratcher(&mut self) -> &mut CMsgPaintKit_Definition_Item {
        if self.back_scratcher.is_none() {
            self.back_scratcher.set_default();
        }
        self.back_scratcher.as_mut().unwrap()
    }

    // Take field
    pub fn take_back_scratcher(&mut self) -> CMsgPaintKit_Definition_Item {
        self.back_scratcher.take().unwrap_or_else(|| CMsgPaintKit_Definition_Item::new())
    }

    // optional .CMsgPaintKit_Definition.Item battleaxe = 25;


    pub fn get_battleaxe(&self) -> &CMsgPaintKit_Definition_Item {
        self.battleaxe.as_ref().unwrap_or_else(|| <CMsgPaintKit_Definition_Item as ::protobuf::Message>::default_instance())
    }
    pub fn clear_battleaxe(&mut self) {
        self.battleaxe.clear();
    }

    pub fn has_battleaxe(&self) -> bool {
        self.battleaxe.is_some()
    }

    // Param is passed by value, moved
    pub fn set_battleaxe(&mut self, v: CMsgPaintKit_Definition_Item) {
        self.battleaxe = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_battleaxe(&mut self) -> &mut CMsgPaintKit_Definition_Item {
        if self.battleaxe.is_none() {
            self.battleaxe.set_default();
        }
        self.battleaxe.as_mut().unwrap()
    }

    // Take field
    pub fn take_battleaxe(&mut self) -> CMsgPaintKit_Definition_Item {
        self.battleaxe.take().unwrap_or_else(|| CMsgPaintKit_Definition_Item::new())
    }

    // optional .CMsgPaintKit_Definition.Item bazaar_sniper = 26;


    pub fn get_bazaar_sniper(&self) -> &CMsgPaintKit_Definition_Item {
        self.bazaar_sniper.as_ref().unwrap_or_else(|| <CMsgPaintKit_Definition_Item as ::protobuf::Message>::default_instance())
    }
    pub fn clear_bazaar_sniper(&mut self) {
        self.bazaar_sniper.clear();
    }

    pub fn has_bazaar_sniper(&self) -> bool {
        self.bazaar_sniper.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bazaar_sniper(&mut self, v: CMsgPaintKit_Definition_Item) {
        self.bazaar_sniper = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bazaar_sniper(&mut self) -> &mut CMsgPaintKit_Definition_Item {
        if self.bazaar_sniper.is_none() {
            self.bazaar_sniper.set_default();
        }
        self.bazaar_sniper.as_mut().unwrap()
    }

    // Take field
    pub fn take_bazaar_sniper(&mut self) -> CMsgPaintKit_Definition_Item {
        self.bazaar_sniper.take().unwrap_or_else(|| CMsgPaintKit_Definition_Item::new())
    }

    // optional .CMsgPaintKit_Definition.Item blackbox = 27;


    pub fn get_blackbox(&self) -> &CMsgPaintKit_Definition_Item {
        self.blackbox.as_ref().unwrap_or_else(|| <CMsgPaintKit_Definition_Item as ::protobuf::Message>::default_instance())
    }
    pub fn clear_blackbox(&mut self) {
        self.blackbox.clear();
    }

    pub fn has_blackbox(&self) -> bool {
        self.blackbox.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blackbox(&mut self, v: CMsgPaintKit_Definition_Item) {
        self.blackbox = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blackbox(&mut self) -> &mut CMsgPaintKit_Definition_Item {
        if self.blackbox.is_none() {
            self.blackbox.set_default();
        }
        self.blackbox.as_mut().unwrap()
    }

    // Take field
    pub fn take_blackbox(&mut self) -> CMsgPaintKit_Definition_Item {
        self.blackbox.take().unwrap_or_else(|| CMsgPaintKit_Definition_Item::new())
    }

    // optional .CMsgPaintKit_Definition.Item claidheamohmor = 28;


    pub fn get_claidheamohmor(&self) -> &CMsgPaintKit_Definition_Item {
        self.claidheamohmor.as_ref().unwrap_or_else(|| <CMsgPaintKit_Definition_Item as ::protobuf::Message>::default_instance())
    }
    pub fn clear_claidheamohmor(&mut self) {
        self.claidheamohmor.clear();
    }

    pub fn has_claidheamohmor(&self) -> bool {
        self.claidheamohmor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_claidheamohmor(&mut self, v: CMsgPaintKit_Definition_Item) {
        self.claidheamohmor = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_claidheamohmor(&mut self) -> &mut CMsgPaintKit_Definition_Item {
        if self.claidheamohmor.is_none() {
            self.claidheamohmor.set_default();
        }
        self.claidheamohmor.as_mut().unwrap()
    }

    // Take field
    pub fn take_claidheamohmor(&mut self) -> CMsgPaintKit_Definition_Item {
        self.claidheamohmor.take().unwrap_or_else(|| CMsgPaintKit_Definition_Item::new())
    }

    // optional .CMsgPaintKit_Definition.Item crusaders_crossbow = 29;


    pub fn get_crusaders_crossbow(&self) -> &CMsgPaintKit_Definition_Item {
        self.crusaders_crossbow.as_ref().unwrap_or_else(|| <CMsgPaintKit_Definition_Item as ::protobuf::Message>::default_instance())
    }
    pub fn clear_crusaders_crossbow(&mut self) {
        self.crusaders_crossbow.clear();
    }

    pub fn has_crusaders_crossbow(&self) -> bool {
        self.crusaders_crossbow.is_some()
    }

    // Param is passed by value, moved
    pub fn set_crusaders_crossbow(&mut self, v: CMsgPaintKit_Definition_Item) {
        self.crusaders_crossbow = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_crusaders_crossbow(&mut self) -> &mut CMsgPaintKit_Definition_Item {
        if self.crusaders_crossbow.is_none() {
            self.crusaders_crossbow.set_default();
        }
        self.crusaders_crossbow.as_mut().unwrap()
    }

    // Take field
    pub fn take_crusaders_crossbow(&mut self) -> CMsgPaintKit_Definition_Item {
        self.crusaders_crossbow.take().unwrap_or_else(|| CMsgPaintKit_Definition_Item::new())
    }

    // optional .CMsgPaintKit_Definition.Item degreaser = 30;


    pub fn get_degreaser(&self) -> &CMsgPaintKit_Definition_Item {
        self.degreaser.as_ref().unwrap_or_else(|| <CMsgPaintKit_Definition_Item as ::protobuf::Message>::default_instance())
    }
    pub fn clear_degreaser(&mut self) {
        self.degreaser.clear();
    }

    pub fn has_degreaser(&self) -> bool {
        self.degreaser.is_some()
    }

    // Param is passed by value, moved
    pub fn set_degreaser(&mut self, v: CMsgPaintKit_Definition_Item) {
        self.degreaser = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_degreaser(&mut self) -> &mut CMsgPaintKit_Definition_Item {
        if self.degreaser.is_none() {
            self.degreaser.set_default();
        }
        self.degreaser.as_mut().unwrap()
    }

    // Take field
    pub fn take_degreaser(&mut self) -> CMsgPaintKit_Definition_Item {
        self.degreaser.take().unwrap_or_else(|| CMsgPaintKit_Definition_Item::new())
    }

    // optional .CMsgPaintKit_Definition.Item demo_cannon = 31;


    pub fn get_demo_cannon(&self) -> &CMsgPaintKit_Definition_Item {
        self.demo_cannon.as_ref().unwrap_or_else(|| <CMsgPaintKit_Definition_Item as ::protobuf::Message>::default_instance())
    }
    pub fn clear_demo_cannon(&mut self) {
        self.demo_cannon.clear();
    }

    pub fn has_demo_cannon(&self) -> bool {
        self.demo_cannon.is_some()
    }

    // Param is passed by value, moved
    pub fn set_demo_cannon(&mut self, v: CMsgPaintKit_Definition_Item) {
        self.demo_cannon = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_demo_cannon(&mut self) -> &mut CMsgPaintKit_Definition_Item {
        if self.demo_cannon.is_none() {
            self.demo_cannon.set_default();
        }
        self.demo_cannon.as_mut().unwrap()
    }

    // Take field
    pub fn take_demo_cannon(&mut self) -> CMsgPaintKit_Definition_Item {
        self.demo_cannon.take().unwrap_or_else(|| CMsgPaintKit_Definition_Item::new())
    }

    // optional .CMsgPaintKit_Definition.Item demo_sultan_sword = 32;


    pub fn get_demo_sultan_sword(&self) -> &CMsgPaintKit_Definition_Item {
        self.demo_sultan_sword.as_ref().unwrap_or_else(|| <CMsgPaintKit_Definition_Item as ::protobuf::Message>::default_instance())
    }
    pub fn clear_demo_sultan_sword(&mut self) {
        self.demo_sultan_sword.clear();
    }

    pub fn has_demo_sultan_sword(&self) -> bool {
        self.demo_sultan_sword.is_some()
    }

    // Param is passed by value, moved
    pub fn set_demo_sultan_sword(&mut self, v: CMsgPaintKit_Definition_Item) {
        self.demo_sultan_sword = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_demo_sultan_sword(&mut self) -> &mut CMsgPaintKit_Definition_Item {
        if self.demo_sultan_sword.is_none() {
            self.demo_sultan_sword.set_default();
        }
        self.demo_sultan_sword.as_mut().unwrap()
    }

    // Take field
    pub fn take_demo_sultan_sword(&mut self) -> CMsgPaintKit_Definition_Item {
        self.demo_sultan_sword.take().unwrap_or_else(|| CMsgPaintKit_Definition_Item::new())
    }

    // optional .CMsgPaintKit_Definition.Item detonator = 33;


    pub fn get_detonator(&self) -> &CMsgPaintKit_Definition_Item {
        self.detonator.as_ref().unwrap_or_else(|| <CMsgPaintKit_Definition_Item as ::protobuf::Message>::default_instance())
    }
    pub fn clear_detonator(&mut self) {
        self.detonator.clear();
    }

    pub fn has_detonator(&self) -> bool {
        self.detonator.is_some()
    }

    // Param is passed by value, moved
    pub fn set_detonator(&mut self, v: CMsgPaintKit_Definition_Item) {
        self.detonator = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_detonator(&mut self) -> &mut CMsgPaintKit_Definition_Item {
        if self.detonator.is_none() {
            self.detonator.set_default();
        }
        self.detonator.as_mut().unwrap()
    }

    // Take field
    pub fn take_detonator(&mut self) -> CMsgPaintKit_Definition_Item {
        self.detonator.take().unwrap_or_else(|| CMsgPaintKit_Definition_Item::new())
    }

    // optional .CMsgPaintKit_Definition.Item gatling_gun = 34;


    pub fn get_gatling_gun(&self) -> &CMsgPaintKit_Definition_Item {
        self.gatling_gun.as_ref().unwrap_or_else(|| <CMsgPaintKit_Definition_Item as ::protobuf::Message>::default_instance())
    }
    pub fn clear_gatling_gun(&mut self) {
        self.gatling_gun.clear();
    }

    pub fn has_gatling_gun(&self) -> bool {
        self.gatling_gun.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gatling_gun(&mut self, v: CMsgPaintKit_Definition_Item) {
        self.gatling_gun = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gatling_gun(&mut self) -> &mut CMsgPaintKit_Definition_Item {
        if self.gatling_gun.is_none() {
            self.gatling_gun.set_default();
        }
        self.gatling_gun.as_mut().unwrap()
    }

    // Take field
    pub fn take_gatling_gun(&mut self) -> CMsgPaintKit_Definition_Item {
        self.gatling_gun.take().unwrap_or_else(|| CMsgPaintKit_Definition_Item::new())
    }

    // optional .CMsgPaintKit_Definition.Item holymackerel = 35;


    pub fn get_holymackerel(&self) -> &CMsgPaintKit_Definition_Item {
        self.holymackerel.as_ref().unwrap_or_else(|| <CMsgPaintKit_Definition_Item as ::protobuf::Message>::default_instance())
    }
    pub fn clear_holymackerel(&mut self) {
        self.holymackerel.clear();
    }

    pub fn has_holymackerel(&self) -> bool {
        self.holymackerel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_holymackerel(&mut self, v: CMsgPaintKit_Definition_Item) {
        self.holymackerel = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_holymackerel(&mut self) -> &mut CMsgPaintKit_Definition_Item {
        if self.holymackerel.is_none() {
            self.holymackerel.set_default();
        }
        self.holymackerel.as_mut().unwrap()
    }

    // Take field
    pub fn take_holymackerel(&mut self) -> CMsgPaintKit_Definition_Item {
        self.holymackerel.take().unwrap_or_else(|| CMsgPaintKit_Definition_Item::new())
    }

    // optional .CMsgPaintKit_Definition.Item jag = 36;


    pub fn get_jag(&self) -> &CMsgPaintKit_Definition_Item {
        self.jag.as_ref().unwrap_or_else(|| <CMsgPaintKit_Definition_Item as ::protobuf::Message>::default_instance())
    }
    pub fn clear_jag(&mut self) {
        self.jag.clear();
    }

    pub fn has_jag(&self) -> bool {
        self.jag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_jag(&mut self, v: CMsgPaintKit_Definition_Item) {
        self.jag = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_jag(&mut self) -> &mut CMsgPaintKit_Definition_Item {
        if self.jag.is_none() {
            self.jag.set_default();
        }
        self.jag.as_mut().unwrap()
    }

    // Take field
    pub fn take_jag(&mut self) -> CMsgPaintKit_Definition_Item {
        self.jag.take().unwrap_or_else(|| CMsgPaintKit_Definition_Item::new())
    }

    // optional .CMsgPaintKit_Definition.Item lochnload = 37;


    pub fn get_lochnload(&self) -> &CMsgPaintKit_Definition_Item {
        self.lochnload.as_ref().unwrap_or_else(|| <CMsgPaintKit_Definition_Item as ::protobuf::Message>::default_instance())
    }
    pub fn clear_lochnload(&mut self) {
        self.lochnload.clear();
    }

    pub fn has_lochnload(&self) -> bool {
        self.lochnload.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lochnload(&mut self, v: CMsgPaintKit_Definition_Item) {
        self.lochnload = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lochnload(&mut self) -> &mut CMsgPaintKit_Definition_Item {
        if self.lochnload.is_none() {
            self.lochnload.set_default();
        }
        self.lochnload.as_mut().unwrap()
    }

    // Take field
    pub fn take_lochnload(&mut self) -> CMsgPaintKit_Definition_Item {
        self.lochnload.take().unwrap_or_else(|| CMsgPaintKit_Definition_Item::new())
    }

    // optional .CMsgPaintKit_Definition.Item powerjack = 38;


    pub fn get_powerjack(&self) -> &CMsgPaintKit_Definition_Item {
        self.powerjack.as_ref().unwrap_or_else(|| <CMsgPaintKit_Definition_Item as ::protobuf::Message>::default_instance())
    }
    pub fn clear_powerjack(&mut self) {
        self.powerjack.clear();
    }

    pub fn has_powerjack(&self) -> bool {
        self.powerjack.is_some()
    }

    // Param is passed by value, moved
    pub fn set_powerjack(&mut self, v: CMsgPaintKit_Definition_Item) {
        self.powerjack = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_powerjack(&mut self) -> &mut CMsgPaintKit_Definition_Item {
        if self.powerjack.is_none() {
            self.powerjack.set_default();
        }
        self.powerjack.as_mut().unwrap()
    }

    // Take field
    pub fn take_powerjack(&mut self) -> CMsgPaintKit_Definition_Item {
        self.powerjack.take().unwrap_or_else(|| CMsgPaintKit_Definition_Item::new())
    }

    // optional .CMsgPaintKit_Definition.Item quadball = 39;


    pub fn get_quadball(&self) -> &CMsgPaintKit_Definition_Item {
        self.quadball.as_ref().unwrap_or_else(|| <CMsgPaintKit_Definition_Item as ::protobuf::Message>::default_instance())
    }
    pub fn clear_quadball(&mut self) {
        self.quadball.clear();
    }

    pub fn has_quadball(&self) -> bool {
        self.quadball.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quadball(&mut self, v: CMsgPaintKit_Definition_Item) {
        self.quadball = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_quadball(&mut self) -> &mut CMsgPaintKit_Definition_Item {
        if self.quadball.is_none() {
            self.quadball.set_default();
        }
        self.quadball.as_mut().unwrap()
    }

    // Take field
    pub fn take_quadball(&mut self) -> CMsgPaintKit_Definition_Item {
        self.quadball.take().unwrap_or_else(|| CMsgPaintKit_Definition_Item::new())
    }

    // optional .CMsgPaintKit_Definition.Item reserve_shooter = 40;


    pub fn get_reserve_shooter(&self) -> &CMsgPaintKit_Definition_Item {
        self.reserve_shooter.as_ref().unwrap_or_else(|| <CMsgPaintKit_Definition_Item as ::protobuf::Message>::default_instance())
    }
    pub fn clear_reserve_shooter(&mut self) {
        self.reserve_shooter.clear();
    }

    pub fn has_reserve_shooter(&self) -> bool {
        self.reserve_shooter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reserve_shooter(&mut self, v: CMsgPaintKit_Definition_Item) {
        self.reserve_shooter = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reserve_shooter(&mut self) -> &mut CMsgPaintKit_Definition_Item {
        if self.reserve_shooter.is_none() {
            self.reserve_shooter.set_default();
        }
        self.reserve_shooter.as_mut().unwrap()
    }

    // Take field
    pub fn take_reserve_shooter(&mut self) -> CMsgPaintKit_Definition_Item {
        self.reserve_shooter.take().unwrap_or_else(|| CMsgPaintKit_Definition_Item::new())
    }

    // optional .CMsgPaintKit_Definition.Item riding_crop = 41;


    pub fn get_riding_crop(&self) -> &CMsgPaintKit_Definition_Item {
        self.riding_crop.as_ref().unwrap_or_else(|| <CMsgPaintKit_Definition_Item as ::protobuf::Message>::default_instance())
    }
    pub fn clear_riding_crop(&mut self) {
        self.riding_crop.clear();
    }

    pub fn has_riding_crop(&self) -> bool {
        self.riding_crop.is_some()
    }

    // Param is passed by value, moved
    pub fn set_riding_crop(&mut self, v: CMsgPaintKit_Definition_Item) {
        self.riding_crop = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_riding_crop(&mut self) -> &mut CMsgPaintKit_Definition_Item {
        if self.riding_crop.is_none() {
            self.riding_crop.set_default();
        }
        self.riding_crop.as_mut().unwrap()
    }

    // Take field
    pub fn take_riding_crop(&mut self) -> CMsgPaintKit_Definition_Item {
        self.riding_crop.take().unwrap_or_else(|| CMsgPaintKit_Definition_Item::new())
    }

    // optional .CMsgPaintKit_Definition.Item russian_riot = 42;


    pub fn get_russian_riot(&self) -> &CMsgPaintKit_Definition_Item {
        self.russian_riot.as_ref().unwrap_or_else(|| <CMsgPaintKit_Definition_Item as ::protobuf::Message>::default_instance())
    }
    pub fn clear_russian_riot(&mut self) {
        self.russian_riot.clear();
    }

    pub fn has_russian_riot(&self) -> bool {
        self.russian_riot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_russian_riot(&mut self, v: CMsgPaintKit_Definition_Item) {
        self.russian_riot = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_russian_riot(&mut self) -> &mut CMsgPaintKit_Definition_Item {
        if self.russian_riot.is_none() {
            self.russian_riot.set_default();
        }
        self.russian_riot.as_mut().unwrap()
    }

    // Take field
    pub fn take_russian_riot(&mut self) -> CMsgPaintKit_Definition_Item {
        self.russian_riot.take().unwrap_or_else(|| CMsgPaintKit_Definition_Item::new())
    }

    // optional .CMsgPaintKit_Definition.Item scimitar = 43;


    pub fn get_scimitar(&self) -> &CMsgPaintKit_Definition_Item {
        self.scimitar.as_ref().unwrap_or_else(|| <CMsgPaintKit_Definition_Item as ::protobuf::Message>::default_instance())
    }
    pub fn clear_scimitar(&mut self) {
        self.scimitar.clear();
    }

    pub fn has_scimitar(&self) -> bool {
        self.scimitar.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scimitar(&mut self, v: CMsgPaintKit_Definition_Item) {
        self.scimitar = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_scimitar(&mut self) -> &mut CMsgPaintKit_Definition_Item {
        if self.scimitar.is_none() {
            self.scimitar.set_default();
        }
        self.scimitar.as_mut().unwrap()
    }

    // Take field
    pub fn take_scimitar(&mut self) -> CMsgPaintKit_Definition_Item {
        self.scimitar.take().unwrap_or_else(|| CMsgPaintKit_Definition_Item::new())
    }

    // optional .CMsgPaintKit_Definition.Item scorch_shot = 44;


    pub fn get_scorch_shot(&self) -> &CMsgPaintKit_Definition_Item {
        self.scorch_shot.as_ref().unwrap_or_else(|| <CMsgPaintKit_Definition_Item as ::protobuf::Message>::default_instance())
    }
    pub fn clear_scorch_shot(&mut self) {
        self.scorch_shot.clear();
    }

    pub fn has_scorch_shot(&self) -> bool {
        self.scorch_shot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scorch_shot(&mut self, v: CMsgPaintKit_Definition_Item) {
        self.scorch_shot = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_scorch_shot(&mut self) -> &mut CMsgPaintKit_Definition_Item {
        if self.scorch_shot.is_none() {
            self.scorch_shot.set_default();
        }
        self.scorch_shot.as_mut().unwrap()
    }

    // Take field
    pub fn take_scorch_shot(&mut self) -> CMsgPaintKit_Definition_Item {
        self.scorch_shot.take().unwrap_or_else(|| CMsgPaintKit_Definition_Item::new())
    }

    // optional .CMsgPaintKit_Definition.Item shortstop = 45;


    pub fn get_shortstop(&self) -> &CMsgPaintKit_Definition_Item {
        self.shortstop.as_ref().unwrap_or_else(|| <CMsgPaintKit_Definition_Item as ::protobuf::Message>::default_instance())
    }
    pub fn clear_shortstop(&mut self) {
        self.shortstop.clear();
    }

    pub fn has_shortstop(&self) -> bool {
        self.shortstop.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shortstop(&mut self, v: CMsgPaintKit_Definition_Item) {
        self.shortstop = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_shortstop(&mut self) -> &mut CMsgPaintKit_Definition_Item {
        if self.shortstop.is_none() {
            self.shortstop.set_default();
        }
        self.shortstop.as_mut().unwrap()
    }

    // Take field
    pub fn take_shortstop(&mut self) -> CMsgPaintKit_Definition_Item {
        self.shortstop.take().unwrap_or_else(|| CMsgPaintKit_Definition_Item::new())
    }

    // optional .CMsgPaintKit_Definition.Item soda_popper = 46;


    pub fn get_soda_popper(&self) -> &CMsgPaintKit_Definition_Item {
        self.soda_popper.as_ref().unwrap_or_else(|| <CMsgPaintKit_Definition_Item as ::protobuf::Message>::default_instance())
    }
    pub fn clear_soda_popper(&mut self) {
        self.soda_popper.clear();
    }

    pub fn has_soda_popper(&self) -> bool {
        self.soda_popper.is_some()
    }

    // Param is passed by value, moved
    pub fn set_soda_popper(&mut self, v: CMsgPaintKit_Definition_Item) {
        self.soda_popper = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_soda_popper(&mut self) -> &mut CMsgPaintKit_Definition_Item {
        if self.soda_popper.is_none() {
            self.soda_popper.set_default();
        }
        self.soda_popper.as_mut().unwrap()
    }

    // Take field
    pub fn take_soda_popper(&mut self) -> CMsgPaintKit_Definition_Item {
        self.soda_popper.take().unwrap_or_else(|| CMsgPaintKit_Definition_Item::new())
    }

    // optional .CMsgPaintKit_Definition.Item tele_shotgun = 47;


    pub fn get_tele_shotgun(&self) -> &CMsgPaintKit_Definition_Item {
        self.tele_shotgun.as_ref().unwrap_or_else(|| <CMsgPaintKit_Definition_Item as ::protobuf::Message>::default_instance())
    }
    pub fn clear_tele_shotgun(&mut self) {
        self.tele_shotgun.clear();
    }

    pub fn has_tele_shotgun(&self) -> bool {
        self.tele_shotgun.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tele_shotgun(&mut self, v: CMsgPaintKit_Definition_Item) {
        self.tele_shotgun = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tele_shotgun(&mut self) -> &mut CMsgPaintKit_Definition_Item {
        if self.tele_shotgun.is_none() {
            self.tele_shotgun.set_default();
        }
        self.tele_shotgun.as_mut().unwrap()
    }

    // Take field
    pub fn take_tele_shotgun(&mut self) -> CMsgPaintKit_Definition_Item {
        self.tele_shotgun.take().unwrap_or_else(|| CMsgPaintKit_Definition_Item::new())
    }

    // optional .CMsgPaintKit_Definition.Item tomislav = 48;


    pub fn get_tomislav(&self) -> &CMsgPaintKit_Definition_Item {
        self.tomislav.as_ref().unwrap_or_else(|| <CMsgPaintKit_Definition_Item as ::protobuf::Message>::default_instance())
    }
    pub fn clear_tomislav(&mut self) {
        self.tomislav.clear();
    }

    pub fn has_tomislav(&self) -> bool {
        self.tomislav.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tomislav(&mut self, v: CMsgPaintKit_Definition_Item) {
        self.tomislav = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tomislav(&mut self) -> &mut CMsgPaintKit_Definition_Item {
        if self.tomislav.is_none() {
            self.tomislav.set_default();
        }
        self.tomislav.as_mut().unwrap()
    }

    // Take field
    pub fn take_tomislav(&mut self) -> CMsgPaintKit_Definition_Item {
        self.tomislav.take().unwrap_or_else(|| CMsgPaintKit_Definition_Item::new())
    }

    // optional .CMsgPaintKit_Definition.Item trenchgun = 49;


    pub fn get_trenchgun(&self) -> &CMsgPaintKit_Definition_Item {
        self.trenchgun.as_ref().unwrap_or_else(|| <CMsgPaintKit_Definition_Item as ::protobuf::Message>::default_instance())
    }
    pub fn clear_trenchgun(&mut self) {
        self.trenchgun.clear();
    }

    pub fn has_trenchgun(&self) -> bool {
        self.trenchgun.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trenchgun(&mut self, v: CMsgPaintKit_Definition_Item) {
        self.trenchgun = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trenchgun(&mut self) -> &mut CMsgPaintKit_Definition_Item {
        if self.trenchgun.is_none() {
            self.trenchgun.set_default();
        }
        self.trenchgun.as_mut().unwrap()
    }

    // Take field
    pub fn take_trenchgun(&mut self) -> CMsgPaintKit_Definition_Item {
        self.trenchgun.take().unwrap_or_else(|| CMsgPaintKit_Definition_Item::new())
    }

    // optional .CMsgPaintKit_Definition.Item winger_pistol = 50;


    pub fn get_winger_pistol(&self) -> &CMsgPaintKit_Definition_Item {
        self.winger_pistol.as_ref().unwrap_or_else(|| <CMsgPaintKit_Definition_Item as ::protobuf::Message>::default_instance())
    }
    pub fn clear_winger_pistol(&mut self) {
        self.winger_pistol.clear();
    }

    pub fn has_winger_pistol(&self) -> bool {
        self.winger_pistol.is_some()
    }

    // Param is passed by value, moved
    pub fn set_winger_pistol(&mut self, v: CMsgPaintKit_Definition_Item) {
        self.winger_pistol = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_winger_pistol(&mut self) -> &mut CMsgPaintKit_Definition_Item {
        if self.winger_pistol.is_none() {
            self.winger_pistol.set_default();
        }
        self.winger_pistol.as_mut().unwrap()
    }

    // Take field
    pub fn take_winger_pistol(&mut self) -> CMsgPaintKit_Definition_Item {
        self.winger_pistol.take().unwrap_or_else(|| CMsgPaintKit_Definition_Item::new())
    }
}

impl ::protobuf::Message for CMsgPaintKit_Definition {
    fn is_initialized(&self) -> bool {
        if self.header.is_none() {
            return false;
        }
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.operation_template {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.item {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.paintkit_tool {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.flamethrower {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.grenadelauncher {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.knife {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.medigun {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.minigun {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pistol {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.revolver {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.rocketlauncher {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.scattergun {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.shotgun {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.smg {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sniperrifle {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.stickybomb_launcher {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ubersaw {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.wrench {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.amputator {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.atom_launcher {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.back_scratcher {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.battleaxe {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.bazaar_sniper {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.blackbox {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.claidheamohmor {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.crusaders_crossbow {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.degreaser {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.demo_cannon {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.demo_sultan_sword {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.detonator {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.gatling_gun {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.holymackerel {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.jag {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.lochnload {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.powerjack {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.quadball {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.reserve_shooter {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.riding_crop {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.russian_riot {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.scimitar {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.scorch_shot {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.shortstop {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.soda_popper {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tele_shotgun {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tomislav {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.trenchgun {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.winger_pistol {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.loc_desctoken)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.operation_template)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_team_textures = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.item)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.paintkit_tool)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.flamethrower)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.grenadelauncher)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.knife)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.medigun)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.minigun)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pistol)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.revolver)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.rocketlauncher)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.scattergun)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.shotgun)?;
                },
                17 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.smg)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sniperrifle)?;
                },
                19 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.stickybomb_launcher)?;
                },
                20 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ubersaw)?;
                },
                21 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.wrench)?;
                },
                22 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.amputator)?;
                },
                23 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.atom_launcher)?;
                },
                24 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.back_scratcher)?;
                },
                25 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.battleaxe)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.bazaar_sniper)?;
                },
                27 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.blackbox)?;
                },
                28 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.claidheamohmor)?;
                },
                29 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.crusaders_crossbow)?;
                },
                30 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.degreaser)?;
                },
                31 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.demo_cannon)?;
                },
                32 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.demo_sultan_sword)?;
                },
                33 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.detonator)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.gatling_gun)?;
                },
                35 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.holymackerel)?;
                },
                36 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.jag)?;
                },
                37 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.lochnload)?;
                },
                38 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.powerjack)?;
                },
                39 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.quadball)?;
                },
                40 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.reserve_shooter)?;
                },
                41 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.riding_crop)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.russian_riot)?;
                },
                43 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.scimitar)?;
                },
                44 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.scorch_shot)?;
                },
                45 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.shortstop)?;
                },
                46 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.soda_popper)?;
                },
                47 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.tele_shotgun)?;
                },
                48 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.tomislav)?;
                },
                49 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.trenchgun)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.winger_pistol)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.loc_desctoken.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.operation_template.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.has_team_textures {
            my_size += 2;
        }
        for value in &self.item {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.paintkit_tool.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.flamethrower.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.grenadelauncher.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.knife.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.medigun.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.minigun.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.pistol.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.revolver.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.rocketlauncher.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.scattergun.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.shotgun.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.smg.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.sniperrifle.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.stickybomb_launcher.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.ubersaw.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.wrench.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.amputator.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.atom_launcher.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.back_scratcher.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.battleaxe.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.bazaar_sniper.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.blackbox.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.claidheamohmor.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.crusaders_crossbow.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.degreaser.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.demo_cannon.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.demo_sultan_sword.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.detonator.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.gatling_gun.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.holymackerel.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.jag.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.lochnload.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.powerjack.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.quadball.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.reserve_shooter.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.riding_crop.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.russian_riot.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.scimitar.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.scorch_shot.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.shortstop.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.soda_popper.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.tele_shotgun.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.tomislav.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.trenchgun.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.winger_pistol.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.loc_desctoken.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.operation_template.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.has_team_textures {
            os.write_bool(4, v)?;
        }
        for v in &self.item {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.paintkit_tool.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.flamethrower.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.grenadelauncher.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.knife.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.medigun.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.minigun.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.pistol.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.revolver.as_ref() {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.rocketlauncher.as_ref() {
            os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.scattergun.as_ref() {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.shotgun.as_ref() {
            os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.smg.as_ref() {
            os.write_tag(17, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.sniperrifle.as_ref() {
            os.write_tag(18, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.stickybomb_launcher.as_ref() {
            os.write_tag(19, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.ubersaw.as_ref() {
            os.write_tag(20, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.wrench.as_ref() {
            os.write_tag(21, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.amputator.as_ref() {
            os.write_tag(22, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.atom_launcher.as_ref() {
            os.write_tag(23, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.back_scratcher.as_ref() {
            os.write_tag(24, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.battleaxe.as_ref() {
            os.write_tag(25, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.bazaar_sniper.as_ref() {
            os.write_tag(26, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.blackbox.as_ref() {
            os.write_tag(27, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.claidheamohmor.as_ref() {
            os.write_tag(28, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.crusaders_crossbow.as_ref() {
            os.write_tag(29, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.degreaser.as_ref() {
            os.write_tag(30, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.demo_cannon.as_ref() {
            os.write_tag(31, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.demo_sultan_sword.as_ref() {
            os.write_tag(32, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.detonator.as_ref() {
            os.write_tag(33, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.gatling_gun.as_ref() {
            os.write_tag(34, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.holymackerel.as_ref() {
            os.write_tag(35, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.jag.as_ref() {
            os.write_tag(36, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.lochnload.as_ref() {
            os.write_tag(37, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.powerjack.as_ref() {
            os.write_tag(38, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.quadball.as_ref() {
            os.write_tag(39, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.reserve_shooter.as_ref() {
            os.write_tag(40, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.riding_crop.as_ref() {
            os.write_tag(41, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.russian_riot.as_ref() {
            os.write_tag(42, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.scimitar.as_ref() {
            os.write_tag(43, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.scorch_shot.as_ref() {
            os.write_tag(44, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.shortstop.as_ref() {
            os.write_tag(45, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.soda_popper.as_ref() {
            os.write_tag(46, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.tele_shotgun.as_ref() {
            os.write_tag(47, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.tomislav.as_ref() {
            os.write_tag(48, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.trenchgun.as_ref() {
            os.write_tag(49, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.winger_pistol.as_ref() {
            os.write_tag(50, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgPaintKit_Definition {
        CMsgPaintKit_Definition::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgProtoDefHeader>>(
                "header",
                |m: &CMsgPaintKit_Definition| { &m.header },
                |m: &mut CMsgPaintKit_Definition| { &mut m.header },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "loc_desctoken",
                |m: &CMsgPaintKit_Definition| { &m.loc_desctoken },
                |m: &mut CMsgPaintKit_Definition| { &mut m.loc_desctoken },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgProtoDefID>>(
                "operation_template",
                |m: &CMsgPaintKit_Definition| { &m.operation_template },
                |m: &mut CMsgPaintKit_Definition| { &mut m.operation_template },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "has_team_textures",
                |m: &CMsgPaintKit_Definition| { &m.has_team_textures },
                |m: &mut CMsgPaintKit_Definition| { &mut m.has_team_textures },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgPaintKit_Definition_Item>>(
                "item",
                |m: &CMsgPaintKit_Definition| { &m.item },
                |m: &mut CMsgPaintKit_Definition| { &mut m.item },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgPaintKit_Definition_Item>>(
                "paintkit_tool",
                |m: &CMsgPaintKit_Definition| { &m.paintkit_tool },
                |m: &mut CMsgPaintKit_Definition| { &mut m.paintkit_tool },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgPaintKit_Definition_Item>>(
                "flamethrower",
                |m: &CMsgPaintKit_Definition| { &m.flamethrower },
                |m: &mut CMsgPaintKit_Definition| { &mut m.flamethrower },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgPaintKit_Definition_Item>>(
                "grenadelauncher",
                |m: &CMsgPaintKit_Definition| { &m.grenadelauncher },
                |m: &mut CMsgPaintKit_Definition| { &mut m.grenadelauncher },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgPaintKit_Definition_Item>>(
                "knife",
                |m: &CMsgPaintKit_Definition| { &m.knife },
                |m: &mut CMsgPaintKit_Definition| { &mut m.knife },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgPaintKit_Definition_Item>>(
                "medigun",
                |m: &CMsgPaintKit_Definition| { &m.medigun },
                |m: &mut CMsgPaintKit_Definition| { &mut m.medigun },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgPaintKit_Definition_Item>>(
                "minigun",
                |m: &CMsgPaintKit_Definition| { &m.minigun },
                |m: &mut CMsgPaintKit_Definition| { &mut m.minigun },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgPaintKit_Definition_Item>>(
                "pistol",
                |m: &CMsgPaintKit_Definition| { &m.pistol },
                |m: &mut CMsgPaintKit_Definition| { &mut m.pistol },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgPaintKit_Definition_Item>>(
                "revolver",
                |m: &CMsgPaintKit_Definition| { &m.revolver },
                |m: &mut CMsgPaintKit_Definition| { &mut m.revolver },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgPaintKit_Definition_Item>>(
                "rocketlauncher",
                |m: &CMsgPaintKit_Definition| { &m.rocketlauncher },
                |m: &mut CMsgPaintKit_Definition| { &mut m.rocketlauncher },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgPaintKit_Definition_Item>>(
                "scattergun",
                |m: &CMsgPaintKit_Definition| { &m.scattergun },
                |m: &mut CMsgPaintKit_Definition| { &mut m.scattergun },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgPaintKit_Definition_Item>>(
                "shotgun",
                |m: &CMsgPaintKit_Definition| { &m.shotgun },
                |m: &mut CMsgPaintKit_Definition| { &mut m.shotgun },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgPaintKit_Definition_Item>>(
                "smg",
                |m: &CMsgPaintKit_Definition| { &m.smg },
                |m: &mut CMsgPaintKit_Definition| { &mut m.smg },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgPaintKit_Definition_Item>>(
                "sniperrifle",
                |m: &CMsgPaintKit_Definition| { &m.sniperrifle },
                |m: &mut CMsgPaintKit_Definition| { &mut m.sniperrifle },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgPaintKit_Definition_Item>>(
                "stickybomb_launcher",
                |m: &CMsgPaintKit_Definition| { &m.stickybomb_launcher },
                |m: &mut CMsgPaintKit_Definition| { &mut m.stickybomb_launcher },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgPaintKit_Definition_Item>>(
                "ubersaw",
                |m: &CMsgPaintKit_Definition| { &m.ubersaw },
                |m: &mut CMsgPaintKit_Definition| { &mut m.ubersaw },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgPaintKit_Definition_Item>>(
                "wrench",
                |m: &CMsgPaintKit_Definition| { &m.wrench },
                |m: &mut CMsgPaintKit_Definition| { &mut m.wrench },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgPaintKit_Definition_Item>>(
                "amputator",
                |m: &CMsgPaintKit_Definition| { &m.amputator },
                |m: &mut CMsgPaintKit_Definition| { &mut m.amputator },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgPaintKit_Definition_Item>>(
                "atom_launcher",
                |m: &CMsgPaintKit_Definition| { &m.atom_launcher },
                |m: &mut CMsgPaintKit_Definition| { &mut m.atom_launcher },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgPaintKit_Definition_Item>>(
                "back_scratcher",
                |m: &CMsgPaintKit_Definition| { &m.back_scratcher },
                |m: &mut CMsgPaintKit_Definition| { &mut m.back_scratcher },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgPaintKit_Definition_Item>>(
                "battleaxe",
                |m: &CMsgPaintKit_Definition| { &m.battleaxe },
                |m: &mut CMsgPaintKit_Definition| { &mut m.battleaxe },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgPaintKit_Definition_Item>>(
                "bazaar_sniper",
                |m: &CMsgPaintKit_Definition| { &m.bazaar_sniper },
                |m: &mut CMsgPaintKit_Definition| { &mut m.bazaar_sniper },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgPaintKit_Definition_Item>>(
                "blackbox",
                |m: &CMsgPaintKit_Definition| { &m.blackbox },
                |m: &mut CMsgPaintKit_Definition| { &mut m.blackbox },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgPaintKit_Definition_Item>>(
                "claidheamohmor",
                |m: &CMsgPaintKit_Definition| { &m.claidheamohmor },
                |m: &mut CMsgPaintKit_Definition| { &mut m.claidheamohmor },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgPaintKit_Definition_Item>>(
                "crusaders_crossbow",
                |m: &CMsgPaintKit_Definition| { &m.crusaders_crossbow },
                |m: &mut CMsgPaintKit_Definition| { &mut m.crusaders_crossbow },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgPaintKit_Definition_Item>>(
                "degreaser",
                |m: &CMsgPaintKit_Definition| { &m.degreaser },
                |m: &mut CMsgPaintKit_Definition| { &mut m.degreaser },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgPaintKit_Definition_Item>>(
                "demo_cannon",
                |m: &CMsgPaintKit_Definition| { &m.demo_cannon },
                |m: &mut CMsgPaintKit_Definition| { &mut m.demo_cannon },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgPaintKit_Definition_Item>>(
                "demo_sultan_sword",
                |m: &CMsgPaintKit_Definition| { &m.demo_sultan_sword },
                |m: &mut CMsgPaintKit_Definition| { &mut m.demo_sultan_sword },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgPaintKit_Definition_Item>>(
                "detonator",
                |m: &CMsgPaintKit_Definition| { &m.detonator },
                |m: &mut CMsgPaintKit_Definition| { &mut m.detonator },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgPaintKit_Definition_Item>>(
                "gatling_gun",
                |m: &CMsgPaintKit_Definition| { &m.gatling_gun },
                |m: &mut CMsgPaintKit_Definition| { &mut m.gatling_gun },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgPaintKit_Definition_Item>>(
                "holymackerel",
                |m: &CMsgPaintKit_Definition| { &m.holymackerel },
                |m: &mut CMsgPaintKit_Definition| { &mut m.holymackerel },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgPaintKit_Definition_Item>>(
                "jag",
                |m: &CMsgPaintKit_Definition| { &m.jag },
                |m: &mut CMsgPaintKit_Definition| { &mut m.jag },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgPaintKit_Definition_Item>>(
                "lochnload",
                |m: &CMsgPaintKit_Definition| { &m.lochnload },
                |m: &mut CMsgPaintKit_Definition| { &mut m.lochnload },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgPaintKit_Definition_Item>>(
                "powerjack",
                |m: &CMsgPaintKit_Definition| { &m.powerjack },
                |m: &mut CMsgPaintKit_Definition| { &mut m.powerjack },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgPaintKit_Definition_Item>>(
                "quadball",
                |m: &CMsgPaintKit_Definition| { &m.quadball },
                |m: &mut CMsgPaintKit_Definition| { &mut m.quadball },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgPaintKit_Definition_Item>>(
                "reserve_shooter",
                |m: &CMsgPaintKit_Definition| { &m.reserve_shooter },
                |m: &mut CMsgPaintKit_Definition| { &mut m.reserve_shooter },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgPaintKit_Definition_Item>>(
                "riding_crop",
                |m: &CMsgPaintKit_Definition| { &m.riding_crop },
                |m: &mut CMsgPaintKit_Definition| { &mut m.riding_crop },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgPaintKit_Definition_Item>>(
                "russian_riot",
                |m: &CMsgPaintKit_Definition| { &m.russian_riot },
                |m: &mut CMsgPaintKit_Definition| { &mut m.russian_riot },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgPaintKit_Definition_Item>>(
                "scimitar",
                |m: &CMsgPaintKit_Definition| { &m.scimitar },
                |m: &mut CMsgPaintKit_Definition| { &mut m.scimitar },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgPaintKit_Definition_Item>>(
                "scorch_shot",
                |m: &CMsgPaintKit_Definition| { &m.scorch_shot },
                |m: &mut CMsgPaintKit_Definition| { &mut m.scorch_shot },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgPaintKit_Definition_Item>>(
                "shortstop",
                |m: &CMsgPaintKit_Definition| { &m.shortstop },
                |m: &mut CMsgPaintKit_Definition| { &mut m.shortstop },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgPaintKit_Definition_Item>>(
                "soda_popper",
                |m: &CMsgPaintKit_Definition| { &m.soda_popper },
                |m: &mut CMsgPaintKit_Definition| { &mut m.soda_popper },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgPaintKit_Definition_Item>>(
                "tele_shotgun",
                |m: &CMsgPaintKit_Definition| { &m.tele_shotgun },
                |m: &mut CMsgPaintKit_Definition| { &mut m.tele_shotgun },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgPaintKit_Definition_Item>>(
                "tomislav",
                |m: &CMsgPaintKit_Definition| { &m.tomislav },
                |m: &mut CMsgPaintKit_Definition| { &mut m.tomislav },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgPaintKit_Definition_Item>>(
                "trenchgun",
                |m: &CMsgPaintKit_Definition| { &m.trenchgun },
                |m: &mut CMsgPaintKit_Definition| { &mut m.trenchgun },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgPaintKit_Definition_Item>>(
                "winger_pistol",
                |m: &CMsgPaintKit_Definition| { &m.winger_pistol },
                |m: &mut CMsgPaintKit_Definition| { &mut m.winger_pistol },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgPaintKit_Definition>(
                "CMsgPaintKit_Definition",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgPaintKit_Definition {
        static instance: ::protobuf::rt::LazyV2<CMsgPaintKit_Definition> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgPaintKit_Definition::new)
    }
}

impl ::protobuf::Clear for CMsgPaintKit_Definition {
    fn clear(&mut self) {
        self.header.clear();
        self.loc_desctoken.clear();
        self.operation_template.clear();
        self.has_team_textures = ::std::option::Option::None;
        self.item.clear();
        self.paintkit_tool.clear();
        self.flamethrower.clear();
        self.grenadelauncher.clear();
        self.knife.clear();
        self.medigun.clear();
        self.minigun.clear();
        self.pistol.clear();
        self.revolver.clear();
        self.rocketlauncher.clear();
        self.scattergun.clear();
        self.shotgun.clear();
        self.smg.clear();
        self.sniperrifle.clear();
        self.stickybomb_launcher.clear();
        self.ubersaw.clear();
        self.wrench.clear();
        self.amputator.clear();
        self.atom_launcher.clear();
        self.back_scratcher.clear();
        self.battleaxe.clear();
        self.bazaar_sniper.clear();
        self.blackbox.clear();
        self.claidheamohmor.clear();
        self.crusaders_crossbow.clear();
        self.degreaser.clear();
        self.demo_cannon.clear();
        self.demo_sultan_sword.clear();
        self.detonator.clear();
        self.gatling_gun.clear();
        self.holymackerel.clear();
        self.jag.clear();
        self.lochnload.clear();
        self.powerjack.clear();
        self.quadball.clear();
        self.reserve_shooter.clear();
        self.riding_crop.clear();
        self.russian_riot.clear();
        self.scimitar.clear();
        self.scorch_shot.clear();
        self.shortstop.clear();
        self.soda_popper.clear();
        self.tele_shotgun.clear();
        self.tomislav.clear();
        self.trenchgun.clear();
        self.winger_pistol.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgPaintKit_Definition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPaintKit_Definition {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgPaintKit_Definition_Item {
    // message fields
    pub item_definition_template: ::protobuf::SingularPtrField<CMsgProtoDefID>,
    pub data: ::protobuf::SingularPtrField<CMsgPaintKit_Definition_Item_ItemData>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgPaintKit_Definition_Item {
    fn default() -> &'a CMsgPaintKit_Definition_Item {
        <CMsgPaintKit_Definition_Item as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPaintKit_Definition_Item {
    pub fn new() -> CMsgPaintKit_Definition_Item {
        ::std::default::Default::default()
    }

    // required .CMsgProtoDefID item_definition_template = 1;


    pub fn get_item_definition_template(&self) -> &CMsgProtoDefID {
        self.item_definition_template.as_ref().unwrap_or_else(|| <CMsgProtoDefID as ::protobuf::Message>::default_instance())
    }
    pub fn clear_item_definition_template(&mut self) {
        self.item_definition_template.clear();
    }

    pub fn has_item_definition_template(&self) -> bool {
        self.item_definition_template.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_definition_template(&mut self, v: CMsgProtoDefID) {
        self.item_definition_template = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_item_definition_template(&mut self) -> &mut CMsgProtoDefID {
        if self.item_definition_template.is_none() {
            self.item_definition_template.set_default();
        }
        self.item_definition_template.as_mut().unwrap()
    }

    // Take field
    pub fn take_item_definition_template(&mut self) -> CMsgProtoDefID {
        self.item_definition_template.take().unwrap_or_else(|| CMsgProtoDefID::new())
    }

    // optional .CMsgPaintKit_Definition.Item.ItemData data = 5;


    pub fn get_data(&self) -> &CMsgPaintKit_Definition_Item_ItemData {
        self.data.as_ref().unwrap_or_else(|| <CMsgPaintKit_Definition_Item_ItemData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: CMsgPaintKit_Definition_Item_ItemData) {
        self.data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut CMsgPaintKit_Definition_Item_ItemData {
        if self.data.is_none() {
            self.data.set_default();
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> CMsgPaintKit_Definition_Item_ItemData {
        self.data.take().unwrap_or_else(|| CMsgPaintKit_Definition_Item_ItemData::new())
    }
}

impl ::protobuf::Message for CMsgPaintKit_Definition_Item {
    fn is_initialized(&self) -> bool {
        if self.item_definition_template.is_none() {
            return false;
        }
        for v in &self.item_definition_template {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.item_definition_template)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.item_definition_template.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.item_definition_template.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.data.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgPaintKit_Definition_Item {
        CMsgPaintKit_Definition_Item::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgProtoDefID>>(
                "item_definition_template",
                |m: &CMsgPaintKit_Definition_Item| { &m.item_definition_template },
                |m: &mut CMsgPaintKit_Definition_Item| { &mut m.item_definition_template },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgPaintKit_Definition_Item_ItemData>>(
                "data",
                |m: &CMsgPaintKit_Definition_Item| { &m.data },
                |m: &mut CMsgPaintKit_Definition_Item| { &mut m.data },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgPaintKit_Definition_Item>(
                "CMsgPaintKit_Definition.Item",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgPaintKit_Definition_Item {
        static instance: ::protobuf::rt::LazyV2<CMsgPaintKit_Definition_Item> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgPaintKit_Definition_Item::new)
    }
}

impl ::protobuf::Clear for CMsgPaintKit_Definition_Item {
    fn clear(&mut self) {
        self.item_definition_template.clear();
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgPaintKit_Definition_Item {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPaintKit_Definition_Item {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgPaintKit_Definition_Item_ItemData {
    // message fields
    can_apply_paintkit: ::std::option::Option<bool>,
    material_override: ::protobuf::SingularField<::std::string::String>,
    pub variable: ::protobuf::RepeatedField<CMsgVarField>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgPaintKit_Definition_Item_ItemData {
    fn default() -> &'a CMsgPaintKit_Definition_Item_ItemData {
        <CMsgPaintKit_Definition_Item_ItemData as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPaintKit_Definition_Item_ItemData {
    pub fn new() -> CMsgPaintKit_Definition_Item_ItemData {
        ::std::default::Default::default()
    }

    // optional bool can_apply_paintkit = 2;


    pub fn get_can_apply_paintkit(&self) -> bool {
        self.can_apply_paintkit.unwrap_or(true)
    }
    pub fn clear_can_apply_paintkit(&mut self) {
        self.can_apply_paintkit = ::std::option::Option::None;
    }

    pub fn has_can_apply_paintkit(&self) -> bool {
        self.can_apply_paintkit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_can_apply_paintkit(&mut self, v: bool) {
        self.can_apply_paintkit = ::std::option::Option::Some(v);
    }

    // optional string material_override = 3;


    pub fn get_material_override(&self) -> &str {
        match self.material_override.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_material_override(&mut self) {
        self.material_override.clear();
    }

    pub fn has_material_override(&self) -> bool {
        self.material_override.is_some()
    }

    // Param is passed by value, moved
    pub fn set_material_override(&mut self, v: ::std::string::String) {
        self.material_override = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_material_override(&mut self) -> &mut ::std::string::String {
        if self.material_override.is_none() {
            self.material_override.set_default();
        }
        self.material_override.as_mut().unwrap()
    }

    // Take field
    pub fn take_material_override(&mut self) -> ::std::string::String {
        self.material_override.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .CMsgVarField variable = 4;


    pub fn get_variable(&self) -> &[CMsgVarField] {
        &self.variable
    }
    pub fn clear_variable(&mut self) {
        self.variable.clear();
    }

    // Param is passed by value, moved
    pub fn set_variable(&mut self, v: ::protobuf::RepeatedField<CMsgVarField>) {
        self.variable = v;
    }

    // Mutable pointer to the field.
    pub fn mut_variable(&mut self) -> &mut ::protobuf::RepeatedField<CMsgVarField> {
        &mut self.variable
    }

    // Take field
    pub fn take_variable(&mut self) -> ::protobuf::RepeatedField<CMsgVarField> {
        ::std::mem::replace(&mut self.variable, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgPaintKit_Definition_Item_ItemData {
    fn is_initialized(&self) -> bool {
        for v in &self.variable {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.can_apply_paintkit = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.material_override)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.variable)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.can_apply_paintkit {
            my_size += 2;
        }
        if let Some(ref v) = self.material_override.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        for value in &self.variable {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.can_apply_paintkit {
            os.write_bool(2, v)?;
        }
        if let Some(ref v) = self.material_override.as_ref() {
            os.write_string(3, &v)?;
        }
        for v in &self.variable {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgPaintKit_Definition_Item_ItemData {
        CMsgPaintKit_Definition_Item_ItemData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "can_apply_paintkit",
                |m: &CMsgPaintKit_Definition_Item_ItemData| { &m.can_apply_paintkit },
                |m: &mut CMsgPaintKit_Definition_Item_ItemData| { &mut m.can_apply_paintkit },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "material_override",
                |m: &CMsgPaintKit_Definition_Item_ItemData| { &m.material_override },
                |m: &mut CMsgPaintKit_Definition_Item_ItemData| { &mut m.material_override },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgVarField>>(
                "variable",
                |m: &CMsgPaintKit_Definition_Item_ItemData| { &m.variable },
                |m: &mut CMsgPaintKit_Definition_Item_ItemData| { &mut m.variable },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgPaintKit_Definition_Item_ItemData>(
                "CMsgPaintKit_Definition.Item.ItemData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgPaintKit_Definition_Item_ItemData {
        static instance: ::protobuf::rt::LazyV2<CMsgPaintKit_Definition_Item_ItemData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgPaintKit_Definition_Item_ItemData::new)
    }
}

impl ::protobuf::Clear for CMsgPaintKit_Definition_Item_ItemData {
    fn clear(&mut self) {
        self.can_apply_paintkit = ::std::option::Option::None;
        self.material_override.clear();
        self.variable.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgPaintKit_Definition_Item_ItemData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPaintKit_Definition_Item_ItemData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgQuestTheme {
    // message fields
    pub header: ::protobuf::SingularPtrField<CMsgProtoDefHeader>,
    notification_res: ::protobuf::SingularField<::std::string::String>,
    quest_item_res: ::protobuf::SingularField<::std::string::String>,
    in_game_tracker_res: ::protobuf::SingularField<::std::string::String>,
    pub give_sounds: ::protobuf::RepeatedField<CMsgQuestTheme_WeightedStringSet>,
    pub complete_sounds: ::protobuf::RepeatedField<CMsgQuestTheme_WeightedStringSet>,
    pub fully_complete_sounds: ::protobuf::RepeatedField<CMsgQuestTheme_WeightedStringSet>,
    reward_sound: ::protobuf::SingularField<::std::string::String>,
    discard_sound: ::protobuf::SingularField<::std::string::String>,
    reveal_sound: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgQuestTheme {
    fn default() -> &'a CMsgQuestTheme {
        <CMsgQuestTheme as ::protobuf::Message>::default_instance()
    }
}

impl CMsgQuestTheme {
    pub fn new() -> CMsgQuestTheme {
        ::std::default::Default::default()
    }

    // required .CMsgProtoDefHeader header = 1;


    pub fn get_header(&self) -> &CMsgProtoDefHeader {
        self.header.as_ref().unwrap_or_else(|| <CMsgProtoDefHeader as ::protobuf::Message>::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: CMsgProtoDefHeader) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut CMsgProtoDefHeader {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> CMsgProtoDefHeader {
        self.header.take().unwrap_or_else(|| CMsgProtoDefHeader::new())
    }

    // optional string notification_res = 2;


    pub fn get_notification_res(&self) -> &str {
        match self.notification_res.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_notification_res(&mut self) {
        self.notification_res.clear();
    }

    pub fn has_notification_res(&self) -> bool {
        self.notification_res.is_some()
    }

    // Param is passed by value, moved
    pub fn set_notification_res(&mut self, v: ::std::string::String) {
        self.notification_res = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_notification_res(&mut self) -> &mut ::std::string::String {
        if self.notification_res.is_none() {
            self.notification_res.set_default();
        }
        self.notification_res.as_mut().unwrap()
    }

    // Take field
    pub fn take_notification_res(&mut self) -> ::std::string::String {
        self.notification_res.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string quest_item_res = 3;


    pub fn get_quest_item_res(&self) -> &str {
        match self.quest_item_res.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_quest_item_res(&mut self) {
        self.quest_item_res.clear();
    }

    pub fn has_quest_item_res(&self) -> bool {
        self.quest_item_res.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quest_item_res(&mut self, v: ::std::string::String) {
        self.quest_item_res = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_quest_item_res(&mut self) -> &mut ::std::string::String {
        if self.quest_item_res.is_none() {
            self.quest_item_res.set_default();
        }
        self.quest_item_res.as_mut().unwrap()
    }

    // Take field
    pub fn take_quest_item_res(&mut self) -> ::std::string::String {
        self.quest_item_res.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string in_game_tracker_res = 4;


    pub fn get_in_game_tracker_res(&self) -> &str {
        match self.in_game_tracker_res.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_in_game_tracker_res(&mut self) {
        self.in_game_tracker_res.clear();
    }

    pub fn has_in_game_tracker_res(&self) -> bool {
        self.in_game_tracker_res.is_some()
    }

    // Param is passed by value, moved
    pub fn set_in_game_tracker_res(&mut self, v: ::std::string::String) {
        self.in_game_tracker_res = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_in_game_tracker_res(&mut self) -> &mut ::std::string::String {
        if self.in_game_tracker_res.is_none() {
            self.in_game_tracker_res.set_default();
        }
        self.in_game_tracker_res.as_mut().unwrap()
    }

    // Take field
    pub fn take_in_game_tracker_res(&mut self) -> ::std::string::String {
        self.in_game_tracker_res.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .CMsgQuestTheme.WeightedStringSet give_sounds = 5;


    pub fn get_give_sounds(&self) -> &[CMsgQuestTheme_WeightedStringSet] {
        &self.give_sounds
    }
    pub fn clear_give_sounds(&mut self) {
        self.give_sounds.clear();
    }

    // Param is passed by value, moved
    pub fn set_give_sounds(&mut self, v: ::protobuf::RepeatedField<CMsgQuestTheme_WeightedStringSet>) {
        self.give_sounds = v;
    }

    // Mutable pointer to the field.
    pub fn mut_give_sounds(&mut self) -> &mut ::protobuf::RepeatedField<CMsgQuestTheme_WeightedStringSet> {
        &mut self.give_sounds
    }

    // Take field
    pub fn take_give_sounds(&mut self) -> ::protobuf::RepeatedField<CMsgQuestTheme_WeightedStringSet> {
        ::std::mem::replace(&mut self.give_sounds, ::protobuf::RepeatedField::new())
    }

    // repeated .CMsgQuestTheme.WeightedStringSet complete_sounds = 6;


    pub fn get_complete_sounds(&self) -> &[CMsgQuestTheme_WeightedStringSet] {
        &self.complete_sounds
    }
    pub fn clear_complete_sounds(&mut self) {
        self.complete_sounds.clear();
    }

    // Param is passed by value, moved
    pub fn set_complete_sounds(&mut self, v: ::protobuf::RepeatedField<CMsgQuestTheme_WeightedStringSet>) {
        self.complete_sounds = v;
    }

    // Mutable pointer to the field.
    pub fn mut_complete_sounds(&mut self) -> &mut ::protobuf::RepeatedField<CMsgQuestTheme_WeightedStringSet> {
        &mut self.complete_sounds
    }

    // Take field
    pub fn take_complete_sounds(&mut self) -> ::protobuf::RepeatedField<CMsgQuestTheme_WeightedStringSet> {
        ::std::mem::replace(&mut self.complete_sounds, ::protobuf::RepeatedField::new())
    }

    // repeated .CMsgQuestTheme.WeightedStringSet fully_complete_sounds = 7;


    pub fn get_fully_complete_sounds(&self) -> &[CMsgQuestTheme_WeightedStringSet] {
        &self.fully_complete_sounds
    }
    pub fn clear_fully_complete_sounds(&mut self) {
        self.fully_complete_sounds.clear();
    }

    // Param is passed by value, moved
    pub fn set_fully_complete_sounds(&mut self, v: ::protobuf::RepeatedField<CMsgQuestTheme_WeightedStringSet>) {
        self.fully_complete_sounds = v;
    }

    // Mutable pointer to the field.
    pub fn mut_fully_complete_sounds(&mut self) -> &mut ::protobuf::RepeatedField<CMsgQuestTheme_WeightedStringSet> {
        &mut self.fully_complete_sounds
    }

    // Take field
    pub fn take_fully_complete_sounds(&mut self) -> ::protobuf::RepeatedField<CMsgQuestTheme_WeightedStringSet> {
        ::std::mem::replace(&mut self.fully_complete_sounds, ::protobuf::RepeatedField::new())
    }

    // optional string reward_sound = 8;


    pub fn get_reward_sound(&self) -> &str {
        match self.reward_sound.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_reward_sound(&mut self) {
        self.reward_sound.clear();
    }

    pub fn has_reward_sound(&self) -> bool {
        self.reward_sound.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reward_sound(&mut self, v: ::std::string::String) {
        self.reward_sound = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reward_sound(&mut self) -> &mut ::std::string::String {
        if self.reward_sound.is_none() {
            self.reward_sound.set_default();
        }
        self.reward_sound.as_mut().unwrap()
    }

    // Take field
    pub fn take_reward_sound(&mut self) -> ::std::string::String {
        self.reward_sound.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string discard_sound = 9;


    pub fn get_discard_sound(&self) -> &str {
        match self.discard_sound.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_discard_sound(&mut self) {
        self.discard_sound.clear();
    }

    pub fn has_discard_sound(&self) -> bool {
        self.discard_sound.is_some()
    }

    // Param is passed by value, moved
    pub fn set_discard_sound(&mut self, v: ::std::string::String) {
        self.discard_sound = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_discard_sound(&mut self) -> &mut ::std::string::String {
        if self.discard_sound.is_none() {
            self.discard_sound.set_default();
        }
        self.discard_sound.as_mut().unwrap()
    }

    // Take field
    pub fn take_discard_sound(&mut self) -> ::std::string::String {
        self.discard_sound.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string reveal_sound = 10;


    pub fn get_reveal_sound(&self) -> &str {
        match self.reveal_sound.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_reveal_sound(&mut self) {
        self.reveal_sound.clear();
    }

    pub fn has_reveal_sound(&self) -> bool {
        self.reveal_sound.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reveal_sound(&mut self, v: ::std::string::String) {
        self.reveal_sound = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reveal_sound(&mut self) -> &mut ::std::string::String {
        if self.reveal_sound.is_none() {
            self.reveal_sound.set_default();
        }
        self.reveal_sound.as_mut().unwrap()
    }

    // Take field
    pub fn take_reveal_sound(&mut self) -> ::std::string::String {
        self.reveal_sound.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgQuestTheme {
    fn is_initialized(&self) -> bool {
        if self.header.is_none() {
            return false;
        }
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.give_sounds {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.complete_sounds {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.fully_complete_sounds {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.notification_res)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.quest_item_res)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.in_game_tracker_res)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.give_sounds)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.complete_sounds)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.fully_complete_sounds)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.reward_sound)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.discard_sound)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.reveal_sound)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.notification_res.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.quest_item_res.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.in_game_tracker_res.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        for value in &self.give_sounds {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.complete_sounds {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.fully_complete_sounds {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.reward_sound.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(ref v) = self.discard_sound.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(ref v) = self.reveal_sound.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.notification_res.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.quest_item_res.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.in_game_tracker_res.as_ref() {
            os.write_string(4, &v)?;
        }
        for v in &self.give_sounds {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.complete_sounds {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.fully_complete_sounds {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.reward_sound.as_ref() {
            os.write_string(8, &v)?;
        }
        if let Some(ref v) = self.discard_sound.as_ref() {
            os.write_string(9, &v)?;
        }
        if let Some(ref v) = self.reveal_sound.as_ref() {
            os.write_string(10, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgQuestTheme {
        CMsgQuestTheme::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgProtoDefHeader>>(
                "header",
                |m: &CMsgQuestTheme| { &m.header },
                |m: &mut CMsgQuestTheme| { &mut m.header },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "notification_res",
                |m: &CMsgQuestTheme| { &m.notification_res },
                |m: &mut CMsgQuestTheme| { &mut m.notification_res },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "quest_item_res",
                |m: &CMsgQuestTheme| { &m.quest_item_res },
                |m: &mut CMsgQuestTheme| { &mut m.quest_item_res },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "in_game_tracker_res",
                |m: &CMsgQuestTheme| { &m.in_game_tracker_res },
                |m: &mut CMsgQuestTheme| { &mut m.in_game_tracker_res },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgQuestTheme_WeightedStringSet>>(
                "give_sounds",
                |m: &CMsgQuestTheme| { &m.give_sounds },
                |m: &mut CMsgQuestTheme| { &mut m.give_sounds },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgQuestTheme_WeightedStringSet>>(
                "complete_sounds",
                |m: &CMsgQuestTheme| { &m.complete_sounds },
                |m: &mut CMsgQuestTheme| { &mut m.complete_sounds },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgQuestTheme_WeightedStringSet>>(
                "fully_complete_sounds",
                |m: &CMsgQuestTheme| { &m.fully_complete_sounds },
                |m: &mut CMsgQuestTheme| { &mut m.fully_complete_sounds },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "reward_sound",
                |m: &CMsgQuestTheme| { &m.reward_sound },
                |m: &mut CMsgQuestTheme| { &mut m.reward_sound },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "discard_sound",
                |m: &CMsgQuestTheme| { &m.discard_sound },
                |m: &mut CMsgQuestTheme| { &mut m.discard_sound },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "reveal_sound",
                |m: &CMsgQuestTheme| { &m.reveal_sound },
                |m: &mut CMsgQuestTheme| { &mut m.reveal_sound },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgQuestTheme>(
                "CMsgQuestTheme",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgQuestTheme {
        static instance: ::protobuf::rt::LazyV2<CMsgQuestTheme> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgQuestTheme::new)
    }
}

impl ::protobuf::Clear for CMsgQuestTheme {
    fn clear(&mut self) {
        self.header.clear();
        self.notification_res.clear();
        self.quest_item_res.clear();
        self.in_game_tracker_res.clear();
        self.give_sounds.clear();
        self.complete_sounds.clear();
        self.fully_complete_sounds.clear();
        self.reward_sound.clear();
        self.discard_sound.clear();
        self.reveal_sound.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgQuestTheme {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgQuestTheme {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgQuestTheme_WeightedString {
    // message fields
    string: ::protobuf::SingularField<::std::string::String>,
    weight: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgQuestTheme_WeightedString {
    fn default() -> &'a CMsgQuestTheme_WeightedString {
        <CMsgQuestTheme_WeightedString as ::protobuf::Message>::default_instance()
    }
}

impl CMsgQuestTheme_WeightedString {
    pub fn new() -> CMsgQuestTheme_WeightedString {
        ::std::default::Default::default()
    }

    // optional string string = 1;


    pub fn get_string(&self) -> &str {
        match self.string.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_string(&mut self) {
        self.string.clear();
    }

    pub fn has_string(&self) -> bool {
        self.string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_string(&mut self, v: ::std::string::String) {
        self.string = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_string(&mut self) -> &mut ::std::string::String {
        if self.string.is_none() {
            self.string.set_default();
        }
        self.string.as_mut().unwrap()
    }

    // Take field
    pub fn take_string(&mut self) -> ::std::string::String {
        self.string.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 weight = 2;


    pub fn get_weight(&self) -> u32 {
        self.weight.unwrap_or(0)
    }
    pub fn clear_weight(&mut self) {
        self.weight = ::std::option::Option::None;
    }

    pub fn has_weight(&self) -> bool {
        self.weight.is_some()
    }

    // Param is passed by value, moved
    pub fn set_weight(&mut self, v: u32) {
        self.weight = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgQuestTheme_WeightedString {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.string)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.weight = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.string.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.weight {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.string.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.weight {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgQuestTheme_WeightedString {
        CMsgQuestTheme_WeightedString::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "string",
                |m: &CMsgQuestTheme_WeightedString| { &m.string },
                |m: &mut CMsgQuestTheme_WeightedString| { &mut m.string },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "weight",
                |m: &CMsgQuestTheme_WeightedString| { &m.weight },
                |m: &mut CMsgQuestTheme_WeightedString| { &mut m.weight },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgQuestTheme_WeightedString>(
                "CMsgQuestTheme.WeightedString",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgQuestTheme_WeightedString {
        static instance: ::protobuf::rt::LazyV2<CMsgQuestTheme_WeightedString> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgQuestTheme_WeightedString::new)
    }
}

impl ::protobuf::Clear for CMsgQuestTheme_WeightedString {
    fn clear(&mut self) {
        self.string.clear();
        self.weight = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgQuestTheme_WeightedString {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgQuestTheme_WeightedString {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgQuestTheme_WeightedStringSet {
    // message fields
    pub weighted_strings: ::protobuf::RepeatedField<CMsgQuestTheme_WeightedString>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgQuestTheme_WeightedStringSet {
    fn default() -> &'a CMsgQuestTheme_WeightedStringSet {
        <CMsgQuestTheme_WeightedStringSet as ::protobuf::Message>::default_instance()
    }
}

impl CMsgQuestTheme_WeightedStringSet {
    pub fn new() -> CMsgQuestTheme_WeightedStringSet {
        ::std::default::Default::default()
    }

    // repeated .CMsgQuestTheme.WeightedString weighted_strings = 1;


    pub fn get_weighted_strings(&self) -> &[CMsgQuestTheme_WeightedString] {
        &self.weighted_strings
    }
    pub fn clear_weighted_strings(&mut self) {
        self.weighted_strings.clear();
    }

    // Param is passed by value, moved
    pub fn set_weighted_strings(&mut self, v: ::protobuf::RepeatedField<CMsgQuestTheme_WeightedString>) {
        self.weighted_strings = v;
    }

    // Mutable pointer to the field.
    pub fn mut_weighted_strings(&mut self) -> &mut ::protobuf::RepeatedField<CMsgQuestTheme_WeightedString> {
        &mut self.weighted_strings
    }

    // Take field
    pub fn take_weighted_strings(&mut self) -> ::protobuf::RepeatedField<CMsgQuestTheme_WeightedString> {
        ::std::mem::replace(&mut self.weighted_strings, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgQuestTheme_WeightedStringSet {
    fn is_initialized(&self) -> bool {
        for v in &self.weighted_strings {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.weighted_strings)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.weighted_strings {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.weighted_strings {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgQuestTheme_WeightedStringSet {
        CMsgQuestTheme_WeightedStringSet::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgQuestTheme_WeightedString>>(
                "weighted_strings",
                |m: &CMsgQuestTheme_WeightedStringSet| { &m.weighted_strings },
                |m: &mut CMsgQuestTheme_WeightedStringSet| { &mut m.weighted_strings },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgQuestTheme_WeightedStringSet>(
                "CMsgQuestTheme.WeightedStringSet",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgQuestTheme_WeightedStringSet {
        static instance: ::protobuf::rt::LazyV2<CMsgQuestTheme_WeightedStringSet> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgQuestTheme_WeightedStringSet::new)
    }
}

impl ::protobuf::Clear for CMsgQuestTheme_WeightedStringSet {
    fn clear(&mut self) {
        self.weighted_strings.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgQuestTheme_WeightedStringSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgQuestTheme_WeightedStringSet {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgQuestMapNodeCondition_NodeState {
    // message fields
    bonus_objectives_required: ::std::option::Option<u32>,
    pub target_node_defid: ::protobuf::SingularPtrField<CMsgProtoDefID>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgQuestMapNodeCondition_NodeState {
    fn default() -> &'a CMsgQuestMapNodeCondition_NodeState {
        <CMsgQuestMapNodeCondition_NodeState as ::protobuf::Message>::default_instance()
    }
}

impl CMsgQuestMapNodeCondition_NodeState {
    pub fn new() -> CMsgQuestMapNodeCondition_NodeState {
        ::std::default::Default::default()
    }

    // optional uint32 bonus_objectives_required = 1;


    pub fn get_bonus_objectives_required(&self) -> u32 {
        self.bonus_objectives_required.unwrap_or(0u32)
    }
    pub fn clear_bonus_objectives_required(&mut self) {
        self.bonus_objectives_required = ::std::option::Option::None;
    }

    pub fn has_bonus_objectives_required(&self) -> bool {
        self.bonus_objectives_required.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bonus_objectives_required(&mut self, v: u32) {
        self.bonus_objectives_required = ::std::option::Option::Some(v);
    }

    // required .CMsgProtoDefID target_node_defid = 2;


    pub fn get_target_node_defid(&self) -> &CMsgProtoDefID {
        self.target_node_defid.as_ref().unwrap_or_else(|| <CMsgProtoDefID as ::protobuf::Message>::default_instance())
    }
    pub fn clear_target_node_defid(&mut self) {
        self.target_node_defid.clear();
    }

    pub fn has_target_node_defid(&self) -> bool {
        self.target_node_defid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_node_defid(&mut self, v: CMsgProtoDefID) {
        self.target_node_defid = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_target_node_defid(&mut self) -> &mut CMsgProtoDefID {
        if self.target_node_defid.is_none() {
            self.target_node_defid.set_default();
        }
        self.target_node_defid.as_mut().unwrap()
    }

    // Take field
    pub fn take_target_node_defid(&mut self) -> CMsgProtoDefID {
        self.target_node_defid.take().unwrap_or_else(|| CMsgProtoDefID::new())
    }
}

impl ::protobuf::Message for CMsgQuestMapNodeCondition_NodeState {
    fn is_initialized(&self) -> bool {
        if self.target_node_defid.is_none() {
            return false;
        }
        for v in &self.target_node_defid {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.bonus_objectives_required = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.target_node_defid)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.bonus_objectives_required {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.target_node_defid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.bonus_objectives_required {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.target_node_defid.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgQuestMapNodeCondition_NodeState {
        CMsgQuestMapNodeCondition_NodeState::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "bonus_objectives_required",
                |m: &CMsgQuestMapNodeCondition_NodeState| { &m.bonus_objectives_required },
                |m: &mut CMsgQuestMapNodeCondition_NodeState| { &mut m.bonus_objectives_required },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgProtoDefID>>(
                "target_node_defid",
                |m: &CMsgQuestMapNodeCondition_NodeState| { &m.target_node_defid },
                |m: &mut CMsgQuestMapNodeCondition_NodeState| { &mut m.target_node_defid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgQuestMapNodeCondition_NodeState>(
                "CMsgQuestMapNodeCondition_NodeState",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgQuestMapNodeCondition_NodeState {
        static instance: ::protobuf::rt::LazyV2<CMsgQuestMapNodeCondition_NodeState> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgQuestMapNodeCondition_NodeState::new)
    }
}

impl ::protobuf::Clear for CMsgQuestMapNodeCondition_NodeState {
    fn clear(&mut self) {
        self.bonus_objectives_required = ::std::option::Option::None;
        self.target_node_defid.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgQuestMapNodeCondition_NodeState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgQuestMapNodeCondition_NodeState {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgQuestMapNodeCondition_Logic {
    // message fields
    operation: ::std::option::Option<LogicalOperation>,
    pub sub_conditions: ::protobuf::RepeatedField<CMsgQuestMapNodeCondition>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgQuestMapNodeCondition_Logic {
    fn default() -> &'a CMsgQuestMapNodeCondition_Logic {
        <CMsgQuestMapNodeCondition_Logic as ::protobuf::Message>::default_instance()
    }
}

impl CMsgQuestMapNodeCondition_Logic {
    pub fn new() -> CMsgQuestMapNodeCondition_Logic {
        ::std::default::Default::default()
    }

    // required .LogicalOperation operation = 1;


    pub fn get_operation(&self) -> LogicalOperation {
        self.operation.unwrap_or(LogicalOperation::AND)
    }
    pub fn clear_operation(&mut self) {
        self.operation = ::std::option::Option::None;
    }

    pub fn has_operation(&self) -> bool {
        self.operation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_operation(&mut self, v: LogicalOperation) {
        self.operation = ::std::option::Option::Some(v);
    }

    // repeated .CMsgQuestMapNodeCondition sub_conditions = 2;


    pub fn get_sub_conditions(&self) -> &[CMsgQuestMapNodeCondition] {
        &self.sub_conditions
    }
    pub fn clear_sub_conditions(&mut self) {
        self.sub_conditions.clear();
    }

    // Param is passed by value, moved
    pub fn set_sub_conditions(&mut self, v: ::protobuf::RepeatedField<CMsgQuestMapNodeCondition>) {
        self.sub_conditions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_sub_conditions(&mut self) -> &mut ::protobuf::RepeatedField<CMsgQuestMapNodeCondition> {
        &mut self.sub_conditions
    }

    // Take field
    pub fn take_sub_conditions(&mut self) -> ::protobuf::RepeatedField<CMsgQuestMapNodeCondition> {
        ::std::mem::replace(&mut self.sub_conditions, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgQuestMapNodeCondition_Logic {
    fn is_initialized(&self) -> bool {
        if self.operation.is_none() {
            return false;
        }
        for v in &self.sub_conditions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.operation, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.sub_conditions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.operation {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        for value in &self.sub_conditions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.operation {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        for v in &self.sub_conditions {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgQuestMapNodeCondition_Logic {
        CMsgQuestMapNodeCondition_Logic::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<LogicalOperation>>(
                "operation",
                |m: &CMsgQuestMapNodeCondition_Logic| { &m.operation },
                |m: &mut CMsgQuestMapNodeCondition_Logic| { &mut m.operation },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgQuestMapNodeCondition>>(
                "sub_conditions",
                |m: &CMsgQuestMapNodeCondition_Logic| { &m.sub_conditions },
                |m: &mut CMsgQuestMapNodeCondition_Logic| { &mut m.sub_conditions },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgQuestMapNodeCondition_Logic>(
                "CMsgQuestMapNodeCondition_Logic",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgQuestMapNodeCondition_Logic {
        static instance: ::protobuf::rt::LazyV2<CMsgQuestMapNodeCondition_Logic> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgQuestMapNodeCondition_Logic::new)
    }
}

impl ::protobuf::Clear for CMsgQuestMapNodeCondition_Logic {
    fn clear(&mut self) {
        self.operation = ::std::option::Option::None;
        self.sub_conditions.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgQuestMapNodeCondition_Logic {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgQuestMapNodeCondition_Logic {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgQuestMapNodeCondition {
    // message oneof groups
    pub operation: ::std::option::Option<CMsgQuestMapNodeCondition_oneof_operation>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgQuestMapNodeCondition {
    fn default() -> &'a CMsgQuestMapNodeCondition {
        <CMsgQuestMapNodeCondition as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum CMsgQuestMapNodeCondition_oneof_operation {
    node_state(CMsgQuestMapNodeCondition_NodeState),
    logical(CMsgQuestMapNodeCondition_Logic),
}

impl CMsgQuestMapNodeCondition {
    pub fn new() -> CMsgQuestMapNodeCondition {
        ::std::default::Default::default()
    }

    // optional .CMsgQuestMapNodeCondition_NodeState node_state = 1;


    pub fn get_node_state(&self) -> &CMsgQuestMapNodeCondition_NodeState {
        match self.operation {
            ::std::option::Option::Some(CMsgQuestMapNodeCondition_oneof_operation::node_state(ref v)) => v,
            _ => <CMsgQuestMapNodeCondition_NodeState as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_node_state(&mut self) {
        self.operation = ::std::option::Option::None;
    }

    pub fn has_node_state(&self) -> bool {
        match self.operation {
            ::std::option::Option::Some(CMsgQuestMapNodeCondition_oneof_operation::node_state(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_node_state(&mut self, v: CMsgQuestMapNodeCondition_NodeState) {
        self.operation = ::std::option::Option::Some(CMsgQuestMapNodeCondition_oneof_operation::node_state(v))
    }

    // Mutable pointer to the field.
    pub fn mut_node_state(&mut self) -> &mut CMsgQuestMapNodeCondition_NodeState {
        if let ::std::option::Option::Some(CMsgQuestMapNodeCondition_oneof_operation::node_state(_)) = self.operation {
        } else {
            self.operation = ::std::option::Option::Some(CMsgQuestMapNodeCondition_oneof_operation::node_state(CMsgQuestMapNodeCondition_NodeState::new()));
        }
        match self.operation {
            ::std::option::Option::Some(CMsgQuestMapNodeCondition_oneof_operation::node_state(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_node_state(&mut self) -> CMsgQuestMapNodeCondition_NodeState {
        if self.has_node_state() {
            match self.operation.take() {
                ::std::option::Option::Some(CMsgQuestMapNodeCondition_oneof_operation::node_state(v)) => v,
                _ => panic!(),
            }
        } else {
            CMsgQuestMapNodeCondition_NodeState::new()
        }
    }

    // optional .CMsgQuestMapNodeCondition_Logic logical = 2;


    pub fn get_logical(&self) -> &CMsgQuestMapNodeCondition_Logic {
        match self.operation {
            ::std::option::Option::Some(CMsgQuestMapNodeCondition_oneof_operation::logical(ref v)) => v,
            _ => <CMsgQuestMapNodeCondition_Logic as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_logical(&mut self) {
        self.operation = ::std::option::Option::None;
    }

    pub fn has_logical(&self) -> bool {
        match self.operation {
            ::std::option::Option::Some(CMsgQuestMapNodeCondition_oneof_operation::logical(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_logical(&mut self, v: CMsgQuestMapNodeCondition_Logic) {
        self.operation = ::std::option::Option::Some(CMsgQuestMapNodeCondition_oneof_operation::logical(v))
    }

    // Mutable pointer to the field.
    pub fn mut_logical(&mut self) -> &mut CMsgQuestMapNodeCondition_Logic {
        if let ::std::option::Option::Some(CMsgQuestMapNodeCondition_oneof_operation::logical(_)) = self.operation {
        } else {
            self.operation = ::std::option::Option::Some(CMsgQuestMapNodeCondition_oneof_operation::logical(CMsgQuestMapNodeCondition_Logic::new()));
        }
        match self.operation {
            ::std::option::Option::Some(CMsgQuestMapNodeCondition_oneof_operation::logical(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_logical(&mut self) -> CMsgQuestMapNodeCondition_Logic {
        if self.has_logical() {
            match self.operation.take() {
                ::std::option::Option::Some(CMsgQuestMapNodeCondition_oneof_operation::logical(v)) => v,
                _ => panic!(),
            }
        } else {
            CMsgQuestMapNodeCondition_Logic::new()
        }
    }
}

impl ::protobuf::Message for CMsgQuestMapNodeCondition {
    fn is_initialized(&self) -> bool {
        if let Some(CMsgQuestMapNodeCondition_oneof_operation::node_state(ref v)) = self.operation {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(CMsgQuestMapNodeCondition_oneof_operation::logical(ref v)) = self.operation {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.operation = ::std::option::Option::Some(CMsgQuestMapNodeCondition_oneof_operation::node_state(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.operation = ::std::option::Option::Some(CMsgQuestMapNodeCondition_oneof_operation::logical(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.operation {
            match v {
                &CMsgQuestMapNodeCondition_oneof_operation::node_state(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &CMsgQuestMapNodeCondition_oneof_operation::logical(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.operation {
            match v {
                &CMsgQuestMapNodeCondition_oneof_operation::node_state(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &CMsgQuestMapNodeCondition_oneof_operation::logical(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgQuestMapNodeCondition {
        CMsgQuestMapNodeCondition::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, CMsgQuestMapNodeCondition_NodeState>(
                "node_state",
                CMsgQuestMapNodeCondition::has_node_state,
                CMsgQuestMapNodeCondition::get_node_state,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, CMsgQuestMapNodeCondition_Logic>(
                "logical",
                CMsgQuestMapNodeCondition::has_logical,
                CMsgQuestMapNodeCondition::get_logical,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgQuestMapNodeCondition>(
                "CMsgQuestMapNodeCondition",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgQuestMapNodeCondition {
        static instance: ::protobuf::rt::LazyV2<CMsgQuestMapNodeCondition> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgQuestMapNodeCondition::new)
    }
}

impl ::protobuf::Clear for CMsgQuestMapNodeCondition {
    fn clear(&mut self) {
        self.operation = ::std::option::Option::None;
        self.operation = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgQuestMapNodeCondition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgQuestMapNodeCondition {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgHeaderOnly {
    // message fields
    pub header: ::protobuf::SingularPtrField<CMsgProtoDefHeader>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgHeaderOnly {
    fn default() -> &'a CMsgHeaderOnly {
        <CMsgHeaderOnly as ::protobuf::Message>::default_instance()
    }
}

impl CMsgHeaderOnly {
    pub fn new() -> CMsgHeaderOnly {
        ::std::default::Default::default()
    }

    // required .CMsgProtoDefHeader header = 1;


    pub fn get_header(&self) -> &CMsgProtoDefHeader {
        self.header.as_ref().unwrap_or_else(|| <CMsgProtoDefHeader as ::protobuf::Message>::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: CMsgProtoDefHeader) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut CMsgProtoDefHeader {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> CMsgProtoDefHeader {
        self.header.take().unwrap_or_else(|| CMsgProtoDefHeader::new())
    }
}

impl ::protobuf::Message for CMsgHeaderOnly {
    fn is_initialized(&self) -> bool {
        if self.header.is_none() {
            return false;
        }
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgHeaderOnly {
        CMsgHeaderOnly::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgProtoDefHeader>>(
                "header",
                |m: &CMsgHeaderOnly| { &m.header },
                |m: &mut CMsgHeaderOnly| { &mut m.header },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgHeaderOnly>(
                "CMsgHeaderOnly",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgHeaderOnly {
        static instance: ::protobuf::rt::LazyV2<CMsgHeaderOnly> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgHeaderOnly::new)
    }
}

impl ::protobuf::Clear for CMsgHeaderOnly {
    fn clear(&mut self) {
        self.header.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgHeaderOnly {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgHeaderOnly {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum LogicalOperation {
    AND = 0,
    OR = 1,
    NOT = 2,
}

impl ::protobuf::ProtobufEnum for LogicalOperation {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<LogicalOperation> {
        match value {
            0 => ::std::option::Option::Some(LogicalOperation::AND),
            1 => ::std::option::Option::Some(LogicalOperation::OR),
            2 => ::std::option::Option::Some(LogicalOperation::NOT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [LogicalOperation] = &[
            LogicalOperation::AND,
            LogicalOperation::OR,
            LogicalOperation::NOT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<LogicalOperation>("LogicalOperation", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for LogicalOperation {
}

impl ::std::default::Default for LogicalOperation {
    fn default() -> Self {
        LogicalOperation::AND
    }
}

impl ::protobuf::reflect::ProtobufValue for LogicalOperation {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EValueDefinitionSource {
    REFERENCE_DEFINES = 0,
    PARENT_DEFINES = 1,
    THIS_DEFINES = 2,
    VARIABLE_DEFINES = 3,
    NOT_DEFINED = 4,
}

impl ::protobuf::ProtobufEnum for EValueDefinitionSource {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EValueDefinitionSource> {
        match value {
            0 => ::std::option::Option::Some(EValueDefinitionSource::REFERENCE_DEFINES),
            1 => ::std::option::Option::Some(EValueDefinitionSource::PARENT_DEFINES),
            2 => ::std::option::Option::Some(EValueDefinitionSource::THIS_DEFINES),
            3 => ::std::option::Option::Some(EValueDefinitionSource::VARIABLE_DEFINES),
            4 => ::std::option::Option::Some(EValueDefinitionSource::NOT_DEFINED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EValueDefinitionSource] = &[
            EValueDefinitionSource::REFERENCE_DEFINES,
            EValueDefinitionSource::PARENT_DEFINES,
            EValueDefinitionSource::THIS_DEFINES,
            EValueDefinitionSource::VARIABLE_DEFINES,
            EValueDefinitionSource::NOT_DEFINED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<EValueDefinitionSource>("EValueDefinitionSource", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for EValueDefinitionSource {
}

impl ::std::default::Default for EValueDefinitionSource {
    fn default() -> Self {
        EValueDefinitionSource::REFERENCE_DEFINES
    }
}

impl ::protobuf::reflect::ProtobufValue for EValueDefinitionSource {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ProtoDefTypes {
    DEF_TYPE_QUEST_MAP_NODE = 0,
    DEF_TYPE_QUEST_THEME = 2,
    DEF_TYPE_QUEST_MAP_REGION = 3,
    DEF_TYPE_QUEST = 4,
    DEF_TYPE_QUEST_OBJECTIVE = 5,
    DEF_TYPE_PAINTKIT_VARIABLES = 6,
    DEF_TYPE_PAINTKIT_OPERATION = 7,
    DEF_TYPE_PAINTKIT_ITEM_DEFINITION = 8,
    DEF_TYPE_PAINTKIT_DEFINITION = 9,
    DEF_TYPE_HEADER_ONLY = 10,
    DEF_TYPE_QUEST_MAP_STORE_ITEM = 11,
    DEF_TYPE_QUEST_MAP_STAR_TYPE = 12,
}

impl ::protobuf::ProtobufEnum for ProtoDefTypes {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ProtoDefTypes> {
        match value {
            0 => ::std::option::Option::Some(ProtoDefTypes::DEF_TYPE_QUEST_MAP_NODE),
            2 => ::std::option::Option::Some(ProtoDefTypes::DEF_TYPE_QUEST_THEME),
            3 => ::std::option::Option::Some(ProtoDefTypes::DEF_TYPE_QUEST_MAP_REGION),
            4 => ::std::option::Option::Some(ProtoDefTypes::DEF_TYPE_QUEST),
            5 => ::std::option::Option::Some(ProtoDefTypes::DEF_TYPE_QUEST_OBJECTIVE),
            6 => ::std::option::Option::Some(ProtoDefTypes::DEF_TYPE_PAINTKIT_VARIABLES),
            7 => ::std::option::Option::Some(ProtoDefTypes::DEF_TYPE_PAINTKIT_OPERATION),
            8 => ::std::option::Option::Some(ProtoDefTypes::DEF_TYPE_PAINTKIT_ITEM_DEFINITION),
            9 => ::std::option::Option::Some(ProtoDefTypes::DEF_TYPE_PAINTKIT_DEFINITION),
            10 => ::std::option::Option::Some(ProtoDefTypes::DEF_TYPE_HEADER_ONLY),
            11 => ::std::option::Option::Some(ProtoDefTypes::DEF_TYPE_QUEST_MAP_STORE_ITEM),
            12 => ::std::option::Option::Some(ProtoDefTypes::DEF_TYPE_QUEST_MAP_STAR_TYPE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ProtoDefTypes] = &[
            ProtoDefTypes::DEF_TYPE_QUEST_MAP_NODE,
            ProtoDefTypes::DEF_TYPE_QUEST_THEME,
            ProtoDefTypes::DEF_TYPE_QUEST_MAP_REGION,
            ProtoDefTypes::DEF_TYPE_QUEST,
            ProtoDefTypes::DEF_TYPE_QUEST_OBJECTIVE,
            ProtoDefTypes::DEF_TYPE_PAINTKIT_VARIABLES,
            ProtoDefTypes::DEF_TYPE_PAINTKIT_OPERATION,
            ProtoDefTypes::DEF_TYPE_PAINTKIT_ITEM_DEFINITION,
            ProtoDefTypes::DEF_TYPE_PAINTKIT_DEFINITION,
            ProtoDefTypes::DEF_TYPE_HEADER_ONLY,
            ProtoDefTypes::DEF_TYPE_QUEST_MAP_STORE_ITEM,
            ProtoDefTypes::DEF_TYPE_QUEST_MAP_STAR_TYPE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ProtoDefTypes>("ProtoDefTypes", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ProtoDefTypes {
}

impl ::std::default::Default for ProtoDefTypes {
    fn default() -> Self {
        ProtoDefTypes::DEF_TYPE_QUEST_MAP_NODE
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoDefTypes {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EQuestPoints {
    QUEST_POINTS_NOVICE = 0,
    QUEST_POINTS_ADVANCED = 1,
    QUEST_POINTS_EXPERT = 2,
}

impl ::protobuf::ProtobufEnum for EQuestPoints {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EQuestPoints> {
        match value {
            0 => ::std::option::Option::Some(EQuestPoints::QUEST_POINTS_NOVICE),
            1 => ::std::option::Option::Some(EQuestPoints::QUEST_POINTS_ADVANCED),
            2 => ::std::option::Option::Some(EQuestPoints::QUEST_POINTS_EXPERT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EQuestPoints] = &[
            EQuestPoints::QUEST_POINTS_NOVICE,
            EQuestPoints::QUEST_POINTS_ADVANCED,
            EQuestPoints::QUEST_POINTS_EXPERT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<EQuestPoints>("EQuestPoints", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for EQuestPoints {
}

impl ::std::default::Default for EQuestPoints {
    fn default() -> Self {
        EQuestPoints::QUEST_POINTS_NOVICE
    }
}

impl ::protobuf::reflect::ProtobufValue for EQuestPoints {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EVarFieldType {
    VAR_TYPE_INVALID = 1,
    VAR_TYPE_FLOAT = 2,
    VAR_TYPE_DOUBLE = 3,
    VAR_TYPE_UINT32 = 4,
    VAR_TYPE_UINT64 = 5,
    VAR_TYPE_SINT32 = 6,
    VAR_TYPE_SINT64 = 7,
    VAR_TYPE_BOOL = 8,
    VAR_TYPE_STRING = 9,
}

impl ::protobuf::ProtobufEnum for EVarFieldType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EVarFieldType> {
        match value {
            1 => ::std::option::Option::Some(EVarFieldType::VAR_TYPE_INVALID),
            2 => ::std::option::Option::Some(EVarFieldType::VAR_TYPE_FLOAT),
            3 => ::std::option::Option::Some(EVarFieldType::VAR_TYPE_DOUBLE),
            4 => ::std::option::Option::Some(EVarFieldType::VAR_TYPE_UINT32),
            5 => ::std::option::Option::Some(EVarFieldType::VAR_TYPE_UINT64),
            6 => ::std::option::Option::Some(EVarFieldType::VAR_TYPE_SINT32),
            7 => ::std::option::Option::Some(EVarFieldType::VAR_TYPE_SINT64),
            8 => ::std::option::Option::Some(EVarFieldType::VAR_TYPE_BOOL),
            9 => ::std::option::Option::Some(EVarFieldType::VAR_TYPE_STRING),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EVarFieldType] = &[
            EVarFieldType::VAR_TYPE_INVALID,
            EVarFieldType::VAR_TYPE_FLOAT,
            EVarFieldType::VAR_TYPE_DOUBLE,
            EVarFieldType::VAR_TYPE_UINT32,
            EVarFieldType::VAR_TYPE_UINT64,
            EVarFieldType::VAR_TYPE_SINT32,
            EVarFieldType::VAR_TYPE_SINT64,
            EVarFieldType::VAR_TYPE_BOOL,
            EVarFieldType::VAR_TYPE_STRING,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<EVarFieldType>("EVarFieldType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for EVarFieldType {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EVarFieldType {
    fn default() -> Self {
        EVarFieldType::VAR_TYPE_INVALID
    }
}

impl ::protobuf::reflect::ProtobufValue for EVarFieldType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ENodeCashReward {
    CASH_REWARD_NONE = 1,
    CASH_REWARD_SMALL = 2,
    CASH_REWARD_MEDIUM = 3,
    CASH_REWARD_LARGE = 4,
}

impl ::protobuf::ProtobufEnum for ENodeCashReward {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ENodeCashReward> {
        match value {
            1 => ::std::option::Option::Some(ENodeCashReward::CASH_REWARD_NONE),
            2 => ::std::option::Option::Some(ENodeCashReward::CASH_REWARD_SMALL),
            3 => ::std::option::Option::Some(ENodeCashReward::CASH_REWARD_MEDIUM),
            4 => ::std::option::Option::Some(ENodeCashReward::CASH_REWARD_LARGE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ENodeCashReward] = &[
            ENodeCashReward::CASH_REWARD_NONE,
            ENodeCashReward::CASH_REWARD_SMALL,
            ENodeCashReward::CASH_REWARD_MEDIUM,
            ENodeCashReward::CASH_REWARD_LARGE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ENodeCashReward>("ENodeCashReward", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ENodeCashReward {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for ENodeCashReward {
    fn default() -> Self {
        ENodeCashReward::CASH_REWARD_NONE
    }
}

impl ::protobuf::reflect::ProtobufValue for ENodeCashReward {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

/// Extension fields
pub mod exts {

    pub const start_expanded: ::protobuf::ext::ExtFieldOptional<::protobuf::descriptor::MessageOptions, ::protobuf::types::ProtobufTypeBool> = ::protobuf::ext::ExtFieldOptional { field_number: 80000, phantom: ::std::marker::PhantomData };

    pub const valid_type: ::protobuf::ext::ExtFieldOptional<::protobuf::descriptor::FieldOptions, ::protobuf::types::ProtobufTypeEnum<super::ProtoDefTypes>> = ::protobuf::ext::ExtFieldOptional { field_number: 70000, phantom: ::std::marker::PhantomData };

    pub const editable: ::protobuf::ext::ExtFieldOptional<::protobuf::descriptor::FieldOptions, ::protobuf::types::ProtobufTypeBool> = ::protobuf::ext::ExtFieldOptional { field_number: 70001, phantom: ::std::marker::PhantomData };

    pub const localized: ::protobuf::ext::ExtFieldOptional<::protobuf::descriptor::FieldOptions, ::protobuf::types::ProtobufTypeBool> = ::protobuf::ext::ExtFieldOptional { field_number: 70002, phantom: ::std::marker::PhantomData };

    pub const do_not_inherit: ::protobuf::ext::ExtFieldOptional<::protobuf::descriptor::FieldOptions, ::protobuf::types::ProtobufTypeBool> = ::protobuf::ext::ExtFieldOptional { field_number: 70003, phantom: ::std::marker::PhantomData };

    pub const display_name: ::protobuf::ext::ExtFieldOptional<::protobuf::descriptor::FieldOptions, ::protobuf::types::ProtobufTypeString> = ::protobuf::ext::ExtFieldOptional { field_number: 70004, phantom: ::std::marker::PhantomData };

    pub const comment: ::protobuf::ext::ExtFieldOptional<::protobuf::descriptor::FieldOptions, ::protobuf::types::ProtobufTypeString> = ::protobuf::ext::ExtFieldOptional { field_number: 70005, phantom: ::std::marker::PhantomData };

    pub const max_count: ::protobuf::ext::ExtFieldOptional<::protobuf::descriptor::FieldOptions, ::protobuf::types::ProtobufTypeUint32> = ::protobuf::ext::ExtFieldOptional { field_number: 70007, phantom: ::std::marker::PhantomData };

    pub const allow_add: ::protobuf::ext::ExtFieldOptional<::protobuf::descriptor::FieldOptions, ::protobuf::types::ProtobufTypeBool> = ::protobuf::ext::ExtFieldOptional { field_number: 70008, phantom: ::std::marker::PhantomData };

    pub const allow_delete: ::protobuf::ext::ExtFieldOptional<::protobuf::descriptor::FieldOptions, ::protobuf::types::ProtobufTypeBool> = ::protobuf::ext::ExtFieldOptional { field_number: 70009, phantom: ::std::marker::PhantomData };

    pub const panel_class_override: ::protobuf::ext::ExtFieldOptional<::protobuf::descriptor::FieldOptions, ::protobuf::types::ProtobufTypeString> = ::protobuf::ext::ExtFieldOptional { field_number: 70010, phantom: ::std::marker::PhantomData };

    pub const message_inherhitance_key_field_name: ::protobuf::ext::ExtFieldOptional<::protobuf::descriptor::FieldOptions, ::protobuf::types::ProtobufTypeString> = ::protobuf::ext::ExtFieldOptional { field_number: 70011, phantom: ::std::marker::PhantomData };

    pub const inherit_reference_variables: ::protobuf::ext::ExtFieldOptional<::protobuf::descriptor::FieldOptions, ::protobuf::types::ProtobufTypeBool> = ::protobuf::ext::ExtFieldOptional { field_number: 70012, phantom: ::std::marker::PhantomData };

    pub const self_inherit_only: ::protobuf::ext::ExtFieldOptional<::protobuf::descriptor::FieldOptions, ::protobuf::types::ProtobufTypeBool> = ::protobuf::ext::ExtFieldOptional { field_number: 70013, phantom: ::std::marker::PhantomData };

    pub const var_field_type: ::protobuf::ext::ExtFieldOptional<::protobuf::descriptor::FieldOptions, ::protobuf::types::ProtobufTypeEnum<super::EVarFieldType>> = ::protobuf::ext::ExtFieldOptional { field_number: 70014, phantom: ::std::marker::PhantomData };

    pub const merging_key_field: ::protobuf::ext::ExtFieldOptional<::protobuf::descriptor::FieldOptions, ::protobuf::types::ProtobufTypeBool> = ::protobuf::ext::ExtFieldOptional { field_number: 70015, phantom: ::std::marker::PhantomData };
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1btf_proto_def_messages.proto\x1a\x20google/protobuf/descriptor.prot\
    o\"\x92\x01\n\x0bCMsgFieldID\x12,\n\x05field\x18\x01\x20\x03(\x0b2\x16.C\
    MsgFieldID.CMsgFieldR\x05field\x1aU\n\tCMsgField\x12!\n\x0cfield_number\
    \x18\x01\x20\x01(\rR\x0bfieldNumber\x12%\n\x0erepeated_index\x18\x02\x20\
    \x01(\rR\rrepeatedIndex\"\xc5\x01\n\x14CMsgUniversalFieldID\x12K\n\x0bso\
    urce_type\x18\x01\x20\x01(\x0e2\x17.EValueDefinitionSource:\x11REFERENCE\
    _DEFINESR\nsourceType\x127\n\x0fdefining_obj_id\x18\x02\x20\x01(\x0b2\
    \x0f.CMsgProtoDefIDR\rdefiningObjId\x12'\n\x08field_id\x18\x03\x20\x01(\
    \x0b2\x0c.CMsgFieldIDR\x07fieldId\"h\n\x16CMsgVariableDefinition\x12\x18\
    \n\x04name\x18\x01\x20\x01(\tR\x04nameB\x04\xf8\x97\"\x01\x12\x1e\n\x07i\
    nherit\x18\x02\x20\x01(\x08:\x04trueR\x07inherit\x12\x14\n\x05value\x18\
    \x03\x20\x01(\tR\x05value\"\xa3\x05\n\x12CMsgProtoDefHeader\x12A\n\x08de\
    findex\x18\x01\x20\x02(\rR\x08defindexB%\xaa\x97\"\rAutogenerated\xa2\
    \x97\"\x08Defindex\xe8\x97\"\x01\x88\x97\"\0\x12>\n\x04name\x18\x02\x20\
    \x01(\tR\x04nameB*\xa2\x97\"\x04Name\xe8\x97\"\x01\xaa\x97\"\x1aName\x20\
    to\x20show\x20in\x20the\x20editor\x12\x9e\x01\n\x07prefabs\x18\x03\x20\
    \x03(\x0b2\x0f.CMsgProtoDefIDR\x07prefabsBs\xa2\x97\"\x06Prefab\xd2\x97\
    \"\x18CPrefabFieldEditingPanel\xe8\x97\"\x01\xaa\x97\"EInherit\x20the\
    \x20values\x20of\x20these\x20definitions,\x20in\x20order\x20from\x20top\
    \x20to\x20bottom.\x12y\n\x04tags\x18\x04\x20\x03(\tR\x04tagsBe\xaa\x97\"\
    YStrings\x20used\x20to\x20describe\x20this\x20definition\x20while\x20sea\
    rching.\x20\x20ie.\x20'class',\x20'shotgun',\x20'easy'\xa2\x97\"\x04Tags\
    \x12\x81\x01\n\x0bprefab_only\x18\x05\x20\x01(\x08:\x05falseR\nprefabOnl\
    yBY\xaa\x97\"BIf\x20true,\x20this\x20is\x20only\x20a\x20prefab\x20and\
    \x20will\x20not\x20be\x20made\x20into\x20an\x20object\xa2\x97\"\x0bPure\
    \x20Prefab\xe8\x97\"\x01\x12j\n\tvariables\x18\x06\x20\x03(\x0b2\x17.CMs\
    gVariableDefinitionR\tvariablesB3\xa2\x97\"\tVariables\xaa\x97\"\x1aVari\
    able\x20value\x20definitions\xda\x97\"\x04name\"6\n\x0eCMsgValidTypes\
    \x12$\n\x05types\x18\x01\x20\x03(\x0e2\x0e.ProtoDefTypesR\x05types\"\xce\
    \x08\n\x0eCMsgProtoDefID\x12\x1a\n\x08defindex\x18\x01\x20\x01(\rR\x08de\
    findex\x12;\n\x04type\x18\x02\x20\x01(\x0e2\x0e.ProtoDefTypes:\x17DEF_TY\
    PE_QUEST_MAP_NODER\x04type\x12]\n\x20instance_def_type_quest_map_node\
    \x18\x03\x20\x01(\x0b2\x14.CMsgQuestMapNodeDefH\0R\x1binstanceDefTypeQue\
    stMapNode\x12S\n\x1dinstance_def_type_quest_theme\x18\x05\x20\x01(\x0b2\
    \x0f.CMsgQuestThemeH\0R\x19instanceDefTypeQuestTheme\x12c\n\"instance_de\
    f_type_quest_map_region\x18\x06\x20\x01(\x0b2\x16.CMsgQuestMapRegionDefH\
    \0R\x1dinstanceDefTypeQuestMapRegion\x12F\n\x17instance_def_type_quest\
    \x18\x07\x20\x01(\x0b2\r.CMsgQuestDefH\0R\x14instanceDefTypeQuest\x12b\n\
    !instance_def_type_quest_objective\x18\x08\x20\x01(\x0b2\x16.CMsgQuestOb\
    jectiveDefH\0R\x1dinstanceDefTypeQuestObjective\x12i\n$instance_def_type\
    _paintkit_variables\x18\t\x20\x01(\x0b2\x17.CMsgPaintKit_VariablesH\0R\
    \x20instanceDefTypePaintkitVariables\x12i\n$instance_def_type_paintkit_o\
    peration\x18\n\x20\x01(\x0b2\x17.CMsgPaintKit_OperationH\0R\x20instanceD\
    efTypePaintkitOperation\x12y\n*instance_def_type_paintkit_item_definitio\
    n\x18\x0b\x20\x01(\x0b2\x1c.CMsgPaintKit_ItemDefinitionH\0R%instanceDefT\
    ypePaintkitItemDefinition\x12l\n%instance_def_type_paintkit_definition\
    \x18\x0c\x20\x01(\x0b2\x18.CMsgPaintKit_DefinitionH\0R!instanceDefTypePa\
    intkitDefinition\x12S\n\x1dinstance_def_type_header_only\x18\r\x20\x01(\
    \x0b2\x0f.CMsgHeaderOnlyH\0R\x19instanceDefTypeHeaderOnlyB\n\n\x08instan\
    ce\"\xd2-\n\x15CMsgQuestObjectiveDef\x12+\n\x06header\x18\x01\x20\x02(\
    \x0b2\x13.CMsgProtoDefHeaderR\x06header\x12)\n\rloc_desctoken\x18\x02\
    \x20\x01(\tR\x0clocDesctokenB\x04\x90\x97\"\x01\x12\x16\n\x06points\x18\
    \x03\x20\x01(\rR\x06points\x12/\n\x13conditions_defindex\x18\x05\x20\x01\
    (\rR\x12conditionsDefindex\x12j\n\x03map\x18\x08\x20\x03(\tR\x03mapBX\
    \xa2\x97\"\rMaps\x20Modifier\xaa\x97\"CIf\x20set,\x20the\x20player\x20mu\
    st\x20be\x20on\x20one\x20of\x20the\x20listed\x20maps\x20to\x20get\x20cre\
    dit.\x12\xa6\x01\n\tgame_mode\x18\t\x20\x03(\x0e2$.CMsgQuestObjectiveDef\
    .ETF2GameModesR\x08gameModeBc\xa2\x97\"\x12Game\x20Mode\x20Modifier\xaa\
    \x97\"IIf\x20set,\x20the\x20player\x20must\x20be\x20in\x20one\x20of\x20t\
    he\x20listed\x20game\x20modes\x20to\x20get\x20credit.\x12\x96\x01\n\x04t\
    eam\x18\n\x20\x01(\x0e2\x1f.CMsgQuestObjectiveDef.ETF2Team:\x0bTF_TEAM_R\
    EDR\x04teamBT\xa2\x97\"\rTeam\x20Modifier\xaa\x97\"?If\x20set,\x20the\
    \x20player\x20must\x20be\x20on\x20the\x20specified\x20team\x20to\x20get\
    \x20credit.\x12L\n\x0econdition_vars\x18\x0b\x20\x03(\x0b2\r.CMsgVarFiel\
    dR\rconditionVarsB\x16\xa2\x97\"\x0eObjective\x20Vars\xf0\x97\"\t\x12H\n\
    \x0cclasses_vars\x18\x0c\x20\x03(\x0b2\r.CMsgVarFieldR\x0bclassesVarsB\
    \x16\xf0\x97\"\t\xa2\x97\"\x0eClass\x20Modifier\x12Y\n\nconditions\x18\r\
    \x20\x03(\x0e2%.CMsgQuestObjectiveDef.ETF2ConditionsR\nconditionsB\x12\
    \xa2\x97\"\x0eRequired\x20Conds\x12\x9a\x01\n\x0fcondition_logic\x18\x0e\
    \x20\x01(\x0e2\x11.LogicalOperation:\x03ANDR\x0econditionLogicBY\xaa\x97\
    \"BWhat\x20kind\x20of\x20logic\x20to\x20use\x20when\x20evaluating\x20the\
    \x20player's\x20conditions.\xa2\x97\"\x0fCondition\x20Logic\x12j\n\titem\
    _name\x18\x0f\x20\x03(\tR\x08itemNameBM\xaa\x97\"/Require\x20that\x20thi\
    s\x20item\x20be\x20equipped\x20in\x20any\x20slot.\xa2\x97\"\x16Required\
    \x20equipped\x20item\x12\x86\x01\n\nitem_logic\x18\x10\x20\x01(\x0e2\x11\
    .LogicalOperation:\x03ANDR\titemLogicBO\xa2\x97\"\nItem\x20logic\xaa\x97\
    \"=What\x20kind\x20of\x20logic\x20to\x20use\x20when\x20evaluating\x20the\
    \x20player's\x20items.\x12a\n\njump_state\x18\x11\x20\x01(\rR\tjumpState\
    BB\xaa\x97\"0What\x20state\x20of\x20jumping\x20the\x20player\x20needs\
    \x20to\x20be\x20in.\xa2\x97\"\nJump\x20logic\"\xbd\x04\n\rETF2GameModes\
    \x12\x18\n\x14kGameCategory_Escort\x10\0\x12\x15\n\x11kGameCategory_CTF\
    \x10\x01\x12\x1f\n\x1bkGameCategory_AttackDefense\x10\x02\x12\x16\n\x12k\
    GameCategory_Koth\x10\x03\x12\x14\n\x10kGameCategory_CP\x10\x04\x12\x1c\
    \n\x18kGameCategory_EscortRace\x10\x05\x12\x1a\n\x16kGameCategory_EventM\
    ix\x10\x06\x12\x14\n\x10kGameCategory_SD\x10\x07\x12\x1b\n\x17kGameCateg\
    ory_Quickplay\x10\x08\x12\x1a\n\x16kGameCategory_Event247\x10\t\x12\x17\
    \n\x13kGameCategory_Arena\x10\n\x12\"\n\x1ekGameCategory_RobotDestructio\
    n\x10\x0b\x12\x19\n\x15kGameCategory_Powerup\x10\x0c\x12\x1a\n\x16kGameC\
    ategory_Featured\x10\r\x12\x1a\n\x16kGameCategory_Passtime\x10\x0e\x12\"\
    \n\x1ekGameCategory_Community_Update\x10\x0f\x12\x16\n\x12kGameCategory_\
    Misc\x10\x10\x12!\n\x1dkGameCategory_Competitive_6v6\x10\x11\x12\x17\n\
    \x13kGameCategory_Other\x10\x12\x12\x1b\n\x17kGameCategory_Halloween\x10\
    \x13\"\x92\x1e\n\x0eETF2Conditions\x12\x12\n\x0eTF_COND_AIMING\x10\0\x12\
    \x12\n\x0eTF_COND_ZOOMED\x10\x01\x12\x16\n\x12TF_COND_DISGUISING\x10\x02\
    \x12\x15\n\x11TF_COND_DISGUISED\x10\x03\x12\x15\n\x11TF_COND_STEALTHED\
    \x10\x04\x12\x18\n\x14TF_COND_INVULNERABLE\x10\x05\x12\x16\n\x12TF_COND_\
    TELEPORTED\x10\x06\x12\x14\n\x10TF_COND_TAUNTING\x10\x07\x12#\n\x1fTF_CO\
    ND_INVULNERABLE_WEARINGOFF\x10\x08\x12\x1b\n\x17TF_COND_STEALTHED_BLINK\
    \x10\t\x12\x20\n\x1cTF_COND_SELECTED_TO_TELEPORT\x10\n\x12\x17\n\x13TF_C\
    OND_CRITBOOSTED\x10\x0b\x12\x1a\n\x16TF_COND_TMPDAMAGEBONUS\x10\x0c\x12\
    \x17\n\x13TF_COND_FEIGN_DEATH\x10\r\x12\x11\n\rTF_COND_PHASE\x10\x0e\x12\
    \x13\n\x0fTF_COND_STUNNED\x10\x0f\x12\x17\n\x13TF_COND_OFFENSEBUFF\x10\
    \x10\x12\x19\n\x15TF_COND_SHIELD_CHARGE\x10\x11\x12\x15\n\x11TF_COND_DEM\
    O_BUFF\x10\x12\x12\x17\n\x13TF_COND_ENERGY_BUFF\x10\x13\x12\x16\n\x12TF_\
    COND_RADIUSHEAL\x10\x14\x12\x17\n\x13TF_COND_HEALTH_BUFF\x10\x15\x12\x13\
    \n\x0fTF_COND_BURNING\x10\x16\x12\x1d\n\x19TF_COND_HEALTH_OVERHEALED\x10\
    \x17\x12\x11\n\rTF_COND_URINE\x10\x18\x12\x14\n\x10TF_COND_BLEEDING\x10\
    \x19\x12\x17\n\x13TF_COND_DEFENSEBUFF\x10\x1a\x12\x14\n\x10TF_COND_MAD_M\
    ILK\x10\x1b\x12\x14\n\x10TF_COND_MEGAHEAL\x10\x1c\x12\x1d\n\x19TF_COND_R\
    EGENONDAMAGEBUFF\x10\x1d\x12\x1a\n\x16TF_COND_MARKEDFORDEATH\x10\x1e\x12\
    \x1f\n\x1bTF_COND_NOHEALINGDAMAGEBUFF\x10\x1f\x12\x17\n\x13TF_COND_SPEED\
    _BOOST\x10\x20\x12\x1f\n\x1bTF_COND_CRITBOOSTED_PUMPKIN\x10!\x12!\n\x1dT\
    F_COND_CRITBOOSTED_USER_BUFF\x10\"\x12#\n\x1fTF_COND_CRITBOOSTED_DEMO_CH\
    ARGE\x10#\x12\x1b\n\x17TF_COND_SODAPOPPER_HYPE\x10$\x12#\n\x1fTF_COND_CR\
    ITBOOSTED_FIRST_BLOOD\x10%\x12\"\n\x1eTF_COND_CRITBOOSTED_BONUS_TIME\x10\
    &\x12#\n\x1fTF_COND_CRITBOOSTED_CTF_CAPTURE\x10'\x12\x1f\n\x1bTF_COND_CR\
    ITBOOSTED_ON_KILL\x10(\x12$\n\x20TF_COND_CANNOT_SWITCH_FROM_MELEE\x10)\
    \x12%\n!TF_COND_DEFENSEBUFF_NO_CRIT_BLOCK\x10*\x12\x18\n\x14TF_COND_REPR\
    OGRAMMED\x10+\x12!\n\x1dTF_COND_CRITBOOSTED_RAGE_BUFF\x10,\x12\x1c\n\x18\
    TF_COND_DEFENSEBUFF_HIGH\x10-\x12\"\n\x1eTF_COND_SNIPERCHARGE_RAGE_BUFF\
    \x10.\x12\x1f\n\x1bTF_COND_DISGUISE_WEARINGOFF\x10/\x12!\n\x1dTF_COND_MA\
    RKEDFORDEATH_SILENT\x100\x12\"\n\x1eTF_COND_DISGUISED_AS_DISPENSER\x101\
    \x12\x12\n\x0eTF_COND_SAPPED\x102\x12,\n(TF_COND_INVULNERABLE_HIDE_UNLES\
    S_DAMAGED\x103\x12\"\n\x1eTF_COND_INVULNERABLE_USER_BUFF\x104\x12\x1f\n\
    \x1bTF_COND_HALLOWEEN_BOMB_HEAD\x105\x12\x1e\n\x1aTF_COND_HALLOWEEN_THRI\
    LLER\x106\x12\x20\n\x1cTF_COND_RADIUSHEAL_ON_DAMAGE\x107\x12#\n\x1fTF_CO\
    ND_CRITBOOSTED_CARD_EFFECT\x108\x12$\n\x20TF_COND_INVULNERABLE_CARD_EFFE\
    CT\x109\x12&\n\"TF_COND_MEDIGUN_UBER_BULLET_RESIST\x10:\x12%\n!TF_COND_M\
    EDIGUN_UBER_BLAST_RESIST\x10;\x12$\n\x20TF_COND_MEDIGUN_UBER_FIRE_RESIST\
    \x10<\x12'\n#TF_COND_MEDIGUN_SMALL_BULLET_RESIST\x10=\x12&\n\"TF_COND_ME\
    DIGUN_SMALL_BLAST_RESIST\x10>\x12%\n!TF_COND_MEDIGUN_SMALL_FIRE_RESIST\
    \x10?\x12\x1f\n\x1bTF_COND_STEALTHED_USER_BUFF\x10@\x12\x1a\n\x16TF_COND\
    _MEDIGUN_DEBUFF\x10A\x12&\n\"TF_COND_STEALTHED_USER_BUFF_FADING\x10B\x12\
    \x19\n\x15TF_COND_BULLET_IMMUNE\x10C\x12\x18\n\x14TF_COND_BLAST_IMMUNE\
    \x10D\x12\x17\n\x13TF_COND_FIRE_IMMUNE\x10E\x12\x19\n\x15TF_COND_PREVENT\
    _DEATH\x10F\x12\"\n\x1eTF_COND_MVM_BOT_STUN_RADIOWAVE\x10G\x12!\n\x1dTF_\
    COND_HALLOWEEN_SPEED_BOOST\x10H\x12\x20\n\x1cTF_COND_HALLOWEEN_QUICK_HEA\
    L\x10I\x12\x1b\n\x17TF_COND_HALLOWEEN_GIANT\x10J\x12\x1a\n\x16TF_COND_HA\
    LLOWEEN_TINY\x10K\x12\x1d\n\x19TF_COND_HALLOWEEN_IN_HELL\x10L\x12\x20\n\
    \x1cTF_COND_HALLOWEEN_GHOST_MODE\x10M\x12#\n\x1fTF_COND_MINICRITBOOSTED_\
    ON_KILL\x10N\x12\x1a\n\x16TF_COND_OBSCURED_SMOKE\x10O\x12\x1c\n\x18TF_CO\
    ND_PARACHUTE_ACTIVE\x10P\x12\x18\n\x14TF_COND_BLASTJUMPING\x10Q\x12\x1a\
    \n\x16TF_COND_HALLOWEEN_KART\x10R\x12\x1f\n\x1bTF_COND_HALLOWEEN_KART_DA\
    SH\x10S\x12\x18\n\x14TF_COND_BALLOON_HEAD\x10T\x12\x16\n\x12TF_COND_MELE\
    E_ONLY\x10U\x12\x1a\n\x16TF_COND_SWIMMING_CURSE\x10V\x12\x18\n\x14TF_CON\
    D_FREEZE_INPUT\x10W\x12\x1f\n\x1bTF_COND_HALLOWEEN_KART_CAGE\x10X\x12\
    \x16\n\x12TF_COND_DONOTUSE_0\x10Y\x12\x19\n\x15TF_COND_RUNE_STRENGTH\x10\
    Z\x12\x16\n\x12TF_COND_RUNE_HASTE\x10[\x12\x16\n\x12TF_COND_RUNE_REGEN\
    \x10\\\x12\x17\n\x13TF_COND_RUNE_RESIST\x10]\x12\x18\n\x14TF_COND_RUNE_V\
    AMPIRE\x10^\x12\x18\n\x14TF_COND_RUNE_REFLECT\x10_\x12\x1a\n\x16TF_COND_\
    RUNE_PRECISION\x10`\x12\x18\n\x14TF_COND_RUNE_AGILITY\x10a\x12\x19\n\x15\
    TF_COND_GRAPPLINGHOOK\x10b\x12\"\n\x1eTF_COND_GRAPPLINGHOOK_SAFEFALL\x10\
    c\x12!\n\x1dTF_COND_GRAPPLINGHOOK_LATCHED\x10d\x12\"\n\x1eTF_COND_GRAPPL\
    INGHOOK_BLEEDING\x10e\x12\x1c\n\x18TF_COND_AFTERBURN_IMMUNE\x10f\x12\x19\
    \n\x15TF_COND_RUNE_KNOCKOUT\x10g\x12\x1a\n\x16TF_COND_RUNE_IMBALANCE\x10\
    h\x12!\n\x1dTF_COND_CRITBOOSTED_RUNE_TEMP\x10i\x12!\n\x1dTF_COND_PASSTIM\
    E_INTERCEPTION\x10j\x12\x1f\n\x1bTF_COND_SWIMMING_NO_EFFECTS\x10k\x12\
    \x15\n\x11TF_COND_PURGATORY\x10l\x12\x15\n\x11TF_COND_RUNE_KING\x10m\x12\
    \x17\n\x13TF_COND_RUNE_PLAGUE\x10n\x12\x1a\n\x16TF_COND_RUNE_SUPERNOVA\
    \x10o\x12\x12\n\x0eTF_COND_PLAGUE\x10p\x12\x17\n\x13TF_COND_KING_BUFFED\
    \x10q\x12\x16\n\x12TF_COND_TEAM_GLOWS\x10r\x12\x1c\n\x18TF_COND_KNOCKED_\
    INTO_AIR\x10s\x12\x1e\n\x1aTF_COND_COMPETITIVE_WINNER\x10t\x12\x1d\n\x19\
    TF_COND_COMPETITIVE_LOSER\x10u\x12\x1a\n\x16TF_COND_HEALING_DEBUFF\x10v\
    \x12#\n\x1fTF_COND_PASSTIME_PENALTY_DEBUFF\x10w\x12\x1e\n\x1aTF_COND_PAR\
    ACHUTE_DEPLOYED\x10x\x12!\n\x1dTF_COND_NO_COMBAT_SPEED_BOOST\x10y\x12\
    \x1b\n\x17TF_COND_TRANQ_SPY_BOOST\x10z\x12\x18\n\x14TF_COND_TRANQ_MARKED\
    \x10{\x12\x16\n\x12TF_COND_ROCKETPACK\x10~\x12\x20\n\x1cTF_COND_ROCKETPA\
    CK_PASSENGER\x10\x7f\x12\x1c\n\x17TF_COND_STEALTHED_PHASE\x10\x80\x01\
    \x12\x1a\n\x15TF_COND_CLIP_OVERLOAD\x10\x81\x01\x12\x1c\n\x17TF_COND_SPY\
    _CLASS_STEAL\x10\x82\x01\x12\x10\n\x0bTF_COND_GAS\x10\x83\x01\"-\n\x08ET\
    F2Team\x12\x0f\n\x0bTF_TEAM_RED\x10\x02\x12\x10\n\x0cTF_TEAM_BLUE\x10\
    \x03\"\x9c\t\n\x0cCMsgQuestDef\x12+\n\x06header\x18\x01\x20\x02(\x0b2\
    \x13.CMsgProtoDefHeaderR\x06header\x12\x20\n\x0cmax_points_0\x18\x02\x20\
    \x01(\rR\nmaxPoints0\x12\x20\n\x0cmax_points_1\x18\x03\x20\x01(\rR\nmaxP\
    oints1\x12\x20\n\x0cmax_points_2\x18\x04\x20\x01(\rR\nmaxPoints2\x12)\n\
    \rname_loctoken\x18\x05\x20\x01(\tR\x0cnameLoctokenB\x04\x90\x97\"\x01\
    \x12\x1c\n\toperation\x18\x07\x20\x01(\tR\toperation\x129\n\x0bmm_criter\
    ia\x18\x08\x20\x01(\x0b2\x18.CMsgQuestDef.MMCriteriaR\nmmCriteria\x12_\n\
    \nnode_image\x18\x0c\x20\x01(\tR\tnodeImageB@\xa2\x97\"\nNode\x20Image\
    \xaa\x97\".Filename\x20of\x20the\x20image\x20to\x20show\x20on\x20the\x20\
    node\x20view\x12M\n\nicon_image\x18\r\x20\x01(\tR\ticonImageB.\xaa\x97\"\
    \x1dWhich\x20icon\x20to\x20show\x20on\x20the\x20map\xa2\x97\"\tNode\x20I\
    con\x12+\n\x05theme\x18\x0e\x20\x01(\x0b2\x0f.CMsgProtoDefIDR\x05themeB\
    \x04\x80\x97\"\x02\x12S\n\x0cloaner_names\x18\x0f\x20\x03(\tR\x0bloanerN\
    amesB0\xa2\x97\"\x07Loaners\xaa\x97\"!Names\x20of\x20items\x20to\x20give\
    \x20as\x20loaners\x12?\n\nobjectives\x18\x10\x20\x03(\x0b2\x1f.CMsgQuest\
    Def.ObjectiveInstanceR\nobjectives\x12j\n\x03map\x18\x11\x20\x03(\tR\x03\
    mapBX\xa2\x97\"\rMaps\x20Modifier\xaa\x97\"CIf\x20set,\x20the\x20player\
    \x20must\x20be\x20on\x20one\x20of\x20the\x20listed\x20maps\x20to\x20get\
    \x20credit.\x1ak\n\nMMCriteria\x12\x1d\n\ngroup_name\x18\x01\x20\x01(\tR\
    \tgroupName\x12#\n\rcategory_name\x18\x02\x20\x01(\tR\x0ccategoryName\
    \x12\x19\n\x08map_name\x18\x03\x20\x01(\tR\x07mapName\x1a\xa8\x02\n\x11O\
    bjectiveInstance\x123\n\tobjective\x18\x01\x20\x01(\x0b2\x0f.CMsgProtoDe\
    fIDR\tobjectiveB\x04\x80\x97\"\x05\x12A\n\npoint_type\x18\x02\x20\x01(\
    \x0e2\r.EQuestPoints:\x13QUEST_POINTS_NOVICER\tpointType\x12\x9a\x01\n\
    \x0bpoint_value\x18\x03\x20\x01(\rR\npointValueBy\xa2\x97\"\x0fPoints\
    \x20Override\xaa\x97\"bOverride\x20value\x20for\x20the\x20point\x20value\
    \x20of\x20the\x20objective.\x20\x20If\x20not\x20set,\x20uses\x20the\x20o\
    bjective's\x20point\x20value\"\xc7\x03\n\x15CMsgQuestMapStoreItem\x12+\n\
    \x06header\x18\x01\x20\x02(\x0b2\x13.CMsgProtoDefHeaderR\x06header\x12\
    \x1b\n\titem_name\x18\x02\x20\x01(\tR\x08itemName\x12u\n\x14reward_lootl\
    ist_name\x18\x06\x20\x01(\tR\x12rewardLootlistNameBC\xa2\x97\"\x0fReward\
    \x20Lootlist\xaa\x97\",The\x20name\x20of\x20the\x20lootlist\x20to\x20rol\
    l\x20as\x20a\x20reward\x12)\n\x05price\x18\x03\x20\x01(\x0b2\r.CMsgVarFi\
    eldR\x05priceB\x04\xf0\x97\"\x06\x12h\n\x0epurchase_limit\x18\x04\x20\
    \x01(\rR\rpurchaseLimitBA\xaa\x97\"+How\x20many\x20times\x20this\x20rewa\
    rd\x20can\x20be\x20purchased\xa2\x97\"\x0ePurchase\x20Limit\x12X\n\nsort\
    _group\x18\x05\x20\x01(\rR\tsortGroupB9\xa2\x97\"\nSort\x20group\xaa\x97\
    \"'Sort\x20by\x20this\x20group,\x20then\x20alhpabetically\"\xbd\x06\n\
    \x15CMsgQuestMapRegionDef\x12+\n\x06header\x18\x01\x20\x02(\x0b2\x13.CMs\
    gProtoDefHeaderR\x06header\x12\x18\n\x04name\x18\x02\x20\x01(\tR\x04name\
    B\x04\x90\x97\"\x01\x12\x18\n\x07resfile\x18\x03\x20\x01(\tR\x07resfile\
    \x127\n\x05links\x18\x04\x20\x03(\x0b2!.CMsgQuestMapRegionDef.RegionLink\
    R\x05links\x12\x7f\n\x0breturn_link\x18\x05\x20\x01(\x0b2\x0f.CMsgProtoD\
    efIDR\nreturnLinkBM\x80\x97\"\x03\xaa\x97\"6Which\x20link\x20we\x20go\
    \x20to\x20when\x20right-clicking\x20in\x20this\x20region\xa2\x97\"\x0bRe\
    turn\x20Link\x12z\n\nradio_freq\x18\x06\x20\x01(\x02R\tradioFreqB[\xaa\
    \x97\"HWhere\x20the\x20radio\x20tuner\x20goes\x20on\x20the\x20CYOA\x20PD\
    A\x20when\x20this\x20region\x20is\x20selection\xa2\x97\"\x0bRadio\x20Fre\
    q.\x12\x98\x01\n\nzoom_scale\x18\x07\x20\x01(\x02R\tzoomScaleBy\xaa\x97\
    \"gHow\x20zoomed\x20in\x20this\x20panel\x20should\x20be.\x20\x20Affects\
    \x20the\x20scale\x20of\x20the\x20map\x20grid\x20lines\x20and\x20node\x20\
    link\x20dashed\x20lines\xa2\x97\"\nZoom\x20Scale\x12u\n\tstar_type\x18\
    \x08\x20\x01(\x0b2\x0f.CMsgProtoDefIDR\x08starTypeBG\xaa\x97\"2What\x20s\
    tars\x20(if\x20any)\x20the\x20nodes\x20within\x20use\x20to\x20unlock\xa2\
    \x97\"\tStar\x20Type\x80\x97\"\x0c\x1a{\n\nRegionLink\x12E\n\x13target_r\
    egion_defid\x18\x01\x20\x02(\x0b2\x0f.CMsgProtoDefIDR\x11targetRegionDef\
    idB\x04\x80\x97\"\x03\x12\x12\n\x04xpos\x18\x02\x20\x01(\rR\x04xpos\x12\
    \x12\n\x04ypos\x18\x03\x20\x01(\rR\x04ypos\"\x83\x02\n\x0cCMsgVarField\
    \x12\x20\n\x08variable\x18\x01\x20\x01(\tR\x08variableB\x04\xf8\x97\"\
    \x01\x12\x16\n\x05float\x18\x02\x20\x01(\x02H\0R\x05float\x12\x18\n\x06d\
    ouble\x18\x03\x20\x01(\x01H\0R\x06double\x12\x18\n\x06uint32\x18\x04\x20\
    \x01(\rH\0R\x06uint32\x12\x18\n\x06uint64\x18\x05\x20\x01(\x04H\0R\x06ui\
    nt64\x12\x18\n\x06sint32\x18\x06\x20\x01(\x11H\0R\x06sint32\x12\x18\n\
    \x06sint64\x18\x07\x20\x01(\x12H\0R\x06sint64\x12\x14\n\x04bool\x18\x08\
    \x20\x01(\x08H\0R\x04bool\x12\x18\n\x06string\x18\t\x20\x01(\tH\0R\x06st\
    ringB\x07\n\x05value\"j\n\x14CMsgQuestMapStarType\x12+\n\x06header\x18\
    \x01\x20\x02(\x0b2\x13.CMsgProtoDefHeaderR\x06header\x12%\n\x04name\x18\
    \x02\x20\x01(\tR\x04nameB\x11\x90\x97\"\x01\xa2\x97\"\tType\x20Name\"\
    \xbc\n\n\x13CMsgQuestMapNodeDef\x12+\n\x06header\x18\x01\x20\x02(\x0b2\
    \x13.CMsgProtoDefHeaderR\x06header\x12O\n\rname_loctoken\x18\x04\x20\x01\
    (\tR\x0cnameLoctokenB*\xa2\x97\"\tNode\x20Name\xaa\x97\"\x15The\x20name\
    \x20of\x20this\x20node\x90\x97\"\x01\x12A\n\x05x_pos\x18\x06\x20\x01(\
    \x02R\x04xPosB,\xaa\x97\"\x1bX\x20position\x20on\x20the\x20quest\x20map\
    \xa2\x97\"\tMap\x20X\x20Pos\x12A\n\x05y_pos\x18\x07\x20\x01(\x02R\x04yPo\
    sB,\xa2\x97\"\tMap\x20Y\x20Pos\xaa\x97\"\x1bY\x20position\x20on\x20the\
    \x20quest\x20map\x12\x7f\n\tcondition\x18\t\x20\x01(\x0b2\x1a.CMsgQuestM\
    apNodeConditionR\tconditionBE\xaa\x97\"3Logic\x20to\x20unlock\x20this\
    \x20node.\x20Can\x20be\x20nested\x20with\x20logic\xa2\x97\"\nConditions\
    \x12u\n\rowning_region\x18\n\x20\x01(\x0b2\x0f.CMsgProtoDefIDR\x0cowning\
    RegionB?\xa2\x97\"\x06Region\x80\x97\"\x03\xaa\x97\"-Which\x20region\x20\
    in\x20the\x20map\x20this\x20node\x20shows\x20up\x20in\x12r\n\rquest_opti\
    ons\x18\x0b\x20\x03(\x0b2\x0f.CMsgProtoDefIDR\x0cquestOptionsB<\xb8\x97\
    \"\x03\x80\x97\"\x04\xaa\x97\"\x1eWhich\x20quests\x20this\x20node\x20off\
    ers.\xa2\x97\"\x0eOffered\x20Quests\x12u\n\x14associated_operation\x18\
    \x10\x20\x01(\tR\x13associatedOperationBB\xa2\x97\"\x14Associated\x20Ope\
    ration\xaa\x97\"&Operation\x20this\x20node\x20is\x20associated\x20with\
    \x12d\n\x10reward_item_name\x18\x12\x20\x01(\tR\x0erewardItemNameB:\xaa\
    \x97\"'The\x20name\x20of\x20an\x20item\x20to\x20give\x20as\x20a\x20rewar\
    d\xa2\x97\"\x0bReward\x20Item\x12u\n\x14reward_lootlist_name\x18\x16\x20\
    \x01(\tR\x12rewardLootlistNameBC\xa2\x97\"\x0fReward\x20Lootlist\xaa\x97\
    \",The\x20name\x20of\x20the\x20lootlist\x20to\x20roll\x20as\x20a\x20rewa\
    rd\x12\x93\x01\n\x0bcash_reward\x18\x13\x20\x01(\x0e2\x10.ENodeCashRewar\
    d:\x10CASH_REWARD_NONER\ncashRewardBN\xa2\x97\"\x0bCash\x20Reward\xaa\
    \x97\";How\x20much\x20cash\x20to\x20give\x20when\x20completing\x20the\
    \x20primary\x20objective\x12d\n\tstar_type\x18\x14\x20\x01(\x0b2\x0f.CMs\
    gProtoDefIDR\x08starTypeB6\xa2\x97\"\tStar\x20Type\x80\x97\"\x0c\xaa\x97\
    \"!Which\x20type\x20of\x20star\x20this\x20node\x20uses\x12e\n\x0fstars_t\
    o_unlock\x18\x15\x20\x01(\r:\x011R\rstarsToUnlockB:\xa2\x97\"\x0fStars\
    \x20to\x20Unlock\xaa\x97\"#Numbers\x20of\x20stars\x20it\x20costs\x20to\
    \x20unlock\"E\n\x16CMsgPaintKit_Variables\x12+\n\x06header\x18\x01\x20\
    \x02(\x0b2\x13.CMsgProtoDefHeaderR\x06header\"\x91\x05\n#CMsgPaintKit_Op\
    eration_TextureStage\x12-\n\x07texture\x18\x01\x20\x01(\x0b2\r.CMsgVarFi\
    eldR\x07textureB\x04\xf0\x97\"\t\x124\n\x0btexture_red\x18\x02\x20\x01(\
    \x0b2\r.CMsgVarFieldR\ntextureRedB\x04\xf0\x97\"\t\x126\n\x0ctexture_blu\
    e\x18\x03\x20\x01(\x0b2\r.CMsgVarFieldR\x0btextureBlueB\x04\xf0\x97\"\t\
    \x126\n\x0cadjust_black\x18\x04\x20\x01(\x0b2\r.CMsgVarFieldR\x0badjustB\
    lackB\x04\xf0\x97\"\t\x128\n\radjust_offset\x18\x05\x20\x01(\x0b2\r.CMsg\
    VarFieldR\x0cadjustOffsetB\x04\xf0\x97\"\t\x126\n\x0cadjust_gamma\x18\
    \x06\x20\x01(\x0b2\r.CMsgVarFieldR\x0badjustGammaB\x04\xf0\x97\"\t\x12/\
    \n\x08rotation\x18\x07\x20\x01(\x0b2\r.CMsgVarFieldR\x08rotationB\x04\
    \xf0\x97\"\t\x124\n\x0btranslate_u\x18\x08\x20\x01(\x0b2\r.CMsgVarFieldR\
    \ntranslateUB\x04\xf0\x97\"\t\x124\n\x0btranslate_v\x18\t\x20\x01(\x0b2\
    \r.CMsgVarFieldR\ntranslateVB\x04\xf0\x97\"\t\x12.\n\x08scale_uv\x18\n\
    \x20\x01(\x0b2\r.CMsgVarFieldR\x07scaleUvB\x04\xf0\x97\"\t\x12*\n\x06fli\
    p_u\x18\x0b\x20\x01(\x0b2\r.CMsgVarFieldR\x05flipUB\x04\xf0\x97\"\t\x12*\
    \n\x06flip_v\x18\x0c\x20\x01(\x0b2\r.CMsgVarFieldR\x05flipVB\x04\xf0\x97\
    \"\t\"\xb8\x04\n#CMsgPaintKit_Operation_CombineStage\x126\n\x0cadjust_bl\
    ack\x18\x01\x20\x01(\x0b2\r.CMsgVarFieldR\x0badjustBlackB\x04\xf0\x97\"\
    \t\x128\n\radjust_offset\x18\x02\x20\x01(\x0b2\r.CMsgVarFieldR\x0cadjust\
    OffsetB\x04\xf0\x97\"\t\x126\n\x0cadjust_gamma\x18\x03\x20\x01(\x0b2\r.C\
    MsgVarFieldR\x0badjustGammaB\x04\xf0\x97\"\t\x12/\n\x08rotation\x18\x04\
    \x20\x01(\x0b2\r.CMsgVarFieldR\x08rotationB\x04\xf0\x97\"\t\x124\n\x0btr\
    anslate_u\x18\x05\x20\x01(\x0b2\r.CMsgVarFieldR\ntranslateUB\x04\xf0\x97\
    \"\t\x124\n\x0btranslate_v\x18\x06\x20\x01(\x0b2\r.CMsgVarFieldR\ntransl\
    ateVB\x04\xf0\x97\"\t\x12.\n\x08scale_uv\x18\x07\x20\x01(\x0b2\r.CMsgVar\
    FieldR\x07scaleUvB\x04\xf0\x97\"\t\x12*\n\x06flip_u\x18\x08\x20\x01(\x0b\
    2\r.CMsgVarFieldR\x05flipUB\x04\xf0\x97\"\t\x12*\n\x06flip_v\x18\t\x20\
    \x01(\x0b2\r.CMsgVarFieldR\x05flipVB\x04\xf0\x97\"\t\x12B\n\x0eoperation\
    _node\x18\x0b\x20\x03(\x0b2\x1b.CMsgPaintKit_OperationNodeR\roperationNo\
    de\"\x82\x01\n\"CMsgPaintKit_Operation_SelectStage\x12+\n\x06groups\x18\
    \x01\x20\x01(\x0b2\r.CMsgVarFieldR\x06groupsB\x04\xf0\x97\"\t\x12/\n\x06\
    select\x18\x02\x20\x03(\x0b2\r.CMsgVarFieldR\x06selectB\x08\xf0\x97\"\t\
    \xb8\x97\"\x10\"\xfa\x02\n\x1eCMsgPaintKit_Operation_Sticker\x12]\n\x04b\
    ase\x18\x01\x20\x01(\x0b2\r.CMsgVarFieldR\x04baseB:\xf0\x97\"\t\xaa\x97\
    \"2Name\x20of\x20the\x20base\x20file\x20for\x20the\x20sticker\x20(the\
    \x20albedo)\x12[\n\x06weight\x18\x02\x20\x01(\x0b2\r.CMsgVarFieldR\x06we\
    ightB4\xf0\x97\"\t\xaa\x97\",Random\x20likelihood\x20this\x20one\x20is\
    \x20to\x20be\x20selected\x12\x9b\x01\n\x04spec\x18\x03\x20\x01(\x0b2\r.C\
    MsgVarFieldR\x04specBx\xaa\x97\"pName\x20of\x20the\x20specular\x20file\
    \x20for\x20the\x20sticker,\x20or\x20if\x20blank\x20we\x20will\x20assume\
    \x20it\x20is\x20baseFilename\x20+\x20_spec\x20+\x20baseExtension\xf0\x97\
    \"\t\"\xd8\x03\n#CMsgPaintKit_Operation_StickerStage\x129\n\x07sticker\
    \x18\x01\x20\x03(\x0b2\x1f.CMsgPaintKit_Operation_StickerR\x07sticker\
    \x12,\n\x07dest_tl\x18\x02\x20\x01(\x0b2\r.CMsgVarFieldR\x06destTlB\x04\
    \xf0\x97\"\t\x12,\n\x07dest_tr\x18\x03\x20\x01(\x0b2\r.CMsgVarFieldR\x06\
    destTrB\x04\xf0\x97\"\t\x12,\n\x07dest_bl\x18\x04\x20\x01(\x0b2\r.CMsgVa\
    rFieldR\x06destBlB\x04\xf0\x97\"\t\x126\n\x0cadjust_black\x18\x05\x20\
    \x01(\x0b2\r.CMsgVarFieldR\x0badjustBlackB\x04\xf0\x97\"\t\x128\n\radjus\
    t_offset\x18\x06\x20\x01(\x0b2\r.CMsgVarFieldR\x0cadjustOffsetB\x04\xf0\
    \x97\"\t\x126\n\x0cadjust_gamma\x18\x07\x20\x01(\x0b2\r.CMsgVarFieldR\
    \x0badjustGammaB\x04\xf0\x97\"\t\x12B\n\x0eoperation_node\x18\t\x20\x03(\
    \x0b2\x1b.CMsgPaintKit_OperationNodeR\roperationNode\"\xe8\x03\n\x1bCMsg\
    PaintKit_OperationStage\x12M\n\x0etexture_lookup\x18\x01\x20\x01(\x0b2$.\
    CMsgPaintKit_Operation_TextureStageH\0R\rtextureLookup\x12G\n\x0bcombine\
    _add\x18\x02\x20\x01(\x0b2$.CMsgPaintKit_Operation_CombineStageH\0R\ncom\
    bineAdd\x12I\n\x0ccombine_lerp\x18\x03\x20\x01(\x0b2$.CMsgPaintKit_Opera\
    tion_CombineStageH\0R\x0bcombineLerp\x12Q\n\x10combine_multiply\x18\x04\
    \x20\x01(\x0b2$.CMsgPaintKit_Operation_CombineStageH\0R\x0fcombineMultip\
    ly\x12=\n\x06select\x18\x05\x20\x01(\x0b2#.CMsgPaintKit_Operation_Select\
    StageH\0R\x06select\x12K\n\rapply_sticker\x18\x06\x20\x01(\x0b2$.CMsgPai\
    ntKit_Operation_StickerStageH\0R\x0capplyStickerB\x07\n\x05stage\"\xa6\
    \x01\n\x1aCMsgPaintKit_OperationNode\x124\n\x05stage\x18\x01\x20\x01(\
    \x0b2\x1c.CMsgPaintKit_OperationStageH\0R\x05stage\x12J\n\x12operation_t\
    emplate\x18\x02\x20\x01(\x0b2\x0f.CMsgProtoDefIDH\0R\x11operationTemplat\
    eB\x08\xe0\x97\"\x01\x80\x97\"\x07B\x06\n\x04node\"\x89\x01\n\x16CMsgPai\
    ntKit_Operation\x12+\n\x06header\x18\x01\x20\x02(\x0b2\x13.CMsgProtoDefH\
    eaderR\x06header\x12B\n\x0eoperation_node\x18\x02\x20\x03(\x0b2\x1b.CMsg\
    PaintKit_OperationNodeR\roperationNode\"\xa3\x03\n\x1bCMsgPaintKit_ItemD\
    efinition\x12+\n\x06header\x18\x01\x20\x02(\x0b2\x13.CMsgProtoDefHeaderR\
    \x06header\x122\n\x15item_definition_index\x18\x02\x20\x02(\rR\x13itemDe\
    finitionIndex\x12F\n\x11variable_template\x18\x03\x20\x01(\x0b2\x0f.CMsg\
    ProtoDefIDR\x10variableTemplateB\x08\xe0\x97\"\x01\x80\x97\"\x06\x12M\n\
    \ndefinition\x18\x04\x20\x03(\x0b2'.CMsgPaintKit_ItemDefinition.Definiti\
    onR\ndefinitionB\x04\xb8\x97\"\x05\x1a\x8b\x01\n\nDefinition\x12D\n\x12o\
    peration_template\x18\x01\x20\x01(\x0b2\x0f.CMsgProtoDefIDR\x11operation\
    TemplateB\x04\x80\x97\"\x07\x127\n\x08variable\x18\x02\x20\x03(\x0b2\r.C\
    MsgVarFieldR\x08variableB\x0c\xc8\x97\"\0\xf0\x97\"\t\xc0\x97\"\0\"\xa3\
    \x1c\n\x17CMsgPaintKit_Definition\x12+\n\x06header\x18\x01\x20\x02(\x0b2\
    \x13.CMsgProtoDefHeaderR\x06header\x12)\n\rloc_desctoken\x18\x02\x20\x01\
    (\tR\x0clocDesctokenB\x04\x90\x97\"\x01\x12\xc6\x01\n\x12operation_templ\
    ate\x18\x03\x20\x01(\x0b2\x0f.CMsgProtoDefIDR\x11operationTemplateB\x85\
    \x01\x80\x97\"\x07\xe0\x97\"\x01\xaa\x97\"yoperation\x20template\x20whic\
    h\x20all\x20items\x20in\x20the\x20list\x20will\x20use\x20unless\x20there\
    's\x20operation_template\x20specified\x20in\x20an\x20item_definition\x12\
    *\n\x11has_team_textures\x18\x04\x20\x01(\x08R\x0fhasTeamTextures\x121\n\
    \x04item\x18\x05\x20\x03(\x0b2\x1d.CMsgPaintKit_Definition.ItemR\x04item\
    \x12B\n\rpaintkit_tool\x18\x06\x20\x01(\x0b2\x1d.CMsgPaintKit_Definition\
    .ItemR\x0cpaintkitTool\x12A\n\x0cflamethrower\x18\x07\x20\x01(\x0b2\x1d.\
    CMsgPaintKit_Definition.ItemR\x0cflamethrower\x12G\n\x0fgrenadelauncher\
    \x18\x08\x20\x01(\x0b2\x1d.CMsgPaintKit_Definition.ItemR\x0fgrenadelaunc\
    her\x123\n\x05knife\x18\t\x20\x01(\x0b2\x1d.CMsgPaintKit_Definition.Item\
    R\x05knife\x127\n\x07medigun\x18\n\x20\x01(\x0b2\x1d.CMsgPaintKit_Defini\
    tion.ItemR\x07medigun\x127\n\x07minigun\x18\x0b\x20\x01(\x0b2\x1d.CMsgPa\
    intKit_Definition.ItemR\x07minigun\x125\n\x06pistol\x18\x0c\x20\x01(\x0b\
    2\x1d.CMsgPaintKit_Definition.ItemR\x06pistol\x129\n\x08revolver\x18\r\
    \x20\x01(\x0b2\x1d.CMsgPaintKit_Definition.ItemR\x08revolver\x12E\n\x0er\
    ocketlauncher\x18\x0e\x20\x01(\x0b2\x1d.CMsgPaintKit_Definition.ItemR\
    \x0erocketlauncher\x12=\n\nscattergun\x18\x0f\x20\x01(\x0b2\x1d.CMsgPain\
    tKit_Definition.ItemR\nscattergun\x127\n\x07shotgun\x18\x10\x20\x01(\x0b\
    2\x1d.CMsgPaintKit_Definition.ItemR\x07shotgun\x12/\n\x03smg\x18\x11\x20\
    \x01(\x0b2\x1d.CMsgPaintKit_Definition.ItemR\x03smg\x12?\n\x0bsniperrifl\
    e\x18\x12\x20\x01(\x0b2\x1d.CMsgPaintKit_Definition.ItemR\x0bsniperrifle\
    \x12N\n\x13stickybomb_launcher\x18\x13\x20\x01(\x0b2\x1d.CMsgPaintKit_De\
    finition.ItemR\x12stickybombLauncher\x127\n\x07ubersaw\x18\x14\x20\x01(\
    \x0b2\x1d.CMsgPaintKit_Definition.ItemR\x07ubersaw\x125\n\x06wrench\x18\
    \x15\x20\x01(\x0b2\x1d.CMsgPaintKit_Definition.ItemR\x06wrench\x12;\n\ta\
    mputator\x18\x16\x20\x01(\x0b2\x1d.CMsgPaintKit_Definition.ItemR\tamputa\
    tor\x12B\n\ratom_launcher\x18\x17\x20\x01(\x0b2\x1d.CMsgPaintKit_Definit\
    ion.ItemR\x0catomLauncher\x12D\n\x0eback_scratcher\x18\x18\x20\x01(\x0b2\
    \x1d.CMsgPaintKit_Definition.ItemR\rbackScratcher\x12;\n\tbattleaxe\x18\
    \x19\x20\x01(\x0b2\x1d.CMsgPaintKit_Definition.ItemR\tbattleaxe\x12B\n\r\
    bazaar_sniper\x18\x1a\x20\x01(\x0b2\x1d.CMsgPaintKit_Definition.ItemR\
    \x0cbazaarSniper\x129\n\x08blackbox\x18\x1b\x20\x01(\x0b2\x1d.CMsgPaintK\
    it_Definition.ItemR\x08blackbox\x12E\n\x0eclaidheamohmor\x18\x1c\x20\x01\
    (\x0b2\x1d.CMsgPaintKit_Definition.ItemR\x0eclaidheamohmor\x12L\n\x12cru\
    saders_crossbow\x18\x1d\x20\x01(\x0b2\x1d.CMsgPaintKit_Definition.ItemR\
    \x11crusadersCrossbow\x12;\n\tdegreaser\x18\x1e\x20\x01(\x0b2\x1d.CMsgPa\
    intKit_Definition.ItemR\tdegreaser\x12>\n\x0bdemo_cannon\x18\x1f\x20\x01\
    (\x0b2\x1d.CMsgPaintKit_Definition.ItemR\ndemoCannon\x12I\n\x11demo_sult\
    an_sword\x18\x20\x20\x01(\x0b2\x1d.CMsgPaintKit_Definition.ItemR\x0fdemo\
    SultanSword\x12;\n\tdetonator\x18!\x20\x01(\x0b2\x1d.CMsgPaintKit_Defini\
    tion.ItemR\tdetonator\x12>\n\x0bgatling_gun\x18\"\x20\x01(\x0b2\x1d.CMsg\
    PaintKit_Definition.ItemR\ngatlingGun\x12A\n\x0cholymackerel\x18#\x20\
    \x01(\x0b2\x1d.CMsgPaintKit_Definition.ItemR\x0cholymackerel\x12/\n\x03j\
    ag\x18$\x20\x01(\x0b2\x1d.CMsgPaintKit_Definition.ItemR\x03jag\x12;\n\tl\
    ochnload\x18%\x20\x01(\x0b2\x1d.CMsgPaintKit_Definition.ItemR\tlochnload\
    \x12;\n\tpowerjack\x18&\x20\x01(\x0b2\x1d.CMsgPaintKit_Definition.ItemR\
    \tpowerjack\x129\n\x08quadball\x18'\x20\x01(\x0b2\x1d.CMsgPaintKit_Defin\
    ition.ItemR\x08quadball\x12F\n\x0freserve_shooter\x18(\x20\x01(\x0b2\x1d\
    .CMsgPaintKit_Definition.ItemR\x0ereserveShooter\x12>\n\x0briding_crop\
    \x18)\x20\x01(\x0b2\x1d.CMsgPaintKit_Definition.ItemR\nridingCrop\x12@\n\
    \x0crussian_riot\x18*\x20\x01(\x0b2\x1d.CMsgPaintKit_Definition.ItemR\
    \x0brussianRiot\x129\n\x08scimitar\x18+\x20\x01(\x0b2\x1d.CMsgPaintKit_D\
    efinition.ItemR\x08scimitar\x12>\n\x0bscorch_shot\x18,\x20\x01(\x0b2\x1d\
    .CMsgPaintKit_Definition.ItemR\nscorchShot\x12;\n\tshortstop\x18-\x20\
    \x01(\x0b2\x1d.CMsgPaintKit_Definition.ItemR\tshortstop\x12>\n\x0bsoda_p\
    opper\x18.\x20\x01(\x0b2\x1d.CMsgPaintKit_Definition.ItemR\nsodaPopper\
    \x12@\n\x0ctele_shotgun\x18/\x20\x01(\x0b2\x1d.CMsgPaintKit_Definition.I\
    temR\x0bteleShotgun\x129\n\x08tomislav\x180\x20\x01(\x0b2\x1d.CMsgPaintK\
    it_Definition.ItemR\x08tomislav\x12;\n\ttrenchgun\x181\x20\x01(\x0b2\x1d\
    .CMsgPaintKit_Definition.ItemR\ttrenchgun\x12B\n\rwinger_pistol\x182\x20\
    \x01(\x0b2\x1d.CMsgPaintKit_Definition.ItemR\x0cwingerPistol\x1a\xe7\x02\
    \n\x04Item\x12v\n\x18item_definition_template\x18\x01\x20\x02(\x0b2\x0f.\
    CMsgProtoDefIDR\x16itemDefinitionTemplateB+\xd2\x97\"#CPaintKitDefIdFiel\
    dProtoEditorField\x80\x97\"\x08\x12:\n\x04data\x18\x05\x20\x01(\x0b2&.CM\
    sgPaintKit_Definition.Item.ItemDataR\x04data\x1a\xa4\x01\n\x08ItemData\
    \x122\n\x12can_apply_paintkit\x18\x02\x20\x01(\x08:\x04trueR\x10canApply\
    Paintkit\x12+\n\x11material_override\x18\x03\x20\x01(\tR\x10materialOver\
    ride\x127\n\x08variable\x18\x04\x20\x03(\x0b2\r.CMsgVarFieldR\x08variabl\
    eB\x0c\xc8\x97\"\0\xf0\x97\"\t\xc0\x97\"\0:\x04\x80\x88'\0\"\xb1\x05\n\
    \x0eCMsgQuestTheme\x12+\n\x06header\x18\x01\x20\x02(\x0b2\x13.CMsgProtoD\
    efHeaderR\x06header\x12)\n\x10notification_res\x18\x02\x20\x01(\tR\x0fno\
    tificationRes\x12$\n\x0equest_item_res\x18\x03\x20\x01(\tR\x0cquestItemR\
    es\x12-\n\x13in_game_tracker_res\x18\x04\x20\x01(\tR\x10inGameTrackerRes\
    \x12B\n\x0bgive_sounds\x18\x05\x20\x03(\x0b2!.CMsgQuestTheme.WeightedStr\
    ingSetR\ngiveSounds\x12J\n\x0fcomplete_sounds\x18\x06\x20\x03(\x0b2!.CMs\
    gQuestTheme.WeightedStringSetR\x0ecompleteSounds\x12U\n\x15fully_complet\
    e_sounds\x18\x07\x20\x03(\x0b2!.CMsgQuestTheme.WeightedStringSetR\x13ful\
    lyCompleteSounds\x12!\n\x0creward_sound\x18\x08\x20\x01(\tR\x0brewardSou\
    nd\x12#\n\rdiscard_sound\x18\t\x20\x01(\tR\x0cdiscardSound\x12!\n\x0crev\
    eal_sound\x18\n\x20\x01(\tR\x0brevealSound\x1a@\n\x0eWeightedString\x12\
    \x16\n\x06string\x18\x01\x20\x01(\tR\x06string\x12\x16\n\x06weight\x18\
    \x02\x20\x01(\rR\x06weight\x1a^\n\x11WeightedStringSet\x12I\n\x10weighte\
    d_strings\x18\x01\x20\x03(\x0b2\x1e.CMsgQuestTheme.WeightedStringR\x0fwe\
    ightedStrings\"\xd1\x02\n#CMsgQuestMapNodeCondition_NodeState\x12\x99\
    \x01\n\x19bonus_objectives_required\x18\x01\x20\x01(\r:\x010R\x17bonusOb\
    jectivesRequiredBZ\xa2\x97\"\x0eBonus\x20Required\xaa\x97\"DNumber\x20of\
    \x20bonus\x20objectives\x20required,\x20on\x20top\x20of\x20the\x20primar\
    y\x20objective\x12\x8d\x01\n\x11target_node_defid\x18\x02\x20\x02(\x0b2\
    \x0f.CMsgProtoDefIDR\x0ftargetNodeDefidBP\x80\x97\"\0\xa2\x97\"\x0bTarge\
    t\x20Node\xaa\x97\"9Which\x20node\x20is\x20required\x20to\x20have\x20the\
    \x20above\x20number\x20of\x20medals\"\xf7\x01\n\x1fCMsgQuestMapNodeCondi\
    tion_Logic\x12T\n\toperation\x18\x01\x20\x02(\x0e2\x11.LogicalOperation:\
    \x03ANDR\toperationB\x1e\xa2\x97\"\x05Logic\xaa\x97\"\x11Logical\x20oper\
    ation\x12~\n\x0esub_conditions\x18\x02\x20\x03(\x0b2\x1a.CMsgQuestMapNod\
    eConditionR\rsubConditionsB;\xaa\x97\"+Definitions\x20to\x20use\x20in\
    \x20the\x20logical\x20operation\xa2\x97\"\x08Operands\"\xe3\x02\n\x19CMs\
    gQuestMapNodeCondition\x12\xa2\x01\n\nnode_state\x18\x01\x20\x01(\x0b2$.\
    CMsgQuestMapNodeCondition_NodeStateH\0R\tnodeStateB[\xaa\x97\"?Returns\
    \x20true\x20if\x20a\x20specific\x20node\x20has\x20a\x20required\x20numbe\
    r\x20of\x20medals\xa2\x97\"\x14Node\x20State\x20Condition\x12\x93\x01\n\
    \x07logical\x18\x02\x20\x01(\x0b2\x20.CMsgQuestMapNodeCondition_LogicH\0\
    R\x07logicalBU\xa2\x97\"\x11Logical\x20Condition\xaa\x97\"<Performs\x20a\
    \x20specified\x20logical\x20operation\x20to\x20all\x20sub\x20conditionsB\
    \x0b\n\toperation\"=\n\x0eCMsgHeaderOnly\x12+\n\x06header\x18\x01\x20\
    \x02(\x0b2\x13.CMsgProtoDefHeaderR\x06header*,\n\x10LogicalOperation\x12\
    \x07\n\x03AND\x10\0\x12\x06\n\x02OR\x10\x01\x12\x07\n\x03NOT\x10\x02*|\n\
    \x16EValueDefinitionSource\x12\x15\n\x11REFERENCE_DEFINES\x10\0\x12\x12\
    \n\x0ePARENT_DEFINES\x10\x01\x12\x10\n\x0cTHIS_DEFINES\x10\x02\x12\x14\n\
    \x10VARIABLE_DEFINES\x10\x03\x12\x0f\n\x0bNOT_DEFINED\x10\x04*\x81\x03\n\
    \rProtoDefTypes\x12\x1b\n\x17DEF_TYPE_QUEST_MAP_NODE\x10\0\x12\x18\n\x14\
    DEF_TYPE_QUEST_THEME\x10\x02\x12\x1d\n\x19DEF_TYPE_QUEST_MAP_REGION\x10\
    \x03\x12\x12\n\x0eDEF_TYPE_QUEST\x10\x04\x12\x1c\n\x18DEF_TYPE_QUEST_OBJ\
    ECTIVE\x10\x05\x12\x1f\n\x1bDEF_TYPE_PAINTKIT_VARIABLES\x10\x06\x12\x1f\
    \n\x1bDEF_TYPE_PAINTKIT_OPERATION\x10\x07\x12%\n!DEF_TYPE_PAINTKIT_ITEM_\
    DEFINITION\x10\x08\x12\x20\n\x1cDEF_TYPE_PAINTKIT_DEFINITION\x10\t\x12\
    \x18\n\x14DEF_TYPE_HEADER_ONLY\x10\n\x12!\n\x1dDEF_TYPE_QUEST_MAP_STORE_\
    ITEM\x10\x0b\x12\x20\n\x1cDEF_TYPE_QUEST_MAP_STAR_TYPE\x10\x0c*[\n\x0cEQ\
    uestPoints\x12\x17\n\x13QUEST_POINTS_NOVICE\x10\0\x12\x19\n\x15QUEST_POI\
    NTS_ADVANCED\x10\x01\x12\x17\n\x13QUEST_POINTS_EXPERT\x10\x02*\xca\x01\n\
    \rEVarFieldType\x12\x14\n\x10VAR_TYPE_INVALID\x10\x01\x12\x12\n\x0eVAR_T\
    YPE_FLOAT\x10\x02\x12\x13\n\x0fVAR_TYPE_DOUBLE\x10\x03\x12\x13\n\x0fVAR_\
    TYPE_UINT32\x10\x04\x12\x13\n\x0fVAR_TYPE_UINT64\x10\x05\x12\x13\n\x0fVA\
    R_TYPE_SINT32\x10\x06\x12\x13\n\x0fVAR_TYPE_SINT64\x10\x07\x12\x11\n\rVA\
    R_TYPE_BOOL\x10\x08\x12\x13\n\x0fVAR_TYPE_STRING\x10\t*m\n\x0fENodeCashR\
    eward\x12\x14\n\x10CASH_REWARD_NONE\x10\x01\x12\x15\n\x11CASH_REWARD_SMA\
    LL\x10\x02\x12\x16\n\x12CASH_REWARD_MEDIUM\x10\x03\x12\x15\n\x11CASH_REW\
    ARD_LARGE\x10\x04:N\n\x0estart_expanded\x18\x80\xf1\x04\x20\x01(\x08\x12\
    \x1f.google.protobuf.MessageOptions:\x04trueR\rstartExpanded:g\n\nvalid_\
    type\x18\xf0\xa2\x04\x20\x01(\x0e2\x0e.ProtoDefTypes\x12\x1d.google.prot\
    obuf.FieldOptions:\x17DEF_TYPE_QUEST_MAP_NODER\tvalidType:A\n\x08editabl\
    e\x18\xf1\xa2\x04\x20\x01(\x08\x12\x1d.google.protobuf.FieldOptions:\x04\
    trueR\x08editable:D\n\tlocalized\x18\xf2\xa2\x04\x20\x01(\x08\x12\x1d.go\
    ogle.protobuf.FieldOptions:\x05falseR\tlocalized:L\n\x0edo_not_inherit\
    \x18\xf3\xa2\x04\x20\x01(\x08\x12\x1d.google.protobuf.FieldOptions:\x05f\
    alseR\x0cdoNotInherit:B\n\x0cdisplay_name\x18\xf4\xa2\x04\x20\x01(\t\x12\
    \x1d.google.protobuf.FieldOptionsR\x0bdisplayName:9\n\x07comment\x18\xf5\
    \xa2\x04\x20\x01(\t\x12\x1d.google.protobuf.FieldOptionsR\x07comment:<\n\
    \tmax_count\x18\xf7\xa2\x04\x20\x01(\r\x12\x1d.google.protobuf.FieldOpti\
    onsR\x08maxCount:B\n\tallow_add\x18\xf8\xa2\x04\x20\x01(\x08\x12\x1d.goo\
    gle.protobuf.FieldOptions:\x04trueR\x08allowAdd:H\n\x0callow_delete\x18\
    \xf9\xa2\x04\x20\x01(\x08\x12\x1d.google.protobuf.FieldOptions:\x04trueR\
    \x0ballowDelete:Q\n\x14panel_class_override\x18\xfa\xa2\x04\x20\x01(\t\
    \x12\x1d.google.protobuf.FieldOptionsR\x12panelClassOverride:m\n#message\
    _inherhitance_key_field_name\x18\xfb\xa2\x04\x20\x01(\t\x12\x1d.google.p\
    rotobuf.FieldOptionsR\x1fmessageInherhitanceKeyFieldName:f\n\x1binherit_\
    reference_variables\x18\xfc\xa2\x04\x20\x01(\x08\x12\x1d.google.protobuf\
    .FieldOptions:\x05falseR\x19inheritReferenceVariables:R\n\x11self_inheri\
    t_only\x18\xfd\xa2\x04\x20\x01(\x08\x12\x1d.google.protobuf.FieldOptions\
    :\x05falseR\x0fselfInheritOnly:g\n\x0evar_field_type\x18\xfe\xa2\x04\x20\
    \x01(\x0e2\x0e.EVarFieldType\x12\x1d.google.protobuf.FieldOptions:\x10VA\
    R_TYPE_INVALIDR\x0cvarFieldType:R\n\x11merging_key_field\x18\xff\xa2\x04\
    \x20\x01(\x08\x12\x1d.google.protobuf.FieldOptions:\x05falseR\x0fmerging\
    KeyFieldB\x05H\x01\x80\x01\0J\xfb\x86\x02\n\x07\x12\x05\0\0\xd5\x04\x01\
    \n\t\n\x02\x03\0\x12\x03\0\x07)\n\x08\n\x01\x08\x12\x03\x02\0\x1c\n\t\n\
    \x02\x08\t\x12\x03\x02\0\x1c\n\x08\n\x01\x08\x12\x03\x03\0#\n\t\n\x02\
    \x08\x10\x12\x03\x03\0#\n\t\n\x01\x07\x12\x04\x05\0\x07\x01\n\t\n\x02\
    \x07\0\x12\x03\x06\x08>\n\n\n\x03\x07\0\x02\x12\x03\x05\x07&\n\n\n\x03\
    \x07\0\x04\x12\x03\x06\x08\x10\n\n\n\x03\x07\0\x05\x12\x03\x06\x11\x15\n\
    \n\n\x03\x07\0\x01\x12\x03\x06\x16$\n\n\n\x03\x07\0\x03\x12\x03\x06',\n\
    \n\n\x03\x07\0\x08\x12\x03\x06-=\n\n\n\x03\x07\0\x07\x12\x03\x068<\n\t\n\
    \x01\x07\x12\x04\t\0\x19\x01\n\t\n\x02\x07\x01\x12\x03\n\x08W\n\n\n\x03\
    \x07\x01\x02\x12\x03\t\x07$\n\n\n\x03\x07\x01\x04\x12\x03\n\x08\x10\n\n\
    \n\x03\x07\x01\x06\x12\x03\n\x11\x1f\n\n\n\x03\x07\x01\x01\x12\x03\n\x20\
    *\n\n\n\x03\x07\x01\x03\x12\x03\n-2\n\n\n\x03\x07\x01\x08\x12\x03\n3V\n\
    \n\n\x03\x07\x01\x07\x12\x03\n>U\n\t\n\x02\x07\x02\x12\x03\x0b\x088\n\n\
    \n\x03\x07\x02\x02\x12\x03\t\x07$\n\n\n\x03\x07\x02\x04\x12\x03\x0b\x08\
    \x10\n\n\n\x03\x07\x02\x05\x12\x03\x0b\x11\x15\n\n\n\x03\x07\x02\x01\x12\
    \x03\x0b\x16\x1e\n\n\n\x03\x07\x02\x03\x12\x03\x0b!&\n\n\n\x03\x07\x02\
    \x08\x12\x03\x0b'7\n\n\n\x03\x07\x02\x07\x12\x03\x0b26\n\t\n\x02\x07\x03\
    \x12\x03\x0c\x08:\n\n\n\x03\x07\x03\x02\x12\x03\t\x07$\n\n\n\x03\x07\x03\
    \x04\x12\x03\x0c\x08\x10\n\n\n\x03\x07\x03\x05\x12\x03\x0c\x11\x15\n\n\n\
    \x03\x07\x03\x01\x12\x03\x0c\x16\x1f\n\n\n\x03\x07\x03\x03\x12\x03\x0c\"\
    '\n\n\n\x03\x07\x03\x08\x12\x03\x0c(9\n\n\n\x03\x07\x03\x07\x12\x03\x0c3\
    8\n\t\n\x02\x07\x04\x12\x03\r\x08?\n\n\n\x03\x07\x04\x02\x12\x03\t\x07$\
    \n\n\n\x03\x07\x04\x04\x12\x03\r\x08\x10\n\n\n\x03\x07\x04\x05\x12\x03\r\
    \x11\x15\n\n\n\x03\x07\x04\x01\x12\x03\r\x16$\n\n\n\x03\x07\x04\x03\x12\
    \x03\r',\n\n\n\x03\x07\x04\x08\x12\x03\r->\n\n\n\x03\x07\x04\x07\x12\x03\
    \r8=\n\t\n\x02\x07\x05\x12\x03\x0e\x08-\n\n\n\x03\x07\x05\x02\x12\x03\t\
    \x07$\n\n\n\x03\x07\x05\x04\x12\x03\x0e\x08\x10\n\n\n\x03\x07\x05\x05\
    \x12\x03\x0e\x11\x17\n\n\n\x03\x07\x05\x01\x12\x03\x0e\x18$\n\n\n\x03\
    \x07\x05\x03\x12\x03\x0e',\n\t\n\x02\x07\x06\x12\x03\x0f\x08(\n\n\n\x03\
    \x07\x06\x02\x12\x03\t\x07$\n\n\n\x03\x07\x06\x04\x12\x03\x0f\x08\x10\n\
    \n\n\x03\x07\x06\x05\x12\x03\x0f\x11\x17\n\n\n\x03\x07\x06\x01\x12\x03\
    \x0f\x18\x1f\n\n\n\x03\x07\x06\x03\x12\x03\x0f\"'\n\t\n\x02\x07\x07\x12\
    \x03\x10\x08*\n\n\n\x03\x07\x07\x02\x12\x03\t\x07$\n\n\n\x03\x07\x07\x04\
    \x12\x03\x10\x08\x10\n\n\n\x03\x07\x07\x05\x12\x03\x10\x11\x17\n\n\n\x03\
    \x07\x07\x01\x12\x03\x10\x18!\n\n\n\x03\x07\x07\x03\x12\x03\x10$)\n\t\n\
    \x02\x07\x08\x12\x03\x11\x089\n\n\n\x03\x07\x08\x02\x12\x03\t\x07$\n\n\n\
    \x03\x07\x08\x04\x12\x03\x11\x08\x10\n\n\n\x03\x07\x08\x05\x12\x03\x11\
    \x11\x15\n\n\n\x03\x07\x08\x01\x12\x03\x11\x16\x1f\n\n\n\x03\x07\x08\x03\
    \x12\x03\x11\"'\n\n\n\x03\x07\x08\x08\x12\x03\x11(8\n\n\n\x03\x07\x08\
    \x07\x12\x03\x1137\n\t\n\x02\x07\t\x12\x03\x12\x08<\n\n\n\x03\x07\t\x02\
    \x12\x03\t\x07$\n\n\n\x03\x07\t\x04\x12\x03\x12\x08\x10\n\n\n\x03\x07\t\
    \x05\x12\x03\x12\x11\x15\n\n\n\x03\x07\t\x01\x12\x03\x12\x16\"\n\n\n\x03\
    \x07\t\x03\x12\x03\x12%*\n\n\n\x03\x07\t\x08\x12\x03\x12+;\n\n\n\x03\x07\
    \t\x07\x12\x03\x126:\n\t\n\x02\x07\n\x12\x03\x13\x085\n\n\n\x03\x07\n\
    \x02\x12\x03\t\x07$\n\n\n\x03\x07\n\x04\x12\x03\x13\x08\x10\n\n\n\x03\
    \x07\n\x05\x12\x03\x13\x11\x17\n\n\n\x03\x07\n\x01\x12\x03\x13\x18,\n\n\
    \n\x03\x07\n\x03\x12\x03\x13/4\n\t\n\x02\x07\x0b\x12\x03\x14\x08D\n\n\n\
    \x03\x07\x0b\x02\x12\x03\t\x07$\n\n\n\x03\x07\x0b\x04\x12\x03\x14\x08\
    \x10\n\n\n\x03\x07\x0b\x05\x12\x03\x14\x11\x17\n\n\n\x03\x07\x0b\x01\x12\
    \x03\x14\x18;\n\n\n\x03\x07\x0b\x03\x12\x03\x14>C\n\t\n\x02\x07\x0c\x12\
    \x03\x15\x08L\n\n\n\x03\x07\x0c\x02\x12\x03\t\x07$\n\n\n\x03\x07\x0c\x04\
    \x12\x03\x15\x08\x10\n\n\n\x03\x07\x0c\x05\x12\x03\x15\x11\x15\n\n\n\x03\
    \x07\x0c\x01\x12\x03\x15\x161\n\n\n\x03\x07\x0c\x03\x12\x03\x1549\n\n\n\
    \x03\x07\x0c\x08\x12\x03\x15:K\n\n\n\x03\x07\x0c\x07\x12\x03\x15EJ\n\t\n\
    \x02\x07\r\x12\x03\x16\x08B\n\n\n\x03\x07\r\x02\x12\x03\t\x07$\n\n\n\x03\
    \x07\r\x04\x12\x03\x16\x08\x10\n\n\n\x03\x07\r\x05\x12\x03\x16\x11\x15\n\
    \n\n\x03\x07\r\x01\x12\x03\x16\x16'\n\n\n\x03\x07\r\x03\x12\x03\x16*/\n\
    \n\n\x03\x07\r\x08\x12\x03\x160A\n\n\n\x03\x07\r\x07\x12\x03\x16;@\n\t\n\
    \x02\x07\x0e\x12\x03\x17\x08T\n\n\n\x03\x07\x0e\x02\x12\x03\t\x07$\n\n\n\
    \x03\x07\x0e\x04\x12\x03\x17\x08\x10\n\n\n\x03\x07\x0e\x06\x12\x03\x17\
    \x11\x1f\n\n\n\x03\x07\x0e\x01\x12\x03\x17\x20.\n\n\n\x03\x07\x0e\x03\
    \x12\x03\x1716\n\n\n\x03\x07\x0e\x08\x12\x03\x177S\n\n\n\x03\x07\x0e\x07\
    \x12\x03\x17BR\n\t\n\x02\x07\x0f\x12\x03\x18\x08B\n\n\n\x03\x07\x0f\x02\
    \x12\x03\t\x07$\n\n\n\x03\x07\x0f\x04\x12\x03\x18\x08\x10\n\n\n\x03\x07\
    \x0f\x05\x12\x03\x18\x11\x15\n\n\n\x03\x07\x0f\x01\x12\x03\x18\x16'\n\n\
    \n\x03\x07\x0f\x03\x12\x03\x18*/\n\n\n\x03\x07\x0f\x08\x12\x03\x180A\n\n\
    \n\x03\x07\x0f\x07\x12\x03\x18;@\n\n\n\x02\x05\0\x12\x04\x1b\0\x1f\x01\n\
    \n\n\x03\x05\0\x01\x12\x03\x1b\x05\x15\n\x0b\n\x04\x05\0\x02\0\x12\x03\
    \x1c\x08\x10\n\x0c\n\x05\x05\0\x02\0\x01\x12\x03\x1c\x08\x0b\n\x0c\n\x05\
    \x05\0\x02\0\x02\x12\x03\x1c\x0e\x0f\n\x0b\n\x04\x05\0\x02\x01\x12\x03\
    \x1d\x08\x0f\n\x0c\n\x05\x05\0\x02\x01\x01\x12\x03\x1d\x08\n\n\x0c\n\x05\
    \x05\0\x02\x01\x02\x12\x03\x1d\r\x0e\n\x0b\n\x04\x05\0\x02\x02\x12\x03\
    \x1e\x08\x10\n\x0c\n\x05\x05\0\x02\x02\x01\x12\x03\x1e\x08\x0b\n\x0c\n\
    \x05\x05\0\x02\x02\x02\x12\x03\x1e\x0e\x0f\n\n\n\x02\x05\x01\x12\x04!\0'\
    \x01\n\n\n\x03\x05\x01\x01\x12\x03!\x05\x1b\n\x0b\n\x04\x05\x01\x02\0\
    \x12\x03\"\x08\x1e\n\x0c\n\x05\x05\x01\x02\0\x01\x12\x03\"\x08\x19\n\x0c\
    \n\x05\x05\x01\x02\0\x02\x12\x03\"\x1c\x1d\n\x0b\n\x04\x05\x01\x02\x01\
    \x12\x03#\x08\x1b\n\x0c\n\x05\x05\x01\x02\x01\x01\x12\x03#\x08\x16\n\x0c\
    \n\x05\x05\x01\x02\x01\x02\x12\x03#\x19\x1a\n\x0b\n\x04\x05\x01\x02\x02\
    \x12\x03$\x08\x19\n\x0c\n\x05\x05\x01\x02\x02\x01\x12\x03$\x08\x14\n\x0c\
    \n\x05\x05\x01\x02\x02\x02\x12\x03$\x17\x18\n\x0b\n\x04\x05\x01\x02\x03\
    \x12\x03%\x08\x1d\n\x0c\n\x05\x05\x01\x02\x03\x01\x12\x03%\x08\x18\n\x0c\
    \n\x05\x05\x01\x02\x03\x02\x12\x03%\x1b\x1c\n\x0b\n\x04\x05\x01\x02\x04\
    \x12\x03&\x08\x18\n\x0c\n\x05\x05\x01\x02\x04\x01\x12\x03&\x08\x13\n\x0c\
    \n\x05\x05\x01\x02\x04\x02\x12\x03&\x16\x17\n\n\n\x02\x05\x02\x12\x04)\0\
    6\x01\n\n\n\x03\x05\x02\x01\x12\x03)\x05\x12\n\x0b\n\x04\x05\x02\x02\0\
    \x12\x03*\x08$\n\x0c\n\x05\x05\x02\x02\0\x01\x12\x03*\x08\x1f\n\x0c\n\
    \x05\x05\x02\x02\0\x02\x12\x03*\"#\n\x0b\n\x04\x05\x02\x02\x01\x12\x03+\
    \x08!\n\x0c\n\x05\x05\x02\x02\x01\x01\x12\x03+\x08\x1c\n\x0c\n\x05\x05\
    \x02\x02\x01\x02\x12\x03+\x1f\x20\n\x0b\n\x04\x05\x02\x02\x02\x12\x03,\
    \x08&\n\x0c\n\x05\x05\x02\x02\x02\x01\x12\x03,\x08!\n\x0c\n\x05\x05\x02\
    \x02\x02\x02\x12\x03,$%\n\x0b\n\x04\x05\x02\x02\x03\x12\x03-\x08\x1b\n\
    \x0c\n\x05\x05\x02\x02\x03\x01\x12\x03-\x08\x16\n\x0c\n\x05\x05\x02\x02\
    \x03\x02\x12\x03-\x19\x1a\n\x0b\n\x04\x05\x02\x02\x04\x12\x03.\x08%\n\
    \x0c\n\x05\x05\x02\x02\x04\x01\x12\x03.\x08\x20\n\x0c\n\x05\x05\x02\x02\
    \x04\x02\x12\x03.#$\n\x0b\n\x04\x05\x02\x02\x05\x12\x03/\x08(\n\x0c\n\
    \x05\x05\x02\x02\x05\x01\x12\x03/\x08#\n\x0c\n\x05\x05\x02\x02\x05\x02\
    \x12\x03/&'\n\x0b\n\x04\x05\x02\x02\x06\x12\x030\x08(\n\x0c\n\x05\x05\
    \x02\x02\x06\x01\x12\x030\x08#\n\x0c\n\x05\x05\x02\x02\x06\x02\x12\x030&\
    '\n\x0b\n\x04\x05\x02\x02\x07\x12\x031\x08.\n\x0c\n\x05\x05\x02\x02\x07\
    \x01\x12\x031\x08)\n\x0c\n\x05\x05\x02\x02\x07\x02\x12\x031,-\n\x0b\n\
    \x04\x05\x02\x02\x08\x12\x032\x08)\n\x0c\n\x05\x05\x02\x02\x08\x01\x12\
    \x032\x08$\n\x0c\n\x05\x05\x02\x02\x08\x02\x12\x032'(\n\x0b\n\x04\x05\
    \x02\x02\t\x12\x033\x08\"\n\x0c\n\x05\x05\x02\x02\t\x01\x12\x033\x08\x1c\
    \n\x0c\n\x05\x05\x02\x02\t\x02\x12\x033\x1f!\n\x0b\n\x04\x05\x02\x02\n\
    \x12\x034\x08+\n\x0c\n\x05\x05\x02\x02\n\x01\x12\x034\x08%\n\x0c\n\x05\
    \x05\x02\x02\n\x02\x12\x034(*\n\x0b\n\x04\x05\x02\x02\x0b\x12\x035\x08*\
    \n\x0c\n\x05\x05\x02\x02\x0b\x01\x12\x035\x08$\n\x0c\n\x05\x05\x02\x02\
    \x0b\x02\x12\x035')\n\n\n\x02\x05\x03\x12\x048\0<\x01\n\n\n\x03\x05\x03\
    \x01\x12\x038\x05\x11\n\x0b\n\x04\x05\x03\x02\0\x12\x039\x08\x20\n\x0c\n\
    \x05\x05\x03\x02\0\x01\x12\x039\x08\x1b\n\x0c\n\x05\x05\x03\x02\0\x02\
    \x12\x039\x1e\x1f\n\x0b\n\x04\x05\x03\x02\x01\x12\x03:\x08\"\n\x0c\n\x05\
    \x05\x03\x02\x01\x01\x12\x03:\x08\x1d\n\x0c\n\x05\x05\x03\x02\x01\x02\
    \x12\x03:\x20!\n\x0b\n\x04\x05\x03\x02\x02\x12\x03;\x08\x20\n\x0c\n\x05\
    \x05\x03\x02\x02\x01\x12\x03;\x08\x1b\n\x0c\n\x05\x05\x03\x02\x02\x02\
    \x12\x03;\x1e\x1f\n\n\n\x02\x05\x04\x12\x04>\0H\x01\n\n\n\x03\x05\x04\
    \x01\x12\x03>\x05\x12\n\x0b\n\x04\x05\x04\x02\0\x12\x03?\x08\x1d\n\x0c\n\
    \x05\x05\x04\x02\0\x01\x12\x03?\x08\x18\n\x0c\n\x05\x05\x04\x02\0\x02\
    \x12\x03?\x1b\x1c\n\x0b\n\x04\x05\x04\x02\x01\x12\x03@\x08\x1b\n\x0c\n\
    \x05\x05\x04\x02\x01\x01\x12\x03@\x08\x16\n\x0c\n\x05\x05\x04\x02\x01\
    \x02\x12\x03@\x19\x1a\n\x0b\n\x04\x05\x04\x02\x02\x12\x03A\x08\x1c\n\x0c\
    \n\x05\x05\x04\x02\x02\x01\x12\x03A\x08\x17\n\x0c\n\x05\x05\x04\x02\x02\
    \x02\x12\x03A\x1a\x1b\n\x0b\n\x04\x05\x04\x02\x03\x12\x03B\x08\x1c\n\x0c\
    \n\x05\x05\x04\x02\x03\x01\x12\x03B\x08\x17\n\x0c\n\x05\x05\x04\x02\x03\
    \x02\x12\x03B\x1a\x1b\n\x0b\n\x04\x05\x04\x02\x04\x12\x03C\x08\x1c\n\x0c\
    \n\x05\x05\x04\x02\x04\x01\x12\x03C\x08\x17\n\x0c\n\x05\x05\x04\x02\x04\
    \x02\x12\x03C\x1a\x1b\n\x0b\n\x04\x05\x04\x02\x05\x12\x03D\x08\x1c\n\x0c\
    \n\x05\x05\x04\x02\x05\x01\x12\x03D\x08\x17\n\x0c\n\x05\x05\x04\x02\x05\
    \x02\x12\x03D\x1a\x1b\n\x0b\n\x04\x05\x04\x02\x06\x12\x03E\x08\x1c\n\x0c\
    \n\x05\x05\x04\x02\x06\x01\x12\x03E\x08\x17\n\x0c\n\x05\x05\x04\x02\x06\
    \x02\x12\x03E\x1a\x1b\n\x0b\n\x04\x05\x04\x02\x07\x12\x03F\x08\x1a\n\x0c\
    \n\x05\x05\x04\x02\x07\x01\x12\x03F\x08\x15\n\x0c\n\x05\x05\x04\x02\x07\
    \x02\x12\x03F\x18\x19\n\x0b\n\x04\x05\x04\x02\x08\x12\x03G\x08\x1c\n\x0c\
    \n\x05\x05\x04\x02\x08\x01\x12\x03G\x08\x17\n\x0c\n\x05\x05\x04\x02\x08\
    \x02\x12\x03G\x1a\x1b\n\n\n\x02\x05\x05\x12\x04J\0O\x01\n\n\n\x03\x05\
    \x05\x01\x12\x03J\x05\x14\n\x0b\n\x04\x05\x05\x02\0\x12\x03K\x08\x1d\n\
    \x0c\n\x05\x05\x05\x02\0\x01\x12\x03K\x08\x18\n\x0c\n\x05\x05\x05\x02\0\
    \x02\x12\x03K\x1b\x1c\n\x0b\n\x04\x05\x05\x02\x01\x12\x03L\x08\x1e\n\x0c\
    \n\x05\x05\x05\x02\x01\x01\x12\x03L\x08\x19\n\x0c\n\x05\x05\x05\x02\x01\
    \x02\x12\x03L\x1c\x1d\n\x0b\n\x04\x05\x05\x02\x02\x12\x03M\x08\x1f\n\x0c\
    \n\x05\x05\x05\x02\x02\x01\x12\x03M\x08\x1a\n\x0c\n\x05\x05\x05\x02\x02\
    \x02\x12\x03M\x1d\x1e\n\x0b\n\x04\x05\x05\x02\x03\x12\x03N\x08\x1e\n\x0c\
    \n\x05\x05\x05\x02\x03\x01\x12\x03N\x08\x19\n\x0c\n\x05\x05\x05\x02\x03\
    \x02\x12\x03N\x1c\x1d\n\n\n\x02\x04\0\x12\x04Q\0X\x01\n\n\n\x03\x04\0\
    \x01\x12\x03Q\x08\x13\n\x0c\n\x04\x04\0\x03\0\x12\x04R\x08U\t\n\x0c\n\
    \x05\x04\0\x03\0\x01\x12\x03R\x10\x19\n\r\n\x06\x04\0\x03\0\x02\0\x12\
    \x03S\x101\n\x0e\n\x07\x04\0\x03\0\x02\0\x04\x12\x03S\x10\x18\n\x0e\n\
    \x07\x04\0\x03\0\x02\0\x05\x12\x03S\x19\x1f\n\x0e\n\x07\x04\0\x03\0\x02\
    \0\x01\x12\x03S\x20,\n\x0e\n\x07\x04\0\x03\0\x02\0\x03\x12\x03S/0\n\r\n\
    \x06\x04\0\x03\0\x02\x01\x12\x03T\x103\n\x0e\n\x07\x04\0\x03\0\x02\x01\
    \x04\x12\x03T\x10\x18\n\x0e\n\x07\x04\0\x03\0\x02\x01\x05\x12\x03T\x19\
    \x1f\n\x0e\n\x07\x04\0\x03\0\x02\x01\x01\x12\x03T\x20.\n\x0e\n\x07\x04\0\
    \x03\0\x02\x01\x03\x12\x03T12\n\x0b\n\x04\x04\0\x02\0\x12\x03W\x082\n\
    \x0c\n\x05\x04\0\x02\0\x04\x12\x03W\x08\x10\n\x0c\n\x05\x04\0\x02\0\x06\
    \x12\x03W\x11'\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03W(-\n\x0c\n\x05\x04\0\
    \x02\0\x03\x12\x03W01\n\n\n\x02\x04\x01\x12\x04Z\0^\x01\n\n\n\x03\x04\
    \x01\x01\x12\x03Z\x08\x1c\n\x0b\n\x04\x04\x01\x02\0\x12\x03[\x08W\n\x0c\
    \n\x05\x04\x01\x02\0\x04\x12\x03[\x08\x10\n\x0c\n\x05\x04\x01\x02\0\x06\
    \x12\x03[\x11(\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03[)4\n\x0c\n\x05\x04\
    \x01\x02\0\x03\x12\x03[78\n\x0c\n\x05\x04\x01\x02\0\x08\x12\x03[9V\n\x0c\
    \n\x05\x04\x01\x02\0\x07\x12\x03[DU\n\x0b\n\x04\x04\x01\x02\x01\x12\x03\
    \\\x085\n\x0c\n\x05\x04\x01\x02\x01\x04\x12\x03\\\x08\x10\n\x0c\n\x05\
    \x04\x01\x02\x01\x06\x12\x03\\\x11\x20\n\x0c\n\x05\x04\x01\x02\x01\x01\
    \x12\x03\\!0\n\x0c\n\x05\x04\x01\x02\x01\x03\x12\x03\\34\n\x0b\n\x04\x04\
    \x01\x02\x02\x12\x03]\x08+\n\x0c\n\x05\x04\x01\x02\x02\x04\x12\x03]\x08\
    \x10\n\x0c\n\x05\x04\x01\x02\x02\x06\x12\x03]\x11\x1d\n\x0c\n\x05\x04\
    \x01\x02\x02\x01\x12\x03]\x1e&\n\x0c\n\x05\x04\x01\x02\x02\x03\x12\x03])\
    *\n\n\n\x02\x04\x02\x12\x04`\0d\x01\n\n\n\x03\x04\x02\x01\x12\x03`\x08\
    \x1e\n\x0b\n\x04\x04\x02\x02\0\x12\x03a\x08>\n\x0c\n\x05\x04\x02\x02\0\
    \x04\x12\x03a\x08\x10\n\x0c\n\x05\x04\x02\x02\0\x05\x12\x03a\x11\x17\n\
    \x0c\n\x05\x04\x02\x02\0\x01\x12\x03a\x18\x1c\n\x0c\n\x05\x04\x02\x02\0\
    \x03\x12\x03a\x1f\x20\n\x0c\n\x05\x04\x02\x02\0\x08\x12\x03a!=\n\x0f\n\
    \x08\x04\x02\x02\0\x08\xff\xa2\x04\x12\x03a\"<\n\x0b\n\x04\x04\x02\x02\
    \x01\x12\x03b\x083\n\x0c\n\x05\x04\x02\x02\x01\x04\x12\x03b\x08\x10\n\
    \x0c\n\x05\x04\x02\x02\x01\x05\x12\x03b\x11\x15\n\x0c\n\x05\x04\x02\x02\
    \x01\x01\x12\x03b\x16\x1d\n\x0c\n\x05\x04\x02\x02\x01\x03\x12\x03b\x20!\
    \n\x0c\n\x05\x04\x02\x02\x01\x08\x12\x03b\"2\n\x0c\n\x05\x04\x02\x02\x01\
    \x07\x12\x03b-1\n\x0b\n\x04\x04\x02\x02\x02\x12\x03c\x08\"\n\x0c\n\x05\
    \x04\x02\x02\x02\x04\x12\x03c\x08\x10\n\x0c\n\x05\x04\x02\x02\x02\x05\
    \x12\x03c\x11\x17\n\x0c\n\x05\x04\x02\x02\x02\x01\x12\x03c\x18\x1d\n\x0c\
    \n\x05\x04\x02\x02\x02\x03\x12\x03c\x20!\n\n\n\x02\x04\x03\x12\x04f\0m\
    \x01\n\n\n\x03\x04\x03\x01\x12\x03f\x08\x1a\n\x0c\n\x04\x04\x03\x02\0\
    \x12\x04g\x08\x90\x01\n\x0c\n\x05\x04\x03\x02\0\x04\x12\x03g\x08\x10\n\
    \x0c\n\x05\x04\x03\x02\0\x05\x12\x03g\x11\x17\n\x0c\n\x05\x04\x03\x02\0\
    \x01\x12\x03g\x18\x20\n\x0c\n\x05\x04\x03\x02\0\x03\x12\x03g#$\n\r\n\x05\
    \x04\x03\x02\0\x08\x12\x04g%\x8f\x01\n\x0f\n\x08\x04\x03\x02\0\x08\xf1\
    \xa2\x04\x12\x03g&8\n\x0f\n\x08\x04\x03\x02\0\x08\xf4\xa2\x04\x12\x03g:U\
    \n\x0f\n\x08\x04\x03\x02\0\x08\xf5\xa2\x04\x12\x03gWr\n\x10\n\x08\x04\
    \x03\x02\0\x08\xfd\xa2\x04\x12\x04gt\x8e\x01\n\x0c\n\x04\x04\x03\x02\x01\
    \x12\x04h\x08\x81\x01\n\x0c\n\x05\x04\x03\x02\x01\x04\x12\x03h\x08\x10\n\
    \x0c\n\x05\x04\x03\x02\x01\x05\x12\x03h\x11\x17\n\x0c\n\x05\x04\x03\x02\
    \x01\x01\x12\x03h\x18\x1c\n\x0c\n\x05\x04\x03\x02\x01\x03\x12\x03h\x1f\
    \x20\n\r\n\x05\x04\x03\x02\x01\x08\x12\x04h!\x80\x01\n\x0f\n\x08\x04\x03\
    \x02\x01\x08\xf4\xa2\x04\x12\x03h\"9\n\x0f\n\x08\x04\x03\x02\x01\x08\xf5\
    \xa2\x04\x12\x03h;c\n\x0f\n\x08\x04\x03\x02\x01\x08\xfd\xa2\x04\x12\x03h\
    e\x7f\n\x0c\n\x04\x04\x03\x02\x02\x12\x04i\x08\xef\x01\n\x0c\n\x05\x04\
    \x03\x02\x02\x04\x12\x03i\x08\x10\n\x0c\n\x05\x04\x03\x02\x02\x06\x12\
    \x03i\x11\x20\n\x0c\n\x05\x04\x03\x02\x02\x01\x12\x03i!(\n\x0c\n\x05\x04\
    \x03\x02\x02\x03\x12\x03i+,\n\r\n\x05\x04\x03\x02\x02\x08\x12\x04i-\xee\
    \x01\n\x0f\n\x08\x04\x03\x02\x02\x08\xf4\xa2\x04\x12\x03i.G\n\x10\n\x08\
    \x04\x03\x02\x02\x08\xf5\xa2\x04\x12\x04iI\x9c\x01\n\x11\n\x08\x04\x03\
    \x02\x02\x08\xfa\xa2\x04\x12\x05i\x9e\x01\xd1\x01\n\x11\n\x08\x04\x03\
    \x02\x02\x08\xfd\xa2\x04\x12\x05i\xd3\x01\xed\x01\n\x0c\n\x04\x04\x03\
    \x02\x03\x12\x04j\x08\xa4\x01\n\x0c\n\x05\x04\x03\x02\x03\x04\x12\x03j\
    \x08\x10\n\x0c\n\x05\x04\x03\x02\x03\x05\x12\x03j\x11\x17\n\x0c\n\x05\
    \x04\x03\x02\x03\x01\x12\x03j\x18\x1c\n\x0c\n\x05\x04\x03\x02\x03\x03\
    \x12\x03j\x1f\x20\n\r\n\x05\x04\x03\x02\x03\x08\x12\x04j!\xa3\x01\n\x0f\
    \n\x08\x04\x03\x02\x03\x08\xf4\xa2\x04\x12\x03j\"9\n\x10\n\x08\x04\x03\
    \x02\x03\x08\xf5\xa2\x04\x12\x04j;\xa2\x01\n\x0c\n\x04\x04\x03\x02\x04\
    \x12\x04k\x08\xc6\x01\n\x0c\n\x05\x04\x03\x02\x04\x04\x12\x03k\x08\x10\n\
    \x0c\n\x05\x04\x03\x02\x04\x05\x12\x03k\x11\x15\n\x0c\n\x05\x04\x03\x02\
    \x04\x01\x12\x03k\x16!\n\x0c\n\x05\x04\x03\x02\x04\x03\x12\x03k$%\n\r\n\
    \x05\x04\x03\x02\x04\x08\x12\x04k&\xc5\x01\n\x0c\n\x05\x04\x03\x02\x04\
    \x07\x12\x03k16\n\x0f\n\x08\x04\x03\x02\x04\x08\xf4\xa2\x04\x12\x03k8V\n\
    \x10\n\x08\x04\x03\x02\x04\x08\xf5\xa2\x04\x12\x04kX\xa8\x01\n\x11\n\x08\
    \x04\x03\x02\x04\x08\xfd\xa2\x04\x12\x05k\xaa\x01\xc4\x01\n\x0c\n\x04\
    \x04\x03\x02\x05\x12\x04l\x08\xb0\x01\n\x0c\n\x05\x04\x03\x02\x05\x04\
    \x12\x03l\x08\x10\n\x0c\n\x05\x04\x03\x02\x05\x06\x12\x03l\x11(\n\x0c\n\
    \x05\x04\x03\x02\x05\x01\x12\x03l)2\n\x0c\n\x05\x04\x03\x02\x05\x03\x12\
    \x03l56\n\r\n\x05\x04\x03\x02\x05\x08\x12\x04l7\xaf\x01\n\x0f\n\x08\x04\
    \x03\x02\x05\x08\xf4\xa2\x04\x12\x03l8T\n\x0f\n\x08\x04\x03\x02\x05\x08\
    \xf5\xa2\x04\x12\x03lV~\n\x11\n\x08\x04\x03\x02\x05\x08\xfb\xa2\x04\x12\
    \x05l\x80\x01\xae\x01\n\n\n\x02\x04\x04\x12\x04o\0q\x01\n\n\n\x03\x04\
    \x04\x01\x12\x03o\x08\x16\n\x0b\n\x04\x04\x04\x02\0\x12\x03p\x08*\n\x0c\
    \n\x05\x04\x04\x02\0\x04\x12\x03p\x08\x10\n\x0c\n\x05\x04\x04\x02\0\x06\
    \x12\x03p\x11\x1f\n\x0c\n\x05\x04\x04\x02\0\x01\x12\x03p\x20%\n\x0c\n\
    \x05\x04\x04\x02\0\x03\x12\x03p()\n\x0b\n\x02\x04\x05\x12\x05s\0\x83\x01\
    \x01\n\n\n\x03\x04\x05\x01\x12\x03s\x08\x16\n\x0b\n\x04\x04\x05\x02\0\
    \x12\x03t\x08%\n\x0c\n\x05\x04\x05\x02\0\x04\x12\x03t\x08\x10\n\x0c\n\
    \x05\x04\x05\x02\0\x05\x12\x03t\x11\x17\n\x0c\n\x05\x04\x05\x02\0\x01\
    \x12\x03t\x18\x20\n\x0c\n\x05\x04\x05\x02\0\x03\x12\x03t#$\n\x0b\n\x04\
    \x04\x05\x02\x01\x12\x03u\x08M\n\x0c\n\x05\x04\x05\x02\x01\x04\x12\x03u\
    \x08\x10\n\x0c\n\x05\x04\x05\x02\x01\x06\x12\x03u\x11\x1f\n\x0c\n\x05\
    \x04\x05\x02\x01\x01\x12\x03u\x20$\n\x0c\n\x05\x04\x05\x02\x01\x03\x12\
    \x03u'(\n\x0c\n\x05\x04\x05\x02\x01\x08\x12\x03u)L\n\x0c\n\x05\x04\x05\
    \x02\x01\x07\x12\x03u4K\n\r\n\x04\x04\x05\x08\0\x12\x05w\x08\x82\x01\t\n\
    \x0c\n\x05\x04\x05\x08\0\x01\x12\x03w\x0e\x16\n\x0b\n\x04\x04\x05\x02\
    \x02\x12\x03x\x10J\n\x0c\n\x05\x04\x05\x02\x02\x06\x12\x03x\x10$\n\x0c\n\
    \x05\x04\x05\x02\x02\x01\x12\x03x%E\n\x0c\n\x05\x04\x05\x02\x02\x03\x12\
    \x03xHI\n\x0b\n\x04\x04\x05\x02\x03\x12\x03y\x10B\n\x0c\n\x05\x04\x05\
    \x02\x03\x06\x12\x03y\x10\x1f\n\x0c\n\x05\x04\x05\x02\x03\x01\x12\x03y\
    \x20=\n\x0c\n\x05\x04\x05\x02\x03\x03\x12\x03y@A\n\x0b\n\x04\x04\x05\x02\
    \x04\x12\x03z\x10N\n\x0c\n\x05\x04\x05\x02\x04\x06\x12\x03z\x10&\n\x0c\n\
    \x05\x04\x05\x02\x04\x01\x12\x03z'I\n\x0c\n\x05\x04\x05\x02\x04\x03\x12\
    \x03zLM\n\x0b\n\x04\x04\x05\x02\x05\x12\x03{\x10:\n\x0c\n\x05\x04\x05\
    \x02\x05\x06\x12\x03{\x10\x1d\n\x0c\n\x05\x04\x05\x02\x05\x01\x12\x03{\
    \x1e5\n\x0c\n\x05\x04\x05\x02\x05\x03\x12\x03{89\n\x0b\n\x04\x04\x05\x02\
    \x06\x12\x03|\x10M\n\x0c\n\x05\x04\x05\x02\x06\x06\x12\x03|\x10&\n\x0c\n\
    \x05\x04\x05\x02\x06\x01\x12\x03|'H\n\x0c\n\x05\x04\x05\x02\x06\x03\x12\
    \x03|KL\n\x0b\n\x04\x04\x05\x02\x07\x12\x03}\x10Q\n\x0c\n\x05\x04\x05\
    \x02\x07\x06\x12\x03}\x10'\n\x0c\n\x05\x04\x05\x02\x07\x01\x12\x03}(L\n\
    \x0c\n\x05\x04\x05\x02\x07\x03\x12\x03}OP\n\x0b\n\x04\x04\x05\x02\x08\
    \x12\x03~\x10R\n\x0c\n\x05\x04\x05\x02\x08\x06\x12\x03~\x10'\n\x0c\n\x05\
    \x04\x05\x02\x08\x01\x12\x03~(L\n\x0c\n\x05\x04\x05\x02\x08\x03\x12\x03~\
    OQ\n\x0b\n\x04\x04\x05\x02\t\x12\x03\x7f\x10]\n\x0c\n\x05\x04\x05\x02\t\
    \x06\x12\x03\x7f\x10,\n\x0c\n\x05\x04\x05\x02\t\x01\x12\x03\x7f-W\n\x0c\
    \n\x05\x04\x05\x02\t\x03\x12\x03\x7fZ\\\n\x0c\n\x04\x04\x05\x02\n\x12\
    \x04\x80\x01\x10T\n\r\n\x05\x04\x05\x02\n\x06\x12\x04\x80\x01\x10(\n\r\n\
    \x05\x04\x05\x02\n\x01\x12\x04\x80\x01)N\n\r\n\x05\x04\x05\x02\n\x03\x12\
    \x04\x80\x01QS\n\x0c\n\x04\x04\x05\x02\x0b\x12\x04\x81\x01\x10C\n\r\n\
    \x05\x04\x05\x02\x0b\x06\x12\x04\x81\x01\x10\x1f\n\r\n\x05\x04\x05\x02\
    \x0b\x01\x12\x04\x81\x01\x20=\n\r\n\x05\x04\x05\x02\x0b\x03\x12\x04\x81\
    \x01@B\n\x0c\n\x02\x04\x06\x12\x06\x85\x01\0\xb5\x02\x01\n\x0b\n\x03\x04\
    \x06\x01\x12\x04\x85\x01\x08\x1d\n\x0e\n\x04\x04\x06\x04\0\x12\x06\x86\
    \x01\x08\x9b\x01\t\n\r\n\x05\x04\x06\x04\0\x01\x12\x04\x86\x01\r\x1a\n\
    \x0e\n\x06\x04\x06\x04\0\x02\0\x12\x04\x87\x01\x10)\n\x0f\n\x07\x04\x06\
    \x04\0\x02\0\x01\x12\x04\x87\x01\x10$\n\x0f\n\x07\x04\x06\x04\0\x02\0\
    \x02\x12\x04\x87\x01'(\n\x0e\n\x06\x04\x06\x04\0\x02\x01\x12\x04\x88\x01\
    \x10&\n\x0f\n\x07\x04\x06\x04\0\x02\x01\x01\x12\x04\x88\x01\x10!\n\x0f\n\
    \x07\x04\x06\x04\0\x02\x01\x02\x12\x04\x88\x01$%\n\x0e\n\x06\x04\x06\x04\
    \0\x02\x02\x12\x04\x89\x01\x100\n\x0f\n\x07\x04\x06\x04\0\x02\x02\x01\
    \x12\x04\x89\x01\x10+\n\x0f\n\x07\x04\x06\x04\0\x02\x02\x02\x12\x04\x89\
    \x01./\n\x0e\n\x06\x04\x06\x04\0\x02\x03\x12\x04\x8a\x01\x10'\n\x0f\n\
    \x07\x04\x06\x04\0\x02\x03\x01\x12\x04\x8a\x01\x10\"\n\x0f\n\x07\x04\x06\
    \x04\0\x02\x03\x02\x12\x04\x8a\x01%&\n\x0e\n\x06\x04\x06\x04\0\x02\x04\
    \x12\x04\x8b\x01\x10%\n\x0f\n\x07\x04\x06\x04\0\x02\x04\x01\x12\x04\x8b\
    \x01\x10\x20\n\x0f\n\x07\x04\x06\x04\0\x02\x04\x02\x12\x04\x8b\x01#$\n\
    \x0e\n\x06\x04\x06\x04\0\x02\x05\x12\x04\x8c\x01\x10-\n\x0f\n\x07\x04\
    \x06\x04\0\x02\x05\x01\x12\x04\x8c\x01\x10(\n\x0f\n\x07\x04\x06\x04\0\
    \x02\x05\x02\x12\x04\x8c\x01+,\n\x0e\n\x06\x04\x06\x04\0\x02\x06\x12\x04\
    \x8d\x01\x10+\n\x0f\n\x07\x04\x06\x04\0\x02\x06\x01\x12\x04\x8d\x01\x10&\
    \n\x0f\n\x07\x04\x06\x04\0\x02\x06\x02\x12\x04\x8d\x01)*\n\x0e\n\x06\x04\
    \x06\x04\0\x02\x07\x12\x04\x8e\x01\x10%\n\x0f\n\x07\x04\x06\x04\0\x02\
    \x07\x01\x12\x04\x8e\x01\x10\x20\n\x0f\n\x07\x04\x06\x04\0\x02\x07\x02\
    \x12\x04\x8e\x01#$\n\x0e\n\x06\x04\x06\x04\0\x02\x08\x12\x04\x8f\x01\x10\
    ,\n\x0f\n\x07\x04\x06\x04\0\x02\x08\x01\x12\x04\x8f\x01\x10'\n\x0f\n\x07\
    \x04\x06\x04\0\x02\x08\x02\x12\x04\x8f\x01*+\n\x0e\n\x06\x04\x06\x04\0\
    \x02\t\x12\x04\x90\x01\x10+\n\x0f\n\x07\x04\x06\x04\0\x02\t\x01\x12\x04\
    \x90\x01\x10&\n\x0f\n\x07\x04\x06\x04\0\x02\t\x02\x12\x04\x90\x01)*\n\
    \x0e\n\x06\x04\x06\x04\0\x02\n\x12\x04\x91\x01\x10)\n\x0f\n\x07\x04\x06\
    \x04\0\x02\n\x01\x12\x04\x91\x01\x10#\n\x0f\n\x07\x04\x06\x04\0\x02\n\
    \x02\x12\x04\x91\x01&(\n\x0e\n\x06\x04\x06\x04\0\x02\x0b\x12\x04\x92\x01\
    \x104\n\x0f\n\x07\x04\x06\x04\0\x02\x0b\x01\x12\x04\x92\x01\x10.\n\x0f\n\
    \x07\x04\x06\x04\0\x02\x0b\x02\x12\x04\x92\x0113\n\x0e\n\x06\x04\x06\x04\
    \0\x02\x0c\x12\x04\x93\x01\x10+\n\x0f\n\x07\x04\x06\x04\0\x02\x0c\x01\
    \x12\x04\x93\x01\x10%\n\x0f\n\x07\x04\x06\x04\0\x02\x0c\x02\x12\x04\x93\
    \x01(*\n\x0e\n\x06\x04\x06\x04\0\x02\r\x12\x04\x94\x01\x10,\n\x0f\n\x07\
    \x04\x06\x04\0\x02\r\x01\x12\x04\x94\x01\x10&\n\x0f\n\x07\x04\x06\x04\0\
    \x02\r\x02\x12\x04\x94\x01)+\n\x0e\n\x06\x04\x06\x04\0\x02\x0e\x12\x04\
    \x95\x01\x10,\n\x0f\n\x07\x04\x06\x04\0\x02\x0e\x01\x12\x04\x95\x01\x10&\
    \n\x0f\n\x07\x04\x06\x04\0\x02\x0e\x02\x12\x04\x95\x01)+\n\x0e\n\x06\x04\
    \x06\x04\0\x02\x0f\x12\x04\x96\x01\x104\n\x0f\n\x07\x04\x06\x04\0\x02\
    \x0f\x01\x12\x04\x96\x01\x10.\n\x0f\n\x07\x04\x06\x04\0\x02\x0f\x02\x12\
    \x04\x96\x0113\n\x0e\n\x06\x04\x06\x04\0\x02\x10\x12\x04\x97\x01\x10(\n\
    \x0f\n\x07\x04\x06\x04\0\x02\x10\x01\x12\x04\x97\x01\x10\"\n\x0f\n\x07\
    \x04\x06\x04\0\x02\x10\x02\x12\x04\x97\x01%'\n\x0e\n\x06\x04\x06\x04\0\
    \x02\x11\x12\x04\x98\x01\x103\n\x0f\n\x07\x04\x06\x04\0\x02\x11\x01\x12\
    \x04\x98\x01\x10-\n\x0f\n\x07\x04\x06\x04\0\x02\x11\x02\x12\x04\x98\x010\
    2\n\x0e\n\x06\x04\x06\x04\0\x02\x12\x12\x04\x99\x01\x10)\n\x0f\n\x07\x04\
    \x06\x04\0\x02\x12\x01\x12\x04\x99\x01\x10#\n\x0f\n\x07\x04\x06\x04\0\
    \x02\x12\x02\x12\x04\x99\x01&(\n\x0e\n\x06\x04\x06\x04\0\x02\x13\x12\x04\
    \x9a\x01\x10-\n\x0f\n\x07\x04\x06\x04\0\x02\x13\x01\x12\x04\x9a\x01\x10'\
    \n\x0f\n\x07\x04\x06\x04\0\x02\x13\x02\x12\x04\x9a\x01*,\n\x0e\n\x04\x04\
    \x06\x04\x01\x12\x06\x9d\x01\x08\xa0\x02\t\n\r\n\x05\x04\x06\x04\x01\x01\
    \x12\x04\x9d\x01\r\x1b\n\x0e\n\x06\x04\x06\x04\x01\x02\0\x12\x04\x9e\x01\
    \x10#\n\x0f\n\x07\x04\x06\x04\x01\x02\0\x01\x12\x04\x9e\x01\x10\x1e\n\
    \x0f\n\x07\x04\x06\x04\x01\x02\0\x02\x12\x04\x9e\x01!\"\n\x0e\n\x06\x04\
    \x06\x04\x01\x02\x01\x12\x04\x9f\x01\x10#\n\x0f\n\x07\x04\x06\x04\x01\
    \x02\x01\x01\x12\x04\x9f\x01\x10\x1e\n\x0f\n\x07\x04\x06\x04\x01\x02\x01\
    \x02\x12\x04\x9f\x01!\"\n\x0e\n\x06\x04\x06\x04\x01\x02\x02\x12\x04\xa0\
    \x01\x10'\n\x0f\n\x07\x04\x06\x04\x01\x02\x02\x01\x12\x04\xa0\x01\x10\"\
    \n\x0f\n\x07\x04\x06\x04\x01\x02\x02\x02\x12\x04\xa0\x01%&\n\x0e\n\x06\
    \x04\x06\x04\x01\x02\x03\x12\x04\xa1\x01\x10&\n\x0f\n\x07\x04\x06\x04\
    \x01\x02\x03\x01\x12\x04\xa1\x01\x10!\n\x0f\n\x07\x04\x06\x04\x01\x02\
    \x03\x02\x12\x04\xa1\x01$%\n\x0e\n\x06\x04\x06\x04\x01\x02\x04\x12\x04\
    \xa2\x01\x10&\n\x0f\n\x07\x04\x06\x04\x01\x02\x04\x01\x12\x04\xa2\x01\
    \x10!\n\x0f\n\x07\x04\x06\x04\x01\x02\x04\x02\x12\x04\xa2\x01$%\n\x0e\n\
    \x06\x04\x06\x04\x01\x02\x05\x12\x04\xa3\x01\x10)\n\x0f\n\x07\x04\x06\
    \x04\x01\x02\x05\x01\x12\x04\xa3\x01\x10$\n\x0f\n\x07\x04\x06\x04\x01\
    \x02\x05\x02\x12\x04\xa3\x01'(\n\x0e\n\x06\x04\x06\x04\x01\x02\x06\x12\
    \x04\xa4\x01\x10'\n\x0f\n\x07\x04\x06\x04\x01\x02\x06\x01\x12\x04\xa4\
    \x01\x10\"\n\x0f\n\x07\x04\x06\x04\x01\x02\x06\x02\x12\x04\xa4\x01%&\n\
    \x0e\n\x06\x04\x06\x04\x01\x02\x07\x12\x04\xa5\x01\x10%\n\x0f\n\x07\x04\
    \x06\x04\x01\x02\x07\x01\x12\x04\xa5\x01\x10\x20\n\x0f\n\x07\x04\x06\x04\
    \x01\x02\x07\x02\x12\x04\xa5\x01#$\n\x0e\n\x06\x04\x06\x04\x01\x02\x08\
    \x12\x04\xa6\x01\x104\n\x0f\n\x07\x04\x06\x04\x01\x02\x08\x01\x12\x04\
    \xa6\x01\x10/\n\x0f\n\x07\x04\x06\x04\x01\x02\x08\x02\x12\x04\xa6\x0123\
    \n\x0e\n\x06\x04\x06\x04\x01\x02\t\x12\x04\xa7\x01\x10,\n\x0f\n\x07\x04\
    \x06\x04\x01\x02\t\x01\x12\x04\xa7\x01\x10'\n\x0f\n\x07\x04\x06\x04\x01\
    \x02\t\x02\x12\x04\xa7\x01*+\n\x0e\n\x06\x04\x06\x04\x01\x02\n\x12\x04\
    \xa8\x01\x102\n\x0f\n\x07\x04\x06\x04\x01\x02\n\x01\x12\x04\xa8\x01\x10,\
    \n\x0f\n\x07\x04\x06\x04\x01\x02\n\x02\x12\x04\xa8\x01/1\n\x0e\n\x06\x04\
    \x06\x04\x01\x02\x0b\x12\x04\xa9\x01\x10)\n\x0f\n\x07\x04\x06\x04\x01\
    \x02\x0b\x01\x12\x04\xa9\x01\x10#\n\x0f\n\x07\x04\x06\x04\x01\x02\x0b\
    \x02\x12\x04\xa9\x01&(\n\x0e\n\x06\x04\x06\x04\x01\x02\x0c\x12\x04\xaa\
    \x01\x10,\n\x0f\n\x07\x04\x06\x04\x01\x02\x0c\x01\x12\x04\xaa\x01\x10&\n\
    \x0f\n\x07\x04\x06\x04\x01\x02\x0c\x02\x12\x04\xaa\x01)+\n\x0e\n\x06\x04\
    \x06\x04\x01\x02\r\x12\x04\xab\x01\x10)\n\x0f\n\x07\x04\x06\x04\x01\x02\
    \r\x01\x12\x04\xab\x01\x10#\n\x0f\n\x07\x04\x06\x04\x01\x02\r\x02\x12\
    \x04\xab\x01&(\n\x0e\n\x06\x04\x06\x04\x01\x02\x0e\x12\x04\xac\x01\x10#\
    \n\x0f\n\x07\x04\x06\x04\x01\x02\x0e\x01\x12\x04\xac\x01\x10\x1d\n\x0f\n\
    \x07\x04\x06\x04\x01\x02\x0e\x02\x12\x04\xac\x01\x20\"\n\x0e\n\x06\x04\
    \x06\x04\x01\x02\x0f\x12\x04\xad\x01\x10%\n\x0f\n\x07\x04\x06\x04\x01\
    \x02\x0f\x01\x12\x04\xad\x01\x10\x1f\n\x0f\n\x07\x04\x06\x04\x01\x02\x0f\
    \x02\x12\x04\xad\x01\"$\n\x0e\n\x06\x04\x06\x04\x01\x02\x10\x12\x04\xae\
    \x01\x10)\n\x0f\n\x07\x04\x06\x04\x01\x02\x10\x01\x12\x04\xae\x01\x10#\n\
    \x0f\n\x07\x04\x06\x04\x01\x02\x10\x02\x12\x04\xae\x01&(\n\x0e\n\x06\x04\
    \x06\x04\x01\x02\x11\x12\x04\xaf\x01\x10+\n\x0f\n\x07\x04\x06\x04\x01\
    \x02\x11\x01\x12\x04\xaf\x01\x10%\n\x0f\n\x07\x04\x06\x04\x01\x02\x11\
    \x02\x12\x04\xaf\x01(*\n\x0e\n\x06\x04\x06\x04\x01\x02\x12\x12\x04\xb0\
    \x01\x10'\n\x0f\n\x07\x04\x06\x04\x01\x02\x12\x01\x12\x04\xb0\x01\x10!\n\
    \x0f\n\x07\x04\x06\x04\x01\x02\x12\x02\x12\x04\xb0\x01$&\n\x0e\n\x06\x04\
    \x06\x04\x01\x02\x13\x12\x04\xb1\x01\x10)\n\x0f\n\x07\x04\x06\x04\x01\
    \x02\x13\x01\x12\x04\xb1\x01\x10#\n\x0f\n\x07\x04\x06\x04\x01\x02\x13\
    \x02\x12\x04\xb1\x01&(\n\x0e\n\x06\x04\x06\x04\x01\x02\x14\x12\x04\xb2\
    \x01\x10(\n\x0f\n\x07\x04\x06\x04\x01\x02\x14\x01\x12\x04\xb2\x01\x10\"\
    \n\x0f\n\x07\x04\x06\x04\x01\x02\x14\x02\x12\x04\xb2\x01%'\n\x0e\n\x06\
    \x04\x06\x04\x01\x02\x15\x12\x04\xb3\x01\x10)\n\x0f\n\x07\x04\x06\x04\
    \x01\x02\x15\x01\x12\x04\xb3\x01\x10#\n\x0f\n\x07\x04\x06\x04\x01\x02\
    \x15\x02\x12\x04\xb3\x01&(\n\x0e\n\x06\x04\x06\x04\x01\x02\x16\x12\x04\
    \xb4\x01\x10%\n\x0f\n\x07\x04\x06\x04\x01\x02\x16\x01\x12\x04\xb4\x01\
    \x10\x1f\n\x0f\n\x07\x04\x06\x04\x01\x02\x16\x02\x12\x04\xb4\x01\"$\n\
    \x0e\n\x06\x04\x06\x04\x01\x02\x17\x12\x04\xb5\x01\x10/\n\x0f\n\x07\x04\
    \x06\x04\x01\x02\x17\x01\x12\x04\xb5\x01\x10)\n\x0f\n\x07\x04\x06\x04\
    \x01\x02\x17\x02\x12\x04\xb5\x01,.\n\x0e\n\x06\x04\x06\x04\x01\x02\x18\
    \x12\x04\xb6\x01\x10#\n\x0f\n\x07\x04\x06\x04\x01\x02\x18\x01\x12\x04\
    \xb6\x01\x10\x1d\n\x0f\n\x07\x04\x06\x04\x01\x02\x18\x02\x12\x04\xb6\x01\
    \x20\"\n\x0e\n\x06\x04\x06\x04\x01\x02\x19\x12\x04\xb7\x01\x10&\n\x0f\n\
    \x07\x04\x06\x04\x01\x02\x19\x01\x12\x04\xb7\x01\x10\x20\n\x0f\n\x07\x04\
    \x06\x04\x01\x02\x19\x02\x12\x04\xb7\x01#%\n\x0e\n\x06\x04\x06\x04\x01\
    \x02\x1a\x12\x04\xb8\x01\x10)\n\x0f\n\x07\x04\x06\x04\x01\x02\x1a\x01\
    \x12\x04\xb8\x01\x10#\n\x0f\n\x07\x04\x06\x04\x01\x02\x1a\x02\x12\x04\
    \xb8\x01&(\n\x0e\n\x06\x04\x06\x04\x01\x02\x1b\x12\x04\xb9\x01\x10&\n\
    \x0f\n\x07\x04\x06\x04\x01\x02\x1b\x01\x12\x04\xb9\x01\x10\x20\n\x0f\n\
    \x07\x04\x06\x04\x01\x02\x1b\x02\x12\x04\xb9\x01#%\n\x0e\n\x06\x04\x06\
    \x04\x01\x02\x1c\x12\x04\xba\x01\x10&\n\x0f\n\x07\x04\x06\x04\x01\x02\
    \x1c\x01\x12\x04\xba\x01\x10\x20\n\x0f\n\x07\x04\x06\x04\x01\x02\x1c\x02\
    \x12\x04\xba\x01#%\n\x0e\n\x06\x04\x06\x04\x01\x02\x1d\x12\x04\xbb\x01\
    \x10/\n\x0f\n\x07\x04\x06\x04\x01\x02\x1d\x01\x12\x04\xbb\x01\x10)\n\x0f\
    \n\x07\x04\x06\x04\x01\x02\x1d\x02\x12\x04\xbb\x01,.\n\x0e\n\x06\x04\x06\
    \x04\x01\x02\x1e\x12\x04\xbc\x01\x10,\n\x0f\n\x07\x04\x06\x04\x01\x02\
    \x1e\x01\x12\x04\xbc\x01\x10&\n\x0f\n\x07\x04\x06\x04\x01\x02\x1e\x02\
    \x12\x04\xbc\x01)+\n\x0e\n\x06\x04\x06\x04\x01\x02\x1f\x12\x04\xbd\x01\
    \x101\n\x0f\n\x07\x04\x06\x04\x01\x02\x1f\x01\x12\x04\xbd\x01\x10+\n\x0f\
    \n\x07\x04\x06\x04\x01\x02\x1f\x02\x12\x04\xbd\x01.0\n\x0e\n\x06\x04\x06\
    \x04\x01\x02\x20\x12\x04\xbe\x01\x10)\n\x0f\n\x07\x04\x06\x04\x01\x02\
    \x20\x01\x12\x04\xbe\x01\x10#\n\x0f\n\x07\x04\x06\x04\x01\x02\x20\x02\
    \x12\x04\xbe\x01&(\n\x0e\n\x06\x04\x06\x04\x01\x02!\x12\x04\xbf\x01\x101\
    \n\x0f\n\x07\x04\x06\x04\x01\x02!\x01\x12\x04\xbf\x01\x10+\n\x0f\n\x07\
    \x04\x06\x04\x01\x02!\x02\x12\x04\xbf\x01.0\n\x0e\n\x06\x04\x06\x04\x01\
    \x02\"\x12\x04\xc0\x01\x103\n\x0f\n\x07\x04\x06\x04\x01\x02\"\x01\x12\
    \x04\xc0\x01\x10-\n\x0f\n\x07\x04\x06\x04\x01\x02\"\x02\x12\x04\xc0\x010\
    2\n\x0e\n\x06\x04\x06\x04\x01\x02#\x12\x04\xc1\x01\x105\n\x0f\n\x07\x04\
    \x06\x04\x01\x02#\x01\x12\x04\xc1\x01\x10/\n\x0f\n\x07\x04\x06\x04\x01\
    \x02#\x02\x12\x04\xc1\x0124\n\x0e\n\x06\x04\x06\x04\x01\x02$\x12\x04\xc2\
    \x01\x10-\n\x0f\n\x07\x04\x06\x04\x01\x02$\x01\x12\x04\xc2\x01\x10'\n\
    \x0f\n\x07\x04\x06\x04\x01\x02$\x02\x12\x04\xc2\x01*,\n\x0e\n\x06\x04\
    \x06\x04\x01\x02%\x12\x04\xc3\x01\x105\n\x0f\n\x07\x04\x06\x04\x01\x02%\
    \x01\x12\x04\xc3\x01\x10/\n\x0f\n\x07\x04\x06\x04\x01\x02%\x02\x12\x04\
    \xc3\x0124\n\x0e\n\x06\x04\x06\x04\x01\x02&\x12\x04\xc4\x01\x104\n\x0f\n\
    \x07\x04\x06\x04\x01\x02&\x01\x12\x04\xc4\x01\x10.\n\x0f\n\x07\x04\x06\
    \x04\x01\x02&\x02\x12\x04\xc4\x0113\n\x0e\n\x06\x04\x06\x04\x01\x02'\x12\
    \x04\xc5\x01\x105\n\x0f\n\x07\x04\x06\x04\x01\x02'\x01\x12\x04\xc5\x01\
    \x10/\n\x0f\n\x07\x04\x06\x04\x01\x02'\x02\x12\x04\xc5\x0124\n\x0e\n\x06\
    \x04\x06\x04\x01\x02(\x12\x04\xc6\x01\x101\n\x0f\n\x07\x04\x06\x04\x01\
    \x02(\x01\x12\x04\xc6\x01\x10+\n\x0f\n\x07\x04\x06\x04\x01\x02(\x02\x12\
    \x04\xc6\x01.0\n\x0e\n\x06\x04\x06\x04\x01\x02)\x12\x04\xc7\x01\x106\n\
    \x0f\n\x07\x04\x06\x04\x01\x02)\x01\x12\x04\xc7\x01\x100\n\x0f\n\x07\x04\
    \x06\x04\x01\x02)\x02\x12\x04\xc7\x0135\n\x0e\n\x06\x04\x06\x04\x01\x02*\
    \x12\x04\xc8\x01\x107\n\x0f\n\x07\x04\x06\x04\x01\x02*\x01\x12\x04\xc8\
    \x01\x101\n\x0f\n\x07\x04\x06\x04\x01\x02*\x02\x12\x04\xc8\x0146\n\x0e\n\
    \x06\x04\x06\x04\x01\x02+\x12\x04\xc9\x01\x10*\n\x0f\n\x07\x04\x06\x04\
    \x01\x02+\x01\x12\x04\xc9\x01\x10$\n\x0f\n\x07\x04\x06\x04\x01\x02+\x02\
    \x12\x04\xc9\x01')\n\x0e\n\x06\x04\x06\x04\x01\x02,\x12\x04\xca\x01\x103\
    \n\x0f\n\x07\x04\x06\x04\x01\x02,\x01\x12\x04\xca\x01\x10-\n\x0f\n\x07\
    \x04\x06\x04\x01\x02,\x02\x12\x04\xca\x0102\n\x0e\n\x06\x04\x06\x04\x01\
    \x02-\x12\x04\xcb\x01\x10.\n\x0f\n\x07\x04\x06\x04\x01\x02-\x01\x12\x04\
    \xcb\x01\x10(\n\x0f\n\x07\x04\x06\x04\x01\x02-\x02\x12\x04\xcb\x01+-\n\
    \x0e\n\x06\x04\x06\x04\x01\x02.\x12\x04\xcc\x01\x104\n\x0f\n\x07\x04\x06\
    \x04\x01\x02.\x01\x12\x04\xcc\x01\x10.\n\x0f\n\x07\x04\x06\x04\x01\x02.\
    \x02\x12\x04\xcc\x0113\n\x0e\n\x06\x04\x06\x04\x01\x02/\x12\x04\xcd\x01\
    \x101\n\x0f\n\x07\x04\x06\x04\x01\x02/\x01\x12\x04\xcd\x01\x10+\n\x0f\n\
    \x07\x04\x06\x04\x01\x02/\x02\x12\x04\xcd\x01.0\n\x0e\n\x06\x04\x06\x04\
    \x01\x020\x12\x04\xce\x01\x103\n\x0f\n\x07\x04\x06\x04\x01\x020\x01\x12\
    \x04\xce\x01\x10-\n\x0f\n\x07\x04\x06\x04\x01\x020\x02\x12\x04\xce\x0102\
    \n\x0e\n\x06\x04\x06\x04\x01\x021\x12\x04\xcf\x01\x104\n\x0f\n\x07\x04\
    \x06\x04\x01\x021\x01\x12\x04\xcf\x01\x10.\n\x0f\n\x07\x04\x06\x04\x01\
    \x021\x02\x12\x04\xcf\x0113\n\x0e\n\x06\x04\x06\x04\x01\x022\x12\x04\xd0\
    \x01\x10$\n\x0f\n\x07\x04\x06\x04\x01\x022\x01\x12\x04\xd0\x01\x10\x1e\n\
    \x0f\n\x07\x04\x06\x04\x01\x022\x02\x12\x04\xd0\x01!#\n\x0e\n\x06\x04\
    \x06\x04\x01\x023\x12\x04\xd1\x01\x10>\n\x0f\n\x07\x04\x06\x04\x01\x023\
    \x01\x12\x04\xd1\x01\x108\n\x0f\n\x07\x04\x06\x04\x01\x023\x02\x12\x04\
    \xd1\x01;=\n\x0e\n\x06\x04\x06\x04\x01\x024\x12\x04\xd2\x01\x104\n\x0f\n\
    \x07\x04\x06\x04\x01\x024\x01\x12\x04\xd2\x01\x10.\n\x0f\n\x07\x04\x06\
    \x04\x01\x024\x02\x12\x04\xd2\x0113\n\x0e\n\x06\x04\x06\x04\x01\x025\x12\
    \x04\xd3\x01\x101\n\x0f\n\x07\x04\x06\x04\x01\x025\x01\x12\x04\xd3\x01\
    \x10+\n\x0f\n\x07\x04\x06\x04\x01\x025\x02\x12\x04\xd3\x01.0\n\x0e\n\x06\
    \x04\x06\x04\x01\x026\x12\x04\xd4\x01\x100\n\x0f\n\x07\x04\x06\x04\x01\
    \x026\x01\x12\x04\xd4\x01\x10*\n\x0f\n\x07\x04\x06\x04\x01\x026\x02\x12\
    \x04\xd4\x01-/\n\x0e\n\x06\x04\x06\x04\x01\x027\x12\x04\xd5\x01\x102\n\
    \x0f\n\x07\x04\x06\x04\x01\x027\x01\x12\x04\xd5\x01\x10,\n\x0f\n\x07\x04\
    \x06\x04\x01\x027\x02\x12\x04\xd5\x01/1\n\x0e\n\x06\x04\x06\x04\x01\x028\
    \x12\x04\xd6\x01\x105\n\x0f\n\x07\x04\x06\x04\x01\x028\x01\x12\x04\xd6\
    \x01\x10/\n\x0f\n\x07\x04\x06\x04\x01\x028\x02\x12\x04\xd6\x0124\n\x0e\n\
    \x06\x04\x06\x04\x01\x029\x12\x04\xd7\x01\x106\n\x0f\n\x07\x04\x06\x04\
    \x01\x029\x01\x12\x04\xd7\x01\x100\n\x0f\n\x07\x04\x06\x04\x01\x029\x02\
    \x12\x04\xd7\x0135\n\x0e\n\x06\x04\x06\x04\x01\x02:\x12\x04\xd8\x01\x108\
    \n\x0f\n\x07\x04\x06\x04\x01\x02:\x01\x12\x04\xd8\x01\x102\n\x0f\n\x07\
    \x04\x06\x04\x01\x02:\x02\x12\x04\xd8\x0157\n\x0e\n\x06\x04\x06\x04\x01\
    \x02;\x12\x04\xd9\x01\x107\n\x0f\n\x07\x04\x06\x04\x01\x02;\x01\x12\x04\
    \xd9\x01\x101\n\x0f\n\x07\x04\x06\x04\x01\x02;\x02\x12\x04\xd9\x0146\n\
    \x0e\n\x06\x04\x06\x04\x01\x02<\x12\x04\xda\x01\x106\n\x0f\n\x07\x04\x06\
    \x04\x01\x02<\x01\x12\x04\xda\x01\x100\n\x0f\n\x07\x04\x06\x04\x01\x02<\
    \x02\x12\x04\xda\x0135\n\x0e\n\x06\x04\x06\x04\x01\x02=\x12\x04\xdb\x01\
    \x109\n\x0f\n\x07\x04\x06\x04\x01\x02=\x01\x12\x04\xdb\x01\x103\n\x0f\n\
    \x07\x04\x06\x04\x01\x02=\x02\x12\x04\xdb\x0168\n\x0e\n\x06\x04\x06\x04\
    \x01\x02>\x12\x04\xdc\x01\x108\n\x0f\n\x07\x04\x06\x04\x01\x02>\x01\x12\
    \x04\xdc\x01\x102\n\x0f\n\x07\x04\x06\x04\x01\x02>\x02\x12\x04\xdc\x0157\
    \n\x0e\n\x06\x04\x06\x04\x01\x02?\x12\x04\xdd\x01\x107\n\x0f\n\x07\x04\
    \x06\x04\x01\x02?\x01\x12\x04\xdd\x01\x101\n\x0f\n\x07\x04\x06\x04\x01\
    \x02?\x02\x12\x04\xdd\x0146\n\x0e\n\x06\x04\x06\x04\x01\x02@\x12\x04\xde\
    \x01\x101\n\x0f\n\x07\x04\x06\x04\x01\x02@\x01\x12\x04\xde\x01\x10+\n\
    \x0f\n\x07\x04\x06\x04\x01\x02@\x02\x12\x04\xde\x01.0\n\x0e\n\x06\x04\
    \x06\x04\x01\x02A\x12\x04\xdf\x01\x10,\n\x0f\n\x07\x04\x06\x04\x01\x02A\
    \x01\x12\x04\xdf\x01\x10&\n\x0f\n\x07\x04\x06\x04\x01\x02A\x02\x12\x04\
    \xdf\x01)+\n\x0e\n\x06\x04\x06\x04\x01\x02B\x12\x04\xe0\x01\x108\n\x0f\n\
    \x07\x04\x06\x04\x01\x02B\x01\x12\x04\xe0\x01\x102\n\x0f\n\x07\x04\x06\
    \x04\x01\x02B\x02\x12\x04\xe0\x0157\n\x0e\n\x06\x04\x06\x04\x01\x02C\x12\
    \x04\xe1\x01\x10+\n\x0f\n\x07\x04\x06\x04\x01\x02C\x01\x12\x04\xe1\x01\
    \x10%\n\x0f\n\x07\x04\x06\x04\x01\x02C\x02\x12\x04\xe1\x01(*\n\x0e\n\x06\
    \x04\x06\x04\x01\x02D\x12\x04\xe2\x01\x10*\n\x0f\n\x07\x04\x06\x04\x01\
    \x02D\x01\x12\x04\xe2\x01\x10$\n\x0f\n\x07\x04\x06\x04\x01\x02D\x02\x12\
    \x04\xe2\x01')\n\x0e\n\x06\x04\x06\x04\x01\x02E\x12\x04\xe3\x01\x10)\n\
    \x0f\n\x07\x04\x06\x04\x01\x02E\x01\x12\x04\xe3\x01\x10#\n\x0f\n\x07\x04\
    \x06\x04\x01\x02E\x02\x12\x04\xe3\x01&(\n\x0e\n\x06\x04\x06\x04\x01\x02F\
    \x12\x04\xe4\x01\x10+\n\x0f\n\x07\x04\x06\x04\x01\x02F\x01\x12\x04\xe4\
    \x01\x10%\n\x0f\n\x07\x04\x06\x04\x01\x02F\x02\x12\x04\xe4\x01(*\n\x0e\n\
    \x06\x04\x06\x04\x01\x02G\x12\x04\xe5\x01\x104\n\x0f\n\x07\x04\x06\x04\
    \x01\x02G\x01\x12\x04\xe5\x01\x10.\n\x0f\n\x07\x04\x06\x04\x01\x02G\x02\
    \x12\x04\xe5\x0113\n\x0e\n\x06\x04\x06\x04\x01\x02H\x12\x04\xe6\x01\x103\
    \n\x0f\n\x07\x04\x06\x04\x01\x02H\x01\x12\x04\xe6\x01\x10-\n\x0f\n\x07\
    \x04\x06\x04\x01\x02H\x02\x12\x04\xe6\x0102\n\x0e\n\x06\x04\x06\x04\x01\
    \x02I\x12\x04\xe7\x01\x102\n\x0f\n\x07\x04\x06\x04\x01\x02I\x01\x12\x04\
    \xe7\x01\x10,\n\x0f\n\x07\x04\x06\x04\x01\x02I\x02\x12\x04\xe7\x01/1\n\
    \x0e\n\x06\x04\x06\x04\x01\x02J\x12\x04\xe8\x01\x10-\n\x0f\n\x07\x04\x06\
    \x04\x01\x02J\x01\x12\x04\xe8\x01\x10'\n\x0f\n\x07\x04\x06\x04\x01\x02J\
    \x02\x12\x04\xe8\x01*,\n\x0e\n\x06\x04\x06\x04\x01\x02K\x12\x04\xe9\x01\
    \x10,\n\x0f\n\x07\x04\x06\x04\x01\x02K\x01\x12\x04\xe9\x01\x10&\n\x0f\n\
    \x07\x04\x06\x04\x01\x02K\x02\x12\x04\xe9\x01)+\n\x0e\n\x06\x04\x06\x04\
    \x01\x02L\x12\x04\xea\x01\x10/\n\x0f\n\x07\x04\x06\x04\x01\x02L\x01\x12\
    \x04\xea\x01\x10)\n\x0f\n\x07\x04\x06\x04\x01\x02L\x02\x12\x04\xea\x01,.\
    \n\x0e\n\x06\x04\x06\x04\x01\x02M\x12\x04\xeb\x01\x102\n\x0f\n\x07\x04\
    \x06\x04\x01\x02M\x01\x12\x04\xeb\x01\x10,\n\x0f\n\x07\x04\x06\x04\x01\
    \x02M\x02\x12\x04\xeb\x01/1\n\x0e\n\x06\x04\x06\x04\x01\x02N\x12\x04\xec\
    \x01\x105\n\x0f\n\x07\x04\x06\x04\x01\x02N\x01\x12\x04\xec\x01\x10/\n\
    \x0f\n\x07\x04\x06\x04\x01\x02N\x02\x12\x04\xec\x0124\n\x0e\n\x06\x04\
    \x06\x04\x01\x02O\x12\x04\xed\x01\x10,\n\x0f\n\x07\x04\x06\x04\x01\x02O\
    \x01\x12\x04\xed\x01\x10&\n\x0f\n\x07\x04\x06\x04\x01\x02O\x02\x12\x04\
    \xed\x01)+\n\x0e\n\x06\x04\x06\x04\x01\x02P\x12\x04\xee\x01\x10.\n\x0f\n\
    \x07\x04\x06\x04\x01\x02P\x01\x12\x04\xee\x01\x10(\n\x0f\n\x07\x04\x06\
    \x04\x01\x02P\x02\x12\x04\xee\x01+-\n\x0e\n\x06\x04\x06\x04\x01\x02Q\x12\
    \x04\xef\x01\x10*\n\x0f\n\x07\x04\x06\x04\x01\x02Q\x01\x12\x04\xef\x01\
    \x10$\n\x0f\n\x07\x04\x06\x04\x01\x02Q\x02\x12\x04\xef\x01')\n\x0e\n\x06\
    \x04\x06\x04\x01\x02R\x12\x04\xf0\x01\x10,\n\x0f\n\x07\x04\x06\x04\x01\
    \x02R\x01\x12\x04\xf0\x01\x10&\n\x0f\n\x07\x04\x06\x04\x01\x02R\x02\x12\
    \x04\xf0\x01)+\n\x0e\n\x06\x04\x06\x04\x01\x02S\x12\x04\xf1\x01\x101\n\
    \x0f\n\x07\x04\x06\x04\x01\x02S\x01\x12\x04\xf1\x01\x10+\n\x0f\n\x07\x04\
    \x06\x04\x01\x02S\x02\x12\x04\xf1\x01.0\n\x0e\n\x06\x04\x06\x04\x01\x02T\
    \x12\x04\xf2\x01\x10*\n\x0f\n\x07\x04\x06\x04\x01\x02T\x01\x12\x04\xf2\
    \x01\x10$\n\x0f\n\x07\x04\x06\x04\x01\x02T\x02\x12\x04\xf2\x01')\n\x0e\n\
    \x06\x04\x06\x04\x01\x02U\x12\x04\xf3\x01\x10(\n\x0f\n\x07\x04\x06\x04\
    \x01\x02U\x01\x12\x04\xf3\x01\x10\"\n\x0f\n\x07\x04\x06\x04\x01\x02U\x02\
    \x12\x04\xf3\x01%'\n\x0e\n\x06\x04\x06\x04\x01\x02V\x12\x04\xf4\x01\x10,\
    \n\x0f\n\x07\x04\x06\x04\x01\x02V\x01\x12\x04\xf4\x01\x10&\n\x0f\n\x07\
    \x04\x06\x04\x01\x02V\x02\x12\x04\xf4\x01)+\n\x0e\n\x06\x04\x06\x04\x01\
    \x02W\x12\x04\xf5\x01\x10*\n\x0f\n\x07\x04\x06\x04\x01\x02W\x01\x12\x04\
    \xf5\x01\x10$\n\x0f\n\x07\x04\x06\x04\x01\x02W\x02\x12\x04\xf5\x01')\n\
    \x0e\n\x06\x04\x06\x04\x01\x02X\x12\x04\xf6\x01\x101\n\x0f\n\x07\x04\x06\
    \x04\x01\x02X\x01\x12\x04\xf6\x01\x10+\n\x0f\n\x07\x04\x06\x04\x01\x02X\
    \x02\x12\x04\xf6\x01.0\n\x0e\n\x06\x04\x06\x04\x01\x02Y\x12\x04\xf7\x01\
    \x10(\n\x0f\n\x07\x04\x06\x04\x01\x02Y\x01\x12\x04\xf7\x01\x10\"\n\x0f\n\
    \x07\x04\x06\x04\x01\x02Y\x02\x12\x04\xf7\x01%'\n\x0e\n\x06\x04\x06\x04\
    \x01\x02Z\x12\x04\xf8\x01\x10+\n\x0f\n\x07\x04\x06\x04\x01\x02Z\x01\x12\
    \x04\xf8\x01\x10%\n\x0f\n\x07\x04\x06\x04\x01\x02Z\x02\x12\x04\xf8\x01(*\
    \n\x0e\n\x06\x04\x06\x04\x01\x02[\x12\x04\xf9\x01\x10(\n\x0f\n\x07\x04\
    \x06\x04\x01\x02[\x01\x12\x04\xf9\x01\x10\"\n\x0f\n\x07\x04\x06\x04\x01\
    \x02[\x02\x12\x04\xf9\x01%'\n\x0e\n\x06\x04\x06\x04\x01\x02\\\x12\x04\
    \xfa\x01\x10(\n\x0f\n\x07\x04\x06\x04\x01\x02\\\x01\x12\x04\xfa\x01\x10\
    \"\n\x0f\n\x07\x04\x06\x04\x01\x02\\\x02\x12\x04\xfa\x01%'\n\x0e\n\x06\
    \x04\x06\x04\x01\x02]\x12\x04\xfb\x01\x10)\n\x0f\n\x07\x04\x06\x04\x01\
    \x02]\x01\x12\x04\xfb\x01\x10#\n\x0f\n\x07\x04\x06\x04\x01\x02]\x02\x12\
    \x04\xfb\x01&(\n\x0e\n\x06\x04\x06\x04\x01\x02^\x12\x04\xfc\x01\x10*\n\
    \x0f\n\x07\x04\x06\x04\x01\x02^\x01\x12\x04\xfc\x01\x10$\n\x0f\n\x07\x04\
    \x06\x04\x01\x02^\x02\x12\x04\xfc\x01')\n\x0e\n\x06\x04\x06\x04\x01\x02_\
    \x12\x04\xfd\x01\x10*\n\x0f\n\x07\x04\x06\x04\x01\x02_\x01\x12\x04\xfd\
    \x01\x10$\n\x0f\n\x07\x04\x06\x04\x01\x02_\x02\x12\x04\xfd\x01')\n\x0e\n\
    \x06\x04\x06\x04\x01\x02`\x12\x04\xfe\x01\x10,\n\x0f\n\x07\x04\x06\x04\
    \x01\x02`\x01\x12\x04\xfe\x01\x10&\n\x0f\n\x07\x04\x06\x04\x01\x02`\x02\
    \x12\x04\xfe\x01)+\n\x0e\n\x06\x04\x06\x04\x01\x02a\x12\x04\xff\x01\x10*\
    \n\x0f\n\x07\x04\x06\x04\x01\x02a\x01\x12\x04\xff\x01\x10$\n\x0f\n\x07\
    \x04\x06\x04\x01\x02a\x02\x12\x04\xff\x01')\n\x0e\n\x06\x04\x06\x04\x01\
    \x02b\x12\x04\x80\x02\x10+\n\x0f\n\x07\x04\x06\x04\x01\x02b\x01\x12\x04\
    \x80\x02\x10%\n\x0f\n\x07\x04\x06\x04\x01\x02b\x02\x12\x04\x80\x02(*\n\
    \x0e\n\x06\x04\x06\x04\x01\x02c\x12\x04\x81\x02\x104\n\x0f\n\x07\x04\x06\
    \x04\x01\x02c\x01\x12\x04\x81\x02\x10.\n\x0f\n\x07\x04\x06\x04\x01\x02c\
    \x02\x12\x04\x81\x0213\n\x0e\n\x06\x04\x06\x04\x01\x02d\x12\x04\x82\x02\
    \x104\n\x0f\n\x07\x04\x06\x04\x01\x02d\x01\x12\x04\x82\x02\x10-\n\x0f\n\
    \x07\x04\x06\x04\x01\x02d\x02\x12\x04\x82\x0203\n\x0e\n\x06\x04\x06\x04\
    \x01\x02e\x12\x04\x83\x02\x105\n\x0f\n\x07\x04\x06\x04\x01\x02e\x01\x12\
    \x04\x83\x02\x10.\n\x0f\n\x07\x04\x06\x04\x01\x02e\x02\x12\x04\x83\x0214\
    \n\x0e\n\x06\x04\x06\x04\x01\x02f\x12\x04\x84\x02\x10/\n\x0f\n\x07\x04\
    \x06\x04\x01\x02f\x01\x12\x04\x84\x02\x10(\n\x0f\n\x07\x04\x06\x04\x01\
    \x02f\x02\x12\x04\x84\x02+.\n\x0e\n\x06\x04\x06\x04\x01\x02g\x12\x04\x85\
    \x02\x10,\n\x0f\n\x07\x04\x06\x04\x01\x02g\x01\x12\x04\x85\x02\x10%\n\
    \x0f\n\x07\x04\x06\x04\x01\x02g\x02\x12\x04\x85\x02(+\n\x0e\n\x06\x04\
    \x06\x04\x01\x02h\x12\x04\x86\x02\x10-\n\x0f\n\x07\x04\x06\x04\x01\x02h\
    \x01\x12\x04\x86\x02\x10&\n\x0f\n\x07\x04\x06\x04\x01\x02h\x02\x12\x04\
    \x86\x02),\n\x0e\n\x06\x04\x06\x04\x01\x02i\x12\x04\x87\x02\x104\n\x0f\n\
    \x07\x04\x06\x04\x01\x02i\x01\x12\x04\x87\x02\x10-\n\x0f\n\x07\x04\x06\
    \x04\x01\x02i\x02\x12\x04\x87\x0203\n\x0e\n\x06\x04\x06\x04\x01\x02j\x12\
    \x04\x88\x02\x104\n\x0f\n\x07\x04\x06\x04\x01\x02j\x01\x12\x04\x88\x02\
    \x10-\n\x0f\n\x07\x04\x06\x04\x01\x02j\x02\x12\x04\x88\x0203\n\x0e\n\x06\
    \x04\x06\x04\x01\x02k\x12\x04\x89\x02\x102\n\x0f\n\x07\x04\x06\x04\x01\
    \x02k\x01\x12\x04\x89\x02\x10+\n\x0f\n\x07\x04\x06\x04\x01\x02k\x02\x12\
    \x04\x89\x02.1\n\x0e\n\x06\x04\x06\x04\x01\x02l\x12\x04\x8a\x02\x10(\n\
    \x0f\n\x07\x04\x06\x04\x01\x02l\x01\x12\x04\x8a\x02\x10!\n\x0f\n\x07\x04\
    \x06\x04\x01\x02l\x02\x12\x04\x8a\x02$'\n\x0e\n\x06\x04\x06\x04\x01\x02m\
    \x12\x04\x8b\x02\x10(\n\x0f\n\x07\x04\x06\x04\x01\x02m\x01\x12\x04\x8b\
    \x02\x10!\n\x0f\n\x07\x04\x06\x04\x01\x02m\x02\x12\x04\x8b\x02$'\n\x0e\n\
    \x06\x04\x06\x04\x01\x02n\x12\x04\x8c\x02\x10*\n\x0f\n\x07\x04\x06\x04\
    \x01\x02n\x01\x12\x04\x8c\x02\x10#\n\x0f\n\x07\x04\x06\x04\x01\x02n\x02\
    \x12\x04\x8c\x02&)\n\x0e\n\x06\x04\x06\x04\x01\x02o\x12\x04\x8d\x02\x10-\
    \n\x0f\n\x07\x04\x06\x04\x01\x02o\x01\x12\x04\x8d\x02\x10&\n\x0f\n\x07\
    \x04\x06\x04\x01\x02o\x02\x12\x04\x8d\x02),\n\x0e\n\x06\x04\x06\x04\x01\
    \x02p\x12\x04\x8e\x02\x10%\n\x0f\n\x07\x04\x06\x04\x01\x02p\x01\x12\x04\
    \x8e\x02\x10\x1e\n\x0f\n\x07\x04\x06\x04\x01\x02p\x02\x12\x04\x8e\x02!$\
    \n\x0e\n\x06\x04\x06\x04\x01\x02q\x12\x04\x8f\x02\x10*\n\x0f\n\x07\x04\
    \x06\x04\x01\x02q\x01\x12\x04\x8f\x02\x10#\n\x0f\n\x07\x04\x06\x04\x01\
    \x02q\x02\x12\x04\x8f\x02&)\n\x0e\n\x06\x04\x06\x04\x01\x02r\x12\x04\x90\
    \x02\x10)\n\x0f\n\x07\x04\x06\x04\x01\x02r\x01\x12\x04\x90\x02\x10\"\n\
    \x0f\n\x07\x04\x06\x04\x01\x02r\x02\x12\x04\x90\x02%(\n\x0e\n\x06\x04\
    \x06\x04\x01\x02s\x12\x04\x91\x02\x10/\n\x0f\n\x07\x04\x06\x04\x01\x02s\
    \x01\x12\x04\x91\x02\x10(\n\x0f\n\x07\x04\x06\x04\x01\x02s\x02\x12\x04\
    \x91\x02+.\n\x0e\n\x06\x04\x06\x04\x01\x02t\x12\x04\x92\x02\x101\n\x0f\n\
    \x07\x04\x06\x04\x01\x02t\x01\x12\x04\x92\x02\x10*\n\x0f\n\x07\x04\x06\
    \x04\x01\x02t\x02\x12\x04\x92\x02-0\n\x0e\n\x06\x04\x06\x04\x01\x02u\x12\
    \x04\x93\x02\x100\n\x0f\n\x07\x04\x06\x04\x01\x02u\x01\x12\x04\x93\x02\
    \x10)\n\x0f\n\x07\x04\x06\x04\x01\x02u\x02\x12\x04\x93\x02,/\n\x0e\n\x06\
    \x04\x06\x04\x01\x02v\x12\x04\x94\x02\x10-\n\x0f\n\x07\x04\x06\x04\x01\
    \x02v\x01\x12\x04\x94\x02\x10&\n\x0f\n\x07\x04\x06\x04\x01\x02v\x02\x12\
    \x04\x94\x02),\n\x0e\n\x06\x04\x06\x04\x01\x02w\x12\x04\x95\x02\x106\n\
    \x0f\n\x07\x04\x06\x04\x01\x02w\x01\x12\x04\x95\x02\x10/\n\x0f\n\x07\x04\
    \x06\x04\x01\x02w\x02\x12\x04\x95\x0225\n\x0e\n\x06\x04\x06\x04\x01\x02x\
    \x12\x04\x96\x02\x101\n\x0f\n\x07\x04\x06\x04\x01\x02x\x01\x12\x04\x96\
    \x02\x10*\n\x0f\n\x07\x04\x06\x04\x01\x02x\x02\x12\x04\x96\x02-0\n\x0e\n\
    \x06\x04\x06\x04\x01\x02y\x12\x04\x97\x02\x104\n\x0f\n\x07\x04\x06\x04\
    \x01\x02y\x01\x12\x04\x97\x02\x10-\n\x0f\n\x07\x04\x06\x04\x01\x02y\x02\
    \x12\x04\x97\x0203\n\x0e\n\x06\x04\x06\x04\x01\x02z\x12\x04\x98\x02\x10.\
    \n\x0f\n\x07\x04\x06\x04\x01\x02z\x01\x12\x04\x98\x02\x10'\n\x0f\n\x07\
    \x04\x06\x04\x01\x02z\x02\x12\x04\x98\x02*-\n\x0e\n\x06\x04\x06\x04\x01\
    \x02{\x12\x04\x99\x02\x10+\n\x0f\n\x07\x04\x06\x04\x01\x02{\x01\x12\x04\
    \x99\x02\x10$\n\x0f\n\x07\x04\x06\x04\x01\x02{\x02\x12\x04\x99\x02'*\n\
    \x0e\n\x06\x04\x06\x04\x01\x02|\x12\x04\x9a\x02\x10)\n\x0f\n\x07\x04\x06\
    \x04\x01\x02|\x01\x12\x04\x9a\x02\x10\"\n\x0f\n\x07\x04\x06\x04\x01\x02|\
    \x02\x12\x04\x9a\x02%(\n\x0e\n\x06\x04\x06\x04\x01\x02}\x12\x04\x9b\x02\
    \x103\n\x0f\n\x07\x04\x06\x04\x01\x02}\x01\x12\x04\x9b\x02\x10,\n\x0f\n\
    \x07\x04\x06\x04\x01\x02}\x02\x12\x04\x9b\x02/2\n\x0e\n\x06\x04\x06\x04\
    \x01\x02~\x12\x04\x9c\x02\x10.\n\x0f\n\x07\x04\x06\x04\x01\x02~\x01\x12\
    \x04\x9c\x02\x10'\n\x0f\n\x07\x04\x06\x04\x01\x02~\x02\x12\x04\x9c\x02*-\
    \n\x0e\n\x06\x04\x06\x04\x01\x02\x7f\x12\x04\x9d\x02\x10,\n\x0f\n\x07\
    \x04\x06\x04\x01\x02\x7f\x01\x12\x04\x9d\x02\x10%\n\x0f\n\x07\x04\x06\
    \x04\x01\x02\x7f\x02\x12\x04\x9d\x02(+\n\x0f\n\x07\x04\x06\x04\x01\x02\
    \x80\x01\x12\x04\x9e\x02\x10.\n\x10\n\x08\x04\x06\x04\x01\x02\x80\x01\
    \x01\x12\x04\x9e\x02\x10'\n\x10\n\x08\x04\x06\x04\x01\x02\x80\x01\x02\
    \x12\x04\x9e\x02*-\n\x0f\n\x07\x04\x06\x04\x01\x02\x81\x01\x12\x04\x9f\
    \x02\x10\"\n\x10\n\x08\x04\x06\x04\x01\x02\x81\x01\x01\x12\x04\x9f\x02\
    \x10\x1b\n\x10\n\x08\x04\x06\x04\x01\x02\x81\x01\x02\x12\x04\x9f\x02\x1e\
    !\n\x0e\n\x04\x04\x06\x04\x02\x12\x06\xa2\x02\x08\xa5\x02\t\n\r\n\x05\
    \x04\x06\x04\x02\x01\x12\x04\xa2\x02\r\x15\n\x0e\n\x06\x04\x06\x04\x02\
    \x02\0\x12\x04\xa3\x02\x10\x20\n\x0f\n\x07\x04\x06\x04\x02\x02\0\x01\x12\
    \x04\xa3\x02\x10\x1b\n\x0f\n\x07\x04\x06\x04\x02\x02\0\x02\x12\x04\xa3\
    \x02\x1e\x1f\n\x0e\n\x06\x04\x06\x04\x02\x02\x01\x12\x04\xa4\x02\x10!\n\
    \x0f\n\x07\x04\x06\x04\x02\x02\x01\x01\x12\x04\xa4\x02\x10\x1c\n\x0f\n\
    \x07\x04\x06\x04\x02\x02\x01\x02\x12\x04\xa4\x02\x1f\x20\n\x0c\n\x04\x04\
    \x06\x02\0\x12\x04\xa7\x02\x080\n\r\n\x05\x04\x06\x02\0\x04\x12\x04\xa7\
    \x02\x08\x10\n\r\n\x05\x04\x06\x02\0\x06\x12\x04\xa7\x02\x11$\n\r\n\x05\
    \x04\x06\x02\0\x01\x12\x04\xa7\x02%+\n\r\n\x05\x04\x06\x02\0\x03\x12\x04\
    \xa7\x02./\n\x0c\n\x04\x04\x06\x02\x01\x12\x04\xa8\x02\x08?\n\r\n\x05\
    \x04\x06\x02\x01\x04\x12\x04\xa8\x02\x08\x10\n\r\n\x05\x04\x06\x02\x01\
    \x05\x12\x04\xa8\x02\x11\x17\n\r\n\x05\x04\x06\x02\x01\x01\x12\x04\xa8\
    \x02\x18%\n\r\n\x05\x04\x06\x02\x01\x03\x12\x04\xa8\x02()\n\r\n\x05\x04\
    \x06\x02\x01\x08\x12\x04\xa8\x02*>\n\x10\n\x08\x04\x06\x02\x01\x08\xf2\
    \xa2\x04\x12\x04\xa8\x02+=\n\x0c\n\x04\x04\x06\x02\x02\x12\x04\xa9\x02\
    \x08#\n\r\n\x05\x04\x06\x02\x02\x04\x12\x04\xa9\x02\x08\x10\n\r\n\x05\
    \x04\x06\x02\x02\x05\x12\x04\xa9\x02\x11\x17\n\r\n\x05\x04\x06\x02\x02\
    \x01\x12\x04\xa9\x02\x18\x1e\n\r\n\x05\x04\x06\x02\x02\x03\x12\x04\xa9\
    \x02!\"\n\x0c\n\x04\x04\x06\x02\x03\x12\x04\xaa\x02\x080\n\r\n\x05\x04\
    \x06\x02\x03\x04\x12\x04\xaa\x02\x08\x10\n\r\n\x05\x04\x06\x02\x03\x05\
    \x12\x04\xaa\x02\x11\x17\n\r\n\x05\x04\x06\x02\x03\x01\x12\x04\xaa\x02\
    \x18+\n\r\n\x05\x04\x06\x02\x03\x03\x12\x04\xaa\x02./\n\r\n\x04\x04\x06\
    \x02\x04\x12\x05\xab\x02\x08\x96\x01\n\r\n\x05\x04\x06\x02\x04\x04\x12\
    \x04\xab\x02\x08\x10\n\r\n\x05\x04\x06\x02\x04\x05\x12\x04\xab\x02\x11\
    \x17\n\r\n\x05\x04\x06\x02\x04\x01\x12\x04\xab\x02\x18\x1b\n\r\n\x05\x04\
    \x06\x02\x04\x03\x12\x04\xab\x02\x1e\x1f\n\x0e\n\x05\x04\x06\x02\x04\x08\
    \x12\x05\xab\x02\x20\x95\x01\n\x10\n\x08\x04\x06\x02\x04\x08\xf4\xa2\x04\
    \x12\x04\xab\x02!A\n\x11\n\x08\x04\x06\x02\x04\x08\xf5\xa2\x04\x12\x05\
    \xab\x02C\x94\x01\n\r\n\x04\x04\x06\x02\x05\x12\x05\xac\x02\x08\xc5\x01\
    \n\r\n\x05\x04\x06\x02\x05\x04\x12\x04\xac\x02\x08\x10\n\r\n\x05\x04\x06\
    \x02\x05\x06\x12\x04\xac\x02\x115\n\r\n\x05\x04\x06\x02\x05\x01\x12\x04\
    \xac\x026?\n\r\n\x05\x04\x06\x02\x05\x03\x12\x04\xac\x02BC\n\x0e\n\x05\
    \x04\x06\x02\x05\x08\x12\x05\xac\x02D\xc4\x01\n\x10\n\x08\x04\x06\x02\
    \x05\x08\xf4\xa2\x04\x12\x04\xac\x02Ej\n\x11\n\x08\x04\x06\x02\x05\x08\
    \xf5\xa2\x04\x12\x05\xac\x02l\xc3\x01\n\r\n\x04\x04\x06\x02\x06\x12\x05\
    \xad\x02\x08\xc4\x01\n\r\n\x05\x04\x06\x02\x06\x04\x12\x04\xad\x02\x08\
    \x10\n\r\n\x05\x04\x06\x02\x06\x06\x12\x04\xad\x02\x110\n\r\n\x05\x04\
    \x06\x02\x06\x01\x12\x04\xad\x0215\n\r\n\x05\x04\x06\x02\x06\x03\x12\x04\
    \xad\x028:\n\x0e\n\x05\x04\x06\x02\x06\x08\x12\x05\xad\x02;\xc3\x01\n\r\
    \n\x05\x04\x06\x02\x06\x07\x12\x04\xad\x02FQ\n\x10\n\x08\x04\x06\x02\x06\
    \x08\xf4\xa2\x04\x12\x04\xad\x02Ss\n\x11\n\x08\x04\x06\x02\x06\x08\xf5\
    \xa2\x04\x12\x05\xad\x02u\xc2\x01\n\x0c\n\x04\x04\x06\x02\x07\x12\x04\
    \xae\x02\x08{\n\r\n\x05\x04\x06\x02\x07\x04\x12\x04\xae\x02\x08\x10\n\r\
    \n\x05\x04\x06\x02\x07\x06\x12\x04\xae\x02\x11\x1e\n\r\n\x05\x04\x06\x02\
    \x07\x01\x12\x04\xae\x02\x1f-\n\r\n\x05\x04\x06\x02\x07\x03\x12\x04\xae\
    \x0202\n\r\n\x05\x04\x06\x02\x07\x08\x12\x04\xae\x023z\n\x10\n\x08\x04\
    \x06\x02\x07\x08\xf4\xa2\x04\x12\x04\xae\x024U\n\x10\n\x08\x04\x06\x02\
    \x07\x08\xfe\xa2\x04\x12\x04\xae\x02Wy\n\x0c\n\x04\x04\x06\x02\x08\x12\
    \x04\xaf\x02\x08y\n\r\n\x05\x04\x06\x02\x08\x04\x12\x04\xaf\x02\x08\x10\
    \n\r\n\x05\x04\x06\x02\x08\x06\x12\x04\xaf\x02\x11\x1e\n\r\n\x05\x04\x06\
    \x02\x08\x01\x12\x04\xaf\x02\x1f+\n\r\n\x05\x04\x06\x02\x08\x03\x12\x04\
    \xaf\x02.0\n\r\n\x05\x04\x06\x02\x08\x08\x12\x04\xaf\x021x\n\x10\n\x08\
    \x04\x06\x02\x08\x08\xf4\xa2\x04\x12\x04\xaf\x022S\n\x10\n\x08\x04\x06\
    \x02\x08\x08\xfe\xa2\x04\x12\x04\xaf\x02Uw\n\x0c\n\x04\x04\x06\x02\t\x12\
    \x04\xb0\x02\x08k\n\r\n\x05\x04\x06\x02\t\x04\x12\x04\xb0\x02\x08\x10\n\
    \r\n\x05\x04\x06\x02\t\x06\x12\x04\xb0\x02\x116\n\r\n\x05\x04\x06\x02\t\
    \x01\x12\x04\xb0\x027A\n\r\n\x05\x04\x06\x02\t\x03\x12\x04\xb0\x02DF\n\r\
    \n\x05\x04\x06\x02\t\x08\x12\x04\xb0\x02Gj\n\x10\n\x08\x04\x06\x02\t\x08\
    \xf4\xa2\x04\x12\x04\xb0\x02Hi\n\r\n\x04\x04\x06\x02\n\x12\x05\xb1\x02\
    \x08\xbe\x01\n\r\n\x05\x04\x06\x02\n\x04\x12\x04\xb1\x02\x08\x10\n\r\n\
    \x05\x04\x06\x02\n\x06\x12\x04\xb1\x02\x11\"\n\r\n\x05\x04\x06\x02\n\x01\
    \x12\x04\xb1\x02#2\n\r\n\x05\x04\x06\x02\n\x03\x12\x04\xb1\x0257\n\x0e\n\
    \x05\x04\x06\x02\n\x08\x12\x05\xb1\x028\xbd\x01\n\r\n\x05\x04\x06\x02\n\
    \x07\x12\x04\xb1\x02CF\n\x10\n\x08\x04\x06\x02\n\x08\xf4\xa2\x04\x12\x04\
    \xb1\x02Hj\n\x11\n\x08\x04\x06\x02\n\x08\xf5\xa2\x04\x12\x05\xb1\x02l\
    \xbc\x01\n\r\n\x04\x04\x06\x02\x0b\x12\x05\xb2\x02\x08\x92\x01\n\r\n\x05\
    \x04\x06\x02\x0b\x04\x12\x04\xb2\x02\x08\x10\n\r\n\x05\x04\x06\x02\x0b\
    \x05\x12\x04\xb2\x02\x11\x17\n\r\n\x05\x04\x06\x02\x0b\x01\x12\x04\xb2\
    \x02\x18!\n\r\n\x05\x04\x06\x02\x0b\x03\x12\x04\xb2\x02$&\n\x0e\n\x05\
    \x04\x06\x02\x0b\x08\x12\x05\xb2\x02'\x91\x01\n\x10\n\x08\x04\x06\x02\
    \x0b\x08\xf4\xa2\x04\x12\x04\xb2\x02(Q\n\x11\n\x08\x04\x06\x02\x0b\x08\
    \xf5\xa2\x04\x12\x05\xb2\x02S\x90\x01\n\r\n\x04\x04\x06\x02\x0c\x12\x05\
    \xb3\x02\x08\xaf\x01\n\r\n\x05\x04\x06\x02\x0c\x04\x12\x04\xb3\x02\x08\
    \x10\n\r\n\x05\x04\x06\x02\x0c\x06\x12\x04\xb3\x02\x11\"\n\r\n\x05\x04\
    \x06\x02\x0c\x01\x12\x04\xb3\x02#-\n\r\n\x05\x04\x06\x02\x0c\x03\x12\x04\
    \xb3\x0202\n\x0e\n\x05\x04\x06\x02\x0c\x08\x12\x05\xb3\x023\xae\x01\n\r\
    \n\x05\x04\x06\x02\x0c\x07\x12\x04\xb3\x02>A\n\x10\n\x08\x04\x06\x02\x0c\
    \x08\xf4\xa2\x04\x12\x04\xb3\x02C`\n\x11\n\x08\x04\x06\x02\x0c\x08\xf5\
    \xa2\x04\x12\x05\xb3\x02b\xad\x01\n\r\n\x04\x04\x06\x02\r\x12\x05\xb4\
    \x02\x08\x88\x01\n\r\n\x05\x04\x06\x02\r\x04\x12\x04\xb4\x02\x08\x10\n\r\
    \n\x05\x04\x06\x02\r\x05\x12\x04\xb4\x02\x11\x17\n\r\n\x05\x04\x06\x02\r\
    \x01\x12\x04\xb4\x02\x18\"\n\r\n\x05\x04\x06\x02\r\x03\x12\x04\xb4\x02%'\
    \n\x0e\n\x05\x04\x06\x02\r\x08\x12\x05\xb4\x02(\x87\x01\n\x10\n\x08\x04\
    \x06\x02\r\x08\xf4\xa2\x04\x12\x04\xb4\x02)F\n\x11\n\x08\x04\x06\x02\r\
    \x08\xf5\xa2\x04\x12\x05\xb4\x02H\x86\x01\n\x0c\n\x02\x04\x07\x12\x06\
    \xb7\x02\0\xd1\x02\x01\n\x0b\n\x03\x04\x07\x01\x12\x04\xb7\x02\x08\x14\n\
    \x0e\n\x04\x04\x07\x03\0\x12\x06\xb8\x02\x08\xbc\x02\t\n\r\n\x05\x04\x07\
    \x03\0\x01\x12\x04\xb8\x02\x10\x1a\n\x0e\n\x06\x04\x07\x03\0\x02\0\x12\
    \x04\xb9\x02\x10/\n\x0f\n\x07\x04\x07\x03\0\x02\0\x04\x12\x04\xb9\x02\
    \x10\x18\n\x0f\n\x07\x04\x07\x03\0\x02\0\x05\x12\x04\xb9\x02\x19\x1f\n\
    \x0f\n\x07\x04\x07\x03\0\x02\0\x01\x12\x04\xb9\x02\x20*\n\x0f\n\x07\x04\
    \x07\x03\0\x02\0\x03\x12\x04\xb9\x02-.\n\x0e\n\x06\x04\x07\x03\0\x02\x01\
    \x12\x04\xba\x02\x102\n\x0f\n\x07\x04\x07\x03\0\x02\x01\x04\x12\x04\xba\
    \x02\x10\x18\n\x0f\n\x07\x04\x07\x03\0\x02\x01\x05\x12\x04\xba\x02\x19\
    \x1f\n\x0f\n\x07\x04\x07\x03\0\x02\x01\x01\x12\x04\xba\x02\x20-\n\x0f\n\
    \x07\x04\x07\x03\0\x02\x01\x03\x12\x04\xba\x0201\n\x0e\n\x06\x04\x07\x03\
    \0\x02\x02\x12\x04\xbb\x02\x10-\n\x0f\n\x07\x04\x07\x03\0\x02\x02\x04\
    \x12\x04\xbb\x02\x10\x18\n\x0f\n\x07\x04\x07\x03\0\x02\x02\x05\x12\x04\
    \xbb\x02\x19\x1f\n\x0f\n\x07\x04\x07\x03\0\x02\x02\x01\x12\x04\xbb\x02\
    \x20(\n\x0f\n\x07\x04\x07\x03\0\x02\x02\x03\x12\x04\xbb\x02+,\n\x0e\n\
    \x04\x04\x07\x03\x01\x12\x06\xbe\x02\x08\xc2\x02\t\n\r\n\x05\x04\x07\x03\
    \x01\x01\x12\x04\xbe\x02\x10!\n\x0e\n\x06\x04\x07\x03\x01\x02\0\x12\x04\
    \xbf\x02\x10a\n\x0f\n\x07\x04\x07\x03\x01\x02\0\x04\x12\x04\xbf\x02\x10\
    \x18\n\x0f\n\x07\x04\x07\x03\x01\x02\0\x06\x12\x04\xbf\x02\x19(\n\x0f\n\
    \x07\x04\x07\x03\x01\x02\0\x01\x12\x04\xbf\x02)2\n\x0f\n\x07\x04\x07\x03\
    \x01\x02\0\x03\x12\x04\xbf\x0256\n\x0f\n\x07\x04\x07\x03\x01\x02\0\x08\
    \x12\x04\xbf\x027`\n\x12\n\n\x04\x07\x03\x01\x02\0\x08\xf0\xa2\x04\x12\
    \x04\xbf\x028_\n\x0e\n\x06\x04\x07\x03\x01\x02\x01\x12\x04\xc0\x02\x10V\
    \n\x0f\n\x07\x04\x07\x03\x01\x02\x01\x04\x12\x04\xc0\x02\x10\x18\n\x0f\n\
    \x07\x04\x07\x03\x01\x02\x01\x06\x12\x04\xc0\x02\x19&\n\x0f\n\x07\x04\
    \x07\x03\x01\x02\x01\x01\x12\x04\xc0\x02'1\n\x0f\n\x07\x04\x07\x03\x01\
    \x02\x01\x03\x12\x04\xc0\x0245\n\x0f\n\x07\x04\x07\x03\x01\x02\x01\x08\
    \x12\x04\xc0\x026U\n\x0f\n\x07\x04\x07\x03\x01\x02\x01\x07\x12\x04\xc0\
    \x02AT\n\x0f\n\x06\x04\x07\x03\x01\x02\x02\x12\x05\xc1\x02\x10\xc7\x01\n\
    \x0f\n\x07\x04\x07\x03\x01\x02\x02\x04\x12\x04\xc1\x02\x10\x18\n\x0f\n\
    \x07\x04\x07\x03\x01\x02\x02\x05\x12\x04\xc1\x02\x19\x1f\n\x0f\n\x07\x04\
    \x07\x03\x01\x02\x02\x01\x12\x04\xc1\x02\x20+\n\x0f\n\x07\x04\x07\x03\
    \x01\x02\x02\x03\x12\x04\xc1\x02./\n\x10\n\x07\x04\x07\x03\x01\x02\x02\
    \x08\x12\x05\xc1\x020\xc6\x01\n\x12\n\n\x04\x07\x03\x01\x02\x02\x08\xf4\
    \xa2\x04\x12\x04\xc1\x021S\n\x13\n\n\x04\x07\x03\x01\x02\x02\x08\xf5\xa2\
    \x04\x12\x05\xc1\x02U\xc5\x01\n\x0c\n\x04\x04\x07\x02\0\x12\x04\xc4\x02\
    \x080\n\r\n\x05\x04\x07\x02\0\x04\x12\x04\xc4\x02\x08\x10\n\r\n\x05\x04\
    \x07\x02\0\x06\x12\x04\xc4\x02\x11$\n\r\n\x05\x04\x07\x02\0\x01\x12\x04\
    \xc4\x02%+\n\r\n\x05\x04\x07\x02\0\x03\x12\x04\xc4\x02./\n\x0c\n\x04\x04\
    \x07\x02\x01\x12\x04\xc5\x02\x08)\n\r\n\x05\x04\x07\x02\x01\x04\x12\x04\
    \xc5\x02\x08\x10\n\r\n\x05\x04\x07\x02\x01\x05\x12\x04\xc5\x02\x11\x17\n\
    \r\n\x05\x04\x07\x02\x01\x01\x12\x04\xc5\x02\x18$\n\r\n\x05\x04\x07\x02\
    \x01\x03\x12\x04\xc5\x02'(\n\x0c\n\x04\x04\x07\x02\x02\x12\x04\xc6\x02\
    \x08)\n\r\n\x05\x04\x07\x02\x02\x04\x12\x04\xc6\x02\x08\x10\n\r\n\x05\
    \x04\x07\x02\x02\x05\x12\x04\xc6\x02\x11\x17\n\r\n\x05\x04\x07\x02\x02\
    \x01\x12\x04\xc6\x02\x18$\n\r\n\x05\x04\x07\x02\x02\x03\x12\x04\xc6\x02'\
    (\n\x0c\n\x04\x04\x07\x02\x03\x12\x04\xc7\x02\x08)\n\r\n\x05\x04\x07\x02\
    \x03\x04\x12\x04\xc7\x02\x08\x10\n\r\n\x05\x04\x07\x02\x03\x05\x12\x04\
    \xc7\x02\x11\x17\n\r\n\x05\x04\x07\x02\x03\x01\x12\x04\xc7\x02\x18$\n\r\
    \n\x05\x04\x07\x02\x03\x03\x12\x04\xc7\x02'(\n\x0c\n\x04\x04\x07\x02\x04\
    \x12\x04\xc8\x02\x08?\n\r\n\x05\x04\x07\x02\x04\x04\x12\x04\xc8\x02\x08\
    \x10\n\r\n\x05\x04\x07\x02\x04\x05\x12\x04\xc8\x02\x11\x17\n\r\n\x05\x04\
    \x07\x02\x04\x01\x12\x04\xc8\x02\x18%\n\r\n\x05\x04\x07\x02\x04\x03\x12\
    \x04\xc8\x02()\n\r\n\x05\x04\x07\x02\x04\x08\x12\x04\xc8\x02*>\n\x10\n\
    \x08\x04\x07\x02\x04\x08\xf2\xa2\x04\x12\x04\xc8\x02+=\n\x0c\n\x04\x04\
    \x07\x02\x05\x12\x04\xc9\x02\x08&\n\r\n\x05\x04\x07\x02\x05\x04\x12\x04\
    \xc9\x02\x08\x10\n\r\n\x05\x04\x07\x02\x05\x05\x12\x04\xc9\x02\x11\x17\n\
    \r\n\x05\x04\x07\x02\x05\x01\x12\x04\xc9\x02\x18!\n\r\n\x05\x04\x07\x02\
    \x05\x03\x12\x04\xc9\x02$%\n\x0c\n\x04\x04\x07\x02\x06\x12\x04\xca\x02\
    \x08:\n\r\n\x05\x04\x07\x02\x06\x04\x12\x04\xca\x02\x08\x10\n\r\n\x05\
    \x04\x07\x02\x06\x06\x12\x04\xca\x02\x11)\n\r\n\x05\x04\x07\x02\x06\x01\
    \x12\x04\xca\x02*5\n\r\n\x05\x04\x07\x02\x06\x03\x12\x04\xca\x0289\n\r\n\
    \x04\x04\x07\x02\x07\x12\x05\xcb\x02\x08\x86\x01\n\r\n\x05\x04\x07\x02\
    \x07\x04\x12\x04\xcb\x02\x08\x10\n\r\n\x05\x04\x07\x02\x07\x05\x12\x04\
    \xcb\x02\x11\x17\n\r\n\x05\x04\x07\x02\x07\x01\x12\x04\xcb\x02\x18\"\n\r\
    \n\x05\x04\x07\x02\x07\x03\x12\x04\xcb\x02%'\n\x0e\n\x05\x04\x07\x02\x07\
    \x08\x12\x05\xcb\x02(\x85\x01\n\x10\n\x08\x04\x07\x02\x07\x08\xf4\xa2\
    \x04\x12\x04\xcb\x02)F\n\x11\n\x08\x04\x07\x02\x07\x08\xf5\xa2\x04\x12\
    \x05\xcb\x02H\x84\x01\n\x0c\n\x04\x04\x07\x02\x08\x12\x04\xcc\x02\x08t\n\
    \r\n\x05\x04\x07\x02\x08\x04\x12\x04\xcc\x02\x08\x10\n\r\n\x05\x04\x07\
    \x02\x08\x05\x12\x04\xcc\x02\x11\x17\n\r\n\x05\x04\x07\x02\x08\x01\x12\
    \x04\xcc\x02\x18\"\n\r\n\x05\x04\x07\x02\x08\x03\x12\x04\xcc\x02%'\n\r\n\
    \x05\x04\x07\x02\x08\x08\x12\x04\xcc\x02(s\n\x10\n\x08\x04\x07\x02\x08\
    \x08\xf4\xa2\x04\x12\x04\xcc\x02)E\n\x10\n\x08\x04\x07\x02\x08\x08\xf5\
    \xa2\x04\x12\x04\xcc\x02Gr\n\x0c\n\x04\x04\x07\x02\t\x12\x04\xcd\x02\x08\
    R\n\r\n\x05\x04\x07\x02\t\x04\x12\x04\xcd\x02\x08\x10\n\r\n\x05\x04\x07\
    \x02\t\x06\x12\x04\xcd\x02\x11\x20\n\r\n\x05\x04\x07\x02\t\x01\x12\x04\
    \xcd\x02!&\n\r\n\x05\x04\x07\x02\t\x03\x12\x04\xcd\x02)+\n\r\n\x05\x04\
    \x07\x02\t\x08\x12\x04\xcd\x02,Q\n\x10\n\x08\x04\x07\x02\t\x08\xf0\xa2\
    \x04\x12\x04\xcd\x02-P\n\x0c\n\x04\x04\x07\x02\n\x12\x04\xce\x02\x08x\n\
    \r\n\x05\x04\x07\x02\n\x04\x12\x04\xce\x02\x08\x10\n\r\n\x05\x04\x07\x02\
    \n\x05\x12\x04\xce\x02\x11\x17\n\r\n\x05\x04\x07\x02\n\x01\x12\x04\xce\
    \x02\x18$\n\r\n\x05\x04\x07\x02\n\x03\x12\x04\xce\x02')\n\r\n\x05\x04\
    \x07\x02\n\x08\x12\x04\xce\x02*w\n\x10\n\x08\x04\x07\x02\n\x08\xf4\xa2\
    \x04\x12\x04\xce\x02+E\n\x10\n\x08\x04\x07\x02\n\x08\xf5\xa2\x04\x12\x04\
    \xce\x02Gv\n\x0c\n\x04\x04\x07\x02\x0b\x12\x04\xcf\x02\x08A\n\r\n\x05\
    \x04\x07\x02\x0b\x04\x12\x04\xcf\x02\x08\x10\n\r\n\x05\x04\x07\x02\x0b\
    \x06\x12\x04\xcf\x02\x110\n\r\n\x05\x04\x07\x02\x0b\x01\x12\x04\xcf\x021\
    ;\n\r\n\x05\x04\x07\x02\x0b\x03\x12\x04\xcf\x02>@\n\r\n\x04\x04\x07\x02\
    \x0c\x12\x05\xd0\x02\x08\x97\x01\n\r\n\x05\x04\x07\x02\x0c\x04\x12\x04\
    \xd0\x02\x08\x10\n\r\n\x05\x04\x07\x02\x0c\x05\x12\x04\xd0\x02\x11\x17\n\
    \r\n\x05\x04\x07\x02\x0c\x01\x12\x04\xd0\x02\x18\x1b\n\r\n\x05\x04\x07\
    \x02\x0c\x03\x12\x04\xd0\x02\x1e\x20\n\x0e\n\x05\x04\x07\x02\x0c\x08\x12\
    \x05\xd0\x02!\x96\x01\n\x10\n\x08\x04\x07\x02\x0c\x08\xf4\xa2\x04\x12\
    \x04\xd0\x02\"B\n\x11\n\x08\x04\x07\x02\x0c\x08\xf5\xa2\x04\x12\x05\xd0\
    \x02D\x95\x01\n\x0c\n\x02\x04\x08\x12\x06\xd3\x02\0\xda\x02\x01\n\x0b\n\
    \x03\x04\x08\x01\x12\x04\xd3\x02\x08\x1d\n\x0c\n\x04\x04\x08\x02\0\x12\
    \x04\xd4\x02\x080\n\r\n\x05\x04\x08\x02\0\x04\x12\x04\xd4\x02\x08\x10\n\
    \r\n\x05\x04\x08\x02\0\x06\x12\x04\xd4\x02\x11$\n\r\n\x05\x04\x08\x02\0\
    \x01\x12\x04\xd4\x02%+\n\r\n\x05\x04\x08\x02\0\x03\x12\x04\xd4\x02./\n\
    \x0c\n\x04\x04\x08\x02\x01\x12\x04\xd5\x02\x08&\n\r\n\x05\x04\x08\x02\
    \x01\x04\x12\x04\xd5\x02\x08\x10\n\r\n\x05\x04\x08\x02\x01\x05\x12\x04\
    \xd5\x02\x11\x17\n\r\n\x05\x04\x08\x02\x01\x01\x12\x04\xd5\x02\x18!\n\r\
    \n\x05\x04\x08\x02\x01\x03\x12\x04\xd5\x02$%\n\r\n\x04\x04\x08\x02\x02\
    \x12\x05\xd6\x02\x08\x92\x01\n\r\n\x05\x04\x08\x02\x02\x04\x12\x04\xd6\
    \x02\x08\x10\n\r\n\x05\x04\x08\x02\x02\x05\x12\x04\xd6\x02\x11\x17\n\r\n\
    \x05\x04\x08\x02\x02\x01\x12\x04\xd6\x02\x18,\n\r\n\x05\x04\x08\x02\x02\
    \x03\x12\x04\xd6\x02/0\n\x0e\n\x05\x04\x08\x02\x02\x08\x12\x05\xd6\x021\
    \x91\x01\n\x10\n\x08\x04\x08\x02\x02\x08\xf4\xa2\x04\x12\x04\xd6\x022T\n\
    \x11\n\x08\x04\x08\x02\x02\x08\xf5\xa2\x04\x12\x05\xd6\x02V\x90\x01\n\
    \x0c\n\x04\x04\x08\x02\x03\x12\x04\xd7\x02\x08N\n\r\n\x05\x04\x08\x02\
    \x03\x04\x12\x04\xd7\x02\x08\x10\n\r\n\x05\x04\x08\x02\x03\x06\x12\x04\
    \xd7\x02\x11\x1e\n\r\n\x05\x04\x08\x02\x03\x01\x12\x04\xd7\x02\x1f$\n\r\
    \n\x05\x04\x08\x02\x03\x03\x12\x04\xd7\x02'(\n\r\n\x05\x04\x08\x02\x03\
    \x08\x12\x04\xd7\x02)M\n\x10\n\x08\x04\x08\x02\x03\x08\xfe\xa2\x04\x12\
    \x04\xd7\x02*L\n\r\n\x04\x04\x08\x02\x04\x12\x05\xd8\x02\x08\x8a\x01\n\r\
    \n\x05\x04\x08\x02\x04\x04\x12\x04\xd8\x02\x08\x10\n\r\n\x05\x04\x08\x02\
    \x04\x05\x12\x04\xd8\x02\x11\x17\n\r\n\x05\x04\x08\x02\x04\x01\x12\x04\
    \xd8\x02\x18&\n\r\n\x05\x04\x08\x02\x04\x03\x12\x04\xd8\x02)*\n\x0e\n\
    \x05\x04\x08\x02\x04\x08\x12\x05\xd8\x02+\x89\x01\n\x10\n\x08\x04\x08\
    \x02\x04\x08\xf4\xa2\x04\x12\x04\xd8\x02,M\n\x11\n\x08\x04\x08\x02\x04\
    \x08\xf5\xa2\x04\x12\x05\xd8\x02O\x88\x01\n\x0c\n\x04\x04\x08\x02\x05\
    \x12\x04\xd9\x02\x08~\n\r\n\x05\x04\x08\x02\x05\x04\x12\x04\xd9\x02\x08\
    \x10\n\r\n\x05\x04\x08\x02\x05\x05\x12\x04\xd9\x02\x11\x17\n\r\n\x05\x04\
    \x08\x02\x05\x01\x12\x04\xd9\x02\x18\"\n\r\n\x05\x04\x08\x02\x05\x03\x12\
    \x04\xd9\x02%&\n\r\n\x05\x04\x08\x02\x05\x08\x12\x04\xd9\x02'}\n\x10\n\
    \x08\x04\x08\x02\x05\x08\xf4\xa2\x04\x12\x04\xd9\x02(E\n\x10\n\x08\x04\
    \x08\x02\x05\x08\xf5\xa2\x04\x12\x04\xd9\x02G|\n\x0c\n\x02\x04\t\x12\x06\
    \xdc\x02\0\xeb\x02\x01\n\x0b\n\x03\x04\t\x01\x12\x04\xdc\x02\x08\x1d\n\
    \x0e\n\x04\x04\t\x03\0\x12\x06\xdd\x02\x08\xe1\x02\t\n\r\n\x05\x04\t\x03\
    \0\x01\x12\x04\xdd\x02\x10\x1a\n\x0e\n\x06\x04\t\x03\0\x02\0\x12\x04\xde\
    \x02\x10l\n\x0f\n\x07\x04\t\x03\0\x02\0\x04\x12\x04\xde\x02\x10\x18\n\
    \x0f\n\x07\x04\t\x03\0\x02\0\x06\x12\x04\xde\x02\x19(\n\x0f\n\x07\x04\t\
    \x03\0\x02\0\x01\x12\x04\xde\x02)<\n\x0f\n\x07\x04\t\x03\0\x02\0\x03\x12\
    \x04\xde\x02?@\n\x0f\n\x07\x04\t\x03\0\x02\0\x08\x12\x04\xde\x02Ak\n\x12\
    \n\n\x04\t\x03\0\x02\0\x08\xf0\xa2\x04\x12\x04\xde\x02Bj\n\x0e\n\x06\x04\
    \t\x03\0\x02\x01\x12\x04\xdf\x02\x10)\n\x0f\n\x07\x04\t\x03\0\x02\x01\
    \x04\x12\x04\xdf\x02\x10\x18\n\x0f\n\x07\x04\t\x03\0\x02\x01\x05\x12\x04\
    \xdf\x02\x19\x1f\n\x0f\n\x07\x04\t\x03\0\x02\x01\x01\x12\x04\xdf\x02\x20\
    $\n\x0f\n\x07\x04\t\x03\0\x02\x01\x03\x12\x04\xdf\x02'(\n\x0e\n\x06\x04\
    \t\x03\0\x02\x02\x12\x04\xe0\x02\x10)\n\x0f\n\x07\x04\t\x03\0\x02\x02\
    \x04\x12\x04\xe0\x02\x10\x18\n\x0f\n\x07\x04\t\x03\0\x02\x02\x05\x12\x04\
    \xe0\x02\x19\x1f\n\x0f\n\x07\x04\t\x03\0\x02\x02\x01\x12\x04\xe0\x02\x20\
    $\n\x0f\n\x07\x04\t\x03\0\x02\x02\x03\x12\x04\xe0\x02'(\n\x0c\n\x04\x04\
    \t\x02\0\x12\x04\xe3\x02\x080\n\r\n\x05\x04\t\x02\0\x04\x12\x04\xe3\x02\
    \x08\x10\n\r\n\x05\x04\t\x02\0\x06\x12\x04\xe3\x02\x11$\n\r\n\x05\x04\t\
    \x02\0\x01\x12\x04\xe3\x02%+\n\r\n\x05\x04\t\x02\0\x03\x12\x04\xe3\x02./\
    \n\x0c\n\x04\x04\t\x02\x01\x12\x04\xe4\x02\x086\n\r\n\x05\x04\t\x02\x01\
    \x04\x12\x04\xe4\x02\x08\x10\n\r\n\x05\x04\t\x02\x01\x05\x12\x04\xe4\x02\
    \x11\x17\n\r\n\x05\x04\t\x02\x01\x01\x12\x04\xe4\x02\x18\x1c\n\r\n\x05\
    \x04\t\x02\x01\x03\x12\x04\xe4\x02\x1f\x20\n\r\n\x05\x04\t\x02\x01\x08\
    \x12\x04\xe4\x02!5\n\x10\n\x08\x04\t\x02\x01\x08\xf2\xa2\x04\x12\x04\xe4\
    \x02\"4\n\x0c\n\x04\x04\t\x02\x02\x12\x04\xe5\x02\x08$\n\r\n\x05\x04\t\
    \x02\x02\x04\x12\x04\xe5\x02\x08\x10\n\r\n\x05\x04\t\x02\x02\x05\x12\x04\
    \xe5\x02\x11\x17\n\r\n\x05\x04\t\x02\x02\x01\x12\x04\xe5\x02\x18\x1f\n\r\
    \n\x05\x04\t\x02\x02\x03\x12\x04\xe5\x02\"#\n\x0c\n\x04\x04\t\x02\x03\
    \x12\x04\xe6\x02\x08=\n\r\n\x05\x04\t\x02\x03\x04\x12\x04\xe6\x02\x08\
    \x10\n\r\n\x05\x04\t\x02\x03\x06\x12\x04\xe6\x02\x112\n\r\n\x05\x04\t\
    \x02\x03\x01\x12\x04\xe6\x0238\n\r\n\x05\x04\t\x02\x03\x03\x12\x04\xe6\
    \x02;<\n\r\n\x04\x04\t\x02\x04\x12\x05\xe7\x02\x08\xc2\x01\n\r\n\x05\x04\
    \t\x02\x04\x04\x12\x04\xe7\x02\x08\x10\n\r\n\x05\x04\t\x02\x04\x06\x12\
    \x04\xe7\x02\x11\x20\n\r\n\x05\x04\t\x02\x04\x01\x12\x04\xe7\x02!,\n\r\n\
    \x05\x04\t\x02\x04\x03\x12\x04\xe7\x02/0\n\x0e\n\x05\x04\t\x02\x04\x08\
    \x12\x05\xe7\x021\xc1\x01\n\x10\n\x08\x04\t\x02\x04\x08\xf0\xa2\x04\x12\
    \x04\xe7\x022Z\n\x10\n\x08\x04\t\x02\x04\x08\xf4\xa2\x04\x12\x04\xe7\x02\
    \\z\n\x11\n\x08\x04\t\x02\x04\x08\xf5\xa2\x04\x12\x05\xe7\x02|\xc0\x01\n\
    \r\n\x04\x04\t\x02\x05\x12\x05\xe8\x02\x08\x9f\x01\n\r\n\x05\x04\t\x02\
    \x05\x04\x12\x04\xe8\x02\x08\x10\n\r\n\x05\x04\t\x02\x05\x05\x12\x04\xe8\
    \x02\x11\x16\n\r\n\x05\x04\t\x02\x05\x01\x12\x04\xe8\x02\x17!\n\r\n\x05\
    \x04\t\x02\x05\x03\x12\x04\xe8\x02$%\n\x0e\n\x05\x04\t\x02\x05\x08\x12\
    \x05\xe8\x02&\x9e\x01\n\x10\n\x08\x04\t\x02\x05\x08\xf4\xa2\x04\x12\x04\
    \xe8\x02'E\n\x11\n\x08\x04\t\x02\x05\x08\xf5\xa2\x04\x12\x05\xe8\x02G\
    \x9d\x01\n\r\n\x04\x04\t\x02\x06\x12\x05\xe9\x02\x08\xbd\x01\n\r\n\x05\
    \x04\t\x02\x06\x04\x12\x04\xe9\x02\x08\x10\n\r\n\x05\x04\t\x02\x06\x05\
    \x12\x04\xe9\x02\x11\x16\n\r\n\x05\x04\t\x02\x06\x01\x12\x04\xe9\x02\x17\
    !\n\r\n\x05\x04\t\x02\x06\x03\x12\x04\xe9\x02$%\n\x0e\n\x05\x04\t\x02\
    \x06\x08\x12\x05\xe9\x02&\xbc\x01\n\x10\n\x08\x04\t\x02\x06\x08\xf4\xa2\
    \x04\x12\x04\xe9\x02'D\n\x11\n\x08\x04\t\x02\x06\x08\xf5\xa2\x04\x12\x05\
    \xe9\x02F\xbb\x01\n\r\n\x04\x04\t\x02\x07\x12\x05\xea\x02\x08\xbd\x01\n\
    \r\n\x05\x04\t\x02\x07\x04\x12\x04\xea\x02\x08\x10\n\r\n\x05\x04\t\x02\
    \x07\x06\x12\x04\xea\x02\x11\x20\n\r\n\x05\x04\t\x02\x07\x01\x12\x04\xea\
    \x02!*\n\r\n\x05\x04\t\x02\x07\x03\x12\x04\xea\x02-.\n\x0e\n\x05\x04\t\
    \x02\x07\x08\x12\x05\xea\x02/\xbc\x01\n\x10\n\x08\x04\t\x02\x07\x08\xf0\
    \xa2\x04\x12\x04\xea\x020[\n\x10\n\x08\x04\t\x02\x07\x08\xf4\xa2\x04\x12\
    \x04\xea\x02]y\n\x11\n\x08\x04\t\x02\x07\x08\xf5\xa2\x04\x12\x05\xea\x02\
    {\xbb\x01\n\x0c\n\x02\x04\n\x12\x06\xed\x02\0\xfa\x02\x01\n\x0b\n\x03\
    \x04\n\x01\x12\x04\xed\x02\x08\x14\n\x0c\n\x04\x04\n\x02\0\x12\x04\xee\
    \x02\x08B\n\r\n\x05\x04\n\x02\0\x04\x12\x04\xee\x02\x08\x10\n\r\n\x05\
    \x04\n\x02\0\x05\x12\x04\xee\x02\x11\x17\n\r\n\x05\x04\n\x02\0\x01\x12\
    \x04\xee\x02\x18\x20\n\r\n\x05\x04\n\x02\0\x03\x12\x04\xee\x02#$\n\r\n\
    \x05\x04\n\x02\0\x08\x12\x04\xee\x02%A\n\x10\n\x08\x04\n\x02\0\x08\xff\
    \xa2\x04\x12\x04\xee\x02&@\n\x0e\n\x04\x04\n\x08\0\x12\x06\xf0\x02\x08\
    \xf9\x02\t\n\r\n\x05\x04\n\x08\0\x01\x12\x04\xf0\x02\x0e\x13\n\x0c\n\x04\
    \x04\n\x02\x01\x12\x04\xf1\x02\x10\x20\n\r\n\x05\x04\n\x02\x01\x05\x12\
    \x04\xf1\x02\x10\x15\n\r\n\x05\x04\n\x02\x01\x01\x12\x04\xf1\x02\x16\x1b\
    \n\r\n\x05\x04\n\x02\x01\x03\x12\x04\xf1\x02\x1e\x1f\n\x0c\n\x04\x04\n\
    \x02\x02\x12\x04\xf2\x02\x10\"\n\r\n\x05\x04\n\x02\x02\x05\x12\x04\xf2\
    \x02\x10\x16\n\r\n\x05\x04\n\x02\x02\x01\x12\x04\xf2\x02\x17\x1d\n\r\n\
    \x05\x04\n\x02\x02\x03\x12\x04\xf2\x02\x20!\n\x0c\n\x04\x04\n\x02\x03\
    \x12\x04\xf3\x02\x10\"\n\r\n\x05\x04\n\x02\x03\x05\x12\x04\xf3\x02\x10\
    \x16\n\r\n\x05\x04\n\x02\x03\x01\x12\x04\xf3\x02\x17\x1d\n\r\n\x05\x04\n\
    \x02\x03\x03\x12\x04\xf3\x02\x20!\n\x0c\n\x04\x04\n\x02\x04\x12\x04\xf4\
    \x02\x10\"\n\r\n\x05\x04\n\x02\x04\x05\x12\x04\xf4\x02\x10\x16\n\r\n\x05\
    \x04\n\x02\x04\x01\x12\x04\xf4\x02\x17\x1d\n\r\n\x05\x04\n\x02\x04\x03\
    \x12\x04\xf4\x02\x20!\n\x0c\n\x04\x04\n\x02\x05\x12\x04\xf5\x02\x10\"\n\
    \r\n\x05\x04\n\x02\x05\x05\x12\x04\xf5\x02\x10\x16\n\r\n\x05\x04\n\x02\
    \x05\x01\x12\x04\xf5\x02\x17\x1d\n\r\n\x05\x04\n\x02\x05\x03\x12\x04\xf5\
    \x02\x20!\n\x0c\n\x04\x04\n\x02\x06\x12\x04\xf6\x02\x10\"\n\r\n\x05\x04\
    \n\x02\x06\x05\x12\x04\xf6\x02\x10\x16\n\r\n\x05\x04\n\x02\x06\x01\x12\
    \x04\xf6\x02\x17\x1d\n\r\n\x05\x04\n\x02\x06\x03\x12\x04\xf6\x02\x20!\n\
    \x0c\n\x04\x04\n\x02\x07\x12\x04\xf7\x02\x10\x1e\n\r\n\x05\x04\n\x02\x07\
    \x05\x12\x04\xf7\x02\x10\x14\n\r\n\x05\x04\n\x02\x07\x01\x12\x04\xf7\x02\
    \x15\x19\n\r\n\x05\x04\n\x02\x07\x03\x12\x04\xf7\x02\x1c\x1d\n\x0c\n\x04\
    \x04\n\x02\x08\x12\x04\xf8\x02\x10\"\n\r\n\x05\x04\n\x02\x08\x05\x12\x04\
    \xf8\x02\x10\x16\n\r\n\x05\x04\n\x02\x08\x01\x12\x04\xf8\x02\x17\x1d\n\r\
    \n\x05\x04\n\x02\x08\x03\x12\x04\xf8\x02\x20!\n\x0c\n\x02\x04\x0b\x12\
    \x06\xfc\x02\0\xff\x02\x01\n\x0b\n\x03\x04\x0b\x01\x12\x04\xfc\x02\x08\
    \x1c\n\x0c\n\x04\x04\x0b\x02\0\x12\x04\xfd\x02\x080\n\r\n\x05\x04\x0b\
    \x02\0\x04\x12\x04\xfd\x02\x08\x10\n\r\n\x05\x04\x0b\x02\0\x06\x12\x04\
    \xfd\x02\x11$\n\r\n\x05\x04\x0b\x02\0\x01\x12\x04\xfd\x02%+\n\r\n\x05\
    \x04\x0b\x02\0\x03\x12\x04\xfd\x02./\n\x0c\n\x04\x04\x0b\x02\x01\x12\x04\
    \xfe\x02\x08T\n\r\n\x05\x04\x0b\x02\x01\x04\x12\x04\xfe\x02\x08\x10\n\r\
    \n\x05\x04\x0b\x02\x01\x05\x12\x04\xfe\x02\x11\x17\n\r\n\x05\x04\x0b\x02\
    \x01\x01\x12\x04\xfe\x02\x18\x1c\n\r\n\x05\x04\x0b\x02\x01\x03\x12\x04\
    \xfe\x02\x1f\x20\n\r\n\x05\x04\x0b\x02\x01\x08\x12\x04\xfe\x02!S\n\x10\n\
    \x08\x04\x0b\x02\x01\x08\xf2\xa2\x04\x12\x04\xfe\x02\"4\n\x10\n\x08\x04\
    \x0b\x02\x01\x08\xf4\xa2\x04\x12\x04\xfe\x026R\n\x0c\n\x02\x04\x0c\x12\
    \x06\x81\x03\0\x8f\x03\x01\n\x0b\n\x03\x04\x0c\x01\x12\x04\x81\x03\x08\
    \x1b\n\x0c\n\x04\x04\x0c\x02\0\x12\x04\x82\x03\x080\n\r\n\x05\x04\x0c\
    \x02\0\x04\x12\x04\x82\x03\x08\x10\n\r\n\x05\x04\x0c\x02\0\x06\x12\x04\
    \x82\x03\x11$\n\r\n\x05\x04\x0c\x02\0\x01\x12\x04\x82\x03%+\n\r\n\x05\
    \x04\x0c\x02\0\x03\x12\x04\x82\x03./\n\r\n\x04\x04\x0c\x02\x01\x12\x05\
    \x83\x03\x08\x82\x01\n\r\n\x05\x04\x0c\x02\x01\x04\x12\x04\x83\x03\x08\
    \x10\n\r\n\x05\x04\x0c\x02\x01\x05\x12\x04\x83\x03\x11\x17\n\r\n\x05\x04\
    \x0c\x02\x01\x01\x12\x04\x83\x03\x18%\n\r\n\x05\x04\x0c\x02\x01\x03\x12\
    \x04\x83\x03()\n\x0e\n\x05\x04\x0c\x02\x01\x08\x12\x05\x83\x03*\x81\x01\
    \n\x10\n\x08\x04\x0c\x02\x01\x08\xf2\xa2\x04\x12\x04\x83\x03+=\n\x10\n\
    \x08\x04\x0c\x02\x01\x08\xf4\xa2\x04\x12\x04\x83\x03?[\n\x11\n\x08\x04\
    \x0c\x02\x01\x08\xf5\xa2\x04\x12\x05\x83\x03]\x80\x01\n\x0c\n\x04\x04\
    \x0c\x02\x02\x12\x04\x84\x03\x08k\n\r\n\x05\x04\x0c\x02\x02\x04\x12\x04\
    \x84\x03\x08\x10\n\r\n\x05\x04\x0c\x02\x02\x05\x12\x04\x84\x03\x11\x16\n\
    \r\n\x05\x04\x0c\x02\x02\x01\x12\x04\x84\x03\x17\x1c\n\r\n\x05\x04\x0c\
    \x02\x02\x03\x12\x04\x84\x03\x1f\x20\n\r\n\x05\x04\x0c\x02\x02\x08\x12\
    \x04\x84\x03!j\n\x10\n\x08\x04\x0c\x02\x02\x08\xf4\xa2\x04\x12\x04\x84\
    \x03\">\n\x10\n\x08\x04\x0c\x02\x02\x08\xf5\xa2\x04\x12\x04\x84\x03@i\n\
    \x0c\n\x04\x04\x0c\x02\x03\x12\x04\x85\x03\x08k\n\r\n\x05\x04\x0c\x02\
    \x03\x04\x12\x04\x85\x03\x08\x10\n\r\n\x05\x04\x0c\x02\x03\x05\x12\x04\
    \x85\x03\x11\x16\n\r\n\x05\x04\x0c\x02\x03\x01\x12\x04\x85\x03\x17\x1c\n\
    \r\n\x05\x04\x0c\x02\x03\x03\x12\x04\x85\x03\x1f\x20\n\r\n\x05\x04\x0c\
    \x02\x03\x08\x12\x04\x85\x03!j\n\x10\n\x08\x04\x0c\x02\x03\x08\xf4\xa2\
    \x04\x12\x04\x85\x03\">\n\x10\n\x08\x04\x0c\x02\x03\x08\xf5\xa2\x04\x12\
    \x04\x85\x03@i\n\r\n\x04\x04\x0c\x02\x04\x12\x05\x86\x03\x08\x9d\x01\n\r\
    \n\x05\x04\x0c\x02\x04\x04\x12\x04\x86\x03\x08\x10\n\r\n\x05\x04\x0c\x02\
    \x04\x06\x12\x04\x86\x03\x11+\n\r\n\x05\x04\x0c\x02\x04\x01\x12\x04\x86\
    \x03,5\n\r\n\x05\x04\x0c\x02\x04\x03\x12\x04\x86\x0389\n\x0e\n\x05\x04\
    \x0c\x02\x04\x08\x12\x05\x86\x03:\x9c\x01\n\x10\n\x08\x04\x0c\x02\x04\
    \x08\xf4\xa2\x04\x12\x04\x86\x03;X\n\x11\n\x08\x04\x0c\x02\x04\x08\xf5\
    \xa2\x04\x12\x05\x86\x03Z\x9b\x01\n\r\n\x04\x04\x0c\x02\x05\x12\x05\x87\
    \x03\x08\xb7\x01\n\r\n\x05\x04\x0c\x02\x05\x04\x12\x04\x87\x03\x08\x10\n\
    \r\n\x05\x04\x0c\x02\x05\x06\x12\x04\x87\x03\x11\x20\n\r\n\x05\x04\x0c\
    \x02\x05\x01\x12\x04\x87\x03!.\n\r\n\x05\x04\x0c\x02\x05\x03\x12\x04\x87\
    \x0313\n\x0e\n\x05\x04\x0c\x02\x05\x08\x12\x05\x87\x034\xb6\x01\n\x10\n\
    \x08\x04\x0c\x02\x05\x08\xf0\xa2\x04\x12\x04\x87\x035]\n\x10\n\x08\x04\
    \x0c\x02\x05\x08\xf4\xa2\x04\x12\x04\x87\x03_x\n\x11\n\x08\x04\x0c\x02\
    \x05\x08\xf5\xa2\x04\x12\x05\x87\x03z\xb5\x01\n\r\n\x04\x04\x0c\x02\x06\
    \x12\x05\x88\x03\x08\xb6\x01\n\r\n\x05\x04\x0c\x02\x06\x04\x12\x04\x88\
    \x03\x08\x10\n\r\n\x05\x04\x0c\x02\x06\x06\x12\x04\x88\x03\x11\x20\n\r\n\
    \x05\x04\x0c\x02\x06\x01\x12\x04\x88\x03!.\n\r\n\x05\x04\x0c\x02\x06\x03\
    \x12\x04\x88\x0313\n\x0e\n\x05\x04\x0c\x02\x06\x08\x12\x05\x88\x034\xb5\
    \x01\n\x10\n\x08\x04\x0c\x02\x06\x08\xf0\xa2\x04\x12\x04\x88\x035R\n\x10\
    \n\x08\x04\x0c\x02\x06\x08\xf4\xa2\x04\x12\x04\x88\x03Tu\n\x11\n\x08\x04\
    \x0c\x02\x06\x08\xf5\xa2\x04\x12\x05\x88\x03w\xa3\x01\n\x12\n\x08\x04\
    \x0c\x02\x06\x08\xf7\xa2\x04\x12\x06\x88\x03\xa5\x01\xb4\x01\n\r\n\x04\
    \x04\x0c\x02\x07\x12\x05\x89\x03\x08\x92\x01\n\r\n\x05\x04\x0c\x02\x07\
    \x04\x12\x04\x89\x03\x08\x10\n\r\n\x05\x04\x0c\x02\x07\x05\x12\x04\x89\
    \x03\x11\x17\n\r\n\x05\x04\x0c\x02\x07\x01\x12\x04\x89\x03\x18,\n\r\n\
    \x05\x04\x0c\x02\x07\x03\x12\x04\x89\x03/1\n\x0e\n\x05\x04\x0c\x02\x07\
    \x08\x12\x05\x89\x032\x91\x01\n\x10\n\x08\x04\x0c\x02\x07\x08\xf4\xa2\
    \x04\x12\x04\x89\x033Z\n\x11\n\x08\x04\x0c\x02\x07\x08\xf5\xa2\x04\x12\
    \x05\x89\x03\\\x90\x01\n\r\n\x04\x04\x0c\x02\x08\x12\x05\x8a\x03\x08\x86\
    \x01\n\r\n\x05\x04\x0c\x02\x08\x04\x12\x04\x8a\x03\x08\x10\n\r\n\x05\x04\
    \x0c\x02\x08\x05\x12\x04\x8a\x03\x11\x17\n\r\n\x05\x04\x0c\x02\x08\x01\
    \x12\x04\x8a\x03\x18(\n\r\n\x05\x04\x0c\x02\x08\x03\x12\x04\x8a\x03+-\n\
    \x0e\n\x05\x04\x0c\x02\x08\x08\x12\x05\x8a\x03.\x85\x01\n\x10\n\x08\x04\
    \x0c\x02\x08\x08\xf4\xa2\x04\x12\x04\x8a\x03/M\n\x11\n\x08\x04\x0c\x02\
    \x08\x08\xf5\xa2\x04\x12\x05\x8a\x03O\x84\x01\n\r\n\x04\x04\x0c\x02\t\
    \x12\x05\x8b\x03\x08\x93\x01\n\r\n\x05\x04\x0c\x02\t\x04\x12\x04\x8b\x03\
    \x08\x10\n\r\n\x05\x04\x0c\x02\t\x05\x12\x04\x8b\x03\x11\x17\n\r\n\x05\
    \x04\x0c\x02\t\x01\x12\x04\x8b\x03\x18,\n\r\n\x05\x04\x0c\x02\t\x03\x12\
    \x04\x8b\x03/1\n\x0e\n\x05\x04\x0c\x02\t\x08\x12\x05\x8b\x032\x92\x01\n\
    \x10\n\x08\x04\x0c\x02\t\x08\xf4\xa2\x04\x12\x04\x8b\x033U\n\x11\n\x08\
    \x04\x0c\x02\t\x08\xf5\xa2\x04\x12\x05\x8b\x03W\x91\x01\n\r\n\x04\x04\
    \x0c\x02\n\x12\x05\x8c\x03\x08\xbb\x01\n\r\n\x05\x04\x0c\x02\n\x04\x12\
    \x04\x8c\x03\x08\x10\n\r\n\x05\x04\x0c\x02\n\x06\x12\x04\x8c\x03\x11!\n\
    \r\n\x05\x04\x0c\x02\n\x01\x12\x04\x8c\x03\"-\n\r\n\x05\x04\x0c\x02\n\
    \x03\x12\x04\x8c\x0302\n\x0e\n\x05\x04\x0c\x02\n\x08\x12\x05\x8c\x033\
    \xba\x01\n\r\n\x05\x04\x0c\x02\n\x07\x12\x04\x8c\x03>N\n\x10\n\x08\x04\
    \x0c\x02\n\x08\xf4\xa2\x04\x12\x04\x8c\x03Pn\n\x11\n\x08\x04\x0c\x02\n\
    \x08\xf5\xa2\x04\x12\x05\x8c\x03p\xb9\x01\n\r\n\x04\x04\x0c\x02\x0b\x12\
    \x05\x8d\x03\x08\xad\x01\n\r\n\x05\x04\x0c\x02\x0b\x04\x12\x04\x8d\x03\
    \x08\x10\n\r\n\x05\x04\x0c\x02\x0b\x06\x12\x04\x8d\x03\x11\x20\n\r\n\x05\
    \x04\x0c\x02\x0b\x01\x12\x04\x8d\x03!*\n\r\n\x05\x04\x0c\x02\x0b\x03\x12\
    \x04\x8d\x03-/\n\x0e\n\x05\x04\x0c\x02\x0b\x08\x12\x05\x8d\x030\xac\x01\
    \n\x10\n\x08\x04\x0c\x02\x0b\x08\xf0\xa2\x04\x12\x04\x8d\x031\\\n\x10\n\
    \x08\x04\x0c\x02\x0b\x08\xf4\xa2\x04\x12\x04\x8d\x03^z\n\x11\n\x08\x04\
    \x0c\x02\x0b\x08\xf5\xa2\x04\x12\x05\x8d\x03|\xab\x01\n\r\n\x04\x04\x0c\
    \x02\x0c\x12\x05\x8e\x03\x08\x92\x01\n\r\n\x05\x04\x0c\x02\x0c\x04\x12\
    \x04\x8e\x03\x08\x10\n\r\n\x05\x04\x0c\x02\x0c\x05\x12\x04\x8e\x03\x11\
    \x17\n\r\n\x05\x04\x0c\x02\x0c\x01\x12\x04\x8e\x03\x18'\n\r\n\x05\x04\
    \x0c\x02\x0c\x03\x12\x04\x8e\x03*,\n\x0e\n\x05\x04\x0c\x02\x0c\x08\x12\
    \x05\x8e\x03-\x91\x01\n\r\n\x05\x04\x0c\x02\x0c\x07\x12\x04\x8e\x0389\n\
    \x10\n\x08\x04\x0c\x02\x0c\x08\xf4\xa2\x04\x12\x04\x8e\x03;]\n\x11\n\x08\
    \x04\x0c\x02\x0c\x08\xf5\xa2\x04\x12\x05\x8e\x03_\x90\x01\n\x0c\n\x02\
    \x04\r\x12\x06\x91\x03\0\x93\x03\x01\n\x0b\n\x03\x04\r\x01\x12\x04\x91\
    \x03\x08\x1e\n\x0c\n\x04\x04\r\x02\0\x12\x04\x92\x03\x080\n\r\n\x05\x04\
    \r\x02\0\x04\x12\x04\x92\x03\x08\x10\n\r\n\x05\x04\r\x02\0\x06\x12\x04\
    \x92\x03\x11$\n\r\n\x05\x04\r\x02\0\x01\x12\x04\x92\x03%+\n\r\n\x05\x04\
    \r\x02\0\x03\x12\x04\x92\x03./\n\x0c\n\x02\x04\x0e\x12\x06\x95\x03\0\xa2\
    \x03\x01\n\x0b\n\x03\x04\x0e\x01\x12\x04\x95\x03\x08+\n\x0c\n\x04\x04\
    \x0e\x02\0\x12\x04\x96\x03\x08P\n\r\n\x05\x04\x0e\x02\0\x04\x12\x04\x96\
    \x03\x08\x10\n\r\n\x05\x04\x0e\x02\0\x06\x12\x04\x96\x03\x11\x1e\n\r\n\
    \x05\x04\x0e\x02\0\x01\x12\x04\x96\x03\x1f&\n\r\n\x05\x04\x0e\x02\0\x03\
    \x12\x04\x96\x03)*\n\r\n\x05\x04\x0e\x02\0\x08\x12\x04\x96\x03+O\n\x10\n\
    \x08\x04\x0e\x02\0\x08\xfe\xa2\x04\x12\x04\x96\x03,N\n\x0c\n\x04\x04\x0e\
    \x02\x01\x12\x04\x97\x03\x08T\n\r\n\x05\x04\x0e\x02\x01\x04\x12\x04\x97\
    \x03\x08\x10\n\r\n\x05\x04\x0e\x02\x01\x06\x12\x04\x97\x03\x11\x1e\n\r\n\
    \x05\x04\x0e\x02\x01\x01\x12\x04\x97\x03\x1f*\n\r\n\x05\x04\x0e\x02\x01\
    \x03\x12\x04\x97\x03-.\n\r\n\x05\x04\x0e\x02\x01\x08\x12\x04\x97\x03/S\n\
    \x10\n\x08\x04\x0e\x02\x01\x08\xfe\xa2\x04\x12\x04\x97\x030R\n\x0c\n\x04\
    \x04\x0e\x02\x02\x12\x04\x98\x03\x08U\n\r\n\x05\x04\x0e\x02\x02\x04\x12\
    \x04\x98\x03\x08\x10\n\r\n\x05\x04\x0e\x02\x02\x06\x12\x04\x98\x03\x11\
    \x1e\n\r\n\x05\x04\x0e\x02\x02\x01\x12\x04\x98\x03\x1f+\n\r\n\x05\x04\
    \x0e\x02\x02\x03\x12\x04\x98\x03./\n\r\n\x05\x04\x0e\x02\x02\x08\x12\x04\
    \x98\x030T\n\x10\n\x08\x04\x0e\x02\x02\x08\xfe\xa2\x04\x12\x04\x98\x031S\
    \n\x0c\n\x04\x04\x0e\x02\x03\x12\x04\x99\x03\x08U\n\r\n\x05\x04\x0e\x02\
    \x03\x04\x12\x04\x99\x03\x08\x10\n\r\n\x05\x04\x0e\x02\x03\x06\x12\x04\
    \x99\x03\x11\x1e\n\r\n\x05\x04\x0e\x02\x03\x01\x12\x04\x99\x03\x1f+\n\r\
    \n\x05\x04\x0e\x02\x03\x03\x12\x04\x99\x03./\n\r\n\x05\x04\x0e\x02\x03\
    \x08\x12\x04\x99\x030T\n\x10\n\x08\x04\x0e\x02\x03\x08\xfe\xa2\x04\x12\
    \x04\x99\x031S\n\x0c\n\x04\x04\x0e\x02\x04\x12\x04\x9a\x03\x08V\n\r\n\
    \x05\x04\x0e\x02\x04\x04\x12\x04\x9a\x03\x08\x10\n\r\n\x05\x04\x0e\x02\
    \x04\x06\x12\x04\x9a\x03\x11\x1e\n\r\n\x05\x04\x0e\x02\x04\x01\x12\x04\
    \x9a\x03\x1f,\n\r\n\x05\x04\x0e\x02\x04\x03\x12\x04\x9a\x03/0\n\r\n\x05\
    \x04\x0e\x02\x04\x08\x12\x04\x9a\x031U\n\x10\n\x08\x04\x0e\x02\x04\x08\
    \xfe\xa2\x04\x12\x04\x9a\x032T\n\x0c\n\x04\x04\x0e\x02\x05\x12\x04\x9b\
    \x03\x08U\n\r\n\x05\x04\x0e\x02\x05\x04\x12\x04\x9b\x03\x08\x10\n\r\n\
    \x05\x04\x0e\x02\x05\x06\x12\x04\x9b\x03\x11\x1e\n\r\n\x05\x04\x0e\x02\
    \x05\x01\x12\x04\x9b\x03\x1f+\n\r\n\x05\x04\x0e\x02\x05\x03\x12\x04\x9b\
    \x03./\n\r\n\x05\x04\x0e\x02\x05\x08\x12\x04\x9b\x030T\n\x10\n\x08\x04\
    \x0e\x02\x05\x08\xfe\xa2\x04\x12\x04\x9b\x031S\n\x0c\n\x04\x04\x0e\x02\
    \x06\x12\x04\x9c\x03\x08Q\n\r\n\x05\x04\x0e\x02\x06\x04\x12\x04\x9c\x03\
    \x08\x10\n\r\n\x05\x04\x0e\x02\x06\x06\x12\x04\x9c\x03\x11\x1e\n\r\n\x05\
    \x04\x0e\x02\x06\x01\x12\x04\x9c\x03\x1f'\n\r\n\x05\x04\x0e\x02\x06\x03\
    \x12\x04\x9c\x03*+\n\r\n\x05\x04\x0e\x02\x06\x08\x12\x04\x9c\x03,P\n\x10\
    \n\x08\x04\x0e\x02\x06\x08\xfe\xa2\x04\x12\x04\x9c\x03-O\n\x0c\n\x04\x04\
    \x0e\x02\x07\x12\x04\x9d\x03\x08T\n\r\n\x05\x04\x0e\x02\x07\x04\x12\x04\
    \x9d\x03\x08\x10\n\r\n\x05\x04\x0e\x02\x07\x06\x12\x04\x9d\x03\x11\x1e\n\
    \r\n\x05\x04\x0e\x02\x07\x01\x12\x04\x9d\x03\x1f*\n\r\n\x05\x04\x0e\x02\
    \x07\x03\x12\x04\x9d\x03-.\n\r\n\x05\x04\x0e\x02\x07\x08\x12\x04\x9d\x03\
    /S\n\x10\n\x08\x04\x0e\x02\x07\x08\xfe\xa2\x04\x12\x04\x9d\x030R\n\x0c\n\
    \x04\x04\x0e\x02\x08\x12\x04\x9e\x03\x08T\n\r\n\x05\x04\x0e\x02\x08\x04\
    \x12\x04\x9e\x03\x08\x10\n\r\n\x05\x04\x0e\x02\x08\x06\x12\x04\x9e\x03\
    \x11\x1e\n\r\n\x05\x04\x0e\x02\x08\x01\x12\x04\x9e\x03\x1f*\n\r\n\x05\
    \x04\x0e\x02\x08\x03\x12\x04\x9e\x03-.\n\r\n\x05\x04\x0e\x02\x08\x08\x12\
    \x04\x9e\x03/S\n\x10\n\x08\x04\x0e\x02\x08\x08\xfe\xa2\x04\x12\x04\x9e\
    \x030R\n\x0c\n\x04\x04\x0e\x02\t\x12\x04\x9f\x03\x08R\n\r\n\x05\x04\x0e\
    \x02\t\x04\x12\x04\x9f\x03\x08\x10\n\r\n\x05\x04\x0e\x02\t\x06\x12\x04\
    \x9f\x03\x11\x1e\n\r\n\x05\x04\x0e\x02\t\x01\x12\x04\x9f\x03\x1f'\n\r\n\
    \x05\x04\x0e\x02\t\x03\x12\x04\x9f\x03*,\n\r\n\x05\x04\x0e\x02\t\x08\x12\
    \x04\x9f\x03-Q\n\x10\n\x08\x04\x0e\x02\t\x08\xfe\xa2\x04\x12\x04\x9f\x03\
    .P\n\x0c\n\x04\x04\x0e\x02\n\x12\x04\xa0\x03\x08P\n\r\n\x05\x04\x0e\x02\
    \n\x04\x12\x04\xa0\x03\x08\x10\n\r\n\x05\x04\x0e\x02\n\x06\x12\x04\xa0\
    \x03\x11\x1e\n\r\n\x05\x04\x0e\x02\n\x01\x12\x04\xa0\x03\x1f%\n\r\n\x05\
    \x04\x0e\x02\n\x03\x12\x04\xa0\x03(*\n\r\n\x05\x04\x0e\x02\n\x08\x12\x04\
    \xa0\x03+O\n\x10\n\x08\x04\x0e\x02\n\x08\xfe\xa2\x04\x12\x04\xa0\x03,N\n\
    \x0c\n\x04\x04\x0e\x02\x0b\x12\x04\xa1\x03\x08P\n\r\n\x05\x04\x0e\x02\
    \x0b\x04\x12\x04\xa1\x03\x08\x10\n\r\n\x05\x04\x0e\x02\x0b\x06\x12\x04\
    \xa1\x03\x11\x1e\n\r\n\x05\x04\x0e\x02\x0b\x01\x12\x04\xa1\x03\x1f%\n\r\
    \n\x05\x04\x0e\x02\x0b\x03\x12\x04\xa1\x03(*\n\r\n\x05\x04\x0e\x02\x0b\
    \x08\x12\x04\xa1\x03+O\n\x10\n\x08\x04\x0e\x02\x0b\x08\xfe\xa2\x04\x12\
    \x04\xa1\x03,N\n\x0c\n\x02\x04\x0f\x12\x06\xa4\x03\0\xaf\x03\x01\n\x0b\n\
    \x03\x04\x0f\x01\x12\x04\xa4\x03\x08+\n\x0c\n\x04\x04\x0f\x02\0\x12\x04\
    \xa5\x03\x08U\n\r\n\x05\x04\x0f\x02\0\x04\x12\x04\xa5\x03\x08\x10\n\r\n\
    \x05\x04\x0f\x02\0\x06\x12\x04\xa5\x03\x11\x1e\n\r\n\x05\x04\x0f\x02\0\
    \x01\x12\x04\xa5\x03\x1f+\n\r\n\x05\x04\x0f\x02\0\x03\x12\x04\xa5\x03./\
    \n\r\n\x05\x04\x0f\x02\0\x08\x12\x04\xa5\x030T\n\x10\n\x08\x04\x0f\x02\0\
    \x08\xfe\xa2\x04\x12\x04\xa5\x031S\n\x0c\n\x04\x04\x0f\x02\x01\x12\x04\
    \xa6\x03\x08V\n\r\n\x05\x04\x0f\x02\x01\x04\x12\x04\xa6\x03\x08\x10\n\r\
    \n\x05\x04\x0f\x02\x01\x06\x12\x04\xa6\x03\x11\x1e\n\r\n\x05\x04\x0f\x02\
    \x01\x01\x12\x04\xa6\x03\x1f,\n\r\n\x05\x04\x0f\x02\x01\x03\x12\x04\xa6\
    \x03/0\n\r\n\x05\x04\x0f\x02\x01\x08\x12\x04\xa6\x031U\n\x10\n\x08\x04\
    \x0f\x02\x01\x08\xfe\xa2\x04\x12\x04\xa6\x032T\n\x0c\n\x04\x04\x0f\x02\
    \x02\x12\x04\xa7\x03\x08U\n\r\n\x05\x04\x0f\x02\x02\x04\x12\x04\xa7\x03\
    \x08\x10\n\r\n\x05\x04\x0f\x02\x02\x06\x12\x04\xa7\x03\x11\x1e\n\r\n\x05\
    \x04\x0f\x02\x02\x01\x12\x04\xa7\x03\x1f+\n\r\n\x05\x04\x0f\x02\x02\x03\
    \x12\x04\xa7\x03./\n\r\n\x05\x04\x0f\x02\x02\x08\x12\x04\xa7\x030T\n\x10\
    \n\x08\x04\x0f\x02\x02\x08\xfe\xa2\x04\x12\x04\xa7\x031S\n\x0c\n\x04\x04\
    \x0f\x02\x03\x12\x04\xa8\x03\x08Q\n\r\n\x05\x04\x0f\x02\x03\x04\x12\x04\
    \xa8\x03\x08\x10\n\r\n\x05\x04\x0f\x02\x03\x06\x12\x04\xa8\x03\x11\x1e\n\
    \r\n\x05\x04\x0f\x02\x03\x01\x12\x04\xa8\x03\x1f'\n\r\n\x05\x04\x0f\x02\
    \x03\x03\x12\x04\xa8\x03*+\n\r\n\x05\x04\x0f\x02\x03\x08\x12\x04\xa8\x03\
    ,P\n\x10\n\x08\x04\x0f\x02\x03\x08\xfe\xa2\x04\x12\x04\xa8\x03-O\n\x0c\n\
    \x04\x04\x0f\x02\x04\x12\x04\xa9\x03\x08T\n\r\n\x05\x04\x0f\x02\x04\x04\
    \x12\x04\xa9\x03\x08\x10\n\r\n\x05\x04\x0f\x02\x04\x06\x12\x04\xa9\x03\
    \x11\x1e\n\r\n\x05\x04\x0f\x02\x04\x01\x12\x04\xa9\x03\x1f*\n\r\n\x05\
    \x04\x0f\x02\x04\x03\x12\x04\xa9\x03-.\n\r\n\x05\x04\x0f\x02\x04\x08\x12\
    \x04\xa9\x03/S\n\x10\n\x08\x04\x0f\x02\x04\x08\xfe\xa2\x04\x12\x04\xa9\
    \x030R\n\x0c\n\x04\x04\x0f\x02\x05\x12\x04\xaa\x03\x08T\n\r\n\x05\x04\
    \x0f\x02\x05\x04\x12\x04\xaa\x03\x08\x10\n\r\n\x05\x04\x0f\x02\x05\x06\
    \x12\x04\xaa\x03\x11\x1e\n\r\n\x05\x04\x0f\x02\x05\x01\x12\x04\xaa\x03\
    \x1f*\n\r\n\x05\x04\x0f\x02\x05\x03\x12\x04\xaa\x03-.\n\r\n\x05\x04\x0f\
    \x02\x05\x08\x12\x04\xaa\x03/S\n\x10\n\x08\x04\x0f\x02\x05\x08\xfe\xa2\
    \x04\x12\x04\xaa\x030R\n\x0c\n\x04\x04\x0f\x02\x06\x12\x04\xab\x03\x08Q\
    \n\r\n\x05\x04\x0f\x02\x06\x04\x12\x04\xab\x03\x08\x10\n\r\n\x05\x04\x0f\
    \x02\x06\x06\x12\x04\xab\x03\x11\x1e\n\r\n\x05\x04\x0f\x02\x06\x01\x12\
    \x04\xab\x03\x1f'\n\r\n\x05\x04\x0f\x02\x06\x03\x12\x04\xab\x03*+\n\r\n\
    \x05\x04\x0f\x02\x06\x08\x12\x04\xab\x03,P\n\x10\n\x08\x04\x0f\x02\x06\
    \x08\xfe\xa2\x04\x12\x04\xab\x03-O\n\x0c\n\x04\x04\x0f\x02\x07\x12\x04\
    \xac\x03\x08O\n\r\n\x05\x04\x0f\x02\x07\x04\x12\x04\xac\x03\x08\x10\n\r\
    \n\x05\x04\x0f\x02\x07\x06\x12\x04\xac\x03\x11\x1e\n\r\n\x05\x04\x0f\x02\
    \x07\x01\x12\x04\xac\x03\x1f%\n\r\n\x05\x04\x0f\x02\x07\x03\x12\x04\xac\
    \x03()\n\r\n\x05\x04\x0f\x02\x07\x08\x12\x04\xac\x03*N\n\x10\n\x08\x04\
    \x0f\x02\x07\x08\xfe\xa2\x04\x12\x04\xac\x03+M\n\x0c\n\x04\x04\x0f\x02\
    \x08\x12\x04\xad\x03\x08O\n\r\n\x05\x04\x0f\x02\x08\x04\x12\x04\xad\x03\
    \x08\x10\n\r\n\x05\x04\x0f\x02\x08\x06\x12\x04\xad\x03\x11\x1e\n\r\n\x05\
    \x04\x0f\x02\x08\x01\x12\x04\xad\x03\x1f%\n\r\n\x05\x04\x0f\x02\x08\x03\
    \x12\x04\xad\x03()\n\r\n\x05\x04\x0f\x02\x08\x08\x12\x04\xad\x03*N\n\x10\
    \n\x08\x04\x0f\x02\x08\x08\xfe\xa2\x04\x12\x04\xad\x03+M\n\x0c\n\x04\x04\
    \x0f\x02\t\x12\x04\xae\x03\x08A\n\r\n\x05\x04\x0f\x02\t\x04\x12\x04\xae\
    \x03\x08\x10\n\r\n\x05\x04\x0f\x02\t\x06\x12\x04\xae\x03\x11,\n\r\n\x05\
    \x04\x0f\x02\t\x01\x12\x04\xae\x03-;\n\r\n\x05\x04\x0f\x02\t\x03\x12\x04\
    \xae\x03>@\n\x0c\n\x02\x04\x10\x12\x06\xb1\x03\0\xb4\x03\x01\n\x0b\n\x03\
    \x04\x10\x01\x12\x04\xb1\x03\x08*\n\x0c\n\x04\x04\x10\x02\0\x12\x04\xb2\
    \x03\x08O\n\r\n\x05\x04\x10\x02\0\x04\x12\x04\xb2\x03\x08\x10\n\r\n\x05\
    \x04\x10\x02\0\x06\x12\x04\xb2\x03\x11\x1e\n\r\n\x05\x04\x10\x02\0\x01\
    \x12\x04\xb2\x03\x1f%\n\r\n\x05\x04\x10\x02\0\x03\x12\x04\xb2\x03()\n\r\
    \n\x05\x04\x10\x02\0\x08\x12\x04\xb2\x03*N\n\x10\n\x08\x04\x10\x02\0\x08\
    \xfe\xa2\x04\x12\x04\xb2\x03+M\n\x0c\n\x04\x04\x10\x02\x01\x12\x04\xb3\
    \x03\x08a\n\r\n\x05\x04\x10\x02\x01\x04\x12\x04\xb3\x03\x08\x10\n\r\n\
    \x05\x04\x10\x02\x01\x06\x12\x04\xb3\x03\x11\x1e\n\r\n\x05\x04\x10\x02\
    \x01\x01\x12\x04\xb3\x03\x1f%\n\r\n\x05\x04\x10\x02\x01\x03\x12\x04\xb3\
    \x03()\n\r\n\x05\x04\x10\x02\x01\x08\x12\x04\xb3\x03*`\n\x10\n\x08\x04\
    \x10\x02\x01\x08\xf7\xa2\x04\x12\x04\xb3\x03+;\n\x10\n\x08\x04\x10\x02\
    \x01\x08\xfe\xa2\x04\x12\x04\xb3\x03=_\n\x0c\n\x02\x04\x11\x12\x06\xb6\
    \x03\0\xba\x03\x01\n\x0b\n\x03\x04\x11\x01\x12\x04\xb6\x03\x08&\n\r\n\
    \x04\x04\x11\x02\0\x12\x05\xb7\x03\x08\x8f\x01\n\r\n\x05\x04\x11\x02\0\
    \x04\x12\x04\xb7\x03\x08\x10\n\r\n\x05\x04\x11\x02\0\x06\x12\x04\xb7\x03\
    \x11\x1e\n\r\n\x05\x04\x11\x02\0\x01\x12\x04\xb7\x03\x1f#\n\r\n\x05\x04\
    \x11\x02\0\x03\x12\x04\xb7\x03&'\n\x0e\n\x05\x04\x11\x02\0\x08\x12\x05\
    \xb7\x03(\x8e\x01\n\x10\n\x08\x04\x11\x02\0\x08\xf5\xa2\x04\x12\x04\xb7\
    \x03)i\n\x11\n\x08\x04\x11\x02\0\x08\xfe\xa2\x04\x12\x05\xb7\x03k\x8d\
    \x01\n\r\n\x04\x04\x11\x02\x01\x12\x05\xb8\x03\x08\x8b\x01\n\r\n\x05\x04\
    \x11\x02\x01\x04\x12\x04\xb8\x03\x08\x10\n\r\n\x05\x04\x11\x02\x01\x06\
    \x12\x04\xb8\x03\x11\x1e\n\r\n\x05\x04\x11\x02\x01\x01\x12\x04\xb8\x03\
    \x1f%\n\r\n\x05\x04\x11\x02\x01\x03\x12\x04\xb8\x03()\n\x0e\n\x05\x04\
    \x11\x02\x01\x08\x12\x05\xb8\x03*\x8a\x01\n\x10\n\x08\x04\x11\x02\x01\
    \x08\xf5\xa2\x04\x12\x04\xb8\x03+e\n\x11\n\x08\x04\x11\x02\x01\x08\xfe\
    \xa2\x04\x12\x05\xb8\x03g\x89\x01\n\r\n\x04\x04\x11\x02\x02\x12\x05\xb9\
    \x03\x08\xcd\x01\n\r\n\x05\x04\x11\x02\x02\x04\x12\x04\xb9\x03\x08\x10\n\
    \r\n\x05\x04\x11\x02\x02\x06\x12\x04\xb9\x03\x11\x1e\n\r\n\x05\x04\x11\
    \x02\x02\x01\x12\x04\xb9\x03\x1f#\n\r\n\x05\x04\x11\x02\x02\x03\x12\x04\
    \xb9\x03&'\n\x0e\n\x05\x04\x11\x02\x02\x08\x12\x05\xb9\x03(\xcc\x01\n\
    \x11\n\x08\x04\x11\x02\x02\x08\xf5\xa2\x04\x12\x05\xb9\x03)\xa7\x01\n\
    \x12\n\x08\x04\x11\x02\x02\x08\xfe\xa2\x04\x12\x06\xb9\x03\xa9\x01\xcb\
    \x01\n\x0c\n\x02\x04\x12\x12\x06\xbc\x03\0\xc5\x03\x01\n\x0b\n\x03\x04\
    \x12\x01\x12\x04\xbc\x03\x08+\n\x0c\n\x04\x04\x12\x02\0\x12\x04\xbd\x03\
    \x08=\n\r\n\x05\x04\x12\x02\0\x04\x12\x04\xbd\x03\x08\x10\n\r\n\x05\x04\
    \x12\x02\0\x06\x12\x04\xbd\x03\x110\n\r\n\x05\x04\x12\x02\0\x01\x12\x04\
    \xbd\x0318\n\r\n\x05\x04\x12\x02\0\x03\x12\x04\xbd\x03;<\n\x0c\n\x04\x04\
    \x12\x02\x01\x12\x04\xbe\x03\x08P\n\r\n\x05\x04\x12\x02\x01\x04\x12\x04\
    \xbe\x03\x08\x10\n\r\n\x05\x04\x12\x02\x01\x06\x12\x04\xbe\x03\x11\x1e\n\
    \r\n\x05\x04\x12\x02\x01\x01\x12\x04\xbe\x03\x1f&\n\r\n\x05\x04\x12\x02\
    \x01\x03\x12\x04\xbe\x03)*\n\r\n\x05\x04\x12\x02\x01\x08\x12\x04\xbe\x03\
    +O\n\x10\n\x08\x04\x12\x02\x01\x08\xfe\xa2\x04\x12\x04\xbe\x03,N\n\x0c\n\
    \x04\x04\x12\x02\x02\x12\x04\xbf\x03\x08P\n\r\n\x05\x04\x12\x02\x02\x04\
    \x12\x04\xbf\x03\x08\x10\n\r\n\x05\x04\x12\x02\x02\x06\x12\x04\xbf\x03\
    \x11\x1e\n\r\n\x05\x04\x12\x02\x02\x01\x12\x04\xbf\x03\x1f&\n\r\n\x05\
    \x04\x12\x02\x02\x03\x12\x04\xbf\x03)*\n\r\n\x05\x04\x12\x02\x02\x08\x12\
    \x04\xbf\x03+O\n\x10\n\x08\x04\x12\x02\x02\x08\xfe\xa2\x04\x12\x04\xbf\
    \x03,N\n\x0c\n\x04\x04\x12\x02\x03\x12\x04\xc0\x03\x08P\n\r\n\x05\x04\
    \x12\x02\x03\x04\x12\x04\xc0\x03\x08\x10\n\r\n\x05\x04\x12\x02\x03\x06\
    \x12\x04\xc0\x03\x11\x1e\n\r\n\x05\x04\x12\x02\x03\x01\x12\x04\xc0\x03\
    \x1f&\n\r\n\x05\x04\x12\x02\x03\x03\x12\x04\xc0\x03)*\n\r\n\x05\x04\x12\
    \x02\x03\x08\x12\x04\xc0\x03+O\n\x10\n\x08\x04\x12\x02\x03\x08\xfe\xa2\
    \x04\x12\x04\xc0\x03,N\n\x0c\n\x04\x04\x12\x02\x04\x12\x04\xc1\x03\x08U\
    \n\r\n\x05\x04\x12\x02\x04\x04\x12\x04\xc1\x03\x08\x10\n\r\n\x05\x04\x12\
    \x02\x04\x06\x12\x04\xc1\x03\x11\x1e\n\r\n\x05\x04\x12\x02\x04\x01\x12\
    \x04\xc1\x03\x1f+\n\r\n\x05\x04\x12\x02\x04\x03\x12\x04\xc1\x03./\n\r\n\
    \x05\x04\x12\x02\x04\x08\x12\x04\xc1\x030T\n\x10\n\x08\x04\x12\x02\x04\
    \x08\xfe\xa2\x04\x12\x04\xc1\x031S\n\x0c\n\x04\x04\x12\x02\x05\x12\x04\
    \xc2\x03\x08V\n\r\n\x05\x04\x12\x02\x05\x04\x12\x04\xc2\x03\x08\x10\n\r\
    \n\x05\x04\x12\x02\x05\x06\x12\x04\xc2\x03\x11\x1e\n\r\n\x05\x04\x12\x02\
    \x05\x01\x12\x04\xc2\x03\x1f,\n\r\n\x05\x04\x12\x02\x05\x03\x12\x04\xc2\
    \x03/0\n\r\n\x05\x04\x12\x02\x05\x08\x12\x04\xc2\x031U\n\x10\n\x08\x04\
    \x12\x02\x05\x08\xfe\xa2\x04\x12\x04\xc2\x032T\n\x0c\n\x04\x04\x12\x02\
    \x06\x12\x04\xc3\x03\x08U\n\r\n\x05\x04\x12\x02\x06\x04\x12\x04\xc3\x03\
    \x08\x10\n\r\n\x05\x04\x12\x02\x06\x06\x12\x04\xc3\x03\x11\x1e\n\r\n\x05\
    \x04\x12\x02\x06\x01\x12\x04\xc3\x03\x1f+\n\r\n\x05\x04\x12\x02\x06\x03\
    \x12\x04\xc3\x03./\n\r\n\x05\x04\x12\x02\x06\x08\x12\x04\xc3\x030T\n\x10\
    \n\x08\x04\x12\x02\x06\x08\xfe\xa2\x04\x12\x04\xc3\x031S\n\x0c\n\x04\x04\
    \x12\x02\x07\x12\x04\xc4\x03\x08@\n\r\n\x05\x04\x12\x02\x07\x04\x12\x04\
    \xc4\x03\x08\x10\n\r\n\x05\x04\x12\x02\x07\x06\x12\x04\xc4\x03\x11,\n\r\
    \n\x05\x04\x12\x02\x07\x01\x12\x04\xc4\x03-;\n\r\n\x05\x04\x12\x02\x07\
    \x03\x12\x04\xc4\x03>?\n\x0c\n\x02\x04\x13\x12\x06\xc7\x03\0\xd0\x03\x01\
    \n\x0b\n\x03\x04\x13\x01\x12\x04\xc7\x03\x08#\n\x0e\n\x04\x04\x13\x08\0\
    \x12\x06\xc8\x03\x08\xcf\x03\t\n\r\n\x05\x04\x13\x08\0\x01\x12\x04\xc8\
    \x03\x0e\x13\n\x0c\n\x04\x04\x13\x02\0\x12\x04\xc9\x03\x10H\n\r\n\x05\
    \x04\x13\x02\0\x06\x12\x04\xc9\x03\x104\n\r\n\x05\x04\x13\x02\0\x01\x12\
    \x04\xc9\x035C\n\r\n\x05\x04\x13\x02\0\x03\x12\x04\xc9\x03FG\n\x0c\n\x04\
    \x04\x13\x02\x01\x12\x04\xca\x03\x10E\n\r\n\x05\x04\x13\x02\x01\x06\x12\
    \x04\xca\x03\x104\n\r\n\x05\x04\x13\x02\x01\x01\x12\x04\xca\x035@\n\r\n\
    \x05\x04\x13\x02\x01\x03\x12\x04\xca\x03CD\n\x0c\n\x04\x04\x13\x02\x02\
    \x12\x04\xcb\x03\x10F\n\r\n\x05\x04\x13\x02\x02\x06\x12\x04\xcb\x03\x104\
    \n\r\n\x05\x04\x13\x02\x02\x01\x12\x04\xcb\x035A\n\r\n\x05\x04\x13\x02\
    \x02\x03\x12\x04\xcb\x03DE\n\x0c\n\x04\x04\x13\x02\x03\x12\x04\xcc\x03\
    \x10J\n\r\n\x05\x04\x13\x02\x03\x06\x12\x04\xcc\x03\x104\n\r\n\x05\x04\
    \x13\x02\x03\x01\x12\x04\xcc\x035E\n\r\n\x05\x04\x13\x02\x03\x03\x12\x04\
    \xcc\x03HI\n\x0c\n\x04\x04\x13\x02\x04\x12\x04\xcd\x03\x10?\n\r\n\x05\
    \x04\x13\x02\x04\x06\x12\x04\xcd\x03\x103\n\r\n\x05\x04\x13\x02\x04\x01\
    \x12\x04\xcd\x034:\n\r\n\x05\x04\x13\x02\x04\x03\x12\x04\xcd\x03=>\n\x0c\
    \n\x04\x04\x13\x02\x05\x12\x04\xce\x03\x10G\n\r\n\x05\x04\x13\x02\x05\
    \x06\x12\x04\xce\x03\x104\n\r\n\x05\x04\x13\x02\x05\x01\x12\x04\xce\x035\
    B\n\r\n\x05\x04\x13\x02\x05\x03\x12\x04\xce\x03EF\n\x0c\n\x02\x04\x14\
    \x12\x06\xd2\x03\0\xd7\x03\x01\n\x0b\n\x03\x04\x14\x01\x12\x04\xd2\x03\
    \x08\"\n\x0e\n\x04\x04\x14\x08\0\x12\x06\xd3\x03\x08\xd6\x03\t\n\r\n\x05\
    \x04\x14\x08\0\x01\x12\x04\xd3\x03\x0e\x12\n\x0c\n\x04\x04\x14\x02\0\x12\
    \x04\xd4\x03\x107\n\r\n\x05\x04\x14\x02\0\x06\x12\x04\xd4\x03\x10,\n\r\n\
    \x05\x04\x14\x02\0\x01\x12\x04\xd4\x03-2\n\r\n\x05\x04\x14\x02\0\x03\x12\
    \x04\xd4\x0356\n\r\n\x04\x04\x14\x02\x01\x12\x05\xd5\x03\x10\x8a\x01\n\r\
    \n\x05\x04\x14\x02\x01\x06\x12\x04\xd5\x03\x10\x1f\n\r\n\x05\x04\x14\x02\
    \x01\x01\x12\x04\xd5\x03\x202\n\r\n\x05\x04\x14\x02\x01\x03\x12\x04\xd5\
    \x0356\n\x0e\n\x05\x04\x14\x02\x01\x08\x12\x05\xd5\x037\x89\x01\n\x10\n\
    \x08\x04\x14\x02\x01\x08\xf0\xa2\x04\x12\x04\xd5\x038b\n\x11\n\x08\x04\
    \x14\x02\x01\x08\xfc\xa2\x04\x12\x05\xd5\x03d\x88\x01\n\x0c\n\x02\x04\
    \x15\x12\x06\xd9\x03\0\xdc\x03\x01\n\x0b\n\x03\x04\x15\x01\x12\x04\xd9\
    \x03\x08\x1e\n\x0c\n\x04\x04\x15\x02\0\x12\x04\xda\x03\x080\n\r\n\x05\
    \x04\x15\x02\0\x04\x12\x04\xda\x03\x08\x10\n\r\n\x05\x04\x15\x02\0\x06\
    \x12\x04\xda\x03\x11$\n\r\n\x05\x04\x15\x02\0\x01\x12\x04\xda\x03%+\n\r\
    \n\x05\x04\x15\x02\0\x03\x12\x04\xda\x03./\n\x0c\n\x04\x04\x15\x02\x01\
    \x12\x04\xdb\x03\x08@\n\r\n\x05\x04\x15\x02\x01\x04\x12\x04\xdb\x03\x08\
    \x10\n\r\n\x05\x04\x15\x02\x01\x06\x12\x04\xdb\x03\x11,\n\r\n\x05\x04\
    \x15\x02\x01\x01\x12\x04\xdb\x03-;\n\r\n\x05\x04\x15\x02\x01\x03\x12\x04\
    \xdb\x03>?\n\x0c\n\x02\x04\x16\x12\x06\xde\x03\0\xe8\x03\x01\n\x0b\n\x03\
    \x04\x16\x01\x12\x04\xde\x03\x08#\n\x0e\n\x04\x04\x16\x03\0\x12\x06\xdf\
    \x03\x08\xe2\x03\t\n\r\n\x05\x04\x16\x03\0\x01\x12\x04\xdf\x03\x10\x1a\n\
    \x0e\n\x06\x04\x16\x03\0\x02\0\x12\x04\xe0\x03\x10m\n\x0f\n\x07\x04\x16\
    \x03\0\x02\0\x04\x12\x04\xe0\x03\x10\x18\n\x0f\n\x07\x04\x16\x03\0\x02\0\
    \x06\x12\x04\xe0\x03\x19(\n\x0f\n\x07\x04\x16\x03\0\x02\0\x01\x12\x04\
    \xe0\x03);\n\x0f\n\x07\x04\x16\x03\0\x02\0\x03\x12\x04\xe0\x03>?\n\x0f\n\
    \x07\x04\x16\x03\0\x02\0\x08\x12\x04\xe0\x03@l\n\x12\n\n\x04\x16\x03\0\
    \x02\0\x08\xf0\xa2\x04\x12\x04\xe0\x03Ak\n\x0f\n\x06\x04\x16\x03\0\x02\
    \x01\x12\x05\xe1\x03\x10\x86\x01\n\x0f\n\x07\x04\x16\x03\0\x02\x01\x04\
    \x12\x04\xe1\x03\x10\x18\n\x0f\n\x07\x04\x16\x03\0\x02\x01\x06\x12\x04\
    \xe1\x03\x19&\n\x0f\n\x07\x04\x16\x03\0\x02\x01\x01\x12\x04\xe1\x03'/\n\
    \x0f\n\x07\x04\x16\x03\0\x02\x01\x03\x12\x04\xe1\x0323\n\x10\n\x07\x04\
    \x16\x03\0\x02\x01\x08\x12\x05\xe1\x034\x85\x01\n\x12\n\n\x04\x16\x03\0\
    \x02\x01\x08\xf8\xa2\x04\x12\x04\xe1\x035H\n\x12\n\n\x04\x16\x03\0\x02\
    \x01\x08\xf9\xa2\x04\x12\x04\xe1\x03J`\n\x13\n\n\x04\x16\x03\0\x02\x01\
    \x08\xfe\xa2\x04\x12\x05\xe1\x03b\x84\x01\n\x0c\n\x04\x04\x16\x02\0\x12\
    \x04\xe4\x03\x080\n\r\n\x05\x04\x16\x02\0\x04\x12\x04\xe4\x03\x08\x10\n\
    \r\n\x05\x04\x16\x02\0\x06\x12\x04\xe4\x03\x11$\n\r\n\x05\x04\x16\x02\0\
    \x01\x12\x04\xe4\x03%+\n\r\n\x05\x04\x16\x02\0\x03\x12\x04\xe4\x03./\n\
    \x0c\n\x04\x04\x16\x02\x01\x12\x04\xe5\x03\x082\n\r\n\x05\x04\x16\x02\
    \x01\x04\x12\x04\xe5\x03\x08\x10\n\r\n\x05\x04\x16\x02\x01\x05\x12\x04\
    \xe5\x03\x11\x17\n\r\n\x05\x04\x16\x02\x01\x01\x12\x04\xe5\x03\x18-\n\r\
    \n\x05\x04\x16\x02\x01\x03\x12\x04\xe5\x0301\n\r\n\x04\x04\x16\x02\x02\
    \x12\x05\xe6\x03\x08\x8a\x01\n\r\n\x05\x04\x16\x02\x02\x04\x12\x04\xe6\
    \x03\x08\x10\n\r\n\x05\x04\x16\x02\x02\x06\x12\x04\xe6\x03\x11\x20\n\r\n\
    \x05\x04\x16\x02\x02\x01\x12\x04\xe6\x03!2\n\r\n\x05\x04\x16\x02\x02\x03\
    \x12\x04\xe6\x0356\n\x0e\n\x05\x04\x16\x02\x02\x08\x12\x05\xe6\x037\x89\
    \x01\n\x10\n\x08\x04\x16\x02\x02\x08\xf0\xa2\x04\x12\x04\xe6\x038b\n\x11\
    \n\x08\x04\x16\x02\x02\x08\xfc\xa2\x04\x12\x05\xe6\x03d\x88\x01\n\x0c\n\
    \x04\x04\x16\x02\x03\x12\x04\xe7\x03\x08Z\n\r\n\x05\x04\x16\x02\x03\x04\
    \x12\x04\xe7\x03\x08\x10\n\r\n\x05\x04\x16\x02\x03\x06\x12\x04\xe7\x03\
    \x118\n\r\n\x05\x04\x16\x02\x03\x01\x12\x04\xe7\x039C\n\r\n\x05\x04\x16\
    \x02\x03\x03\x12\x04\xe7\x03FG\n\r\n\x05\x04\x16\x02\x03\x08\x12\x04\xe7\
    \x03HY\n\x10\n\x08\x04\x16\x02\x03\x08\xf7\xa2\x04\x12\x04\xe7\x03IX\n\
    \x0c\n\x02\x04\x17\x12\x06\xea\x03\0\xaa\x04\x01\n\x0b\n\x03\x04\x17\x01\
    \x12\x04\xea\x03\x08\x1f\n\x0e\n\x04\x04\x17\x03\0\x12\x06\xeb\x03\x08\
    \xf6\x03\t\n\r\n\x05\x04\x17\x03\0\x01\x12\x04\xeb\x03\x10\x14\n\r\n\x05\
    \x04\x17\x03\0\x07\x12\x04\xec\x03\x100\n\x10\n\x08\x04\x17\x03\0\x07\
    \x80\xf1\x04\x12\x04\xec\x03\x100\n\x10\n\x06\x04\x17\x03\0\x03\0\x12\
    \x06\xee\x03\x10\xf2\x03\x11\n\x0f\n\x07\x04\x17\x03\0\x03\0\x01\x12\x04\
    \xee\x03\x18\x20\n\x10\n\x08\x04\x17\x03\0\x03\0\x02\0\x12\x04\xef\x03\
    \x18N\n\x11\n\t\x04\x17\x03\0\x03\0\x02\0\x04\x12\x04\xef\x03\x18\x20\n\
    \x11\n\t\x04\x17\x03\0\x03\0\x02\0\x05\x12\x04\xef\x03!%\n\x11\n\t\x04\
    \x17\x03\0\x03\0\x02\0\x01\x12\x04\xef\x03&8\n\x11\n\t\x04\x17\x03\0\x03\
    \0\x02\0\x03\x12\x04\xef\x03;<\n\x11\n\t\x04\x17\x03\0\x03\0\x02\0\x08\
    \x12\x04\xef\x03=M\n\x11\n\t\x04\x17\x03\0\x03\0\x02\0\x07\x12\x04\xef\
    \x03HL\n\x10\n\x08\x04\x17\x03\0\x03\0\x02\x01\x12\x04\xf0\x03\x18>\n\
    \x11\n\t\x04\x17\x03\0\x03\0\x02\x01\x04\x12\x04\xf0\x03\x18\x20\n\x11\n\
    \t\x04\x17\x03\0\x03\0\x02\x01\x05\x12\x04\xf0\x03!'\n\x11\n\t\x04\x17\
    \x03\0\x03\0\x02\x01\x01\x12\x04\xf0\x03(9\n\x11\n\t\x04\x17\x03\0\x03\0\
    \x02\x01\x03\x12\x04\xf0\x03<=\n\x11\n\x08\x04\x17\x03\0\x03\0\x02\x02\
    \x12\x05\xf1\x03\x18\x8e\x01\n\x11\n\t\x04\x17\x03\0\x03\0\x02\x02\x04\
    \x12\x04\xf1\x03\x18\x20\n\x11\n\t\x04\x17\x03\0\x03\0\x02\x02\x06\x12\
    \x04\xf1\x03!.\n\x11\n\t\x04\x17\x03\0\x03\0\x02\x02\x01\x12\x04\xf1\x03\
    /7\n\x11\n\t\x04\x17\x03\0\x03\0\x02\x02\x03\x12\x04\xf1\x03:;\n\x12\n\t\
    \x04\x17\x03\0\x03\0\x02\x02\x08\x12\x05\xf1\x03<\x8d\x01\n\x14\n\x0c\
    \x04\x17\x03\0\x03\0\x02\x02\x08\xf8\xa2\x04\x12\x04\xf1\x03=P\n\x14\n\
    \x0c\x04\x17\x03\0\x03\0\x02\x02\x08\xf9\xa2\x04\x12\x04\xf1\x03Rh\n\x15\
    \n\x0c\x04\x17\x03\0\x03\0\x02\x02\x08\xfe\xa2\x04\x12\x05\xf1\x03j\x8c\
    \x01\n\x0f\n\x06\x04\x17\x03\0\x02\0\x12\x05\xf4\x03\x10\xb9\x01\n\x0f\n\
    \x07\x04\x17\x03\0\x02\0\x04\x12\x04\xf4\x03\x10\x18\n\x0f\n\x07\x04\x17\
    \x03\0\x02\0\x06\x12\x04\xf4\x03\x19(\n\x0f\n\x07\x04\x17\x03\0\x02\0\
    \x01\x12\x04\xf4\x03)A\n\x0f\n\x07\x04\x17\x03\0\x02\0\x03\x12\x04\xf4\
    \x03DE\n\x10\n\x07\x04\x17\x03\0\x02\0\x08\x12\x05\xf4\x03F\xb8\x01\n\
    \x12\n\n\x04\x17\x03\0\x02\0\x08\xf0\xa2\x04\x12\x04\xf4\x03Gw\n\x13\n\n\
    \x04\x17\x03\0\x02\0\x08\xfa\xa2\x04\x12\x05\xf4\x03y\xb7\x01\n\x0e\n\
    \x06\x04\x17\x03\0\x02\x01\x12\x04\xf5\x03\x10I\n\x0f\n\x07\x04\x17\x03\
    \0\x02\x01\x04\x12\x04\xf5\x03\x10\x18\n\x0f\n\x07\x04\x17\x03\0\x02\x01\
    \x06\x12\x04\xf5\x03\x19?\n\x0f\n\x07\x04\x17\x03\0\x02\x01\x01\x12\x04\
    \xf5\x03@D\n\x0f\n\x07\x04\x17\x03\0\x02\x01\x03\x12\x04\xf5\x03GH\n\x0c\
    \n\x04\x04\x17\x02\0\x12\x04\xf8\x03\x080\n\r\n\x05\x04\x17\x02\0\x04\
    \x12\x04\xf8\x03\x08\x10\n\r\n\x05\x04\x17\x02\0\x06\x12\x04\xf8\x03\x11\
    $\n\r\n\x05\x04\x17\x02\0\x01\x12\x04\xf8\x03%+\n\r\n\x05\x04\x17\x02\0\
    \x03\x12\x04\xf8\x03./\n\x0c\n\x04\x04\x17\x02\x01\x12\x04\xf9\x03\x08?\
    \n\r\n\x05\x04\x17\x02\x01\x04\x12\x04\xf9\x03\x08\x10\n\r\n\x05\x04\x17\
    \x02\x01\x05\x12\x04\xf9\x03\x11\x17\n\r\n\x05\x04\x17\x02\x01\x01\x12\
    \x04\xf9\x03\x18%\n\r\n\x05\x04\x17\x02\x01\x03\x12\x04\xf9\x03()\n\r\n\
    \x05\x04\x17\x02\x01\x08\x12\x04\xf9\x03*>\n\x10\n\x08\x04\x17\x02\x01\
    \x08\xf2\xa2\x04\x12\x04\xf9\x03+=\n\r\n\x04\x04\x17\x02\x02\x12\x05\xfa\
    \x03\x08\x94\x02\n\r\n\x05\x04\x17\x02\x02\x04\x12\x04\xfa\x03\x08\x10\n\
    \r\n\x05\x04\x17\x02\x02\x06\x12\x04\xfa\x03\x11\x20\n\r\n\x05\x04\x17\
    \x02\x02\x01\x12\x04\xfa\x03!3\n\r\n\x05\x04\x17\x02\x02\x03\x12\x04\xfa\
    \x0367\n\x0e\n\x05\x04\x17\x02\x02\x08\x12\x05\xfa\x038\x93\x02\n\x10\n\
    \x08\x04\x17\x02\x02\x08\xf0\xa2\x04\x12\x04\xfa\x039c\n\x11\n\x08\x04\
    \x17\x02\x02\x08\xf5\xa2\x04\x12\x05\xfa\x03e\xec\x01\n\x12\n\x08\x04\
    \x17\x02\x02\x08\xfc\xa2\x04\x12\x06\xfa\x03\xee\x01\x92\x02\n\x0c\n\x04\
    \x04\x17\x02\x03\x12\x04\xfb\x03\x08,\n\r\n\x05\x04\x17\x02\x03\x04\x12\
    \x04\xfb\x03\x08\x10\n\r\n\x05\x04\x17\x02\x03\x05\x12\x04\xfb\x03\x11\
    \x15\n\r\n\x05\x04\x17\x02\x03\x01\x12\x04\xfb\x03\x16'\n\r\n\x05\x04\
    \x17\x02\x03\x03\x12\x04\xfb\x03*+\n\x0c\n\x04\x04\x17\x02\x04\x12\x04\
    \xfc\x03\x088\n\r\n\x05\x04\x17\x02\x04\x04\x12\x04\xfc\x03\x08\x10\n\r\
    \n\x05\x04\x17\x02\x04\x06\x12\x04\xfc\x03\x11.\n\r\n\x05\x04\x17\x02\
    \x04\x01\x12\x04\xfc\x03/3\n\r\n\x05\x04\x17\x02\x04\x03\x12\x04\xfc\x03\
    67\n\x0c\n\x04\x04\x17\x02\x05\x12\x04\xfd\x03\x08A\n\r\n\x05\x04\x17\
    \x02\x05\x04\x12\x04\xfd\x03\x08\x10\n\r\n\x05\x04\x17\x02\x05\x06\x12\
    \x04\xfd\x03\x11.\n\r\n\x05\x04\x17\x02\x05\x01\x12\x04\xfd\x03/<\n\r\n\
    \x05\x04\x17\x02\x05\x03\x12\x04\xfd\x03?@\n\x0c\n\x04\x04\x17\x02\x06\
    \x12\x04\xfe\x03\x08@\n\r\n\x05\x04\x17\x02\x06\x04\x12\x04\xfe\x03\x08\
    \x10\n\r\n\x05\x04\x17\x02\x06\x06\x12\x04\xfe\x03\x11.\n\r\n\x05\x04\
    \x17\x02\x06\x01\x12\x04\xfe\x03/;\n\r\n\x05\x04\x17\x02\x06\x03\x12\x04\
    \xfe\x03>?\n\x0c\n\x04\x04\x17\x02\x07\x12\x04\xff\x03\x08C\n\r\n\x05\
    \x04\x17\x02\x07\x04\x12\x04\xff\x03\x08\x10\n\r\n\x05\x04\x17\x02\x07\
    \x06\x12\x04\xff\x03\x11.\n\r\n\x05\x04\x17\x02\x07\x01\x12\x04\xff\x03/\
    >\n\r\n\x05\x04\x17\x02\x07\x03\x12\x04\xff\x03AB\n\x0c\n\x04\x04\x17\
    \x02\x08\x12\x04\x80\x04\x089\n\r\n\x05\x04\x17\x02\x08\x04\x12\x04\x80\
    \x04\x08\x10\n\r\n\x05\x04\x17\x02\x08\x06\x12\x04\x80\x04\x11.\n\r\n\
    \x05\x04\x17\x02\x08\x01\x12\x04\x80\x04/4\n\r\n\x05\x04\x17\x02\x08\x03\
    \x12\x04\x80\x0478\n\x0c\n\x04\x04\x17\x02\t\x12\x04\x81\x04\x08<\n\r\n\
    \x05\x04\x17\x02\t\x04\x12\x04\x81\x04\x08\x10\n\r\n\x05\x04\x17\x02\t\
    \x06\x12\x04\x81\x04\x11.\n\r\n\x05\x04\x17\x02\t\x01\x12\x04\x81\x04/6\
    \n\r\n\x05\x04\x17\x02\t\x03\x12\x04\x81\x049;\n\x0c\n\x04\x04\x17\x02\n\
    \x12\x04\x82\x04\x08<\n\r\n\x05\x04\x17\x02\n\x04\x12\x04\x82\x04\x08\
    \x10\n\r\n\x05\x04\x17\x02\n\x06\x12\x04\x82\x04\x11.\n\r\n\x05\x04\x17\
    \x02\n\x01\x12\x04\x82\x04/6\n\r\n\x05\x04\x17\x02\n\x03\x12\x04\x82\x04\
    9;\n\x0c\n\x04\x04\x17\x02\x0b\x12\x04\x83\x04\x08;\n\r\n\x05\x04\x17\
    \x02\x0b\x04\x12\x04\x83\x04\x08\x10\n\r\n\x05\x04\x17\x02\x0b\x06\x12\
    \x04\x83\x04\x11.\n\r\n\x05\x04\x17\x02\x0b\x01\x12\x04\x83\x04/5\n\r\n\
    \x05\x04\x17\x02\x0b\x03\x12\x04\x83\x048:\n\x0c\n\x04\x04\x17\x02\x0c\
    \x12\x04\x84\x04\x08=\n\r\n\x05\x04\x17\x02\x0c\x04\x12\x04\x84\x04\x08\
    \x10\n\r\n\x05\x04\x17\x02\x0c\x06\x12\x04\x84\x04\x11.\n\r\n\x05\x04\
    \x17\x02\x0c\x01\x12\x04\x84\x04/7\n\r\n\x05\x04\x17\x02\x0c\x03\x12\x04\
    \x84\x04:<\n\x0c\n\x04\x04\x17\x02\r\x12\x04\x85\x04\x08C\n\r\n\x05\x04\
    \x17\x02\r\x04\x12\x04\x85\x04\x08\x10\n\r\n\x05\x04\x17\x02\r\x06\x12\
    \x04\x85\x04\x11.\n\r\n\x05\x04\x17\x02\r\x01\x12\x04\x85\x04/=\n\r\n\
    \x05\x04\x17\x02\r\x03\x12\x04\x85\x04@B\n\x0c\n\x04\x04\x17\x02\x0e\x12\
    \x04\x86\x04\x08?\n\r\n\x05\x04\x17\x02\x0e\x04\x12\x04\x86\x04\x08\x10\
    \n\r\n\x05\x04\x17\x02\x0e\x06\x12\x04\x86\x04\x11.\n\r\n\x05\x04\x17\
    \x02\x0e\x01\x12\x04\x86\x04/9\n\r\n\x05\x04\x17\x02\x0e\x03\x12\x04\x86\
    \x04<>\n\x0c\n\x04\x04\x17\x02\x0f\x12\x04\x87\x04\x08<\n\r\n\x05\x04\
    \x17\x02\x0f\x04\x12\x04\x87\x04\x08\x10\n\r\n\x05\x04\x17\x02\x0f\x06\
    \x12\x04\x87\x04\x11.\n\r\n\x05\x04\x17\x02\x0f\x01\x12\x04\x87\x04/6\n\
    \r\n\x05\x04\x17\x02\x0f\x03\x12\x04\x87\x049;\n\x0c\n\x04\x04\x17\x02\
    \x10\x12\x04\x88\x04\x088\n\r\n\x05\x04\x17\x02\x10\x04\x12\x04\x88\x04\
    \x08\x10\n\r\n\x05\x04\x17\x02\x10\x06\x12\x04\x88\x04\x11.\n\r\n\x05\
    \x04\x17\x02\x10\x01\x12\x04\x88\x04/2\n\r\n\x05\x04\x17\x02\x10\x03\x12\
    \x04\x88\x0457\n\x0c\n\x04\x04\x17\x02\x11\x12\x04\x89\x04\x08@\n\r\n\
    \x05\x04\x17\x02\x11\x04\x12\x04\x89\x04\x08\x10\n\r\n\x05\x04\x17\x02\
    \x11\x06\x12\x04\x89\x04\x11.\n\r\n\x05\x04\x17\x02\x11\x01\x12\x04\x89\
    \x04/:\n\r\n\x05\x04\x17\x02\x11\x03\x12\x04\x89\x04=?\n\x0c\n\x04\x04\
    \x17\x02\x12\x12\x04\x8a\x04\x08H\n\r\n\x05\x04\x17\x02\x12\x04\x12\x04\
    \x8a\x04\x08\x10\n\r\n\x05\x04\x17\x02\x12\x06\x12\x04\x8a\x04\x11.\n\r\
    \n\x05\x04\x17\x02\x12\x01\x12\x04\x8a\x04/B\n\r\n\x05\x04\x17\x02\x12\
    \x03\x12\x04\x8a\x04EG\n\x0c\n\x04\x04\x17\x02\x13\x12\x04\x8b\x04\x08<\
    \n\r\n\x05\x04\x17\x02\x13\x04\x12\x04\x8b\x04\x08\x10\n\r\n\x05\x04\x17\
    \x02\x13\x06\x12\x04\x8b\x04\x11.\n\r\n\x05\x04\x17\x02\x13\x01\x12\x04\
    \x8b\x04/6\n\r\n\x05\x04\x17\x02\x13\x03\x12\x04\x8b\x049;\n\x0c\n\x04\
    \x04\x17\x02\x14\x12\x04\x8c\x04\x08;\n\r\n\x05\x04\x17\x02\x14\x04\x12\
    \x04\x8c\x04\x08\x10\n\r\n\x05\x04\x17\x02\x14\x06\x12\x04\x8c\x04\x11.\
    \n\r\n\x05\x04\x17\x02\x14\x01\x12\x04\x8c\x04/5\n\r\n\x05\x04\x17\x02\
    \x14\x03\x12\x04\x8c\x048:\n\x0c\n\x04\x04\x17\x02\x15\x12\x04\x8d\x04\
    \x08>\n\r\n\x05\x04\x17\x02\x15\x04\x12\x04\x8d\x04\x08\x10\n\r\n\x05\
    \x04\x17\x02\x15\x06\x12\x04\x8d\x04\x11.\n\r\n\x05\x04\x17\x02\x15\x01\
    \x12\x04\x8d\x04/8\n\r\n\x05\x04\x17\x02\x15\x03\x12\x04\x8d\x04;=\n\x0c\
    \n\x04\x04\x17\x02\x16\x12\x04\x8e\x04\x08B\n\r\n\x05\x04\x17\x02\x16\
    \x04\x12\x04\x8e\x04\x08\x10\n\r\n\x05\x04\x17\x02\x16\x06\x12\x04\x8e\
    \x04\x11.\n\r\n\x05\x04\x17\x02\x16\x01\x12\x04\x8e\x04/<\n\r\n\x05\x04\
    \x17\x02\x16\x03\x12\x04\x8e\x04?A\n\x0c\n\x04\x04\x17\x02\x17\x12\x04\
    \x8f\x04\x08C\n\r\n\x05\x04\x17\x02\x17\x04\x12\x04\x8f\x04\x08\x10\n\r\
    \n\x05\x04\x17\x02\x17\x06\x12\x04\x8f\x04\x11.\n\r\n\x05\x04\x17\x02\
    \x17\x01\x12\x04\x8f\x04/=\n\r\n\x05\x04\x17\x02\x17\x03\x12\x04\x8f\x04\
    @B\n\x0c\n\x04\x04\x17\x02\x18\x12\x04\x90\x04\x08>\n\r\n\x05\x04\x17\
    \x02\x18\x04\x12\x04\x90\x04\x08\x10\n\r\n\x05\x04\x17\x02\x18\x06\x12\
    \x04\x90\x04\x11.\n\r\n\x05\x04\x17\x02\x18\x01\x12\x04\x90\x04/8\n\r\n\
    \x05\x04\x17\x02\x18\x03\x12\x04\x90\x04;=\n\x0c\n\x04\x04\x17\x02\x19\
    \x12\x04\x91\x04\x08B\n\r\n\x05\x04\x17\x02\x19\x04\x12\x04\x91\x04\x08\
    \x10\n\r\n\x05\x04\x17\x02\x19\x06\x12\x04\x91\x04\x11.\n\r\n\x05\x04\
    \x17\x02\x19\x01\x12\x04\x91\x04/<\n\r\n\x05\x04\x17\x02\x19\x03\x12\x04\
    \x91\x04?A\n\x0c\n\x04\x04\x17\x02\x1a\x12\x04\x92\x04\x08=\n\r\n\x05\
    \x04\x17\x02\x1a\x04\x12\x04\x92\x04\x08\x10\n\r\n\x05\x04\x17\x02\x1a\
    \x06\x12\x04\x92\x04\x11.\n\r\n\x05\x04\x17\x02\x1a\x01\x12\x04\x92\x04/\
    7\n\r\n\x05\x04\x17\x02\x1a\x03\x12\x04\x92\x04:<\n\x0c\n\x04\x04\x17\
    \x02\x1b\x12\x04\x93\x04\x08C\n\r\n\x05\x04\x17\x02\x1b\x04\x12\x04\x93\
    \x04\x08\x10\n\r\n\x05\x04\x17\x02\x1b\x06\x12\x04\x93\x04\x11.\n\r\n\
    \x05\x04\x17\x02\x1b\x01\x12\x04\x93\x04/=\n\r\n\x05\x04\x17\x02\x1b\x03\
    \x12\x04\x93\x04@B\n\x0c\n\x04\x04\x17\x02\x1c\x12\x04\x94\x04\x08G\n\r\
    \n\x05\x04\x17\x02\x1c\x04\x12\x04\x94\x04\x08\x10\n\r\n\x05\x04\x17\x02\
    \x1c\x06\x12\x04\x94\x04\x11.\n\r\n\x05\x04\x17\x02\x1c\x01\x12\x04\x94\
    \x04/A\n\r\n\x05\x04\x17\x02\x1c\x03\x12\x04\x94\x04DF\n\x0c\n\x04\x04\
    \x17\x02\x1d\x12\x04\x95\x04\x08>\n\r\n\x05\x04\x17\x02\x1d\x04\x12\x04\
    \x95\x04\x08\x10\n\r\n\x05\x04\x17\x02\x1d\x06\x12\x04\x95\x04\x11.\n\r\
    \n\x05\x04\x17\x02\x1d\x01\x12\x04\x95\x04/8\n\r\n\x05\x04\x17\x02\x1d\
    \x03\x12\x04\x95\x04;=\n\x0c\n\x04\x04\x17\x02\x1e\x12\x04\x96\x04\x08@\
    \n\r\n\x05\x04\x17\x02\x1e\x04\x12\x04\x96\x04\x08\x10\n\r\n\x05\x04\x17\
    \x02\x1e\x06\x12\x04\x96\x04\x11.\n\r\n\x05\x04\x17\x02\x1e\x01\x12\x04\
    \x96\x04/:\n\r\n\x05\x04\x17\x02\x1e\x03\x12\x04\x96\x04=?\n\x0c\n\x04\
    \x04\x17\x02\x1f\x12\x04\x97\x04\x08F\n\r\n\x05\x04\x17\x02\x1f\x04\x12\
    \x04\x97\x04\x08\x10\n\r\n\x05\x04\x17\x02\x1f\x06\x12\x04\x97\x04\x11.\
    \n\r\n\x05\x04\x17\x02\x1f\x01\x12\x04\x97\x04/@\n\r\n\x05\x04\x17\x02\
    \x1f\x03\x12\x04\x97\x04CE\n\x0c\n\x04\x04\x17\x02\x20\x12\x04\x98\x04\
    \x08>\n\r\n\x05\x04\x17\x02\x20\x04\x12\x04\x98\x04\x08\x10\n\r\n\x05\
    \x04\x17\x02\x20\x06\x12\x04\x98\x04\x11.\n\r\n\x05\x04\x17\x02\x20\x01\
    \x12\x04\x98\x04/8\n\r\n\x05\x04\x17\x02\x20\x03\x12\x04\x98\x04;=\n\x0c\
    \n\x04\x04\x17\x02!\x12\x04\x99\x04\x08@\n\r\n\x05\x04\x17\x02!\x04\x12\
    \x04\x99\x04\x08\x10\n\r\n\x05\x04\x17\x02!\x06\x12\x04\x99\x04\x11.\n\r\
    \n\x05\x04\x17\x02!\x01\x12\x04\x99\x04/:\n\r\n\x05\x04\x17\x02!\x03\x12\
    \x04\x99\x04=?\n\x0c\n\x04\x04\x17\x02\"\x12\x04\x9a\x04\x08A\n\r\n\x05\
    \x04\x17\x02\"\x04\x12\x04\x9a\x04\x08\x10\n\r\n\x05\x04\x17\x02\"\x06\
    \x12\x04\x9a\x04\x11.\n\r\n\x05\x04\x17\x02\"\x01\x12\x04\x9a\x04/;\n\r\
    \n\x05\x04\x17\x02\"\x03\x12\x04\x9a\x04>@\n\x0c\n\x04\x04\x17\x02#\x12\
    \x04\x9b\x04\x088\n\r\n\x05\x04\x17\x02#\x04\x12\x04\x9b\x04\x08\x10\n\r\
    \n\x05\x04\x17\x02#\x06\x12\x04\x9b\x04\x11.\n\r\n\x05\x04\x17\x02#\x01\
    \x12\x04\x9b\x04/2\n\r\n\x05\x04\x17\x02#\x03\x12\x04\x9b\x0457\n\x0c\n\
    \x04\x04\x17\x02$\x12\x04\x9c\x04\x08>\n\r\n\x05\x04\x17\x02$\x04\x12\
    \x04\x9c\x04\x08\x10\n\r\n\x05\x04\x17\x02$\x06\x12\x04\x9c\x04\x11.\n\r\
    \n\x05\x04\x17\x02$\x01\x12\x04\x9c\x04/8\n\r\n\x05\x04\x17\x02$\x03\x12\
    \x04\x9c\x04;=\n\x0c\n\x04\x04\x17\x02%\x12\x04\x9d\x04\x08>\n\r\n\x05\
    \x04\x17\x02%\x04\x12\x04\x9d\x04\x08\x10\n\r\n\x05\x04\x17\x02%\x06\x12\
    \x04\x9d\x04\x11.\n\r\n\x05\x04\x17\x02%\x01\x12\x04\x9d\x04/8\n\r\n\x05\
    \x04\x17\x02%\x03\x12\x04\x9d\x04;=\n\x0c\n\x04\x04\x17\x02&\x12\x04\x9e\
    \x04\x08=\n\r\n\x05\x04\x17\x02&\x04\x12\x04\x9e\x04\x08\x10\n\r\n\x05\
    \x04\x17\x02&\x06\x12\x04\x9e\x04\x11.\n\r\n\x05\x04\x17\x02&\x01\x12\
    \x04\x9e\x04/7\n\r\n\x05\x04\x17\x02&\x03\x12\x04\x9e\x04:<\n\x0c\n\x04\
    \x04\x17\x02'\x12\x04\x9f\x04\x08D\n\r\n\x05\x04\x17\x02'\x04\x12\x04\
    \x9f\x04\x08\x10\n\r\n\x05\x04\x17\x02'\x06\x12\x04\x9f\x04\x11.\n\r\n\
    \x05\x04\x17\x02'\x01\x12\x04\x9f\x04/>\n\r\n\x05\x04\x17\x02'\x03\x12\
    \x04\x9f\x04AC\n\x0c\n\x04\x04\x17\x02(\x12\x04\xa0\x04\x08@\n\r\n\x05\
    \x04\x17\x02(\x04\x12\x04\xa0\x04\x08\x10\n\r\n\x05\x04\x17\x02(\x06\x12\
    \x04\xa0\x04\x11.\n\r\n\x05\x04\x17\x02(\x01\x12\x04\xa0\x04/:\n\r\n\x05\
    \x04\x17\x02(\x03\x12\x04\xa0\x04=?\n\x0c\n\x04\x04\x17\x02)\x12\x04\xa1\
    \x04\x08A\n\r\n\x05\x04\x17\x02)\x04\x12\x04\xa1\x04\x08\x10\n\r\n\x05\
    \x04\x17\x02)\x06\x12\x04\xa1\x04\x11.\n\r\n\x05\x04\x17\x02)\x01\x12\
    \x04\xa1\x04/;\n\r\n\x05\x04\x17\x02)\x03\x12\x04\xa1\x04>@\n\x0c\n\x04\
    \x04\x17\x02*\x12\x04\xa2\x04\x08=\n\r\n\x05\x04\x17\x02*\x04\x12\x04\
    \xa2\x04\x08\x10\n\r\n\x05\x04\x17\x02*\x06\x12\x04\xa2\x04\x11.\n\r\n\
    \x05\x04\x17\x02*\x01\x12\x04\xa2\x04/7\n\r\n\x05\x04\x17\x02*\x03\x12\
    \x04\xa2\x04:<\n\x0c\n\x04\x04\x17\x02+\x12\x04\xa3\x04\x08@\n\r\n\x05\
    \x04\x17\x02+\x04\x12\x04\xa3\x04\x08\x10\n\r\n\x05\x04\x17\x02+\x06\x12\
    \x04\xa3\x04\x11.\n\r\n\x05\x04\x17\x02+\x01\x12\x04\xa3\x04/:\n\r\n\x05\
    \x04\x17\x02+\x03\x12\x04\xa3\x04=?\n\x0c\n\x04\x04\x17\x02,\x12\x04\xa4\
    \x04\x08>\n\r\n\x05\x04\x17\x02,\x04\x12\x04\xa4\x04\x08\x10\n\r\n\x05\
    \x04\x17\x02,\x06\x12\x04\xa4\x04\x11.\n\r\n\x05\x04\x17\x02,\x01\x12\
    \x04\xa4\x04/8\n\r\n\x05\x04\x17\x02,\x03\x12\x04\xa4\x04;=\n\x0c\n\x04\
    \x04\x17\x02-\x12\x04\xa5\x04\x08@\n\r\n\x05\x04\x17\x02-\x04\x12\x04\
    \xa5\x04\x08\x10\n\r\n\x05\x04\x17\x02-\x06\x12\x04\xa5\x04\x11.\n\r\n\
    \x05\x04\x17\x02-\x01\x12\x04\xa5\x04/:\n\r\n\x05\x04\x17\x02-\x03\x12\
    \x04\xa5\x04=?\n\x0c\n\x04\x04\x17\x02.\x12\x04\xa6\x04\x08A\n\r\n\x05\
    \x04\x17\x02.\x04\x12\x04\xa6\x04\x08\x10\n\r\n\x05\x04\x17\x02.\x06\x12\
    \x04\xa6\x04\x11.\n\r\n\x05\x04\x17\x02.\x01\x12\x04\xa6\x04/;\n\r\n\x05\
    \x04\x17\x02.\x03\x12\x04\xa6\x04>@\n\x0c\n\x04\x04\x17\x02/\x12\x04\xa7\
    \x04\x08=\n\r\n\x05\x04\x17\x02/\x04\x12\x04\xa7\x04\x08\x10\n\r\n\x05\
    \x04\x17\x02/\x06\x12\x04\xa7\x04\x11.\n\r\n\x05\x04\x17\x02/\x01\x12\
    \x04\xa7\x04/7\n\r\n\x05\x04\x17\x02/\x03\x12\x04\xa7\x04:<\n\x0c\n\x04\
    \x04\x17\x020\x12\x04\xa8\x04\x08>\n\r\n\x05\x04\x17\x020\x04\x12\x04\
    \xa8\x04\x08\x10\n\r\n\x05\x04\x17\x020\x06\x12\x04\xa8\x04\x11.\n\r\n\
    \x05\x04\x17\x020\x01\x12\x04\xa8\x04/8\n\r\n\x05\x04\x17\x020\x03\x12\
    \x04\xa8\x04;=\n\x0c\n\x04\x04\x17\x021\x12\x04\xa9\x04\x08B\n\r\n\x05\
    \x04\x17\x021\x04\x12\x04\xa9\x04\x08\x10\n\r\n\x05\x04\x17\x021\x06\x12\
    \x04\xa9\x04\x11.\n\r\n\x05\x04\x17\x021\x01\x12\x04\xa9\x04/<\n\r\n\x05\
    \x04\x17\x021\x03\x12\x04\xa9\x04?A\n\x0c\n\x02\x04\x18\x12\x06\xac\x04\
    \0\xc0\x04\x01\n\x0b\n\x03\x04\x18\x01\x12\x04\xac\x04\x08\x16\n\x0e\n\
    \x04\x04\x18\x03\0\x12\x06\xad\x04\x08\xb0\x04\t\n\r\n\x05\x04\x18\x03\0\
    \x01\x12\x04\xad\x04\x10\x1e\n\x0e\n\x06\x04\x18\x03\0\x02\0\x12\x04\xae\
    \x04\x10+\n\x0f\n\x07\x04\x18\x03\0\x02\0\x04\x12\x04\xae\x04\x10\x18\n\
    \x0f\n\x07\x04\x18\x03\0\x02\0\x05\x12\x04\xae\x04\x19\x1f\n\x0f\n\x07\
    \x04\x18\x03\0\x02\0\x01\x12\x04\xae\x04\x20&\n\x0f\n\x07\x04\x18\x03\0\
    \x02\0\x03\x12\x04\xae\x04)*\n\x0e\n\x06\x04\x18\x03\0\x02\x01\x12\x04\
    \xaf\x04\x10+\n\x0f\n\x07\x04\x18\x03\0\x02\x01\x04\x12\x04\xaf\x04\x10\
    \x18\n\x0f\n\x07\x04\x18\x03\0\x02\x01\x05\x12\x04\xaf\x04\x19\x1f\n\x0f\
    \n\x07\x04\x18\x03\0\x02\x01\x01\x12\x04\xaf\x04\x20&\n\x0f\n\x07\x04\
    \x18\x03\0\x02\x01\x03\x12\x04\xaf\x04)*\n\x0e\n\x04\x04\x18\x03\x01\x12\
    \x06\xb2\x04\x08\xb4\x04\t\n\r\n\x05\x04\x18\x03\x01\x01\x12\x04\xb2\x04\
    \x10!\n\x0e\n\x06\x04\x18\x03\x01\x02\0\x12\x04\xb3\x04\x10M\n\x0f\n\x07\
    \x04\x18\x03\x01\x02\0\x04\x12\x04\xb3\x04\x10\x18\n\x0f\n\x07\x04\x18\
    \x03\x01\x02\0\x06\x12\x04\xb3\x04\x197\n\x0f\n\x07\x04\x18\x03\x01\x02\
    \0\x01\x12\x04\xb3\x048H\n\x0f\n\x07\x04\x18\x03\x01\x02\0\x03\x12\x04\
    \xb3\x04KL\n\x0c\n\x04\x04\x18\x02\0\x12\x04\xb6\x04\x080\n\r\n\x05\x04\
    \x18\x02\0\x04\x12\x04\xb6\x04\x08\x10\n\r\n\x05\x04\x18\x02\0\x06\x12\
    \x04\xb6\x04\x11$\n\r\n\x05\x04\x18\x02\0\x01\x12\x04\xb6\x04%+\n\r\n\
    \x05\x04\x18\x02\0\x03\x12\x04\xb6\x04./\n\x0c\n\x04\x04\x18\x02\x01\x12\
    \x04\xb7\x04\x08-\n\r\n\x05\x04\x18\x02\x01\x04\x12\x04\xb7\x04\x08\x10\
    \n\r\n\x05\x04\x18\x02\x01\x05\x12\x04\xb7\x04\x11\x17\n\r\n\x05\x04\x18\
    \x02\x01\x01\x12\x04\xb7\x04\x18(\n\r\n\x05\x04\x18\x02\x01\x03\x12\x04\
    \xb7\x04+,\n\x0c\n\x04\x04\x18\x02\x02\x12\x04\xb8\x04\x08+\n\r\n\x05\
    \x04\x18\x02\x02\x04\x12\x04\xb8\x04\x08\x10\n\r\n\x05\x04\x18\x02\x02\
    \x05\x12\x04\xb8\x04\x11\x17\n\r\n\x05\x04\x18\x02\x02\x01\x12\x04\xb8\
    \x04\x18&\n\r\n\x05\x04\x18\x02\x02\x03\x12\x04\xb8\x04)*\n\x0c\n\x04\
    \x04\x18\x02\x03\x12\x04\xb9\x04\x080\n\r\n\x05\x04\x18\x02\x03\x04\x12\
    \x04\xb9\x04\x08\x10\n\r\n\x05\x04\x18\x02\x03\x05\x12\x04\xb9\x04\x11\
    \x17\n\r\n\x05\x04\x18\x02\x03\x01\x12\x04\xb9\x04\x18+\n\r\n\x05\x04\
    \x18\x02\x03\x03\x12\x04\xb9\x04./\n\x0c\n\x04\x04\x18\x02\x04\x12\x04\
    \xba\x04\x08C\n\r\n\x05\x04\x18\x02\x04\x04\x12\x04\xba\x04\x08\x10\n\r\
    \n\x05\x04\x18\x02\x04\x06\x12\x04\xba\x04\x112\n\r\n\x05\x04\x18\x02\
    \x04\x01\x12\x04\xba\x043>\n\r\n\x05\x04\x18\x02\x04\x03\x12\x04\xba\x04\
    AB\n\x0c\n\x04\x04\x18\x02\x05\x12\x04\xbb\x04\x08G\n\r\n\x05\x04\x18\
    \x02\x05\x04\x12\x04\xbb\x04\x08\x10\n\r\n\x05\x04\x18\x02\x05\x06\x12\
    \x04\xbb\x04\x112\n\r\n\x05\x04\x18\x02\x05\x01\x12\x04\xbb\x043B\n\r\n\
    \x05\x04\x18\x02\x05\x03\x12\x04\xbb\x04EF\n\x0c\n\x04\x04\x18\x02\x06\
    \x12\x04\xbc\x04\x08M\n\r\n\x05\x04\x18\x02\x06\x04\x12\x04\xbc\x04\x08\
    \x10\n\r\n\x05\x04\x18\x02\x06\x06\x12\x04\xbc\x04\x112\n\r\n\x05\x04\
    \x18\x02\x06\x01\x12\x04\xbc\x043H\n\r\n\x05\x04\x18\x02\x06\x03\x12\x04\
    \xbc\x04KL\n\x0c\n\x04\x04\x18\x02\x07\x12\x04\xbd\x04\x08)\n\r\n\x05\
    \x04\x18\x02\x07\x04\x12\x04\xbd\x04\x08\x10\n\r\n\x05\x04\x18\x02\x07\
    \x05\x12\x04\xbd\x04\x11\x17\n\r\n\x05\x04\x18\x02\x07\x01\x12\x04\xbd\
    \x04\x18$\n\r\n\x05\x04\x18\x02\x07\x03\x12\x04\xbd\x04'(\n\x0c\n\x04\
    \x04\x18\x02\x08\x12\x04\xbe\x04\x08*\n\r\n\x05\x04\x18\x02\x08\x04\x12\
    \x04\xbe\x04\x08\x10\n\r\n\x05\x04\x18\x02\x08\x05\x12\x04\xbe\x04\x11\
    \x17\n\r\n\x05\x04\x18\x02\x08\x01\x12\x04\xbe\x04\x18%\n\r\n\x05\x04\
    \x18\x02\x08\x03\x12\x04\xbe\x04()\n\x0c\n\x04\x04\x18\x02\t\x12\x04\xbf\
    \x04\x08*\n\r\n\x05\x04\x18\x02\t\x04\x12\x04\xbf\x04\x08\x10\n\r\n\x05\
    \x04\x18\x02\t\x05\x12\x04\xbf\x04\x11\x17\n\r\n\x05\x04\x18\x02\t\x01\
    \x12\x04\xbf\x04\x18$\n\r\n\x05\x04\x18\x02\t\x03\x12\x04\xbf\x04')\n\
    \x0c\n\x02\x04\x19\x12\x06\xc2\x04\0\xc5\x04\x01\n\x0b\n\x03\x04\x19\x01\
    \x12\x04\xc2\x04\x08+\n\r\n\x04\x04\x19\x02\0\x12\x05\xc3\x04\x08\xbb\
    \x01\n\r\n\x05\x04\x19\x02\0\x04\x12\x04\xc3\x04\x08\x10\n\r\n\x05\x04\
    \x19\x02\0\x05\x12\x04\xc3\x04\x11\x17\n\r\n\x05\x04\x19\x02\0\x01\x12\
    \x04\xc3\x04\x181\n\r\n\x05\x04\x19\x02\0\x03\x12\x04\xc3\x0445\n\x0e\n\
    \x05\x04\x19\x02\0\x08\x12\x05\xc3\x046\xba\x01\n\r\n\x05\x04\x19\x02\0\
    \x07\x12\x04\xc3\x04AB\n\x10\n\x08\x04\x19\x02\0\x08\xf4\xa2\x04\x12\x04\
    \xc3\x04De\n\x11\n\x08\x04\x19\x02\0\x08\xf5\xa2\x04\x12\x05\xc3\x04g\
    \xb9\x01\n\r\n\x04\x04\x19\x02\x01\x12\x05\xc4\x04\x08\xc9\x01\n\r\n\x05\
    \x04\x19\x02\x01\x04\x12\x04\xc4\x04\x08\x10\n\r\n\x05\x04\x19\x02\x01\
    \x06\x12\x04\xc4\x04\x11\x20\n\r\n\x05\x04\x19\x02\x01\x01\x12\x04\xc4\
    \x04!2\n\r\n\x05\x04\x19\x02\x01\x03\x12\x04\xc4\x0456\n\x0e\n\x05\x04\
    \x19\x02\x01\x08\x12\x05\xc4\x047\xc8\x01\n\x10\n\x08\x04\x19\x02\x01\
    \x08\xf0\xa2\x04\x12\x04\xc4\x048^\n\x10\n\x08\x04\x19\x02\x01\x08\xf4\
    \xa2\x04\x12\x04\xc4\x04`~\n\x12\n\x08\x04\x19\x02\x01\x08\xf5\xa2\x04\
    \x12\x06\xc4\x04\x80\x01\xc7\x01\n\x0c\n\x02\x04\x1a\x12\x06\xc7\x04\0\
    \xca\x04\x01\n\x0b\n\x03\x04\x1a\x01\x12\x04\xc7\x04\x08'\n\x0c\n\x04\
    \x04\x1a\x02\0\x12\x04\xc8\x04\x08|\n\r\n\x05\x04\x1a\x02\0\x04\x12\x04\
    \xc8\x04\x08\x10\n\r\n\x05\x04\x1a\x02\0\x06\x12\x04\xc8\x04\x11\"\n\r\n\
    \x05\x04\x1a\x02\0\x01\x12\x04\xc8\x04#,\n\r\n\x05\x04\x1a\x02\0\x03\x12\
    \x04\xc8\x04/0\n\r\n\x05\x04\x1a\x02\0\x08\x12\x04\xc8\x041{\n\r\n\x05\
    \x04\x1a\x02\0\x07\x12\x04\xc8\x04<?\n\x10\n\x08\x04\x1a\x02\0\x08\xf4\
    \xa2\x04\x12\x04\xc8\x04AY\n\x10\n\x08\x04\x1a\x02\0\x08\xf5\xa2\x04\x12\
    \x04\xc8\x04[z\n\r\n\x04\x04\x1a\x02\x01\x12\x05\xc9\x04\x08\x98\x01\n\r\
    \n\x05\x04\x1a\x02\x01\x04\x12\x04\xc9\x04\x08\x10\n\r\n\x05\x04\x1a\x02\
    \x01\x06\x12\x04\xc9\x04\x11+\n\r\n\x05\x04\x1a\x02\x01\x01\x12\x04\xc9\
    \x04,:\n\r\n\x05\x04\x1a\x02\x01\x03\x12\x04\xc9\x04=>\n\x0e\n\x05\x04\
    \x1a\x02\x01\x08\x12\x05\xc9\x04?\x97\x01\n\x10\n\x08\x04\x1a\x02\x01\
    \x08\xf4\xa2\x04\x12\x04\xc9\x04@[\n\x11\n\x08\x04\x1a\x02\x01\x08\xf5\
    \xa2\x04\x12\x05\xc9\x04]\x96\x01\n\x0c\n\x02\x04\x1b\x12\x06\xcc\x04\0\
    \xd1\x04\x01\n\x0b\n\x03\x04\x1b\x01\x12\x04\xcc\x04\x08!\n\x0e\n\x04\
    \x04\x1b\x08\0\x12\x06\xcd\x04\x08\xd0\x04\t\n\r\n\x05\x04\x1b\x08\0\x01\
    \x12\x04\xcd\x04\x0e\x17\n\r\n\x04\x04\x1b\x02\0\x12\x05\xce\x04\x10\xbd\
    \x01\n\r\n\x05\x04\x1b\x02\0\x06\x12\x04\xce\x04\x104\n\r\n\x05\x04\x1b\
    \x02\0\x01\x12\x04\xce\x045?\n\r\n\x05\x04\x1b\x02\0\x03\x12\x04\xce\x04\
    BC\n\x0e\n\x05\x04\x1b\x02\0\x08\x12\x05\xce\x04D\xbc\x01\n\x10\n\x08\
    \x04\x1b\x02\0\x08\xf4\xa2\x04\x12\x04\xce\x04El\n\x11\n\x08\x04\x1b\x02\
    \0\x08\xf5\xa2\x04\x12\x05\xce\x04n\xbb\x01\n\r\n\x04\x04\x1b\x02\x01\
    \x12\x05\xcf\x04\x10\xb0\x01\n\r\n\x05\x04\x1b\x02\x01\x06\x12\x04\xcf\
    \x04\x100\n\r\n\x05\x04\x1b\x02\x01\x01\x12\x04\xcf\x0418\n\r\n\x05\x04\
    \x1b\x02\x01\x03\x12\x04\xcf\x04;<\n\x0e\n\x05\x04\x1b\x02\x01\x08\x12\
    \x05\xcf\x04=\xaf\x01\n\x10\n\x08\x04\x1b\x02\x01\x08\xf4\xa2\x04\x12\
    \x04\xcf\x04>b\n\x11\n\x08\x04\x1b\x02\x01\x08\xf5\xa2\x04\x12\x05\xcf\
    \x04d\xae\x01\n\x0c\n\x02\x04\x1c\x12\x06\xd3\x04\0\xd5\x04\x01\n\x0b\n\
    \x03\x04\x1c\x01\x12\x04\xd3\x04\x08\x16\n\x0c\n\x04\x04\x1c\x02\0\x12\
    \x04\xd4\x04\x080\n\r\n\x05\x04\x1c\x02\0\x04\x12\x04\xd4\x04\x08\x10\n\
    \r\n\x05\x04\x1c\x02\0\x06\x12\x04\xd4\x04\x11$\n\r\n\x05\x04\x1c\x02\0\
    \x01\x12\x04\xd4\x04%+\n\r\n\x05\x04\x1c\x02\0\x03\x12\x04\xd4\x04./\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
