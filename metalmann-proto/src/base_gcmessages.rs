// This file is generated by rust-protobuf 2.24.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `base_gcmessages.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_24_1;

#[derive(PartialEq,Clone,Default)]
pub struct CGCStorePurchaseInit_LineItem {
    // message fields
    item_def_id: ::std::option::Option<u32>,
    quantity: ::std::option::Option<u32>,
    cost_in_local_currency: ::std::option::Option<u32>,
    purchase_type: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CGCStorePurchaseInit_LineItem {
    fn default() -> &'a CGCStorePurchaseInit_LineItem {
        <CGCStorePurchaseInit_LineItem as ::protobuf::Message>::default_instance()
    }
}

impl CGCStorePurchaseInit_LineItem {
    pub fn new() -> CGCStorePurchaseInit_LineItem {
        ::std::default::Default::default()
    }

    // optional uint32 item_def_id = 1;


    pub fn get_item_def_id(&self) -> u32 {
        self.item_def_id.unwrap_or(0)
    }
    pub fn clear_item_def_id(&mut self) {
        self.item_def_id = ::std::option::Option::None;
    }

    pub fn has_item_def_id(&self) -> bool {
        self.item_def_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_def_id(&mut self, v: u32) {
        self.item_def_id = ::std::option::Option::Some(v);
    }

    // optional uint32 quantity = 2;


    pub fn get_quantity(&self) -> u32 {
        self.quantity.unwrap_or(0)
    }
    pub fn clear_quantity(&mut self) {
        self.quantity = ::std::option::Option::None;
    }

    pub fn has_quantity(&self) -> bool {
        self.quantity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quantity(&mut self, v: u32) {
        self.quantity = ::std::option::Option::Some(v);
    }

    // optional uint32 cost_in_local_currency = 3;


    pub fn get_cost_in_local_currency(&self) -> u32 {
        self.cost_in_local_currency.unwrap_or(0)
    }
    pub fn clear_cost_in_local_currency(&mut self) {
        self.cost_in_local_currency = ::std::option::Option::None;
    }

    pub fn has_cost_in_local_currency(&self) -> bool {
        self.cost_in_local_currency.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cost_in_local_currency(&mut self, v: u32) {
        self.cost_in_local_currency = ::std::option::Option::Some(v);
    }

    // optional uint32 purchase_type = 4;


    pub fn get_purchase_type(&self) -> u32 {
        self.purchase_type.unwrap_or(0)
    }
    pub fn clear_purchase_type(&mut self) {
        self.purchase_type = ::std::option::Option::None;
    }

    pub fn has_purchase_type(&self) -> bool {
        self.purchase_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_purchase_type(&mut self, v: u32) {
        self.purchase_type = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CGCStorePurchaseInit_LineItem {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.item_def_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.quantity = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.cost_in_local_currency = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.purchase_type = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.item_def_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.quantity {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.cost_in_local_currency {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.purchase_type {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.item_def_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.quantity {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.cost_in_local_currency {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.purchase_type {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CGCStorePurchaseInit_LineItem {
        CGCStorePurchaseInit_LineItem::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "item_def_id",
                |m: &CGCStorePurchaseInit_LineItem| { &m.item_def_id },
                |m: &mut CGCStorePurchaseInit_LineItem| { &mut m.item_def_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "quantity",
                |m: &CGCStorePurchaseInit_LineItem| { &m.quantity },
                |m: &mut CGCStorePurchaseInit_LineItem| { &mut m.quantity },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "cost_in_local_currency",
                |m: &CGCStorePurchaseInit_LineItem| { &m.cost_in_local_currency },
                |m: &mut CGCStorePurchaseInit_LineItem| { &mut m.cost_in_local_currency },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "purchase_type",
                |m: &CGCStorePurchaseInit_LineItem| { &m.purchase_type },
                |m: &mut CGCStorePurchaseInit_LineItem| { &mut m.purchase_type },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CGCStorePurchaseInit_LineItem>(
                "CGCStorePurchaseInit_LineItem",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CGCStorePurchaseInit_LineItem {
        static instance: ::protobuf::rt::LazyV2<CGCStorePurchaseInit_LineItem> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CGCStorePurchaseInit_LineItem::new)
    }
}

impl ::protobuf::Clear for CGCStorePurchaseInit_LineItem {
    fn clear(&mut self) {
        self.item_def_id = ::std::option::Option::None;
        self.quantity = ::std::option::Option::None;
        self.cost_in_local_currency = ::std::option::Option::None;
        self.purchase_type = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CGCStorePurchaseInit_LineItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CGCStorePurchaseInit_LineItem {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCStorePurchaseInit {
    // message fields
    country: ::protobuf::SingularField<::std::string::String>,
    language: ::std::option::Option<i32>,
    currency: ::std::option::Option<i32>,
    pub line_items: ::protobuf::RepeatedField<CGCStorePurchaseInit_LineItem>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCStorePurchaseInit {
    fn default() -> &'a CMsgGCStorePurchaseInit {
        <CMsgGCStorePurchaseInit as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCStorePurchaseInit {
    pub fn new() -> CMsgGCStorePurchaseInit {
        ::std::default::Default::default()
    }

    // optional string country = 1;


    pub fn get_country(&self) -> &str {
        match self.country.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_country(&mut self) {
        self.country.clear();
    }

    pub fn has_country(&self) -> bool {
        self.country.is_some()
    }

    // Param is passed by value, moved
    pub fn set_country(&mut self, v: ::std::string::String) {
        self.country = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_country(&mut self) -> &mut ::std::string::String {
        if self.country.is_none() {
            self.country.set_default();
        }
        self.country.as_mut().unwrap()
    }

    // Take field
    pub fn take_country(&mut self) -> ::std::string::String {
        self.country.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 language = 2;


    pub fn get_language(&self) -> i32 {
        self.language.unwrap_or(0)
    }
    pub fn clear_language(&mut self) {
        self.language = ::std::option::Option::None;
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: i32) {
        self.language = ::std::option::Option::Some(v);
    }

    // optional int32 currency = 3;


    pub fn get_currency(&self) -> i32 {
        self.currency.unwrap_or(0)
    }
    pub fn clear_currency(&mut self) {
        self.currency = ::std::option::Option::None;
    }

    pub fn has_currency(&self) -> bool {
        self.currency.is_some()
    }

    // Param is passed by value, moved
    pub fn set_currency(&mut self, v: i32) {
        self.currency = ::std::option::Option::Some(v);
    }

    // repeated .CGCStorePurchaseInit_LineItem line_items = 4;


    pub fn get_line_items(&self) -> &[CGCStorePurchaseInit_LineItem] {
        &self.line_items
    }
    pub fn clear_line_items(&mut self) {
        self.line_items.clear();
    }

    // Param is passed by value, moved
    pub fn set_line_items(&mut self, v: ::protobuf::RepeatedField<CGCStorePurchaseInit_LineItem>) {
        self.line_items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_line_items(&mut self) -> &mut ::protobuf::RepeatedField<CGCStorePurchaseInit_LineItem> {
        &mut self.line_items
    }

    // Take field
    pub fn take_line_items(&mut self) -> ::protobuf::RepeatedField<CGCStorePurchaseInit_LineItem> {
        ::std::mem::replace(&mut self.line_items, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgGCStorePurchaseInit {
    fn is_initialized(&self) -> bool {
        for v in &self.line_items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.country)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.language = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.currency = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.line_items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.country.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.language {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.currency {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.line_items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.country.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.language {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.currency {
            os.write_int32(3, v)?;
        }
        for v in &self.line_items {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCStorePurchaseInit {
        CMsgGCStorePurchaseInit::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "country",
                |m: &CMsgGCStorePurchaseInit| { &m.country },
                |m: &mut CMsgGCStorePurchaseInit| { &mut m.country },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "language",
                |m: &CMsgGCStorePurchaseInit| { &m.language },
                |m: &mut CMsgGCStorePurchaseInit| { &mut m.language },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "currency",
                |m: &CMsgGCStorePurchaseInit| { &m.currency },
                |m: &mut CMsgGCStorePurchaseInit| { &mut m.currency },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CGCStorePurchaseInit_LineItem>>(
                "line_items",
                |m: &CMsgGCStorePurchaseInit| { &m.line_items },
                |m: &mut CMsgGCStorePurchaseInit| { &mut m.line_items },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCStorePurchaseInit>(
                "CMsgGCStorePurchaseInit",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCStorePurchaseInit {
        static instance: ::protobuf::rt::LazyV2<CMsgGCStorePurchaseInit> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCStorePurchaseInit::new)
    }
}

impl ::protobuf::Clear for CMsgGCStorePurchaseInit {
    fn clear(&mut self) {
        self.country.clear();
        self.language = ::std::option::Option::None;
        self.currency = ::std::option::Option::None;
        self.line_items.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCStorePurchaseInit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCStorePurchaseInit {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCStorePurchaseInitResponse {
    // message fields
    result: ::std::option::Option<i32>,
    txn_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCStorePurchaseInitResponse {
    fn default() -> &'a CMsgGCStorePurchaseInitResponse {
        <CMsgGCStorePurchaseInitResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCStorePurchaseInitResponse {
    pub fn new() -> CMsgGCStorePurchaseInitResponse {
        ::std::default::Default::default()
    }

    // optional int32 result = 1;


    pub fn get_result(&self) -> i32 {
        self.result.unwrap_or(0)
    }
    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: i32) {
        self.result = ::std::option::Option::Some(v);
    }

    // optional uint64 txn_id = 2;


    pub fn get_txn_id(&self) -> u64 {
        self.txn_id.unwrap_or(0)
    }
    pub fn clear_txn_id(&mut self) {
        self.txn_id = ::std::option::Option::None;
    }

    pub fn has_txn_id(&self) -> bool {
        self.txn_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txn_id(&mut self, v: u64) {
        self.txn_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCStorePurchaseInitResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.txn_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.txn_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.txn_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCStorePurchaseInitResponse {
        CMsgGCStorePurchaseInitResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "result",
                |m: &CMsgGCStorePurchaseInitResponse| { &m.result },
                |m: &mut CMsgGCStorePurchaseInitResponse| { &mut m.result },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "txn_id",
                |m: &CMsgGCStorePurchaseInitResponse| { &m.txn_id },
                |m: &mut CMsgGCStorePurchaseInitResponse| { &mut m.txn_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCStorePurchaseInitResponse>(
                "CMsgGCStorePurchaseInitResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCStorePurchaseInitResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgGCStorePurchaseInitResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCStorePurchaseInitResponse::new)
    }
}

impl ::protobuf::Clear for CMsgGCStorePurchaseInitResponse {
    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.txn_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCStorePurchaseInitResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCStorePurchaseInitResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSystemBroadcast {
    // message fields
    message: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSystemBroadcast {
    fn default() -> &'a CMsgSystemBroadcast {
        <CMsgSystemBroadcast as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSystemBroadcast {
    pub fn new() -> CMsgSystemBroadcast {
        ::std::default::Default::default()
    }

    // optional string message = 1;


    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgSystemBroadcast {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.message.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSystemBroadcast {
        CMsgSystemBroadcast::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message",
                |m: &CMsgSystemBroadcast| { &m.message },
                |m: &mut CMsgSystemBroadcast| { &mut m.message },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSystemBroadcast>(
                "CMsgSystemBroadcast",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSystemBroadcast {
        static instance: ::protobuf::rt::LazyV2<CMsgSystemBroadcast> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSystemBroadcast::new)
    }
}

impl ::protobuf::Clear for CMsgSystemBroadcast {
    fn clear(&mut self) {
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSystemBroadcast {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSystemBroadcast {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientHello {
    // message fields
    version: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientHello {
    fn default() -> &'a CMsgClientHello {
        <CMsgClientHello as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientHello {
    pub fn new() -> CMsgClientHello {
        ::std::default::Default::default()
    }

    // optional uint32 version = 1;


    pub fn get_version(&self) -> u32 {
        self.version.unwrap_or(0)
    }
    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u32) {
        self.version = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientHello {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.version = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.version {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientHello {
        CMsgClientHello::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "version",
                |m: &CMsgClientHello| { &m.version },
                |m: &mut CMsgClientHello| { &mut m.version },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientHello>(
                "CMsgClientHello",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientHello {
        static instance: ::protobuf::rt::LazyV2<CMsgClientHello> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientHello::new)
    }
}

impl ::protobuf::Clear for CMsgClientHello {
    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientHello {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientHello {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgServerHello {
    // message fields
    version: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgServerHello {
    fn default() -> &'a CMsgServerHello {
        <CMsgServerHello as ::protobuf::Message>::default_instance()
    }
}

impl CMsgServerHello {
    pub fn new() -> CMsgServerHello {
        ::std::default::Default::default()
    }

    // optional uint32 version = 1;


    pub fn get_version(&self) -> u32 {
        self.version.unwrap_or(0)
    }
    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u32) {
        self.version = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgServerHello {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.version = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.version {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgServerHello {
        CMsgServerHello::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "version",
                |m: &CMsgServerHello| { &m.version },
                |m: &mut CMsgServerHello| { &mut m.version },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgServerHello>(
                "CMsgServerHello",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgServerHello {
        static instance: ::protobuf::rt::LazyV2<CMsgServerHello> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgServerHello::new)
    }
}

impl ::protobuf::Clear for CMsgServerHello {
    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgServerHello {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgServerHello {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientWelcome {
    // message fields
    version: ::std::option::Option<u32>,
    game_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    txn_country_code: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientWelcome {
    fn default() -> &'a CMsgClientWelcome {
        <CMsgClientWelcome as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientWelcome {
    pub fn new() -> CMsgClientWelcome {
        ::std::default::Default::default()
    }

    // optional uint32 version = 1;


    pub fn get_version(&self) -> u32 {
        self.version.unwrap_or(0)
    }
    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u32) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional bytes game_data = 2;


    pub fn get_game_data(&self) -> &[u8] {
        match self.game_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_game_data(&mut self) {
        self.game_data.clear();
    }

    pub fn has_game_data(&self) -> bool {
        self.game_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.game_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.game_data.is_none() {
            self.game_data.set_default();
        }
        self.game_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_data(&mut self) -> ::std::vec::Vec<u8> {
        self.game_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string txn_country_code = 3;


    pub fn get_txn_country_code(&self) -> &str {
        match self.txn_country_code.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_txn_country_code(&mut self) {
        self.txn_country_code.clear();
    }

    pub fn has_txn_country_code(&self) -> bool {
        self.txn_country_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txn_country_code(&mut self, v: ::std::string::String) {
        self.txn_country_code = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_txn_country_code(&mut self) -> &mut ::std::string::String {
        if self.txn_country_code.is_none() {
            self.txn_country_code.set_default();
        }
        self.txn_country_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_txn_country_code(&mut self) -> ::std::string::String {
        self.txn_country_code.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgClientWelcome {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.version = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.game_data)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.txn_country_code)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.game_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(ref v) = self.txn_country_code.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.version {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.game_data.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(ref v) = self.txn_country_code.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientWelcome {
        CMsgClientWelcome::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "version",
                |m: &CMsgClientWelcome| { &m.version },
                |m: &mut CMsgClientWelcome| { &mut m.version },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "game_data",
                |m: &CMsgClientWelcome| { &m.game_data },
                |m: &mut CMsgClientWelcome| { &mut m.game_data },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "txn_country_code",
                |m: &CMsgClientWelcome| { &m.txn_country_code },
                |m: &mut CMsgClientWelcome| { &mut m.txn_country_code },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientWelcome>(
                "CMsgClientWelcome",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientWelcome {
        static instance: ::protobuf::rt::LazyV2<CMsgClientWelcome> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientWelcome::new)
    }
}

impl ::protobuf::Clear for CMsgClientWelcome {
    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.game_data.clear();
        self.txn_country_code.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientWelcome {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientWelcome {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgServerWelcome {
    // message fields
    min_allowed_version: ::std::option::Option<u32>,
    active_version: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgServerWelcome {
    fn default() -> &'a CMsgServerWelcome {
        <CMsgServerWelcome as ::protobuf::Message>::default_instance()
    }
}

impl CMsgServerWelcome {
    pub fn new() -> CMsgServerWelcome {
        ::std::default::Default::default()
    }

    // optional uint32 min_allowed_version = 1;


    pub fn get_min_allowed_version(&self) -> u32 {
        self.min_allowed_version.unwrap_or(0)
    }
    pub fn clear_min_allowed_version(&mut self) {
        self.min_allowed_version = ::std::option::Option::None;
    }

    pub fn has_min_allowed_version(&self) -> bool {
        self.min_allowed_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_min_allowed_version(&mut self, v: u32) {
        self.min_allowed_version = ::std::option::Option::Some(v);
    }

    // optional uint32 active_version = 2;


    pub fn get_active_version(&self) -> u32 {
        self.active_version.unwrap_or(0)
    }
    pub fn clear_active_version(&mut self) {
        self.active_version = ::std::option::Option::None;
    }

    pub fn has_active_version(&self) -> bool {
        self.active_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_active_version(&mut self, v: u32) {
        self.active_version = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgServerWelcome {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.min_allowed_version = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.active_version = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.min_allowed_version {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.active_version {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.min_allowed_version {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.active_version {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgServerWelcome {
        CMsgServerWelcome::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "min_allowed_version",
                |m: &CMsgServerWelcome| { &m.min_allowed_version },
                |m: &mut CMsgServerWelcome| { &mut m.min_allowed_version },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "active_version",
                |m: &CMsgServerWelcome| { &m.active_version },
                |m: &mut CMsgServerWelcome| { &mut m.active_version },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgServerWelcome>(
                "CMsgServerWelcome",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgServerWelcome {
        static instance: ::protobuf::rt::LazyV2<CMsgServerWelcome> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgServerWelcome::new)
    }
}

impl ::protobuf::Clear for CMsgServerWelcome {
    fn clear(&mut self) {
        self.min_allowed_version = ::std::option::Option::None;
        self.active_version = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgServerWelcome {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgServerWelcome {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgClientGoodbye {
    // message fields
    reason: ::std::option::Option<GCGoodbyeReason>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientGoodbye {
    fn default() -> &'a CMsgClientGoodbye {
        <CMsgClientGoodbye as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientGoodbye {
    pub fn new() -> CMsgClientGoodbye {
        ::std::default::Default::default()
    }

    // optional .GCGoodbyeReason reason = 1;


    pub fn get_reason(&self) -> GCGoodbyeReason {
        self.reason.unwrap_or(GCGoodbyeReason::GCGoodbyeReason_GC_GOING_DOWN)
    }
    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: GCGoodbyeReason) {
        self.reason = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientGoodbye {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.reason, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.reason {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.reason {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientGoodbye {
        CMsgClientGoodbye::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<GCGoodbyeReason>>(
                "reason",
                |m: &CMsgClientGoodbye| { &m.reason },
                |m: &mut CMsgClientGoodbye| { &mut m.reason },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientGoodbye>(
                "CMsgClientGoodbye",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientGoodbye {
        static instance: ::protobuf::rt::LazyV2<CMsgClientGoodbye> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientGoodbye::new)
    }
}

impl ::protobuf::Clear for CMsgClientGoodbye {
    fn clear(&mut self) {
        self.reason = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientGoodbye {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientGoodbye {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgServerGoodbye {
    // message fields
    reason: ::std::option::Option<GCGoodbyeReason>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgServerGoodbye {
    fn default() -> &'a CMsgServerGoodbye {
        <CMsgServerGoodbye as ::protobuf::Message>::default_instance()
    }
}

impl CMsgServerGoodbye {
    pub fn new() -> CMsgServerGoodbye {
        ::std::default::Default::default()
    }

    // optional .GCGoodbyeReason reason = 1;


    pub fn get_reason(&self) -> GCGoodbyeReason {
        self.reason.unwrap_or(GCGoodbyeReason::GCGoodbyeReason_GC_GOING_DOWN)
    }
    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: GCGoodbyeReason) {
        self.reason = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgServerGoodbye {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.reason, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.reason {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.reason {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgServerGoodbye {
        CMsgServerGoodbye::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<GCGoodbyeReason>>(
                "reason",
                |m: &CMsgServerGoodbye| { &m.reason },
                |m: &mut CMsgServerGoodbye| { &mut m.reason },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgServerGoodbye>(
                "CMsgServerGoodbye",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgServerGoodbye {
        static instance: ::protobuf::rt::LazyV2<CMsgServerGoodbye> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgServerGoodbye::new)
    }
}

impl ::protobuf::Clear for CMsgServerGoodbye {
    fn clear(&mut self) {
        self.reason = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgServerGoodbye {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgServerGoodbye {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgServerAvailable {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgServerAvailable {
    fn default() -> &'a CMsgServerAvailable {
        <CMsgServerAvailable as ::protobuf::Message>::default_instance()
    }
}

impl CMsgServerAvailable {
    pub fn new() -> CMsgServerAvailable {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgServerAvailable {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgServerAvailable {
        CMsgServerAvailable::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgServerAvailable>(
                "CMsgServerAvailable",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgServerAvailable {
        static instance: ::protobuf::rt::LazyV2<CMsgServerAvailable> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgServerAvailable::new)
    }
}

impl ::protobuf::Clear for CMsgServerAvailable {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgServerAvailable {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgServerAvailable {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgLANServerAvailable {
    // message fields
    lobby_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgLANServerAvailable {
    fn default() -> &'a CMsgLANServerAvailable {
        <CMsgLANServerAvailable as ::protobuf::Message>::default_instance()
    }
}

impl CMsgLANServerAvailable {
    pub fn new() -> CMsgLANServerAvailable {
        ::std::default::Default::default()
    }

    // optional fixed64 lobby_id = 1;


    pub fn get_lobby_id(&self) -> u64 {
        self.lobby_id.unwrap_or(0)
    }
    pub fn clear_lobby_id(&mut self) {
        self.lobby_id = ::std::option::Option::None;
    }

    pub fn has_lobby_id(&self) -> bool {
        self.lobby_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_id(&mut self, v: u64) {
        self.lobby_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgLANServerAvailable {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.lobby_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.lobby_id {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.lobby_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgLANServerAvailable {
        CMsgLANServerAvailable::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "lobby_id",
                |m: &CMsgLANServerAvailable| { &m.lobby_id },
                |m: &mut CMsgLANServerAvailable| { &mut m.lobby_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgLANServerAvailable>(
                "CMsgLANServerAvailable",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgLANServerAvailable {
        static instance: ::protobuf::rt::LazyV2<CMsgLANServerAvailable> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgLANServerAvailable::new)
    }
}

impl ::protobuf::Clear for CMsgLANServerAvailable {
    fn clear(&mut self) {
        self.lobby_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgLANServerAvailable {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgLANServerAvailable {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CSOEconGameAccountClient {
    // message fields
    additional_backpack_slots: ::std::option::Option<u32>,
    trial_account: ::std::option::Option<bool>,
    need_to_choose_most_helpful_friend: ::std::option::Option<bool>,
    in_coaches_list: ::std::option::Option<bool>,
    trade_ban_expiration: ::std::option::Option<u32>,
    duel_ban_expiration: ::std::option::Option<u32>,
    preview_item_def: ::std::option::Option<u32>,
    phone_verified: ::std::option::Option<bool>,
    skill_rating_6v6: ::std::option::Option<u32>,
    skill_rating_9v9: ::std::option::Option<u32>,
    competitive_access: ::std::option::Option<bool>,
    matchmaking_ranked_ban_expiration: ::std::option::Option<u32>,
    matchmaking_ranked_low_priority_expiration: ::std::option::Option<u32>,
    matchmaking_ranked_ban_last_duration: ::std::option::Option<u32>,
    matchmaking_ranked_low_priority_last_duration: ::std::option::Option<u32>,
    matchmaking_casual_ban_expiration: ::std::option::Option<u32>,
    matchmaking_casual_low_priority_expiration: ::std::option::Option<u32>,
    matchmaking_casual_ban_last_duration: ::std::option::Option<u32>,
    matchmaking_casual_low_priority_last_duration: ::std::option::Option<u32>,
    phone_identifying: ::std::option::Option<bool>,
    disable_party_quest_progress: ::std::option::Option<bool>,
    quest_reward_credits: ::std::option::Option<u32>,
    matchmaking_last_casual_excessive_reports_auto_ban_time: ::std::option::Option<u32>,
    matchmaking_last_comp_excessive_reports_auto_ban_time: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CSOEconGameAccountClient {
    fn default() -> &'a CSOEconGameAccountClient {
        <CSOEconGameAccountClient as ::protobuf::Message>::default_instance()
    }
}

impl CSOEconGameAccountClient {
    pub fn new() -> CSOEconGameAccountClient {
        ::std::default::Default::default()
    }

    // optional uint32 additional_backpack_slots = 1;


    pub fn get_additional_backpack_slots(&self) -> u32 {
        self.additional_backpack_slots.unwrap_or(0u32)
    }
    pub fn clear_additional_backpack_slots(&mut self) {
        self.additional_backpack_slots = ::std::option::Option::None;
    }

    pub fn has_additional_backpack_slots(&self) -> bool {
        self.additional_backpack_slots.is_some()
    }

    // Param is passed by value, moved
    pub fn set_additional_backpack_slots(&mut self, v: u32) {
        self.additional_backpack_slots = ::std::option::Option::Some(v);
    }

    // optional bool trial_account = 2;


    pub fn get_trial_account(&self) -> bool {
        self.trial_account.unwrap_or(false)
    }
    pub fn clear_trial_account(&mut self) {
        self.trial_account = ::std::option::Option::None;
    }

    pub fn has_trial_account(&self) -> bool {
        self.trial_account.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trial_account(&mut self, v: bool) {
        self.trial_account = ::std::option::Option::Some(v);
    }

    // optional bool need_to_choose_most_helpful_friend = 4;


    pub fn get_need_to_choose_most_helpful_friend(&self) -> bool {
        self.need_to_choose_most_helpful_friend.unwrap_or(false)
    }
    pub fn clear_need_to_choose_most_helpful_friend(&mut self) {
        self.need_to_choose_most_helpful_friend = ::std::option::Option::None;
    }

    pub fn has_need_to_choose_most_helpful_friend(&self) -> bool {
        self.need_to_choose_most_helpful_friend.is_some()
    }

    // Param is passed by value, moved
    pub fn set_need_to_choose_most_helpful_friend(&mut self, v: bool) {
        self.need_to_choose_most_helpful_friend = ::std::option::Option::Some(v);
    }

    // optional bool in_coaches_list = 5;


    pub fn get_in_coaches_list(&self) -> bool {
        self.in_coaches_list.unwrap_or(false)
    }
    pub fn clear_in_coaches_list(&mut self) {
        self.in_coaches_list = ::std::option::Option::None;
    }

    pub fn has_in_coaches_list(&self) -> bool {
        self.in_coaches_list.is_some()
    }

    // Param is passed by value, moved
    pub fn set_in_coaches_list(&mut self, v: bool) {
        self.in_coaches_list = ::std::option::Option::Some(v);
    }

    // optional fixed32 trade_ban_expiration = 6;


    pub fn get_trade_ban_expiration(&self) -> u32 {
        self.trade_ban_expiration.unwrap_or(0)
    }
    pub fn clear_trade_ban_expiration(&mut self) {
        self.trade_ban_expiration = ::std::option::Option::None;
    }

    pub fn has_trade_ban_expiration(&self) -> bool {
        self.trade_ban_expiration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trade_ban_expiration(&mut self, v: u32) {
        self.trade_ban_expiration = ::std::option::Option::Some(v);
    }

    // optional fixed32 duel_ban_expiration = 7;


    pub fn get_duel_ban_expiration(&self) -> u32 {
        self.duel_ban_expiration.unwrap_or(0)
    }
    pub fn clear_duel_ban_expiration(&mut self) {
        self.duel_ban_expiration = ::std::option::Option::None;
    }

    pub fn has_duel_ban_expiration(&self) -> bool {
        self.duel_ban_expiration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duel_ban_expiration(&mut self, v: u32) {
        self.duel_ban_expiration = ::std::option::Option::Some(v);
    }

    // optional uint32 preview_item_def = 8;


    pub fn get_preview_item_def(&self) -> u32 {
        self.preview_item_def.unwrap_or(0u32)
    }
    pub fn clear_preview_item_def(&mut self) {
        self.preview_item_def = ::std::option::Option::None;
    }

    pub fn has_preview_item_def(&self) -> bool {
        self.preview_item_def.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preview_item_def(&mut self, v: u32) {
        self.preview_item_def = ::std::option::Option::Some(v);
    }

    // optional bool phone_verified = 19;


    pub fn get_phone_verified(&self) -> bool {
        self.phone_verified.unwrap_or(false)
    }
    pub fn clear_phone_verified(&mut self) {
        self.phone_verified = ::std::option::Option::None;
    }

    pub fn has_phone_verified(&self) -> bool {
        self.phone_verified.is_some()
    }

    // Param is passed by value, moved
    pub fn set_phone_verified(&mut self, v: bool) {
        self.phone_verified = ::std::option::Option::Some(v);
    }

    // optional uint32 skill_rating_6v6 = 20;


    pub fn get_skill_rating_6v6(&self) -> u32 {
        self.skill_rating_6v6.unwrap_or(0)
    }
    pub fn clear_skill_rating_6v6(&mut self) {
        self.skill_rating_6v6 = ::std::option::Option::None;
    }

    pub fn has_skill_rating_6v6(&self) -> bool {
        self.skill_rating_6v6.is_some()
    }

    // Param is passed by value, moved
    pub fn set_skill_rating_6v6(&mut self, v: u32) {
        self.skill_rating_6v6 = ::std::option::Option::Some(v);
    }

    // optional uint32 skill_rating_9v9 = 21;


    pub fn get_skill_rating_9v9(&self) -> u32 {
        self.skill_rating_9v9.unwrap_or(0)
    }
    pub fn clear_skill_rating_9v9(&mut self) {
        self.skill_rating_9v9 = ::std::option::Option::None;
    }

    pub fn has_skill_rating_9v9(&self) -> bool {
        self.skill_rating_9v9.is_some()
    }

    // Param is passed by value, moved
    pub fn set_skill_rating_9v9(&mut self, v: u32) {
        self.skill_rating_9v9 = ::std::option::Option::Some(v);
    }

    // optional bool competitive_access = 23;


    pub fn get_competitive_access(&self) -> bool {
        self.competitive_access.unwrap_or(false)
    }
    pub fn clear_competitive_access(&mut self) {
        self.competitive_access = ::std::option::Option::None;
    }

    pub fn has_competitive_access(&self) -> bool {
        self.competitive_access.is_some()
    }

    // Param is passed by value, moved
    pub fn set_competitive_access(&mut self, v: bool) {
        self.competitive_access = ::std::option::Option::Some(v);
    }

    // optional uint32 matchmaking_ranked_ban_expiration = 18;


    pub fn get_matchmaking_ranked_ban_expiration(&self) -> u32 {
        self.matchmaking_ranked_ban_expiration.unwrap_or(0)
    }
    pub fn clear_matchmaking_ranked_ban_expiration(&mut self) {
        self.matchmaking_ranked_ban_expiration = ::std::option::Option::None;
    }

    pub fn has_matchmaking_ranked_ban_expiration(&self) -> bool {
        self.matchmaking_ranked_ban_expiration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matchmaking_ranked_ban_expiration(&mut self, v: u32) {
        self.matchmaking_ranked_ban_expiration = ::std::option::Option::Some(v);
    }

    // optional uint32 matchmaking_ranked_low_priority_expiration = 24;


    pub fn get_matchmaking_ranked_low_priority_expiration(&self) -> u32 {
        self.matchmaking_ranked_low_priority_expiration.unwrap_or(0)
    }
    pub fn clear_matchmaking_ranked_low_priority_expiration(&mut self) {
        self.matchmaking_ranked_low_priority_expiration = ::std::option::Option::None;
    }

    pub fn has_matchmaking_ranked_low_priority_expiration(&self) -> bool {
        self.matchmaking_ranked_low_priority_expiration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matchmaking_ranked_low_priority_expiration(&mut self, v: u32) {
        self.matchmaking_ranked_low_priority_expiration = ::std::option::Option::Some(v);
    }

    // optional uint32 matchmaking_ranked_ban_last_duration = 25;


    pub fn get_matchmaking_ranked_ban_last_duration(&self) -> u32 {
        self.matchmaking_ranked_ban_last_duration.unwrap_or(0)
    }
    pub fn clear_matchmaking_ranked_ban_last_duration(&mut self) {
        self.matchmaking_ranked_ban_last_duration = ::std::option::Option::None;
    }

    pub fn has_matchmaking_ranked_ban_last_duration(&self) -> bool {
        self.matchmaking_ranked_ban_last_duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matchmaking_ranked_ban_last_duration(&mut self, v: u32) {
        self.matchmaking_ranked_ban_last_duration = ::std::option::Option::Some(v);
    }

    // optional uint32 matchmaking_ranked_low_priority_last_duration = 26;


    pub fn get_matchmaking_ranked_low_priority_last_duration(&self) -> u32 {
        self.matchmaking_ranked_low_priority_last_duration.unwrap_or(0)
    }
    pub fn clear_matchmaking_ranked_low_priority_last_duration(&mut self) {
        self.matchmaking_ranked_low_priority_last_duration = ::std::option::Option::None;
    }

    pub fn has_matchmaking_ranked_low_priority_last_duration(&self) -> bool {
        self.matchmaking_ranked_low_priority_last_duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matchmaking_ranked_low_priority_last_duration(&mut self, v: u32) {
        self.matchmaking_ranked_low_priority_last_duration = ::std::option::Option::Some(v);
    }

    // optional uint32 matchmaking_casual_ban_expiration = 27;


    pub fn get_matchmaking_casual_ban_expiration(&self) -> u32 {
        self.matchmaking_casual_ban_expiration.unwrap_or(0)
    }
    pub fn clear_matchmaking_casual_ban_expiration(&mut self) {
        self.matchmaking_casual_ban_expiration = ::std::option::Option::None;
    }

    pub fn has_matchmaking_casual_ban_expiration(&self) -> bool {
        self.matchmaking_casual_ban_expiration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matchmaking_casual_ban_expiration(&mut self, v: u32) {
        self.matchmaking_casual_ban_expiration = ::std::option::Option::Some(v);
    }

    // optional uint32 matchmaking_casual_low_priority_expiration = 28;


    pub fn get_matchmaking_casual_low_priority_expiration(&self) -> u32 {
        self.matchmaking_casual_low_priority_expiration.unwrap_or(0)
    }
    pub fn clear_matchmaking_casual_low_priority_expiration(&mut self) {
        self.matchmaking_casual_low_priority_expiration = ::std::option::Option::None;
    }

    pub fn has_matchmaking_casual_low_priority_expiration(&self) -> bool {
        self.matchmaking_casual_low_priority_expiration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matchmaking_casual_low_priority_expiration(&mut self, v: u32) {
        self.matchmaking_casual_low_priority_expiration = ::std::option::Option::Some(v);
    }

    // optional uint32 matchmaking_casual_ban_last_duration = 29;


    pub fn get_matchmaking_casual_ban_last_duration(&self) -> u32 {
        self.matchmaking_casual_ban_last_duration.unwrap_or(0)
    }
    pub fn clear_matchmaking_casual_ban_last_duration(&mut self) {
        self.matchmaking_casual_ban_last_duration = ::std::option::Option::None;
    }

    pub fn has_matchmaking_casual_ban_last_duration(&self) -> bool {
        self.matchmaking_casual_ban_last_duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matchmaking_casual_ban_last_duration(&mut self, v: u32) {
        self.matchmaking_casual_ban_last_duration = ::std::option::Option::Some(v);
    }

    // optional uint32 matchmaking_casual_low_priority_last_duration = 30;


    pub fn get_matchmaking_casual_low_priority_last_duration(&self) -> u32 {
        self.matchmaking_casual_low_priority_last_duration.unwrap_or(0)
    }
    pub fn clear_matchmaking_casual_low_priority_last_duration(&mut self) {
        self.matchmaking_casual_low_priority_last_duration = ::std::option::Option::None;
    }

    pub fn has_matchmaking_casual_low_priority_last_duration(&self) -> bool {
        self.matchmaking_casual_low_priority_last_duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matchmaking_casual_low_priority_last_duration(&mut self, v: u32) {
        self.matchmaking_casual_low_priority_last_duration = ::std::option::Option::Some(v);
    }

    // optional bool phone_identifying = 31;


    pub fn get_phone_identifying(&self) -> bool {
        self.phone_identifying.unwrap_or(false)
    }
    pub fn clear_phone_identifying(&mut self) {
        self.phone_identifying = ::std::option::Option::None;
    }

    pub fn has_phone_identifying(&self) -> bool {
        self.phone_identifying.is_some()
    }

    // Param is passed by value, moved
    pub fn set_phone_identifying(&mut self, v: bool) {
        self.phone_identifying = ::std::option::Option::Some(v);
    }

    // optional bool disable_party_quest_progress = 32;


    pub fn get_disable_party_quest_progress(&self) -> bool {
        self.disable_party_quest_progress.unwrap_or(false)
    }
    pub fn clear_disable_party_quest_progress(&mut self) {
        self.disable_party_quest_progress = ::std::option::Option::None;
    }

    pub fn has_disable_party_quest_progress(&self) -> bool {
        self.disable_party_quest_progress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_disable_party_quest_progress(&mut self, v: bool) {
        self.disable_party_quest_progress = ::std::option::Option::Some(v);
    }

    // optional uint32 quest_reward_credits = 33;


    pub fn get_quest_reward_credits(&self) -> u32 {
        self.quest_reward_credits.unwrap_or(0)
    }
    pub fn clear_quest_reward_credits(&mut self) {
        self.quest_reward_credits = ::std::option::Option::None;
    }

    pub fn has_quest_reward_credits(&self) -> bool {
        self.quest_reward_credits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quest_reward_credits(&mut self, v: u32) {
        self.quest_reward_credits = ::std::option::Option::Some(v);
    }

    // optional uint32 matchmaking_last_casual_excessive_reports_auto_ban_time = 34;


    pub fn get_matchmaking_last_casual_excessive_reports_auto_ban_time(&self) -> u32 {
        self.matchmaking_last_casual_excessive_reports_auto_ban_time.unwrap_or(0)
    }
    pub fn clear_matchmaking_last_casual_excessive_reports_auto_ban_time(&mut self) {
        self.matchmaking_last_casual_excessive_reports_auto_ban_time = ::std::option::Option::None;
    }

    pub fn has_matchmaking_last_casual_excessive_reports_auto_ban_time(&self) -> bool {
        self.matchmaking_last_casual_excessive_reports_auto_ban_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matchmaking_last_casual_excessive_reports_auto_ban_time(&mut self, v: u32) {
        self.matchmaking_last_casual_excessive_reports_auto_ban_time = ::std::option::Option::Some(v);
    }

    // optional uint32 matchmaking_last_comp_excessive_reports_auto_ban_time = 35;


    pub fn get_matchmaking_last_comp_excessive_reports_auto_ban_time(&self) -> u32 {
        self.matchmaking_last_comp_excessive_reports_auto_ban_time.unwrap_or(0)
    }
    pub fn clear_matchmaking_last_comp_excessive_reports_auto_ban_time(&mut self) {
        self.matchmaking_last_comp_excessive_reports_auto_ban_time = ::std::option::Option::None;
    }

    pub fn has_matchmaking_last_comp_excessive_reports_auto_ban_time(&self) -> bool {
        self.matchmaking_last_comp_excessive_reports_auto_ban_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matchmaking_last_comp_excessive_reports_auto_ban_time(&mut self, v: u32) {
        self.matchmaking_last_comp_excessive_reports_auto_ban_time = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CSOEconGameAccountClient {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.additional_backpack_slots = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.trial_account = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.need_to_choose_most_helpful_friend = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.in_coaches_list = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.trade_ban_expiration = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.duel_ban_expiration = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.preview_item_def = ::std::option::Option::Some(tmp);
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.phone_verified = ::std::option::Option::Some(tmp);
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.skill_rating_6v6 = ::std::option::Option::Some(tmp);
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.skill_rating_9v9 = ::std::option::Option::Some(tmp);
                },
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.competitive_access = ::std::option::Option::Some(tmp);
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.matchmaking_ranked_ban_expiration = ::std::option::Option::Some(tmp);
                },
                24 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.matchmaking_ranked_low_priority_expiration = ::std::option::Option::Some(tmp);
                },
                25 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.matchmaking_ranked_ban_last_duration = ::std::option::Option::Some(tmp);
                },
                26 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.matchmaking_ranked_low_priority_last_duration = ::std::option::Option::Some(tmp);
                },
                27 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.matchmaking_casual_ban_expiration = ::std::option::Option::Some(tmp);
                },
                28 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.matchmaking_casual_low_priority_expiration = ::std::option::Option::Some(tmp);
                },
                29 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.matchmaking_casual_ban_last_duration = ::std::option::Option::Some(tmp);
                },
                30 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.matchmaking_casual_low_priority_last_duration = ::std::option::Option::Some(tmp);
                },
                31 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.phone_identifying = ::std::option::Option::Some(tmp);
                },
                32 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.disable_party_quest_progress = ::std::option::Option::Some(tmp);
                },
                33 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.quest_reward_credits = ::std::option::Option::Some(tmp);
                },
                34 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.matchmaking_last_casual_excessive_reports_auto_ban_time = ::std::option::Option::Some(tmp);
                },
                35 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.matchmaking_last_comp_excessive_reports_auto_ban_time = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.additional_backpack_slots {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.trial_account {
            my_size += 2;
        }
        if let Some(v) = self.need_to_choose_most_helpful_friend {
            my_size += 2;
        }
        if let Some(v) = self.in_coaches_list {
            my_size += 2;
        }
        if let Some(v) = self.trade_ban_expiration {
            my_size += 5;
        }
        if let Some(v) = self.duel_ban_expiration {
            my_size += 5;
        }
        if let Some(v) = self.preview_item_def {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.phone_verified {
            my_size += 3;
        }
        if let Some(v) = self.skill_rating_6v6 {
            my_size += ::protobuf::rt::value_size(20, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.skill_rating_9v9 {
            my_size += ::protobuf::rt::value_size(21, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.competitive_access {
            my_size += 3;
        }
        if let Some(v) = self.matchmaking_ranked_ban_expiration {
            my_size += ::protobuf::rt::value_size(18, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.matchmaking_ranked_low_priority_expiration {
            my_size += ::protobuf::rt::value_size(24, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.matchmaking_ranked_ban_last_duration {
            my_size += ::protobuf::rt::value_size(25, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.matchmaking_ranked_low_priority_last_duration {
            my_size += ::protobuf::rt::value_size(26, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.matchmaking_casual_ban_expiration {
            my_size += ::protobuf::rt::value_size(27, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.matchmaking_casual_low_priority_expiration {
            my_size += ::protobuf::rt::value_size(28, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.matchmaking_casual_ban_last_duration {
            my_size += ::protobuf::rt::value_size(29, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.matchmaking_casual_low_priority_last_duration {
            my_size += ::protobuf::rt::value_size(30, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.phone_identifying {
            my_size += 3;
        }
        if let Some(v) = self.disable_party_quest_progress {
            my_size += 3;
        }
        if let Some(v) = self.quest_reward_credits {
            my_size += ::protobuf::rt::value_size(33, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.matchmaking_last_casual_excessive_reports_auto_ban_time {
            my_size += ::protobuf::rt::value_size(34, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.matchmaking_last_comp_excessive_reports_auto_ban_time {
            my_size += ::protobuf::rt::value_size(35, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.additional_backpack_slots {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.trial_account {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.need_to_choose_most_helpful_friend {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.in_coaches_list {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.trade_ban_expiration {
            os.write_fixed32(6, v)?;
        }
        if let Some(v) = self.duel_ban_expiration {
            os.write_fixed32(7, v)?;
        }
        if let Some(v) = self.preview_item_def {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.phone_verified {
            os.write_bool(19, v)?;
        }
        if let Some(v) = self.skill_rating_6v6 {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.skill_rating_9v9 {
            os.write_uint32(21, v)?;
        }
        if let Some(v) = self.competitive_access {
            os.write_bool(23, v)?;
        }
        if let Some(v) = self.matchmaking_ranked_ban_expiration {
            os.write_uint32(18, v)?;
        }
        if let Some(v) = self.matchmaking_ranked_low_priority_expiration {
            os.write_uint32(24, v)?;
        }
        if let Some(v) = self.matchmaking_ranked_ban_last_duration {
            os.write_uint32(25, v)?;
        }
        if let Some(v) = self.matchmaking_ranked_low_priority_last_duration {
            os.write_uint32(26, v)?;
        }
        if let Some(v) = self.matchmaking_casual_ban_expiration {
            os.write_uint32(27, v)?;
        }
        if let Some(v) = self.matchmaking_casual_low_priority_expiration {
            os.write_uint32(28, v)?;
        }
        if let Some(v) = self.matchmaking_casual_ban_last_duration {
            os.write_uint32(29, v)?;
        }
        if let Some(v) = self.matchmaking_casual_low_priority_last_duration {
            os.write_uint32(30, v)?;
        }
        if let Some(v) = self.phone_identifying {
            os.write_bool(31, v)?;
        }
        if let Some(v) = self.disable_party_quest_progress {
            os.write_bool(32, v)?;
        }
        if let Some(v) = self.quest_reward_credits {
            os.write_uint32(33, v)?;
        }
        if let Some(v) = self.matchmaking_last_casual_excessive_reports_auto_ban_time {
            os.write_uint32(34, v)?;
        }
        if let Some(v) = self.matchmaking_last_comp_excessive_reports_auto_ban_time {
            os.write_uint32(35, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CSOEconGameAccountClient {
        CSOEconGameAccountClient::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "additional_backpack_slots",
                |m: &CSOEconGameAccountClient| { &m.additional_backpack_slots },
                |m: &mut CSOEconGameAccountClient| { &mut m.additional_backpack_slots },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "trial_account",
                |m: &CSOEconGameAccountClient| { &m.trial_account },
                |m: &mut CSOEconGameAccountClient| { &mut m.trial_account },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "need_to_choose_most_helpful_friend",
                |m: &CSOEconGameAccountClient| { &m.need_to_choose_most_helpful_friend },
                |m: &mut CSOEconGameAccountClient| { &mut m.need_to_choose_most_helpful_friend },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "in_coaches_list",
                |m: &CSOEconGameAccountClient| { &m.in_coaches_list },
                |m: &mut CSOEconGameAccountClient| { &mut m.in_coaches_list },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "trade_ban_expiration",
                |m: &CSOEconGameAccountClient| { &m.trade_ban_expiration },
                |m: &mut CSOEconGameAccountClient| { &mut m.trade_ban_expiration },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "duel_ban_expiration",
                |m: &CSOEconGameAccountClient| { &m.duel_ban_expiration },
                |m: &mut CSOEconGameAccountClient| { &mut m.duel_ban_expiration },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "preview_item_def",
                |m: &CSOEconGameAccountClient| { &m.preview_item_def },
                |m: &mut CSOEconGameAccountClient| { &mut m.preview_item_def },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "phone_verified",
                |m: &CSOEconGameAccountClient| { &m.phone_verified },
                |m: &mut CSOEconGameAccountClient| { &mut m.phone_verified },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "skill_rating_6v6",
                |m: &CSOEconGameAccountClient| { &m.skill_rating_6v6 },
                |m: &mut CSOEconGameAccountClient| { &mut m.skill_rating_6v6 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "skill_rating_9v9",
                |m: &CSOEconGameAccountClient| { &m.skill_rating_9v9 },
                |m: &mut CSOEconGameAccountClient| { &mut m.skill_rating_9v9 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "competitive_access",
                |m: &CSOEconGameAccountClient| { &m.competitive_access },
                |m: &mut CSOEconGameAccountClient| { &mut m.competitive_access },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "matchmaking_ranked_ban_expiration",
                |m: &CSOEconGameAccountClient| { &m.matchmaking_ranked_ban_expiration },
                |m: &mut CSOEconGameAccountClient| { &mut m.matchmaking_ranked_ban_expiration },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "matchmaking_ranked_low_priority_expiration",
                |m: &CSOEconGameAccountClient| { &m.matchmaking_ranked_low_priority_expiration },
                |m: &mut CSOEconGameAccountClient| { &mut m.matchmaking_ranked_low_priority_expiration },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "matchmaking_ranked_ban_last_duration",
                |m: &CSOEconGameAccountClient| { &m.matchmaking_ranked_ban_last_duration },
                |m: &mut CSOEconGameAccountClient| { &mut m.matchmaking_ranked_ban_last_duration },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "matchmaking_ranked_low_priority_last_duration",
                |m: &CSOEconGameAccountClient| { &m.matchmaking_ranked_low_priority_last_duration },
                |m: &mut CSOEconGameAccountClient| { &mut m.matchmaking_ranked_low_priority_last_duration },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "matchmaking_casual_ban_expiration",
                |m: &CSOEconGameAccountClient| { &m.matchmaking_casual_ban_expiration },
                |m: &mut CSOEconGameAccountClient| { &mut m.matchmaking_casual_ban_expiration },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "matchmaking_casual_low_priority_expiration",
                |m: &CSOEconGameAccountClient| { &m.matchmaking_casual_low_priority_expiration },
                |m: &mut CSOEconGameAccountClient| { &mut m.matchmaking_casual_low_priority_expiration },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "matchmaking_casual_ban_last_duration",
                |m: &CSOEconGameAccountClient| { &m.matchmaking_casual_ban_last_duration },
                |m: &mut CSOEconGameAccountClient| { &mut m.matchmaking_casual_ban_last_duration },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "matchmaking_casual_low_priority_last_duration",
                |m: &CSOEconGameAccountClient| { &m.matchmaking_casual_low_priority_last_duration },
                |m: &mut CSOEconGameAccountClient| { &mut m.matchmaking_casual_low_priority_last_duration },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "phone_identifying",
                |m: &CSOEconGameAccountClient| { &m.phone_identifying },
                |m: &mut CSOEconGameAccountClient| { &mut m.phone_identifying },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "disable_party_quest_progress",
                |m: &CSOEconGameAccountClient| { &m.disable_party_quest_progress },
                |m: &mut CSOEconGameAccountClient| { &mut m.disable_party_quest_progress },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "quest_reward_credits",
                |m: &CSOEconGameAccountClient| { &m.quest_reward_credits },
                |m: &mut CSOEconGameAccountClient| { &mut m.quest_reward_credits },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "matchmaking_last_casual_excessive_reports_auto_ban_time",
                |m: &CSOEconGameAccountClient| { &m.matchmaking_last_casual_excessive_reports_auto_ban_time },
                |m: &mut CSOEconGameAccountClient| { &mut m.matchmaking_last_casual_excessive_reports_auto_ban_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "matchmaking_last_comp_excessive_reports_auto_ban_time",
                |m: &CSOEconGameAccountClient| { &m.matchmaking_last_comp_excessive_reports_auto_ban_time },
                |m: &mut CSOEconGameAccountClient| { &mut m.matchmaking_last_comp_excessive_reports_auto_ban_time },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CSOEconGameAccountClient>(
                "CSOEconGameAccountClient",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CSOEconGameAccountClient {
        static instance: ::protobuf::rt::LazyV2<CSOEconGameAccountClient> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CSOEconGameAccountClient::new)
    }
}

impl ::protobuf::Clear for CSOEconGameAccountClient {
    fn clear(&mut self) {
        self.additional_backpack_slots = ::std::option::Option::None;
        self.trial_account = ::std::option::Option::None;
        self.need_to_choose_most_helpful_friend = ::std::option::Option::None;
        self.in_coaches_list = ::std::option::Option::None;
        self.trade_ban_expiration = ::std::option::Option::None;
        self.duel_ban_expiration = ::std::option::Option::None;
        self.preview_item_def = ::std::option::Option::None;
        self.phone_verified = ::std::option::Option::None;
        self.skill_rating_6v6 = ::std::option::Option::None;
        self.skill_rating_9v9 = ::std::option::Option::None;
        self.competitive_access = ::std::option::Option::None;
        self.matchmaking_ranked_ban_expiration = ::std::option::Option::None;
        self.matchmaking_ranked_low_priority_expiration = ::std::option::Option::None;
        self.matchmaking_ranked_ban_last_duration = ::std::option::Option::None;
        self.matchmaking_ranked_low_priority_last_duration = ::std::option::Option::None;
        self.matchmaking_casual_ban_expiration = ::std::option::Option::None;
        self.matchmaking_casual_low_priority_expiration = ::std::option::Option::None;
        self.matchmaking_casual_ban_last_duration = ::std::option::Option::None;
        self.matchmaking_casual_low_priority_last_duration = ::std::option::Option::None;
        self.phone_identifying = ::std::option::Option::None;
        self.disable_party_quest_progress = ::std::option::Option::None;
        self.quest_reward_credits = ::std::option::Option::None;
        self.matchmaking_last_casual_excessive_reports_auto_ban_time = ::std::option::Option::None;
        self.matchmaking_last_comp_excessive_reports_auto_ban_time = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSOEconGameAccountClient {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOEconGameAccountClient {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CSOItemCriteriaCondition {
    // message fields
    op: ::std::option::Option<i32>,
    field: ::protobuf::SingularField<::std::string::String>,
    required: ::std::option::Option<bool>,
    float_value: ::std::option::Option<f32>,
    string_value: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CSOItemCriteriaCondition {
    fn default() -> &'a CSOItemCriteriaCondition {
        <CSOItemCriteriaCondition as ::protobuf::Message>::default_instance()
    }
}

impl CSOItemCriteriaCondition {
    pub fn new() -> CSOItemCriteriaCondition {
        ::std::default::Default::default()
    }

    // optional int32 op = 1;


    pub fn get_op(&self) -> i32 {
        self.op.unwrap_or(0)
    }
    pub fn clear_op(&mut self) {
        self.op = ::std::option::Option::None;
    }

    pub fn has_op(&self) -> bool {
        self.op.is_some()
    }

    // Param is passed by value, moved
    pub fn set_op(&mut self, v: i32) {
        self.op = ::std::option::Option::Some(v);
    }

    // optional string field = 2;


    pub fn get_field(&self) -> &str {
        match self.field.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_field(&mut self) {
        self.field.clear();
    }

    pub fn has_field(&self) -> bool {
        self.field.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field(&mut self, v: ::std::string::String) {
        self.field = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field(&mut self) -> &mut ::std::string::String {
        if self.field.is_none() {
            self.field.set_default();
        }
        self.field.as_mut().unwrap()
    }

    // Take field
    pub fn take_field(&mut self) -> ::std::string::String {
        self.field.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool required = 3;


    pub fn get_required(&self) -> bool {
        self.required.unwrap_or(false)
    }
    pub fn clear_required(&mut self) {
        self.required = ::std::option::Option::None;
    }

    pub fn has_required(&self) -> bool {
        self.required.is_some()
    }

    // Param is passed by value, moved
    pub fn set_required(&mut self, v: bool) {
        self.required = ::std::option::Option::Some(v);
    }

    // optional float float_value = 4;


    pub fn get_float_value(&self) -> f32 {
        self.float_value.unwrap_or(0.)
    }
    pub fn clear_float_value(&mut self) {
        self.float_value = ::std::option::Option::None;
    }

    pub fn has_float_value(&self) -> bool {
        self.float_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_float_value(&mut self, v: f32) {
        self.float_value = ::std::option::Option::Some(v);
    }

    // optional string string_value = 5;


    pub fn get_string_value(&self) -> &str {
        match self.string_value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_string_value(&mut self) {
        self.string_value.clear();
    }

    pub fn has_string_value(&self) -> bool {
        self.string_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_string_value(&mut self, v: ::std::string::String) {
        self.string_value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_string_value(&mut self) -> &mut ::std::string::String {
        if self.string_value.is_none() {
            self.string_value.set_default();
        }
        self.string_value.as_mut().unwrap()
    }

    // Take field
    pub fn take_string_value(&mut self) -> ::std::string::String {
        self.string_value.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CSOItemCriteriaCondition {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.op = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.field)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.required = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.float_value = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.string_value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.op {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.field.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.required {
            my_size += 2;
        }
        if let Some(v) = self.float_value {
            my_size += 5;
        }
        if let Some(ref v) = self.string_value.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.op {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.field.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.required {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.float_value {
            os.write_float(4, v)?;
        }
        if let Some(ref v) = self.string_value.as_ref() {
            os.write_string(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CSOItemCriteriaCondition {
        CSOItemCriteriaCondition::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "op",
                |m: &CSOItemCriteriaCondition| { &m.op },
                |m: &mut CSOItemCriteriaCondition| { &mut m.op },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "field",
                |m: &CSOItemCriteriaCondition| { &m.field },
                |m: &mut CSOItemCriteriaCondition| { &mut m.field },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "required",
                |m: &CSOItemCriteriaCondition| { &m.required },
                |m: &mut CSOItemCriteriaCondition| { &mut m.required },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "float_value",
                |m: &CSOItemCriteriaCondition| { &m.float_value },
                |m: &mut CSOItemCriteriaCondition| { &mut m.float_value },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "string_value",
                |m: &CSOItemCriteriaCondition| { &m.string_value },
                |m: &mut CSOItemCriteriaCondition| { &mut m.string_value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CSOItemCriteriaCondition>(
                "CSOItemCriteriaCondition",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CSOItemCriteriaCondition {
        static instance: ::protobuf::rt::LazyV2<CSOItemCriteriaCondition> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CSOItemCriteriaCondition::new)
    }
}

impl ::protobuf::Clear for CSOItemCriteriaCondition {
    fn clear(&mut self) {
        self.op = ::std::option::Option::None;
        self.field.clear();
        self.required = ::std::option::Option::None;
        self.float_value = ::std::option::Option::None;
        self.string_value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSOItemCriteriaCondition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOItemCriteriaCondition {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CSOItemCriteria {
    // message fields
    item_level: ::std::option::Option<u32>,
    item_quality: ::std::option::Option<i32>,
    item_level_set: ::std::option::Option<bool>,
    item_quality_set: ::std::option::Option<bool>,
    initial_inventory: ::std::option::Option<u32>,
    initial_quantity: ::std::option::Option<u32>,
    ignore_enabled_flag: ::std::option::Option<bool>,
    pub conditions: ::protobuf::RepeatedField<CSOItemCriteriaCondition>,
    recent_only: ::std::option::Option<bool>,
    tags: ::protobuf::SingularField<::std::string::String>,
    equip_regions: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CSOItemCriteria {
    fn default() -> &'a CSOItemCriteria {
        <CSOItemCriteria as ::protobuf::Message>::default_instance()
    }
}

impl CSOItemCriteria {
    pub fn new() -> CSOItemCriteria {
        ::std::default::Default::default()
    }

    // optional uint32 item_level = 1;


    pub fn get_item_level(&self) -> u32 {
        self.item_level.unwrap_or(0)
    }
    pub fn clear_item_level(&mut self) {
        self.item_level = ::std::option::Option::None;
    }

    pub fn has_item_level(&self) -> bool {
        self.item_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_level(&mut self, v: u32) {
        self.item_level = ::std::option::Option::Some(v);
    }

    // optional int32 item_quality = 2;


    pub fn get_item_quality(&self) -> i32 {
        self.item_quality.unwrap_or(0)
    }
    pub fn clear_item_quality(&mut self) {
        self.item_quality = ::std::option::Option::None;
    }

    pub fn has_item_quality(&self) -> bool {
        self.item_quality.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_quality(&mut self, v: i32) {
        self.item_quality = ::std::option::Option::Some(v);
    }

    // optional bool item_level_set = 3;


    pub fn get_item_level_set(&self) -> bool {
        self.item_level_set.unwrap_or(false)
    }
    pub fn clear_item_level_set(&mut self) {
        self.item_level_set = ::std::option::Option::None;
    }

    pub fn has_item_level_set(&self) -> bool {
        self.item_level_set.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_level_set(&mut self, v: bool) {
        self.item_level_set = ::std::option::Option::Some(v);
    }

    // optional bool item_quality_set = 4;


    pub fn get_item_quality_set(&self) -> bool {
        self.item_quality_set.unwrap_or(false)
    }
    pub fn clear_item_quality_set(&mut self) {
        self.item_quality_set = ::std::option::Option::None;
    }

    pub fn has_item_quality_set(&self) -> bool {
        self.item_quality_set.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_quality_set(&mut self, v: bool) {
        self.item_quality_set = ::std::option::Option::Some(v);
    }

    // optional uint32 initial_inventory = 5;


    pub fn get_initial_inventory(&self) -> u32 {
        self.initial_inventory.unwrap_or(0)
    }
    pub fn clear_initial_inventory(&mut self) {
        self.initial_inventory = ::std::option::Option::None;
    }

    pub fn has_initial_inventory(&self) -> bool {
        self.initial_inventory.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initial_inventory(&mut self, v: u32) {
        self.initial_inventory = ::std::option::Option::Some(v);
    }

    // optional uint32 initial_quantity = 6;


    pub fn get_initial_quantity(&self) -> u32 {
        self.initial_quantity.unwrap_or(0)
    }
    pub fn clear_initial_quantity(&mut self) {
        self.initial_quantity = ::std::option::Option::None;
    }

    pub fn has_initial_quantity(&self) -> bool {
        self.initial_quantity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initial_quantity(&mut self, v: u32) {
        self.initial_quantity = ::std::option::Option::Some(v);
    }

    // optional bool ignore_enabled_flag = 8;


    pub fn get_ignore_enabled_flag(&self) -> bool {
        self.ignore_enabled_flag.unwrap_or(false)
    }
    pub fn clear_ignore_enabled_flag(&mut self) {
        self.ignore_enabled_flag = ::std::option::Option::None;
    }

    pub fn has_ignore_enabled_flag(&self) -> bool {
        self.ignore_enabled_flag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ignore_enabled_flag(&mut self, v: bool) {
        self.ignore_enabled_flag = ::std::option::Option::Some(v);
    }

    // repeated .CSOItemCriteriaCondition conditions = 9;


    pub fn get_conditions(&self) -> &[CSOItemCriteriaCondition] {
        &self.conditions
    }
    pub fn clear_conditions(&mut self) {
        self.conditions.clear();
    }

    // Param is passed by value, moved
    pub fn set_conditions(&mut self, v: ::protobuf::RepeatedField<CSOItemCriteriaCondition>) {
        self.conditions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_conditions(&mut self) -> &mut ::protobuf::RepeatedField<CSOItemCriteriaCondition> {
        &mut self.conditions
    }

    // Take field
    pub fn take_conditions(&mut self) -> ::protobuf::RepeatedField<CSOItemCriteriaCondition> {
        ::std::mem::replace(&mut self.conditions, ::protobuf::RepeatedField::new())
    }

    // optional bool recent_only = 10;


    pub fn get_recent_only(&self) -> bool {
        self.recent_only.unwrap_or(false)
    }
    pub fn clear_recent_only(&mut self) {
        self.recent_only = ::std::option::Option::None;
    }

    pub fn has_recent_only(&self) -> bool {
        self.recent_only.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recent_only(&mut self, v: bool) {
        self.recent_only = ::std::option::Option::Some(v);
    }

    // optional string tags = 11;


    pub fn get_tags(&self) -> &str {
        match self.tags.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_tags(&mut self) {
        self.tags.clear();
    }

    pub fn has_tags(&self) -> bool {
        self.tags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tags(&mut self, v: ::std::string::String) {
        self.tags = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tags(&mut self) -> &mut ::std::string::String {
        if self.tags.is_none() {
            self.tags.set_default();
        }
        self.tags.as_mut().unwrap()
    }

    // Take field
    pub fn take_tags(&mut self) -> ::std::string::String {
        self.tags.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string equip_regions = 12;


    pub fn get_equip_regions(&self) -> &str {
        match self.equip_regions.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_equip_regions(&mut self) {
        self.equip_regions.clear();
    }

    pub fn has_equip_regions(&self) -> bool {
        self.equip_regions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_equip_regions(&mut self, v: ::std::string::String) {
        self.equip_regions = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_equip_regions(&mut self) -> &mut ::std::string::String {
        if self.equip_regions.is_none() {
            self.equip_regions.set_default();
        }
        self.equip_regions.as_mut().unwrap()
    }

    // Take field
    pub fn take_equip_regions(&mut self) -> ::std::string::String {
        self.equip_regions.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CSOItemCriteria {
    fn is_initialized(&self) -> bool {
        for v in &self.conditions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.item_level = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.item_quality = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.item_level_set = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.item_quality_set = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.initial_inventory = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.initial_quantity = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.ignore_enabled_flag = ::std::option::Option::Some(tmp);
                },
                9 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.conditions)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.recent_only = ::std::option::Option::Some(tmp);
                },
                11 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.tags)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.equip_regions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.item_level {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.item_quality {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.item_level_set {
            my_size += 2;
        }
        if let Some(v) = self.item_quality_set {
            my_size += 2;
        }
        if let Some(v) = self.initial_inventory {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.initial_quantity {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ignore_enabled_flag {
            my_size += 2;
        }
        for value in &self.conditions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.recent_only {
            my_size += 2;
        }
        if let Some(ref v) = self.tags.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(ref v) = self.equip_regions.as_ref() {
            my_size += ::protobuf::rt::string_size(12, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.item_level {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.item_quality {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.item_level_set {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.item_quality_set {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.initial_inventory {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.initial_quantity {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.ignore_enabled_flag {
            os.write_bool(8, v)?;
        }
        for v in &self.conditions {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.recent_only {
            os.write_bool(10, v)?;
        }
        if let Some(ref v) = self.tags.as_ref() {
            os.write_string(11, &v)?;
        }
        if let Some(ref v) = self.equip_regions.as_ref() {
            os.write_string(12, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CSOItemCriteria {
        CSOItemCriteria::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "item_level",
                |m: &CSOItemCriteria| { &m.item_level },
                |m: &mut CSOItemCriteria| { &mut m.item_level },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "item_quality",
                |m: &CSOItemCriteria| { &m.item_quality },
                |m: &mut CSOItemCriteria| { &mut m.item_quality },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "item_level_set",
                |m: &CSOItemCriteria| { &m.item_level_set },
                |m: &mut CSOItemCriteria| { &mut m.item_level_set },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "item_quality_set",
                |m: &CSOItemCriteria| { &m.item_quality_set },
                |m: &mut CSOItemCriteria| { &mut m.item_quality_set },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "initial_inventory",
                |m: &CSOItemCriteria| { &m.initial_inventory },
                |m: &mut CSOItemCriteria| { &mut m.initial_inventory },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "initial_quantity",
                |m: &CSOItemCriteria| { &m.initial_quantity },
                |m: &mut CSOItemCriteria| { &mut m.initial_quantity },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "ignore_enabled_flag",
                |m: &CSOItemCriteria| { &m.ignore_enabled_flag },
                |m: &mut CSOItemCriteria| { &mut m.ignore_enabled_flag },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CSOItemCriteriaCondition>>(
                "conditions",
                |m: &CSOItemCriteria| { &m.conditions },
                |m: &mut CSOItemCriteria| { &mut m.conditions },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "recent_only",
                |m: &CSOItemCriteria| { &m.recent_only },
                |m: &mut CSOItemCriteria| { &mut m.recent_only },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "tags",
                |m: &CSOItemCriteria| { &m.tags },
                |m: &mut CSOItemCriteria| { &mut m.tags },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "equip_regions",
                |m: &CSOItemCriteria| { &m.equip_regions },
                |m: &mut CSOItemCriteria| { &mut m.equip_regions },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CSOItemCriteria>(
                "CSOItemCriteria",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CSOItemCriteria {
        static instance: ::protobuf::rt::LazyV2<CSOItemCriteria> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CSOItemCriteria::new)
    }
}

impl ::protobuf::Clear for CSOItemCriteria {
    fn clear(&mut self) {
        self.item_level = ::std::option::Option::None;
        self.item_quality = ::std::option::Option::None;
        self.item_level_set = ::std::option::Option::None;
        self.item_quality_set = ::std::option::Option::None;
        self.initial_inventory = ::std::option::Option::None;
        self.initial_quantity = ::std::option::Option::None;
        self.ignore_enabled_flag = ::std::option::Option::None;
        self.conditions.clear();
        self.recent_only = ::std::option::Option::None;
        self.tags.clear();
        self.equip_regions.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSOItemCriteria {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOItemCriteria {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CSOItemRecipe {
    // message fields
    def_index: ::std::option::Option<u32>,
    name: ::protobuf::SingularField<::std::string::String>,
    n_a: ::protobuf::SingularField<::std::string::String>,
    desc_inputs: ::protobuf::SingularField<::std::string::String>,
    desc_outputs: ::protobuf::SingularField<::std::string::String>,
    di_a: ::protobuf::SingularField<::std::string::String>,
    di_b: ::protobuf::SingularField<::std::string::String>,
    di_c: ::protobuf::SingularField<::std::string::String>,
    do_a: ::protobuf::SingularField<::std::string::String>,
    do_b: ::protobuf::SingularField<::std::string::String>,
    do_c: ::protobuf::SingularField<::std::string::String>,
    requires_all_same_class: ::std::option::Option<bool>,
    requires_all_same_slot: ::std::option::Option<bool>,
    class_usage_for_output: ::std::option::Option<i32>,
    slot_usage_for_output: ::std::option::Option<i32>,
    set_for_output: ::std::option::Option<i32>,
    pub input_items_criteria: ::protobuf::RepeatedField<CSOItemCriteria>,
    pub output_items_criteria: ::protobuf::RepeatedField<CSOItemCriteria>,
    pub input_item_dupe_counts: ::std::vec::Vec<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CSOItemRecipe {
    fn default() -> &'a CSOItemRecipe {
        <CSOItemRecipe as ::protobuf::Message>::default_instance()
    }
}

impl CSOItemRecipe {
    pub fn new() -> CSOItemRecipe {
        ::std::default::Default::default()
    }

    // optional uint32 def_index = 1;


    pub fn get_def_index(&self) -> u32 {
        self.def_index.unwrap_or(0)
    }
    pub fn clear_def_index(&mut self) {
        self.def_index = ::std::option::Option::None;
    }

    pub fn has_def_index(&self) -> bool {
        self.def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_def_index(&mut self, v: u32) {
        self.def_index = ::std::option::Option::Some(v);
    }

    // optional string name = 2;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string n_a = 3;


    pub fn get_n_a(&self) -> &str {
        match self.n_a.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_n_a(&mut self) {
        self.n_a.clear();
    }

    pub fn has_n_a(&self) -> bool {
        self.n_a.is_some()
    }

    // Param is passed by value, moved
    pub fn set_n_a(&mut self, v: ::std::string::String) {
        self.n_a = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_n_a(&mut self) -> &mut ::std::string::String {
        if self.n_a.is_none() {
            self.n_a.set_default();
        }
        self.n_a.as_mut().unwrap()
    }

    // Take field
    pub fn take_n_a(&mut self) -> ::std::string::String {
        self.n_a.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string desc_inputs = 4;


    pub fn get_desc_inputs(&self) -> &str {
        match self.desc_inputs.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_desc_inputs(&mut self) {
        self.desc_inputs.clear();
    }

    pub fn has_desc_inputs(&self) -> bool {
        self.desc_inputs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desc_inputs(&mut self, v: ::std::string::String) {
        self.desc_inputs = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_desc_inputs(&mut self) -> &mut ::std::string::String {
        if self.desc_inputs.is_none() {
            self.desc_inputs.set_default();
        }
        self.desc_inputs.as_mut().unwrap()
    }

    // Take field
    pub fn take_desc_inputs(&mut self) -> ::std::string::String {
        self.desc_inputs.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string desc_outputs = 5;


    pub fn get_desc_outputs(&self) -> &str {
        match self.desc_outputs.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_desc_outputs(&mut self) {
        self.desc_outputs.clear();
    }

    pub fn has_desc_outputs(&self) -> bool {
        self.desc_outputs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desc_outputs(&mut self, v: ::std::string::String) {
        self.desc_outputs = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_desc_outputs(&mut self) -> &mut ::std::string::String {
        if self.desc_outputs.is_none() {
            self.desc_outputs.set_default();
        }
        self.desc_outputs.as_mut().unwrap()
    }

    // Take field
    pub fn take_desc_outputs(&mut self) -> ::std::string::String {
        self.desc_outputs.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string di_a = 6;


    pub fn get_di_a(&self) -> &str {
        match self.di_a.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_di_a(&mut self) {
        self.di_a.clear();
    }

    pub fn has_di_a(&self) -> bool {
        self.di_a.is_some()
    }

    // Param is passed by value, moved
    pub fn set_di_a(&mut self, v: ::std::string::String) {
        self.di_a = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_di_a(&mut self) -> &mut ::std::string::String {
        if self.di_a.is_none() {
            self.di_a.set_default();
        }
        self.di_a.as_mut().unwrap()
    }

    // Take field
    pub fn take_di_a(&mut self) -> ::std::string::String {
        self.di_a.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string di_b = 7;


    pub fn get_di_b(&self) -> &str {
        match self.di_b.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_di_b(&mut self) {
        self.di_b.clear();
    }

    pub fn has_di_b(&self) -> bool {
        self.di_b.is_some()
    }

    // Param is passed by value, moved
    pub fn set_di_b(&mut self, v: ::std::string::String) {
        self.di_b = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_di_b(&mut self) -> &mut ::std::string::String {
        if self.di_b.is_none() {
            self.di_b.set_default();
        }
        self.di_b.as_mut().unwrap()
    }

    // Take field
    pub fn take_di_b(&mut self) -> ::std::string::String {
        self.di_b.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string di_c = 8;


    pub fn get_di_c(&self) -> &str {
        match self.di_c.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_di_c(&mut self) {
        self.di_c.clear();
    }

    pub fn has_di_c(&self) -> bool {
        self.di_c.is_some()
    }

    // Param is passed by value, moved
    pub fn set_di_c(&mut self, v: ::std::string::String) {
        self.di_c = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_di_c(&mut self) -> &mut ::std::string::String {
        if self.di_c.is_none() {
            self.di_c.set_default();
        }
        self.di_c.as_mut().unwrap()
    }

    // Take field
    pub fn take_di_c(&mut self) -> ::std::string::String {
        self.di_c.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string do_a = 9;


    pub fn get_do_a(&self) -> &str {
        match self.do_a.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_do_a(&mut self) {
        self.do_a.clear();
    }

    pub fn has_do_a(&self) -> bool {
        self.do_a.is_some()
    }

    // Param is passed by value, moved
    pub fn set_do_a(&mut self, v: ::std::string::String) {
        self.do_a = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_do_a(&mut self) -> &mut ::std::string::String {
        if self.do_a.is_none() {
            self.do_a.set_default();
        }
        self.do_a.as_mut().unwrap()
    }

    // Take field
    pub fn take_do_a(&mut self) -> ::std::string::String {
        self.do_a.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string do_b = 10;


    pub fn get_do_b(&self) -> &str {
        match self.do_b.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_do_b(&mut self) {
        self.do_b.clear();
    }

    pub fn has_do_b(&self) -> bool {
        self.do_b.is_some()
    }

    // Param is passed by value, moved
    pub fn set_do_b(&mut self, v: ::std::string::String) {
        self.do_b = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_do_b(&mut self) -> &mut ::std::string::String {
        if self.do_b.is_none() {
            self.do_b.set_default();
        }
        self.do_b.as_mut().unwrap()
    }

    // Take field
    pub fn take_do_b(&mut self) -> ::std::string::String {
        self.do_b.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string do_c = 11;


    pub fn get_do_c(&self) -> &str {
        match self.do_c.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_do_c(&mut self) {
        self.do_c.clear();
    }

    pub fn has_do_c(&self) -> bool {
        self.do_c.is_some()
    }

    // Param is passed by value, moved
    pub fn set_do_c(&mut self, v: ::std::string::String) {
        self.do_c = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_do_c(&mut self) -> &mut ::std::string::String {
        if self.do_c.is_none() {
            self.do_c.set_default();
        }
        self.do_c.as_mut().unwrap()
    }

    // Take field
    pub fn take_do_c(&mut self) -> ::std::string::String {
        self.do_c.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool requires_all_same_class = 12;


    pub fn get_requires_all_same_class(&self) -> bool {
        self.requires_all_same_class.unwrap_or(false)
    }
    pub fn clear_requires_all_same_class(&mut self) {
        self.requires_all_same_class = ::std::option::Option::None;
    }

    pub fn has_requires_all_same_class(&self) -> bool {
        self.requires_all_same_class.is_some()
    }

    // Param is passed by value, moved
    pub fn set_requires_all_same_class(&mut self, v: bool) {
        self.requires_all_same_class = ::std::option::Option::Some(v);
    }

    // optional bool requires_all_same_slot = 13;


    pub fn get_requires_all_same_slot(&self) -> bool {
        self.requires_all_same_slot.unwrap_or(false)
    }
    pub fn clear_requires_all_same_slot(&mut self) {
        self.requires_all_same_slot = ::std::option::Option::None;
    }

    pub fn has_requires_all_same_slot(&self) -> bool {
        self.requires_all_same_slot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_requires_all_same_slot(&mut self, v: bool) {
        self.requires_all_same_slot = ::std::option::Option::Some(v);
    }

    // optional int32 class_usage_for_output = 14;


    pub fn get_class_usage_for_output(&self) -> i32 {
        self.class_usage_for_output.unwrap_or(0)
    }
    pub fn clear_class_usage_for_output(&mut self) {
        self.class_usage_for_output = ::std::option::Option::None;
    }

    pub fn has_class_usage_for_output(&self) -> bool {
        self.class_usage_for_output.is_some()
    }

    // Param is passed by value, moved
    pub fn set_class_usage_for_output(&mut self, v: i32) {
        self.class_usage_for_output = ::std::option::Option::Some(v);
    }

    // optional int32 slot_usage_for_output = 15;


    pub fn get_slot_usage_for_output(&self) -> i32 {
        self.slot_usage_for_output.unwrap_or(0)
    }
    pub fn clear_slot_usage_for_output(&mut self) {
        self.slot_usage_for_output = ::std::option::Option::None;
    }

    pub fn has_slot_usage_for_output(&self) -> bool {
        self.slot_usage_for_output.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slot_usage_for_output(&mut self, v: i32) {
        self.slot_usage_for_output = ::std::option::Option::Some(v);
    }

    // optional int32 set_for_output = 16;


    pub fn get_set_for_output(&self) -> i32 {
        self.set_for_output.unwrap_or(0)
    }
    pub fn clear_set_for_output(&mut self) {
        self.set_for_output = ::std::option::Option::None;
    }

    pub fn has_set_for_output(&self) -> bool {
        self.set_for_output.is_some()
    }

    // Param is passed by value, moved
    pub fn set_set_for_output(&mut self, v: i32) {
        self.set_for_output = ::std::option::Option::Some(v);
    }

    // repeated .CSOItemCriteria input_items_criteria = 20;


    pub fn get_input_items_criteria(&self) -> &[CSOItemCriteria] {
        &self.input_items_criteria
    }
    pub fn clear_input_items_criteria(&mut self) {
        self.input_items_criteria.clear();
    }

    // Param is passed by value, moved
    pub fn set_input_items_criteria(&mut self, v: ::protobuf::RepeatedField<CSOItemCriteria>) {
        self.input_items_criteria = v;
    }

    // Mutable pointer to the field.
    pub fn mut_input_items_criteria(&mut self) -> &mut ::protobuf::RepeatedField<CSOItemCriteria> {
        &mut self.input_items_criteria
    }

    // Take field
    pub fn take_input_items_criteria(&mut self) -> ::protobuf::RepeatedField<CSOItemCriteria> {
        ::std::mem::replace(&mut self.input_items_criteria, ::protobuf::RepeatedField::new())
    }

    // repeated .CSOItemCriteria output_items_criteria = 21;


    pub fn get_output_items_criteria(&self) -> &[CSOItemCriteria] {
        &self.output_items_criteria
    }
    pub fn clear_output_items_criteria(&mut self) {
        self.output_items_criteria.clear();
    }

    // Param is passed by value, moved
    pub fn set_output_items_criteria(&mut self, v: ::protobuf::RepeatedField<CSOItemCriteria>) {
        self.output_items_criteria = v;
    }

    // Mutable pointer to the field.
    pub fn mut_output_items_criteria(&mut self) -> &mut ::protobuf::RepeatedField<CSOItemCriteria> {
        &mut self.output_items_criteria
    }

    // Take field
    pub fn take_output_items_criteria(&mut self) -> ::protobuf::RepeatedField<CSOItemCriteria> {
        ::std::mem::replace(&mut self.output_items_criteria, ::protobuf::RepeatedField::new())
    }

    // repeated uint32 input_item_dupe_counts = 22;


    pub fn get_input_item_dupe_counts(&self) -> &[u32] {
        &self.input_item_dupe_counts
    }
    pub fn clear_input_item_dupe_counts(&mut self) {
        self.input_item_dupe_counts.clear();
    }

    // Param is passed by value, moved
    pub fn set_input_item_dupe_counts(&mut self, v: ::std::vec::Vec<u32>) {
        self.input_item_dupe_counts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_input_item_dupe_counts(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.input_item_dupe_counts
    }

    // Take field
    pub fn take_input_item_dupe_counts(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.input_item_dupe_counts, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CSOItemRecipe {
    fn is_initialized(&self) -> bool {
        for v in &self.input_items_criteria {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.output_items_criteria {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.def_index = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.n_a)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.desc_inputs)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.desc_outputs)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.di_a)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.di_b)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.di_c)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.do_a)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.do_b)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.do_c)?;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.requires_all_same_class = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.requires_all_same_slot = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.class_usage_for_output = ::std::option::Option::Some(tmp);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.slot_usage_for_output = ::std::option::Option::Some(tmp);
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.set_for_output = ::std::option::Option::Some(tmp);
                },
                20 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.input_items_criteria)?;
                },
                21 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.output_items_criteria)?;
                },
                22 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.input_item_dupe_counts)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.def_index {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.n_a.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.desc_inputs.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.desc_outputs.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.di_a.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(ref v) = self.di_b.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(ref v) = self.di_c.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(ref v) = self.do_a.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(ref v) = self.do_b.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(ref v) = self.do_c.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(v) = self.requires_all_same_class {
            my_size += 2;
        }
        if let Some(v) = self.requires_all_same_slot {
            my_size += 2;
        }
        if let Some(v) = self.class_usage_for_output {
            my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.slot_usage_for_output {
            my_size += ::protobuf::rt::value_size(15, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.set_for_output {
            my_size += ::protobuf::rt::value_size(16, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.input_items_criteria {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.output_items_criteria {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.input_item_dupe_counts {
            my_size += ::protobuf::rt::value_size(22, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.def_index {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.n_a.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.desc_inputs.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.desc_outputs.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.di_a.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(ref v) = self.di_b.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(ref v) = self.di_c.as_ref() {
            os.write_string(8, &v)?;
        }
        if let Some(ref v) = self.do_a.as_ref() {
            os.write_string(9, &v)?;
        }
        if let Some(ref v) = self.do_b.as_ref() {
            os.write_string(10, &v)?;
        }
        if let Some(ref v) = self.do_c.as_ref() {
            os.write_string(11, &v)?;
        }
        if let Some(v) = self.requires_all_same_class {
            os.write_bool(12, v)?;
        }
        if let Some(v) = self.requires_all_same_slot {
            os.write_bool(13, v)?;
        }
        if let Some(v) = self.class_usage_for_output {
            os.write_int32(14, v)?;
        }
        if let Some(v) = self.slot_usage_for_output {
            os.write_int32(15, v)?;
        }
        if let Some(v) = self.set_for_output {
            os.write_int32(16, v)?;
        }
        for v in &self.input_items_criteria {
            os.write_tag(20, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.output_items_criteria {
            os.write_tag(21, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.input_item_dupe_counts {
            os.write_uint32(22, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CSOItemRecipe {
        CSOItemRecipe::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "def_index",
                |m: &CSOItemRecipe| { &m.def_index },
                |m: &mut CSOItemRecipe| { &mut m.def_index },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &CSOItemRecipe| { &m.name },
                |m: &mut CSOItemRecipe| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "n_a",
                |m: &CSOItemRecipe| { &m.n_a },
                |m: &mut CSOItemRecipe| { &mut m.n_a },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "desc_inputs",
                |m: &CSOItemRecipe| { &m.desc_inputs },
                |m: &mut CSOItemRecipe| { &mut m.desc_inputs },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "desc_outputs",
                |m: &CSOItemRecipe| { &m.desc_outputs },
                |m: &mut CSOItemRecipe| { &mut m.desc_outputs },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "di_a",
                |m: &CSOItemRecipe| { &m.di_a },
                |m: &mut CSOItemRecipe| { &mut m.di_a },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "di_b",
                |m: &CSOItemRecipe| { &m.di_b },
                |m: &mut CSOItemRecipe| { &mut m.di_b },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "di_c",
                |m: &CSOItemRecipe| { &m.di_c },
                |m: &mut CSOItemRecipe| { &mut m.di_c },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "do_a",
                |m: &CSOItemRecipe| { &m.do_a },
                |m: &mut CSOItemRecipe| { &mut m.do_a },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "do_b",
                |m: &CSOItemRecipe| { &m.do_b },
                |m: &mut CSOItemRecipe| { &mut m.do_b },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "do_c",
                |m: &CSOItemRecipe| { &m.do_c },
                |m: &mut CSOItemRecipe| { &mut m.do_c },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "requires_all_same_class",
                |m: &CSOItemRecipe| { &m.requires_all_same_class },
                |m: &mut CSOItemRecipe| { &mut m.requires_all_same_class },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "requires_all_same_slot",
                |m: &CSOItemRecipe| { &m.requires_all_same_slot },
                |m: &mut CSOItemRecipe| { &mut m.requires_all_same_slot },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "class_usage_for_output",
                |m: &CSOItemRecipe| { &m.class_usage_for_output },
                |m: &mut CSOItemRecipe| { &mut m.class_usage_for_output },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "slot_usage_for_output",
                |m: &CSOItemRecipe| { &m.slot_usage_for_output },
                |m: &mut CSOItemRecipe| { &mut m.slot_usage_for_output },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "set_for_output",
                |m: &CSOItemRecipe| { &m.set_for_output },
                |m: &mut CSOItemRecipe| { &mut m.set_for_output },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CSOItemCriteria>>(
                "input_items_criteria",
                |m: &CSOItemRecipe| { &m.input_items_criteria },
                |m: &mut CSOItemRecipe| { &mut m.input_items_criteria },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CSOItemCriteria>>(
                "output_items_criteria",
                |m: &CSOItemRecipe| { &m.output_items_criteria },
                |m: &mut CSOItemRecipe| { &mut m.output_items_criteria },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "input_item_dupe_counts",
                |m: &CSOItemRecipe| { &m.input_item_dupe_counts },
                |m: &mut CSOItemRecipe| { &mut m.input_item_dupe_counts },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CSOItemRecipe>(
                "CSOItemRecipe",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CSOItemRecipe {
        static instance: ::protobuf::rt::LazyV2<CSOItemRecipe> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CSOItemRecipe::new)
    }
}

impl ::protobuf::Clear for CSOItemRecipe {
    fn clear(&mut self) {
        self.def_index = ::std::option::Option::None;
        self.name.clear();
        self.n_a.clear();
        self.desc_inputs.clear();
        self.desc_outputs.clear();
        self.di_a.clear();
        self.di_b.clear();
        self.di_c.clear();
        self.do_a.clear();
        self.do_b.clear();
        self.do_c.clear();
        self.requires_all_same_class = ::std::option::Option::None;
        self.requires_all_same_slot = ::std::option::Option::None;
        self.class_usage_for_output = ::std::option::Option::None;
        self.slot_usage_for_output = ::std::option::Option::None;
        self.set_for_output = ::std::option::Option::None;
        self.input_items_criteria.clear();
        self.output_items_criteria.clear();
        self.input_item_dupe_counts.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSOItemRecipe {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOItemRecipe {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDevNewItemRequest {
    // message fields
    receiver: ::std::option::Option<u64>,
    pub criteria: ::protobuf::SingularPtrField<CSOItemCriteria>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgDevNewItemRequest {
    fn default() -> &'a CMsgDevNewItemRequest {
        <CMsgDevNewItemRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDevNewItemRequest {
    pub fn new() -> CMsgDevNewItemRequest {
        ::std::default::Default::default()
    }

    // optional fixed64 receiver = 1;


    pub fn get_receiver(&self) -> u64 {
        self.receiver.unwrap_or(0)
    }
    pub fn clear_receiver(&mut self) {
        self.receiver = ::std::option::Option::None;
    }

    pub fn has_receiver(&self) -> bool {
        self.receiver.is_some()
    }

    // Param is passed by value, moved
    pub fn set_receiver(&mut self, v: u64) {
        self.receiver = ::std::option::Option::Some(v);
    }

    // optional .CSOItemCriteria criteria = 2;


    pub fn get_criteria(&self) -> &CSOItemCriteria {
        self.criteria.as_ref().unwrap_or_else(|| <CSOItemCriteria as ::protobuf::Message>::default_instance())
    }
    pub fn clear_criteria(&mut self) {
        self.criteria.clear();
    }

    pub fn has_criteria(&self) -> bool {
        self.criteria.is_some()
    }

    // Param is passed by value, moved
    pub fn set_criteria(&mut self, v: CSOItemCriteria) {
        self.criteria = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_criteria(&mut self) -> &mut CSOItemCriteria {
        if self.criteria.is_none() {
            self.criteria.set_default();
        }
        self.criteria.as_mut().unwrap()
    }

    // Take field
    pub fn take_criteria(&mut self) -> CSOItemCriteria {
        self.criteria.take().unwrap_or_else(|| CSOItemCriteria::new())
    }
}

impl ::protobuf::Message for CMsgDevNewItemRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.criteria {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.receiver = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.criteria)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.receiver {
            my_size += 9;
        }
        if let Some(ref v) = self.criteria.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.receiver {
            os.write_fixed64(1, v)?;
        }
        if let Some(ref v) = self.criteria.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgDevNewItemRequest {
        CMsgDevNewItemRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "receiver",
                |m: &CMsgDevNewItemRequest| { &m.receiver },
                |m: &mut CMsgDevNewItemRequest| { &mut m.receiver },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CSOItemCriteria>>(
                "criteria",
                |m: &CMsgDevNewItemRequest| { &m.criteria },
                |m: &mut CMsgDevNewItemRequest| { &mut m.criteria },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgDevNewItemRequest>(
                "CMsgDevNewItemRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgDevNewItemRequest {
        static instance: ::protobuf::rt::LazyV2<CMsgDevNewItemRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgDevNewItemRequest::new)
    }
}

impl ::protobuf::Clear for CMsgDevNewItemRequest {
    fn clear(&mut self) {
        self.receiver = ::std::option::Option::None;
        self.criteria.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDevNewItemRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDevNewItemRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDevDebugRollLootRequest {
    // message fields
    receiver: ::std::option::Option<u64>,
    loot_list_name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgDevDebugRollLootRequest {
    fn default() -> &'a CMsgDevDebugRollLootRequest {
        <CMsgDevDebugRollLootRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDevDebugRollLootRequest {
    pub fn new() -> CMsgDevDebugRollLootRequest {
        ::std::default::Default::default()
    }

    // optional fixed64 receiver = 1;


    pub fn get_receiver(&self) -> u64 {
        self.receiver.unwrap_or(0)
    }
    pub fn clear_receiver(&mut self) {
        self.receiver = ::std::option::Option::None;
    }

    pub fn has_receiver(&self) -> bool {
        self.receiver.is_some()
    }

    // Param is passed by value, moved
    pub fn set_receiver(&mut self, v: u64) {
        self.receiver = ::std::option::Option::Some(v);
    }

    // optional string loot_list_name = 2;


    pub fn get_loot_list_name(&self) -> &str {
        match self.loot_list_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_loot_list_name(&mut self) {
        self.loot_list_name.clear();
    }

    pub fn has_loot_list_name(&self) -> bool {
        self.loot_list_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_loot_list_name(&mut self, v: ::std::string::String) {
        self.loot_list_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_loot_list_name(&mut self) -> &mut ::std::string::String {
        if self.loot_list_name.is_none() {
            self.loot_list_name.set_default();
        }
        self.loot_list_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_loot_list_name(&mut self) -> ::std::string::String {
        self.loot_list_name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgDevDebugRollLootRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.receiver = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.loot_list_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.receiver {
            my_size += 9;
        }
        if let Some(ref v) = self.loot_list_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.receiver {
            os.write_fixed64(1, v)?;
        }
        if let Some(ref v) = self.loot_list_name.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgDevDebugRollLootRequest {
        CMsgDevDebugRollLootRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "receiver",
                |m: &CMsgDevDebugRollLootRequest| { &m.receiver },
                |m: &mut CMsgDevDebugRollLootRequest| { &mut m.receiver },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "loot_list_name",
                |m: &CMsgDevDebugRollLootRequest| { &m.loot_list_name },
                |m: &mut CMsgDevDebugRollLootRequest| { &mut m.loot_list_name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgDevDebugRollLootRequest>(
                "CMsgDevDebugRollLootRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgDevDebugRollLootRequest {
        static instance: ::protobuf::rt::LazyV2<CMsgDevDebugRollLootRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgDevDebugRollLootRequest::new)
    }
}

impl ::protobuf::Clear for CMsgDevDebugRollLootRequest {
    fn clear(&mut self) {
        self.receiver = ::std::option::Option::None;
        self.loot_list_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDevDebugRollLootRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDevDebugRollLootRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgIncrementKillCountAttribute {
    // message fields
    killer_steam_id: ::std::option::Option<u64>,
    victim_steam_id: ::std::option::Option<u64>,
    item_id: ::std::option::Option<u64>,
    event_type: ::std::option::Option<u32>,
    increment_value: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgIncrementKillCountAttribute {
    fn default() -> &'a CMsgIncrementKillCountAttribute {
        <CMsgIncrementKillCountAttribute as ::protobuf::Message>::default_instance()
    }
}

impl CMsgIncrementKillCountAttribute {
    pub fn new() -> CMsgIncrementKillCountAttribute {
        ::std::default::Default::default()
    }

    // optional uint64 killer_steam_id = 1;


    pub fn get_killer_steam_id(&self) -> u64 {
        self.killer_steam_id.unwrap_or(0)
    }
    pub fn clear_killer_steam_id(&mut self) {
        self.killer_steam_id = ::std::option::Option::None;
    }

    pub fn has_killer_steam_id(&self) -> bool {
        self.killer_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_killer_steam_id(&mut self, v: u64) {
        self.killer_steam_id = ::std::option::Option::Some(v);
    }

    // optional uint64 victim_steam_id = 2;


    pub fn get_victim_steam_id(&self) -> u64 {
        self.victim_steam_id.unwrap_or(0)
    }
    pub fn clear_victim_steam_id(&mut self) {
        self.victim_steam_id = ::std::option::Option::None;
    }

    pub fn has_victim_steam_id(&self) -> bool {
        self.victim_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_victim_steam_id(&mut self, v: u64) {
        self.victim_steam_id = ::std::option::Option::Some(v);
    }

    // optional uint64 item_id = 3;


    pub fn get_item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }
    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    // optional uint32 event_type = 4;


    pub fn get_event_type(&self) -> u32 {
        self.event_type.unwrap_or(0)
    }
    pub fn clear_event_type(&mut self) {
        self.event_type = ::std::option::Option::None;
    }

    pub fn has_event_type(&self) -> bool {
        self.event_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_type(&mut self, v: u32) {
        self.event_type = ::std::option::Option::Some(v);
    }

    // optional uint32 increment_value = 5;


    pub fn get_increment_value(&self) -> u32 {
        self.increment_value.unwrap_or(0)
    }
    pub fn clear_increment_value(&mut self) {
        self.increment_value = ::std::option::Option::None;
    }

    pub fn has_increment_value(&self) -> bool {
        self.increment_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_increment_value(&mut self, v: u32) {
        self.increment_value = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgIncrementKillCountAttribute {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.killer_steam_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.victim_steam_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.item_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.event_type = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.increment_value = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.killer_steam_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.victim_steam_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.event_type {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.increment_value {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.killer_steam_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.victim_steam_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.item_id {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.event_type {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.increment_value {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgIncrementKillCountAttribute {
        CMsgIncrementKillCountAttribute::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "killer_steam_id",
                |m: &CMsgIncrementKillCountAttribute| { &m.killer_steam_id },
                |m: &mut CMsgIncrementKillCountAttribute| { &mut m.killer_steam_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "victim_steam_id",
                |m: &CMsgIncrementKillCountAttribute| { &m.victim_steam_id },
                |m: &mut CMsgIncrementKillCountAttribute| { &mut m.victim_steam_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "item_id",
                |m: &CMsgIncrementKillCountAttribute| { &m.item_id },
                |m: &mut CMsgIncrementKillCountAttribute| { &mut m.item_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "event_type",
                |m: &CMsgIncrementKillCountAttribute| { &m.event_type },
                |m: &mut CMsgIncrementKillCountAttribute| { &mut m.event_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "increment_value",
                |m: &CMsgIncrementKillCountAttribute| { &m.increment_value },
                |m: &mut CMsgIncrementKillCountAttribute| { &mut m.increment_value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgIncrementKillCountAttribute>(
                "CMsgIncrementKillCountAttribute",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgIncrementKillCountAttribute {
        static instance: ::protobuf::rt::LazyV2<CMsgIncrementKillCountAttribute> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgIncrementKillCountAttribute::new)
    }
}

impl ::protobuf::Clear for CMsgIncrementKillCountAttribute {
    fn clear(&mut self) {
        self.killer_steam_id = ::std::option::Option::None;
        self.victim_steam_id = ::std::option::Option::None;
        self.item_id = ::std::option::Option::None;
        self.event_type = ::std::option::Option::None;
        self.increment_value = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgIncrementKillCountAttribute {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgIncrementKillCountAttribute {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgIncrementKillCountAttribute_Multiple {
    // message fields
    pub msgs: ::protobuf::RepeatedField<CMsgIncrementKillCountAttribute>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgIncrementKillCountAttribute_Multiple {
    fn default() -> &'a CMsgIncrementKillCountAttribute_Multiple {
        <CMsgIncrementKillCountAttribute_Multiple as ::protobuf::Message>::default_instance()
    }
}

impl CMsgIncrementKillCountAttribute_Multiple {
    pub fn new() -> CMsgIncrementKillCountAttribute_Multiple {
        ::std::default::Default::default()
    }

    // repeated .CMsgIncrementKillCountAttribute msgs = 1;


    pub fn get_msgs(&self) -> &[CMsgIncrementKillCountAttribute] {
        &self.msgs
    }
    pub fn clear_msgs(&mut self) {
        self.msgs.clear();
    }

    // Param is passed by value, moved
    pub fn set_msgs(&mut self, v: ::protobuf::RepeatedField<CMsgIncrementKillCountAttribute>) {
        self.msgs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_msgs(&mut self) -> &mut ::protobuf::RepeatedField<CMsgIncrementKillCountAttribute> {
        &mut self.msgs
    }

    // Take field
    pub fn take_msgs(&mut self) -> ::protobuf::RepeatedField<CMsgIncrementKillCountAttribute> {
        ::std::mem::replace(&mut self.msgs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgIncrementKillCountAttribute_Multiple {
    fn is_initialized(&self) -> bool {
        for v in &self.msgs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.msgs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.msgs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.msgs {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgIncrementKillCountAttribute_Multiple {
        CMsgIncrementKillCountAttribute_Multiple::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgIncrementKillCountAttribute>>(
                "msgs",
                |m: &CMsgIncrementKillCountAttribute_Multiple| { &m.msgs },
                |m: &mut CMsgIncrementKillCountAttribute_Multiple| { &mut m.msgs },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgIncrementKillCountAttribute_Multiple>(
                "CMsgIncrementKillCountAttribute_Multiple",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgIncrementKillCountAttribute_Multiple {
        static instance: ::protobuf::rt::LazyV2<CMsgIncrementKillCountAttribute_Multiple> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgIncrementKillCountAttribute_Multiple::new)
    }
}

impl ::protobuf::Clear for CMsgIncrementKillCountAttribute_Multiple {
    fn clear(&mut self) {
        self.msgs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgIncrementKillCountAttribute_Multiple {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgIncrementKillCountAttribute_Multiple {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgTrackUniquePlayerPairEvent {
    // message fields
    killer_steam_id: ::std::option::Option<u64>,
    victim_steam_id: ::std::option::Option<u64>,
    item_id: ::std::option::Option<u64>,
    event_type: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgTrackUniquePlayerPairEvent {
    fn default() -> &'a CMsgTrackUniquePlayerPairEvent {
        <CMsgTrackUniquePlayerPairEvent as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTrackUniquePlayerPairEvent {
    pub fn new() -> CMsgTrackUniquePlayerPairEvent {
        ::std::default::Default::default()
    }

    // optional uint64 killer_steam_id = 1;


    pub fn get_killer_steam_id(&self) -> u64 {
        self.killer_steam_id.unwrap_or(0)
    }
    pub fn clear_killer_steam_id(&mut self) {
        self.killer_steam_id = ::std::option::Option::None;
    }

    pub fn has_killer_steam_id(&self) -> bool {
        self.killer_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_killer_steam_id(&mut self, v: u64) {
        self.killer_steam_id = ::std::option::Option::Some(v);
    }

    // optional uint64 victim_steam_id = 2;


    pub fn get_victim_steam_id(&self) -> u64 {
        self.victim_steam_id.unwrap_or(0)
    }
    pub fn clear_victim_steam_id(&mut self) {
        self.victim_steam_id = ::std::option::Option::None;
    }

    pub fn has_victim_steam_id(&self) -> bool {
        self.victim_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_victim_steam_id(&mut self, v: u64) {
        self.victim_steam_id = ::std::option::Option::Some(v);
    }

    // optional uint64 item_id = 3;


    pub fn get_item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }
    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    // optional uint32 event_type = 4;


    pub fn get_event_type(&self) -> u32 {
        self.event_type.unwrap_or(0)
    }
    pub fn clear_event_type(&mut self) {
        self.event_type = ::std::option::Option::None;
    }

    pub fn has_event_type(&self) -> bool {
        self.event_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_type(&mut self, v: u32) {
        self.event_type = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgTrackUniquePlayerPairEvent {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.killer_steam_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.victim_steam_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.item_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.event_type = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.killer_steam_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.victim_steam_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.event_type {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.killer_steam_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.victim_steam_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.item_id {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.event_type {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgTrackUniquePlayerPairEvent {
        CMsgTrackUniquePlayerPairEvent::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "killer_steam_id",
                |m: &CMsgTrackUniquePlayerPairEvent| { &m.killer_steam_id },
                |m: &mut CMsgTrackUniquePlayerPairEvent| { &mut m.killer_steam_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "victim_steam_id",
                |m: &CMsgTrackUniquePlayerPairEvent| { &m.victim_steam_id },
                |m: &mut CMsgTrackUniquePlayerPairEvent| { &mut m.victim_steam_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "item_id",
                |m: &CMsgTrackUniquePlayerPairEvent| { &m.item_id },
                |m: &mut CMsgTrackUniquePlayerPairEvent| { &mut m.item_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "event_type",
                |m: &CMsgTrackUniquePlayerPairEvent| { &m.event_type },
                |m: &mut CMsgTrackUniquePlayerPairEvent| { &mut m.event_type },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgTrackUniquePlayerPairEvent>(
                "CMsgTrackUniquePlayerPairEvent",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgTrackUniquePlayerPairEvent {
        static instance: ::protobuf::rt::LazyV2<CMsgTrackUniquePlayerPairEvent> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgTrackUniquePlayerPairEvent::new)
    }
}

impl ::protobuf::Clear for CMsgTrackUniquePlayerPairEvent {
    fn clear(&mut self) {
        self.killer_steam_id = ::std::option::Option::None;
        self.victim_steam_id = ::std::option::Option::None;
        self.item_id = ::std::option::Option::None;
        self.event_type = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgTrackUniquePlayerPairEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTrackUniquePlayerPairEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgApplyStrangeCountTransfer {
    // message fields
    tool_item_id: ::std::option::Option<u64>,
    item_src_item_id: ::std::option::Option<u64>,
    item_dest_item_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgApplyStrangeCountTransfer {
    fn default() -> &'a CMsgApplyStrangeCountTransfer {
        <CMsgApplyStrangeCountTransfer as ::protobuf::Message>::default_instance()
    }
}

impl CMsgApplyStrangeCountTransfer {
    pub fn new() -> CMsgApplyStrangeCountTransfer {
        ::std::default::Default::default()
    }

    // optional uint64 tool_item_id = 1;


    pub fn get_tool_item_id(&self) -> u64 {
        self.tool_item_id.unwrap_or(0)
    }
    pub fn clear_tool_item_id(&mut self) {
        self.tool_item_id = ::std::option::Option::None;
    }

    pub fn has_tool_item_id(&self) -> bool {
        self.tool_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tool_item_id(&mut self, v: u64) {
        self.tool_item_id = ::std::option::Option::Some(v);
    }

    // optional uint64 item_src_item_id = 2;


    pub fn get_item_src_item_id(&self) -> u64 {
        self.item_src_item_id.unwrap_or(0)
    }
    pub fn clear_item_src_item_id(&mut self) {
        self.item_src_item_id = ::std::option::Option::None;
    }

    pub fn has_item_src_item_id(&self) -> bool {
        self.item_src_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_src_item_id(&mut self, v: u64) {
        self.item_src_item_id = ::std::option::Option::Some(v);
    }

    // optional uint64 item_dest_item_id = 3;


    pub fn get_item_dest_item_id(&self) -> u64 {
        self.item_dest_item_id.unwrap_or(0)
    }
    pub fn clear_item_dest_item_id(&mut self) {
        self.item_dest_item_id = ::std::option::Option::None;
    }

    pub fn has_item_dest_item_id(&self) -> bool {
        self.item_dest_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_dest_item_id(&mut self, v: u64) {
        self.item_dest_item_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgApplyStrangeCountTransfer {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.tool_item_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.item_src_item_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.item_dest_item_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.tool_item_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.item_src_item_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.item_dest_item_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.tool_item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.item_src_item_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.item_dest_item_id {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgApplyStrangeCountTransfer {
        CMsgApplyStrangeCountTransfer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "tool_item_id",
                |m: &CMsgApplyStrangeCountTransfer| { &m.tool_item_id },
                |m: &mut CMsgApplyStrangeCountTransfer| { &mut m.tool_item_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "item_src_item_id",
                |m: &CMsgApplyStrangeCountTransfer| { &m.item_src_item_id },
                |m: &mut CMsgApplyStrangeCountTransfer| { &mut m.item_src_item_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "item_dest_item_id",
                |m: &CMsgApplyStrangeCountTransfer| { &m.item_dest_item_id },
                |m: &mut CMsgApplyStrangeCountTransfer| { &mut m.item_dest_item_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgApplyStrangeCountTransfer>(
                "CMsgApplyStrangeCountTransfer",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgApplyStrangeCountTransfer {
        static instance: ::protobuf::rt::LazyV2<CMsgApplyStrangeCountTransfer> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgApplyStrangeCountTransfer::new)
    }
}

impl ::protobuf::Clear for CMsgApplyStrangeCountTransfer {
    fn clear(&mut self) {
        self.tool_item_id = ::std::option::Option::None;
        self.item_src_item_id = ::std::option::Option::None;
        self.item_dest_item_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgApplyStrangeCountTransfer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgApplyStrangeCountTransfer {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgApplyStrangePart {
    // message fields
    strange_part_item_id: ::std::option::Option<u64>,
    item_item_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgApplyStrangePart {
    fn default() -> &'a CMsgApplyStrangePart {
        <CMsgApplyStrangePart as ::protobuf::Message>::default_instance()
    }
}

impl CMsgApplyStrangePart {
    pub fn new() -> CMsgApplyStrangePart {
        ::std::default::Default::default()
    }

    // optional uint64 strange_part_item_id = 1;


    pub fn get_strange_part_item_id(&self) -> u64 {
        self.strange_part_item_id.unwrap_or(0)
    }
    pub fn clear_strange_part_item_id(&mut self) {
        self.strange_part_item_id = ::std::option::Option::None;
    }

    pub fn has_strange_part_item_id(&self) -> bool {
        self.strange_part_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_strange_part_item_id(&mut self, v: u64) {
        self.strange_part_item_id = ::std::option::Option::Some(v);
    }

    // optional uint64 item_item_id = 2;


    pub fn get_item_item_id(&self) -> u64 {
        self.item_item_id.unwrap_or(0)
    }
    pub fn clear_item_item_id(&mut self) {
        self.item_item_id = ::std::option::Option::None;
    }

    pub fn has_item_item_id(&self) -> bool {
        self.item_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_item_id(&mut self, v: u64) {
        self.item_item_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgApplyStrangePart {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.strange_part_item_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.item_item_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.strange_part_item_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.item_item_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.strange_part_item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.item_item_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgApplyStrangePart {
        CMsgApplyStrangePart::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "strange_part_item_id",
                |m: &CMsgApplyStrangePart| { &m.strange_part_item_id },
                |m: &mut CMsgApplyStrangePart| { &mut m.strange_part_item_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "item_item_id",
                |m: &CMsgApplyStrangePart| { &m.item_item_id },
                |m: &mut CMsgApplyStrangePart| { &mut m.item_item_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgApplyStrangePart>(
                "CMsgApplyStrangePart",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgApplyStrangePart {
        static instance: ::protobuf::rt::LazyV2<CMsgApplyStrangePart> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgApplyStrangePart::new)
    }
}

impl ::protobuf::Clear for CMsgApplyStrangePart {
    fn clear(&mut self) {
        self.strange_part_item_id = ::std::option::Option::None;
        self.item_item_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgApplyStrangePart {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgApplyStrangePart {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgApplyStrangeRestriction {
    // message fields
    strange_part_item_id: ::std::option::Option<u64>,
    item_item_id: ::std::option::Option<u64>,
    strange_attr_index: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgApplyStrangeRestriction {
    fn default() -> &'a CMsgApplyStrangeRestriction {
        <CMsgApplyStrangeRestriction as ::protobuf::Message>::default_instance()
    }
}

impl CMsgApplyStrangeRestriction {
    pub fn new() -> CMsgApplyStrangeRestriction {
        ::std::default::Default::default()
    }

    // optional uint64 strange_part_item_id = 1;


    pub fn get_strange_part_item_id(&self) -> u64 {
        self.strange_part_item_id.unwrap_or(0)
    }
    pub fn clear_strange_part_item_id(&mut self) {
        self.strange_part_item_id = ::std::option::Option::None;
    }

    pub fn has_strange_part_item_id(&self) -> bool {
        self.strange_part_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_strange_part_item_id(&mut self, v: u64) {
        self.strange_part_item_id = ::std::option::Option::Some(v);
    }

    // optional uint64 item_item_id = 2;


    pub fn get_item_item_id(&self) -> u64 {
        self.item_item_id.unwrap_or(0)
    }
    pub fn clear_item_item_id(&mut self) {
        self.item_item_id = ::std::option::Option::None;
    }

    pub fn has_item_item_id(&self) -> bool {
        self.item_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_item_id(&mut self, v: u64) {
        self.item_item_id = ::std::option::Option::Some(v);
    }

    // optional uint32 strange_attr_index = 3;


    pub fn get_strange_attr_index(&self) -> u32 {
        self.strange_attr_index.unwrap_or(0)
    }
    pub fn clear_strange_attr_index(&mut self) {
        self.strange_attr_index = ::std::option::Option::None;
    }

    pub fn has_strange_attr_index(&self) -> bool {
        self.strange_attr_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_strange_attr_index(&mut self, v: u32) {
        self.strange_attr_index = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgApplyStrangeRestriction {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.strange_part_item_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.item_item_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.strange_attr_index = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.strange_part_item_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.item_item_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.strange_attr_index {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.strange_part_item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.item_item_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.strange_attr_index {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgApplyStrangeRestriction {
        CMsgApplyStrangeRestriction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "strange_part_item_id",
                |m: &CMsgApplyStrangeRestriction| { &m.strange_part_item_id },
                |m: &mut CMsgApplyStrangeRestriction| { &mut m.strange_part_item_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "item_item_id",
                |m: &CMsgApplyStrangeRestriction| { &m.item_item_id },
                |m: &mut CMsgApplyStrangeRestriction| { &mut m.item_item_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "strange_attr_index",
                |m: &CMsgApplyStrangeRestriction| { &m.strange_attr_index },
                |m: &mut CMsgApplyStrangeRestriction| { &mut m.strange_attr_index },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgApplyStrangeRestriction>(
                "CMsgApplyStrangeRestriction",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgApplyStrangeRestriction {
        static instance: ::protobuf::rt::LazyV2<CMsgApplyStrangeRestriction> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgApplyStrangeRestriction::new)
    }
}

impl ::protobuf::Clear for CMsgApplyStrangeRestriction {
    fn clear(&mut self) {
        self.strange_part_item_id = ::std::option::Option::None;
        self.item_item_id = ::std::option::Option::None;
        self.strange_attr_index = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgApplyStrangeRestriction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgApplyStrangeRestriction {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgApplyUpgradeCard {
    // message fields
    upgrade_card_item_id: ::std::option::Option<u64>,
    subject_item_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgApplyUpgradeCard {
    fn default() -> &'a CMsgApplyUpgradeCard {
        <CMsgApplyUpgradeCard as ::protobuf::Message>::default_instance()
    }
}

impl CMsgApplyUpgradeCard {
    pub fn new() -> CMsgApplyUpgradeCard {
        ::std::default::Default::default()
    }

    // optional uint64 upgrade_card_item_id = 1;


    pub fn get_upgrade_card_item_id(&self) -> u64 {
        self.upgrade_card_item_id.unwrap_or(0)
    }
    pub fn clear_upgrade_card_item_id(&mut self) {
        self.upgrade_card_item_id = ::std::option::Option::None;
    }

    pub fn has_upgrade_card_item_id(&self) -> bool {
        self.upgrade_card_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_upgrade_card_item_id(&mut self, v: u64) {
        self.upgrade_card_item_id = ::std::option::Option::Some(v);
    }

    // optional uint64 subject_item_id = 2;


    pub fn get_subject_item_id(&self) -> u64 {
        self.subject_item_id.unwrap_or(0)
    }
    pub fn clear_subject_item_id(&mut self) {
        self.subject_item_id = ::std::option::Option::None;
    }

    pub fn has_subject_item_id(&self) -> bool {
        self.subject_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subject_item_id(&mut self, v: u64) {
        self.subject_item_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgApplyUpgradeCard {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.upgrade_card_item_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.subject_item_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.upgrade_card_item_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.subject_item_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.upgrade_card_item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.subject_item_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgApplyUpgradeCard {
        CMsgApplyUpgradeCard::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "upgrade_card_item_id",
                |m: &CMsgApplyUpgradeCard| { &m.upgrade_card_item_id },
                |m: &mut CMsgApplyUpgradeCard| { &mut m.upgrade_card_item_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "subject_item_id",
                |m: &CMsgApplyUpgradeCard| { &m.subject_item_id },
                |m: &mut CMsgApplyUpgradeCard| { &mut m.subject_item_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgApplyUpgradeCard>(
                "CMsgApplyUpgradeCard",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgApplyUpgradeCard {
        static instance: ::protobuf::rt::LazyV2<CMsgApplyUpgradeCard> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgApplyUpgradeCard::new)
    }
}

impl ::protobuf::Clear for CMsgApplyUpgradeCard {
    fn clear(&mut self) {
        self.upgrade_card_item_id = ::std::option::Option::None;
        self.subject_item_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgApplyUpgradeCard {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgApplyUpgradeCard {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CSOEconItemAttribute {
    // message fields
    def_index: ::std::option::Option<u32>,
    value: ::std::option::Option<u32>,
    value_bytes: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CSOEconItemAttribute {
    fn default() -> &'a CSOEconItemAttribute {
        <CSOEconItemAttribute as ::protobuf::Message>::default_instance()
    }
}

impl CSOEconItemAttribute {
    pub fn new() -> CSOEconItemAttribute {
        ::std::default::Default::default()
    }

    // optional uint32 def_index = 1;


    pub fn get_def_index(&self) -> u32 {
        self.def_index.unwrap_or(0)
    }
    pub fn clear_def_index(&mut self) {
        self.def_index = ::std::option::Option::None;
    }

    pub fn has_def_index(&self) -> bool {
        self.def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_def_index(&mut self, v: u32) {
        self.def_index = ::std::option::Option::Some(v);
    }

    // optional uint32 value = 2;


    pub fn get_value(&self) -> u32 {
        self.value.unwrap_or(0)
    }
    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: u32) {
        self.value = ::std::option::Option::Some(v);
    }

    // optional bytes value_bytes = 3;


    pub fn get_value_bytes(&self) -> &[u8] {
        match self.value_bytes.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_value_bytes(&mut self) {
        self.value_bytes.clear();
    }

    pub fn has_value_bytes(&self) -> bool {
        self.value_bytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value_bytes(&mut self, v: ::std::vec::Vec<u8>) {
        self.value_bytes = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value_bytes(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.value_bytes.is_none() {
            self.value_bytes.set_default();
        }
        self.value_bytes.as_mut().unwrap()
    }

    // Take field
    pub fn take_value_bytes(&mut self) -> ::std::vec::Vec<u8> {
        self.value_bytes.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CSOEconItemAttribute {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.def_index = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.value = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.value_bytes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.def_index {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.value {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.value_bytes.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.def_index {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.value {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.value_bytes.as_ref() {
            os.write_bytes(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CSOEconItemAttribute {
        CSOEconItemAttribute::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "def_index",
                |m: &CSOEconItemAttribute| { &m.def_index },
                |m: &mut CSOEconItemAttribute| { &mut m.def_index },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "value",
                |m: &CSOEconItemAttribute| { &m.value },
                |m: &mut CSOEconItemAttribute| { &mut m.value },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "value_bytes",
                |m: &CSOEconItemAttribute| { &m.value_bytes },
                |m: &mut CSOEconItemAttribute| { &mut m.value_bytes },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CSOEconItemAttribute>(
                "CSOEconItemAttribute",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CSOEconItemAttribute {
        static instance: ::protobuf::rt::LazyV2<CSOEconItemAttribute> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CSOEconItemAttribute::new)
    }
}

impl ::protobuf::Clear for CSOEconItemAttribute {
    fn clear(&mut self) {
        self.def_index = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value_bytes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSOEconItemAttribute {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOEconItemAttribute {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CSOEconItemEquipped {
    // message fields
    new_class: ::std::option::Option<u32>,
    new_slot: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CSOEconItemEquipped {
    fn default() -> &'a CSOEconItemEquipped {
        <CSOEconItemEquipped as ::protobuf::Message>::default_instance()
    }
}

impl CSOEconItemEquipped {
    pub fn new() -> CSOEconItemEquipped {
        ::std::default::Default::default()
    }

    // optional uint32 new_class = 1;


    pub fn get_new_class(&self) -> u32 {
        self.new_class.unwrap_or(0)
    }
    pub fn clear_new_class(&mut self) {
        self.new_class = ::std::option::Option::None;
    }

    pub fn has_new_class(&self) -> bool {
        self.new_class.is_some()
    }

    // Param is passed by value, moved
    pub fn set_new_class(&mut self, v: u32) {
        self.new_class = ::std::option::Option::Some(v);
    }

    // optional uint32 new_slot = 2;


    pub fn get_new_slot(&self) -> u32 {
        self.new_slot.unwrap_or(0)
    }
    pub fn clear_new_slot(&mut self) {
        self.new_slot = ::std::option::Option::None;
    }

    pub fn has_new_slot(&self) -> bool {
        self.new_slot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_new_slot(&mut self, v: u32) {
        self.new_slot = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CSOEconItemEquipped {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.new_class = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.new_slot = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.new_class {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.new_slot {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.new_class {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.new_slot {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CSOEconItemEquipped {
        CSOEconItemEquipped::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "new_class",
                |m: &CSOEconItemEquipped| { &m.new_class },
                |m: &mut CSOEconItemEquipped| { &mut m.new_class },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "new_slot",
                |m: &CSOEconItemEquipped| { &m.new_slot },
                |m: &mut CSOEconItemEquipped| { &mut m.new_slot },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CSOEconItemEquipped>(
                "CSOEconItemEquipped",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CSOEconItemEquipped {
        static instance: ::protobuf::rt::LazyV2<CSOEconItemEquipped> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CSOEconItemEquipped::new)
    }
}

impl ::protobuf::Clear for CSOEconItemEquipped {
    fn clear(&mut self) {
        self.new_class = ::std::option::Option::None;
        self.new_slot = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSOEconItemEquipped {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOEconItemEquipped {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CSOEconItem {
    // message fields
    id: ::std::option::Option<u64>,
    account_id: ::std::option::Option<u32>,
    inventory: ::std::option::Option<u32>,
    def_index: ::std::option::Option<u32>,
    quantity: ::std::option::Option<u32>,
    level: ::std::option::Option<u32>,
    quality: ::std::option::Option<u32>,
    flags: ::std::option::Option<u32>,
    origin: ::std::option::Option<u32>,
    custom_name: ::protobuf::SingularField<::std::string::String>,
    custom_desc: ::protobuf::SingularField<::std::string::String>,
    pub attribute: ::protobuf::RepeatedField<CSOEconItemAttribute>,
    pub interior_item: ::protobuf::SingularPtrField<CSOEconItem>,
    in_use: ::std::option::Option<bool>,
    style: ::std::option::Option<u32>,
    original_id: ::std::option::Option<u64>,
    contains_equipped_state: ::std::option::Option<bool>,
    pub equipped_state: ::protobuf::RepeatedField<CSOEconItemEquipped>,
    contains_equipped_state_v2: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CSOEconItem {
    fn default() -> &'a CSOEconItem {
        <CSOEconItem as ::protobuf::Message>::default_instance()
    }
}

impl CSOEconItem {
    pub fn new() -> CSOEconItem {
        ::std::default::Default::default()
    }

    // optional uint64 id = 1;


    pub fn get_id(&self) -> u64 {
        self.id.unwrap_or(0)
    }
    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u64) {
        self.id = ::std::option::Option::Some(v);
    }

    // optional uint32 account_id = 2;


    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }
    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 inventory = 3;


    pub fn get_inventory(&self) -> u32 {
        self.inventory.unwrap_or(0)
    }
    pub fn clear_inventory(&mut self) {
        self.inventory = ::std::option::Option::None;
    }

    pub fn has_inventory(&self) -> bool {
        self.inventory.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inventory(&mut self, v: u32) {
        self.inventory = ::std::option::Option::Some(v);
    }

    // optional uint32 def_index = 4;


    pub fn get_def_index(&self) -> u32 {
        self.def_index.unwrap_or(0)
    }
    pub fn clear_def_index(&mut self) {
        self.def_index = ::std::option::Option::None;
    }

    pub fn has_def_index(&self) -> bool {
        self.def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_def_index(&mut self, v: u32) {
        self.def_index = ::std::option::Option::Some(v);
    }

    // optional uint32 quantity = 5;


    pub fn get_quantity(&self) -> u32 {
        self.quantity.unwrap_or(0)
    }
    pub fn clear_quantity(&mut self) {
        self.quantity = ::std::option::Option::None;
    }

    pub fn has_quantity(&self) -> bool {
        self.quantity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quantity(&mut self, v: u32) {
        self.quantity = ::std::option::Option::Some(v);
    }

    // optional uint32 level = 6;


    pub fn get_level(&self) -> u32 {
        self.level.unwrap_or(0)
    }
    pub fn clear_level(&mut self) {
        self.level = ::std::option::Option::None;
    }

    pub fn has_level(&self) -> bool {
        self.level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_level(&mut self, v: u32) {
        self.level = ::std::option::Option::Some(v);
    }

    // optional uint32 quality = 7;


    pub fn get_quality(&self) -> u32 {
        self.quality.unwrap_or(0)
    }
    pub fn clear_quality(&mut self) {
        self.quality = ::std::option::Option::None;
    }

    pub fn has_quality(&self) -> bool {
        self.quality.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality(&mut self, v: u32) {
        self.quality = ::std::option::Option::Some(v);
    }

    // optional uint32 flags = 8;


    pub fn get_flags(&self) -> u32 {
        self.flags.unwrap_or(0u32)
    }
    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional uint32 origin = 9;


    pub fn get_origin(&self) -> u32 {
        self.origin.unwrap_or(0)
    }
    pub fn clear_origin(&mut self) {
        self.origin = ::std::option::Option::None;
    }

    pub fn has_origin(&self) -> bool {
        self.origin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_origin(&mut self, v: u32) {
        self.origin = ::std::option::Option::Some(v);
    }

    // optional string custom_name = 10;


    pub fn get_custom_name(&self) -> &str {
        match self.custom_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_custom_name(&mut self) {
        self.custom_name.clear();
    }

    pub fn has_custom_name(&self) -> bool {
        self.custom_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_name(&mut self, v: ::std::string::String) {
        self.custom_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_custom_name(&mut self) -> &mut ::std::string::String {
        if self.custom_name.is_none() {
            self.custom_name.set_default();
        }
        self.custom_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_custom_name(&mut self) -> ::std::string::String {
        self.custom_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string custom_desc = 11;


    pub fn get_custom_desc(&self) -> &str {
        match self.custom_desc.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_custom_desc(&mut self) {
        self.custom_desc.clear();
    }

    pub fn has_custom_desc(&self) -> bool {
        self.custom_desc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_desc(&mut self, v: ::std::string::String) {
        self.custom_desc = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_custom_desc(&mut self) -> &mut ::std::string::String {
        if self.custom_desc.is_none() {
            self.custom_desc.set_default();
        }
        self.custom_desc.as_mut().unwrap()
    }

    // Take field
    pub fn take_custom_desc(&mut self) -> ::std::string::String {
        self.custom_desc.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .CSOEconItemAttribute attribute = 12;


    pub fn get_attribute(&self) -> &[CSOEconItemAttribute] {
        &self.attribute
    }
    pub fn clear_attribute(&mut self) {
        self.attribute.clear();
    }

    // Param is passed by value, moved
    pub fn set_attribute(&mut self, v: ::protobuf::RepeatedField<CSOEconItemAttribute>) {
        self.attribute = v;
    }

    // Mutable pointer to the field.
    pub fn mut_attribute(&mut self) -> &mut ::protobuf::RepeatedField<CSOEconItemAttribute> {
        &mut self.attribute
    }

    // Take field
    pub fn take_attribute(&mut self) -> ::protobuf::RepeatedField<CSOEconItemAttribute> {
        ::std::mem::replace(&mut self.attribute, ::protobuf::RepeatedField::new())
    }

    // optional .CSOEconItem interior_item = 13;


    pub fn get_interior_item(&self) -> &CSOEconItem {
        self.interior_item.as_ref().unwrap_or_else(|| <CSOEconItem as ::protobuf::Message>::default_instance())
    }
    pub fn clear_interior_item(&mut self) {
        self.interior_item.clear();
    }

    pub fn has_interior_item(&self) -> bool {
        self.interior_item.is_some()
    }

    // Param is passed by value, moved
    pub fn set_interior_item(&mut self, v: CSOEconItem) {
        self.interior_item = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_interior_item(&mut self) -> &mut CSOEconItem {
        if self.interior_item.is_none() {
            self.interior_item.set_default();
        }
        self.interior_item.as_mut().unwrap()
    }

    // Take field
    pub fn take_interior_item(&mut self) -> CSOEconItem {
        self.interior_item.take().unwrap_or_else(|| CSOEconItem::new())
    }

    // optional bool in_use = 14;


    pub fn get_in_use(&self) -> bool {
        self.in_use.unwrap_or(false)
    }
    pub fn clear_in_use(&mut self) {
        self.in_use = ::std::option::Option::None;
    }

    pub fn has_in_use(&self) -> bool {
        self.in_use.is_some()
    }

    // Param is passed by value, moved
    pub fn set_in_use(&mut self, v: bool) {
        self.in_use = ::std::option::Option::Some(v);
    }

    // optional uint32 style = 15;


    pub fn get_style(&self) -> u32 {
        self.style.unwrap_or(0u32)
    }
    pub fn clear_style(&mut self) {
        self.style = ::std::option::Option::None;
    }

    pub fn has_style(&self) -> bool {
        self.style.is_some()
    }

    // Param is passed by value, moved
    pub fn set_style(&mut self, v: u32) {
        self.style = ::std::option::Option::Some(v);
    }

    // optional uint64 original_id = 16;


    pub fn get_original_id(&self) -> u64 {
        self.original_id.unwrap_or(0u64)
    }
    pub fn clear_original_id(&mut self) {
        self.original_id = ::std::option::Option::None;
    }

    pub fn has_original_id(&self) -> bool {
        self.original_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_original_id(&mut self, v: u64) {
        self.original_id = ::std::option::Option::Some(v);
    }

    // optional bool contains_equipped_state = 17;


    pub fn get_contains_equipped_state(&self) -> bool {
        self.contains_equipped_state.unwrap_or(false)
    }
    pub fn clear_contains_equipped_state(&mut self) {
        self.contains_equipped_state = ::std::option::Option::None;
    }

    pub fn has_contains_equipped_state(&self) -> bool {
        self.contains_equipped_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_contains_equipped_state(&mut self, v: bool) {
        self.contains_equipped_state = ::std::option::Option::Some(v);
    }

    // repeated .CSOEconItemEquipped equipped_state = 18;


    pub fn get_equipped_state(&self) -> &[CSOEconItemEquipped] {
        &self.equipped_state
    }
    pub fn clear_equipped_state(&mut self) {
        self.equipped_state.clear();
    }

    // Param is passed by value, moved
    pub fn set_equipped_state(&mut self, v: ::protobuf::RepeatedField<CSOEconItemEquipped>) {
        self.equipped_state = v;
    }

    // Mutable pointer to the field.
    pub fn mut_equipped_state(&mut self) -> &mut ::protobuf::RepeatedField<CSOEconItemEquipped> {
        &mut self.equipped_state
    }

    // Take field
    pub fn take_equipped_state(&mut self) -> ::protobuf::RepeatedField<CSOEconItemEquipped> {
        ::std::mem::replace(&mut self.equipped_state, ::protobuf::RepeatedField::new())
    }

    // optional bool contains_equipped_state_v2 = 19;


    pub fn get_contains_equipped_state_v2(&self) -> bool {
        self.contains_equipped_state_v2.unwrap_or(false)
    }
    pub fn clear_contains_equipped_state_v2(&mut self) {
        self.contains_equipped_state_v2 = ::std::option::Option::None;
    }

    pub fn has_contains_equipped_state_v2(&self) -> bool {
        self.contains_equipped_state_v2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_contains_equipped_state_v2(&mut self, v: bool) {
        self.contains_equipped_state_v2 = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CSOEconItem {
    fn is_initialized(&self) -> bool {
        for v in &self.attribute {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.interior_item {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.equipped_state {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.inventory = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.def_index = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.quantity = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.level = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.quality = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.flags = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.origin = ::std::option::Option::Some(tmp);
                },
                10 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.custom_name)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.custom_desc)?;
                },
                12 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.attribute)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.interior_item)?;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.in_use = ::std::option::Option::Some(tmp);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.style = ::std::option::Option::Some(tmp);
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.original_id = ::std::option::Option::Some(tmp);
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.contains_equipped_state = ::std::option::Option::Some(tmp);
                },
                18 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.equipped_state)?;
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.contains_equipped_state_v2 = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.inventory {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.def_index {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.quantity {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.level {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.quality {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.origin {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.custom_name.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(ref v) = self.custom_desc.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        for value in &self.attribute {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.interior_item.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.in_use {
            my_size += 2;
        }
        if let Some(v) = self.style {
            my_size += ::protobuf::rt::value_size(15, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.original_id {
            my_size += ::protobuf::rt::value_size(16, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.contains_equipped_state {
            my_size += 3;
        }
        for value in &self.equipped_state {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.contains_equipped_state_v2 {
            my_size += 3;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.account_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.inventory {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.def_index {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.quantity {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.level {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.quality {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.flags {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.origin {
            os.write_uint32(9, v)?;
        }
        if let Some(ref v) = self.custom_name.as_ref() {
            os.write_string(10, &v)?;
        }
        if let Some(ref v) = self.custom_desc.as_ref() {
            os.write_string(11, &v)?;
        }
        for v in &self.attribute {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.interior_item.as_ref() {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.in_use {
            os.write_bool(14, v)?;
        }
        if let Some(v) = self.style {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.original_id {
            os.write_uint64(16, v)?;
        }
        if let Some(v) = self.contains_equipped_state {
            os.write_bool(17, v)?;
        }
        for v in &self.equipped_state {
            os.write_tag(18, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.contains_equipped_state_v2 {
            os.write_bool(19, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CSOEconItem {
        CSOEconItem::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "id",
                |m: &CSOEconItem| { &m.id },
                |m: &mut CSOEconItem| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "account_id",
                |m: &CSOEconItem| { &m.account_id },
                |m: &mut CSOEconItem| { &mut m.account_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "inventory",
                |m: &CSOEconItem| { &m.inventory },
                |m: &mut CSOEconItem| { &mut m.inventory },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "def_index",
                |m: &CSOEconItem| { &m.def_index },
                |m: &mut CSOEconItem| { &mut m.def_index },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "quantity",
                |m: &CSOEconItem| { &m.quantity },
                |m: &mut CSOEconItem| { &mut m.quantity },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "level",
                |m: &CSOEconItem| { &m.level },
                |m: &mut CSOEconItem| { &mut m.level },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "quality",
                |m: &CSOEconItem| { &m.quality },
                |m: &mut CSOEconItem| { &mut m.quality },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "flags",
                |m: &CSOEconItem| { &m.flags },
                |m: &mut CSOEconItem| { &mut m.flags },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "origin",
                |m: &CSOEconItem| { &m.origin },
                |m: &mut CSOEconItem| { &mut m.origin },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "custom_name",
                |m: &CSOEconItem| { &m.custom_name },
                |m: &mut CSOEconItem| { &mut m.custom_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "custom_desc",
                |m: &CSOEconItem| { &m.custom_desc },
                |m: &mut CSOEconItem| { &mut m.custom_desc },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CSOEconItemAttribute>>(
                "attribute",
                |m: &CSOEconItem| { &m.attribute },
                |m: &mut CSOEconItem| { &mut m.attribute },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CSOEconItem>>(
                "interior_item",
                |m: &CSOEconItem| { &m.interior_item },
                |m: &mut CSOEconItem| { &mut m.interior_item },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "in_use",
                |m: &CSOEconItem| { &m.in_use },
                |m: &mut CSOEconItem| { &mut m.in_use },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "style",
                |m: &CSOEconItem| { &m.style },
                |m: &mut CSOEconItem| { &mut m.style },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "original_id",
                |m: &CSOEconItem| { &m.original_id },
                |m: &mut CSOEconItem| { &mut m.original_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "contains_equipped_state",
                |m: &CSOEconItem| { &m.contains_equipped_state },
                |m: &mut CSOEconItem| { &mut m.contains_equipped_state },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CSOEconItemEquipped>>(
                "equipped_state",
                |m: &CSOEconItem| { &m.equipped_state },
                |m: &mut CSOEconItem| { &mut m.equipped_state },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "contains_equipped_state_v2",
                |m: &CSOEconItem| { &m.contains_equipped_state_v2 },
                |m: &mut CSOEconItem| { &mut m.contains_equipped_state_v2 },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CSOEconItem>(
                "CSOEconItem",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CSOEconItem {
        static instance: ::protobuf::rt::LazyV2<CSOEconItem> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CSOEconItem::new)
    }
}

impl ::protobuf::Clear for CSOEconItem {
    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.account_id = ::std::option::Option::None;
        self.inventory = ::std::option::Option::None;
        self.def_index = ::std::option::Option::None;
        self.quantity = ::std::option::Option::None;
        self.level = ::std::option::Option::None;
        self.quality = ::std::option::Option::None;
        self.flags = ::std::option::Option::None;
        self.origin = ::std::option::Option::None;
        self.custom_name.clear();
        self.custom_desc.clear();
        self.attribute.clear();
        self.interior_item.clear();
        self.in_use = ::std::option::Option::None;
        self.style = ::std::option::Option::None;
        self.original_id = ::std::option::Option::None;
        self.contains_equipped_state = ::std::option::Option::None;
        self.equipped_state.clear();
        self.contains_equipped_state_v2 = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSOEconItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOEconItem {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgAdjustItemEquippedState {
    // message fields
    item_id: ::std::option::Option<u64>,
    new_class: ::std::option::Option<u32>,
    new_slot: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgAdjustItemEquippedState {
    fn default() -> &'a CMsgAdjustItemEquippedState {
        <CMsgAdjustItemEquippedState as ::protobuf::Message>::default_instance()
    }
}

impl CMsgAdjustItemEquippedState {
    pub fn new() -> CMsgAdjustItemEquippedState {
        ::std::default::Default::default()
    }

    // optional uint64 item_id = 1;


    pub fn get_item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }
    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    // optional uint32 new_class = 2;


    pub fn get_new_class(&self) -> u32 {
        self.new_class.unwrap_or(0)
    }
    pub fn clear_new_class(&mut self) {
        self.new_class = ::std::option::Option::None;
    }

    pub fn has_new_class(&self) -> bool {
        self.new_class.is_some()
    }

    // Param is passed by value, moved
    pub fn set_new_class(&mut self, v: u32) {
        self.new_class = ::std::option::Option::Some(v);
    }

    // optional uint32 new_slot = 3;


    pub fn get_new_slot(&self) -> u32 {
        self.new_slot.unwrap_or(0)
    }
    pub fn clear_new_slot(&mut self) {
        self.new_slot = ::std::option::Option::None;
    }

    pub fn has_new_slot(&self) -> bool {
        self.new_slot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_new_slot(&mut self, v: u32) {
        self.new_slot = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgAdjustItemEquippedState {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.item_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.new_class = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.new_slot = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.new_class {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.new_slot {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.new_class {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.new_slot {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgAdjustItemEquippedState {
        CMsgAdjustItemEquippedState::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "item_id",
                |m: &CMsgAdjustItemEquippedState| { &m.item_id },
                |m: &mut CMsgAdjustItemEquippedState| { &mut m.item_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "new_class",
                |m: &CMsgAdjustItemEquippedState| { &m.new_class },
                |m: &mut CMsgAdjustItemEquippedState| { &mut m.new_class },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "new_slot",
                |m: &CMsgAdjustItemEquippedState| { &m.new_slot },
                |m: &mut CMsgAdjustItemEquippedState| { &mut m.new_slot },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgAdjustItemEquippedState>(
                "CMsgAdjustItemEquippedState",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgAdjustItemEquippedState {
        static instance: ::protobuf::rt::LazyV2<CMsgAdjustItemEquippedState> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgAdjustItemEquippedState::new)
    }
}

impl ::protobuf::Clear for CMsgAdjustItemEquippedState {
    fn clear(&mut self) {
        self.item_id = ::std::option::Option::None;
        self.new_class = ::std::option::Option::None;
        self.new_slot = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgAdjustItemEquippedState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgAdjustItemEquippedState {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSortItems {
    // message fields
    sort_type: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSortItems {
    fn default() -> &'a CMsgSortItems {
        <CMsgSortItems as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSortItems {
    pub fn new() -> CMsgSortItems {
        ::std::default::Default::default()
    }

    // optional uint32 sort_type = 1;


    pub fn get_sort_type(&self) -> u32 {
        self.sort_type.unwrap_or(0)
    }
    pub fn clear_sort_type(&mut self) {
        self.sort_type = ::std::option::Option::None;
    }

    pub fn has_sort_type(&self) -> bool {
        self.sort_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sort_type(&mut self, v: u32) {
        self.sort_type = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSortItems {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.sort_type = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.sort_type {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.sort_type {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSortItems {
        CMsgSortItems::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "sort_type",
                |m: &CMsgSortItems| { &m.sort_type },
                |m: &mut CMsgSortItems| { &mut m.sort_type },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSortItems>(
                "CMsgSortItems",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSortItems {
        static instance: ::protobuf::rt::LazyV2<CMsgSortItems> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSortItems::new)
    }
}

impl ::protobuf::Clear for CMsgSortItems {
    fn clear(&mut self) {
        self.sort_type = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSortItems {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSortItems {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CSOEconClaimCode {
    // message fields
    account_id: ::std::option::Option<u32>,
    code_type: ::std::option::Option<u32>,
    time_acquired: ::std::option::Option<u32>,
    code: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CSOEconClaimCode {
    fn default() -> &'a CSOEconClaimCode {
        <CSOEconClaimCode as ::protobuf::Message>::default_instance()
    }
}

impl CSOEconClaimCode {
    pub fn new() -> CSOEconClaimCode {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;


    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }
    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 code_type = 2;


    pub fn get_code_type(&self) -> u32 {
        self.code_type.unwrap_or(0)
    }
    pub fn clear_code_type(&mut self) {
        self.code_type = ::std::option::Option::None;
    }

    pub fn has_code_type(&self) -> bool {
        self.code_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_code_type(&mut self, v: u32) {
        self.code_type = ::std::option::Option::Some(v);
    }

    // optional uint32 time_acquired = 3;


    pub fn get_time_acquired(&self) -> u32 {
        self.time_acquired.unwrap_or(0)
    }
    pub fn clear_time_acquired(&mut self) {
        self.time_acquired = ::std::option::Option::None;
    }

    pub fn has_time_acquired(&self) -> bool {
        self.time_acquired.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_acquired(&mut self, v: u32) {
        self.time_acquired = ::std::option::Option::Some(v);
    }

    // optional string code = 4;


    pub fn get_code(&self) -> &str {
        match self.code.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_code(&mut self) {
        self.code.clear();
    }

    pub fn has_code(&self) -> bool {
        self.code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_code(&mut self, v: ::std::string::String) {
        self.code = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_code(&mut self) -> &mut ::std::string::String {
        if self.code.is_none() {
            self.code.set_default();
        }
        self.code.as_mut().unwrap()
    }

    // Take field
    pub fn take_code(&mut self) -> ::std::string::String {
        self.code.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CSOEconClaimCode {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.code_type = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time_acquired = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.code)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.code_type {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.time_acquired {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.code.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.code_type {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.time_acquired {
            os.write_uint32(3, v)?;
        }
        if let Some(ref v) = self.code.as_ref() {
            os.write_string(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CSOEconClaimCode {
        CSOEconClaimCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "account_id",
                |m: &CSOEconClaimCode| { &m.account_id },
                |m: &mut CSOEconClaimCode| { &mut m.account_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "code_type",
                |m: &CSOEconClaimCode| { &m.code_type },
                |m: &mut CSOEconClaimCode| { &mut m.code_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "time_acquired",
                |m: &CSOEconClaimCode| { &m.time_acquired },
                |m: &mut CSOEconClaimCode| { &mut m.time_acquired },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "code",
                |m: &CSOEconClaimCode| { &m.code },
                |m: &mut CSOEconClaimCode| { &mut m.code },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CSOEconClaimCode>(
                "CSOEconClaimCode",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CSOEconClaimCode {
        static instance: ::protobuf::rt::LazyV2<CSOEconClaimCode> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CSOEconClaimCode::new)
    }
}

impl ::protobuf::Clear for CSOEconClaimCode {
    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.code_type = ::std::option::Option::None;
        self.time_acquired = ::std::option::Option::None;
        self.code.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSOEconClaimCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOEconClaimCode {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgStoreGetUserData {
    // message fields
    price_sheet_version: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgStoreGetUserData {
    fn default() -> &'a CMsgStoreGetUserData {
        <CMsgStoreGetUserData as ::protobuf::Message>::default_instance()
    }
}

impl CMsgStoreGetUserData {
    pub fn new() -> CMsgStoreGetUserData {
        ::std::default::Default::default()
    }

    // optional fixed32 price_sheet_version = 1;


    pub fn get_price_sheet_version(&self) -> u32 {
        self.price_sheet_version.unwrap_or(0)
    }
    pub fn clear_price_sheet_version(&mut self) {
        self.price_sheet_version = ::std::option::Option::None;
    }

    pub fn has_price_sheet_version(&self) -> bool {
        self.price_sheet_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_price_sheet_version(&mut self, v: u32) {
        self.price_sheet_version = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgStoreGetUserData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.price_sheet_version = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.price_sheet_version {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.price_sheet_version {
            os.write_fixed32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgStoreGetUserData {
        CMsgStoreGetUserData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "price_sheet_version",
                |m: &CMsgStoreGetUserData| { &m.price_sheet_version },
                |m: &mut CMsgStoreGetUserData| { &mut m.price_sheet_version },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgStoreGetUserData>(
                "CMsgStoreGetUserData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgStoreGetUserData {
        static instance: ::protobuf::rt::LazyV2<CMsgStoreGetUserData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgStoreGetUserData::new)
    }
}

impl ::protobuf::Clear for CMsgStoreGetUserData {
    fn clear(&mut self) {
        self.price_sheet_version = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgStoreGetUserData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgStoreGetUserData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgStoreGetUserDataResponse {
    // message fields
    result: ::std::option::Option<i32>,
    currency: ::std::option::Option<i32>,
    country: ::protobuf::SingularField<::std::string::String>,
    price_sheet_version: ::std::option::Option<u32>,
    experiment_data: ::std::option::Option<u64>,
    featured_item_idx: ::std::option::Option<i32>,
    show_hat_descriptions: ::std::option::Option<bool>,
    price_sheet: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    default_item_sort: ::std::option::Option<i32>,
    pub popular_items: ::std::vec::Vec<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgStoreGetUserDataResponse {
    fn default() -> &'a CMsgStoreGetUserDataResponse {
        <CMsgStoreGetUserDataResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgStoreGetUserDataResponse {
    pub fn new() -> CMsgStoreGetUserDataResponse {
        ::std::default::Default::default()
    }

    // optional int32 result = 1;


    pub fn get_result(&self) -> i32 {
        self.result.unwrap_or(0)
    }
    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: i32) {
        self.result = ::std::option::Option::Some(v);
    }

    // optional int32 currency = 2;


    pub fn get_currency(&self) -> i32 {
        self.currency.unwrap_or(0)
    }
    pub fn clear_currency(&mut self) {
        self.currency = ::std::option::Option::None;
    }

    pub fn has_currency(&self) -> bool {
        self.currency.is_some()
    }

    // Param is passed by value, moved
    pub fn set_currency(&mut self, v: i32) {
        self.currency = ::std::option::Option::Some(v);
    }

    // optional string country = 3;


    pub fn get_country(&self) -> &str {
        match self.country.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_country(&mut self) {
        self.country.clear();
    }

    pub fn has_country(&self) -> bool {
        self.country.is_some()
    }

    // Param is passed by value, moved
    pub fn set_country(&mut self, v: ::std::string::String) {
        self.country = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_country(&mut self) -> &mut ::std::string::String {
        if self.country.is_none() {
            self.country.set_default();
        }
        self.country.as_mut().unwrap()
    }

    // Take field
    pub fn take_country(&mut self) -> ::std::string::String {
        self.country.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional fixed32 price_sheet_version = 4;


    pub fn get_price_sheet_version(&self) -> u32 {
        self.price_sheet_version.unwrap_or(0)
    }
    pub fn clear_price_sheet_version(&mut self) {
        self.price_sheet_version = ::std::option::Option::None;
    }

    pub fn has_price_sheet_version(&self) -> bool {
        self.price_sheet_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_price_sheet_version(&mut self, v: u32) {
        self.price_sheet_version = ::std::option::Option::Some(v);
    }

    // optional uint64 experiment_data = 5;


    pub fn get_experiment_data(&self) -> u64 {
        self.experiment_data.unwrap_or(0u64)
    }
    pub fn clear_experiment_data(&mut self) {
        self.experiment_data = ::std::option::Option::None;
    }

    pub fn has_experiment_data(&self) -> bool {
        self.experiment_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_experiment_data(&mut self, v: u64) {
        self.experiment_data = ::std::option::Option::Some(v);
    }

    // optional int32 featured_item_idx = 6;


    pub fn get_featured_item_idx(&self) -> i32 {
        self.featured_item_idx.unwrap_or(0)
    }
    pub fn clear_featured_item_idx(&mut self) {
        self.featured_item_idx = ::std::option::Option::None;
    }

    pub fn has_featured_item_idx(&self) -> bool {
        self.featured_item_idx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_featured_item_idx(&mut self, v: i32) {
        self.featured_item_idx = ::std::option::Option::Some(v);
    }

    // optional bool show_hat_descriptions = 7;


    pub fn get_show_hat_descriptions(&self) -> bool {
        self.show_hat_descriptions.unwrap_or(true)
    }
    pub fn clear_show_hat_descriptions(&mut self) {
        self.show_hat_descriptions = ::std::option::Option::None;
    }

    pub fn has_show_hat_descriptions(&self) -> bool {
        self.show_hat_descriptions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_show_hat_descriptions(&mut self, v: bool) {
        self.show_hat_descriptions = ::std::option::Option::Some(v);
    }

    // optional bytes price_sheet = 8;


    pub fn get_price_sheet(&self) -> &[u8] {
        match self.price_sheet.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_price_sheet(&mut self) {
        self.price_sheet.clear();
    }

    pub fn has_price_sheet(&self) -> bool {
        self.price_sheet.is_some()
    }

    // Param is passed by value, moved
    pub fn set_price_sheet(&mut self, v: ::std::vec::Vec<u8>) {
        self.price_sheet = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_price_sheet(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.price_sheet.is_none() {
            self.price_sheet.set_default();
        }
        self.price_sheet.as_mut().unwrap()
    }

    // Take field
    pub fn take_price_sheet(&mut self) -> ::std::vec::Vec<u8> {
        self.price_sheet.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional int32 default_item_sort = 9;


    pub fn get_default_item_sort(&self) -> i32 {
        self.default_item_sort.unwrap_or(0i32)
    }
    pub fn clear_default_item_sort(&mut self) {
        self.default_item_sort = ::std::option::Option::None;
    }

    pub fn has_default_item_sort(&self) -> bool {
        self.default_item_sort.is_some()
    }

    // Param is passed by value, moved
    pub fn set_default_item_sort(&mut self, v: i32) {
        self.default_item_sort = ::std::option::Option::Some(v);
    }

    // repeated uint32 popular_items = 10;


    pub fn get_popular_items(&self) -> &[u32] {
        &self.popular_items
    }
    pub fn clear_popular_items(&mut self) {
        self.popular_items.clear();
    }

    // Param is passed by value, moved
    pub fn set_popular_items(&mut self, v: ::std::vec::Vec<u32>) {
        self.popular_items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_popular_items(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.popular_items
    }

    // Take field
    pub fn take_popular_items(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.popular_items, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgStoreGetUserDataResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.currency = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.country)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.price_sheet_version = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.experiment_data = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.featured_item_idx = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.show_hat_descriptions = ::std::option::Option::Some(tmp);
                },
                8 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.price_sheet)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.default_item_sort = ::std::option::Option::Some(tmp);
                },
                10 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.popular_items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.currency {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.country.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.price_sheet_version {
            my_size += 5;
        }
        if let Some(v) = self.experiment_data {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.featured_item_idx {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.show_hat_descriptions {
            my_size += 2;
        }
        if let Some(ref v) = self.price_sheet.as_ref() {
            my_size += ::protobuf::rt::bytes_size(8, &v);
        }
        if let Some(v) = self.default_item_sort {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.popular_items {
            my_size += ::protobuf::rt::value_size(10, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.currency {
            os.write_int32(2, v)?;
        }
        if let Some(ref v) = self.country.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.price_sheet_version {
            os.write_fixed32(4, v)?;
        }
        if let Some(v) = self.experiment_data {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.featured_item_idx {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.show_hat_descriptions {
            os.write_bool(7, v)?;
        }
        if let Some(ref v) = self.price_sheet.as_ref() {
            os.write_bytes(8, &v)?;
        }
        if let Some(v) = self.default_item_sort {
            os.write_int32(9, v)?;
        }
        for v in &self.popular_items {
            os.write_uint32(10, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgStoreGetUserDataResponse {
        CMsgStoreGetUserDataResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "result",
                |m: &CMsgStoreGetUserDataResponse| { &m.result },
                |m: &mut CMsgStoreGetUserDataResponse| { &mut m.result },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "currency",
                |m: &CMsgStoreGetUserDataResponse| { &m.currency },
                |m: &mut CMsgStoreGetUserDataResponse| { &mut m.currency },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "country",
                |m: &CMsgStoreGetUserDataResponse| { &m.country },
                |m: &mut CMsgStoreGetUserDataResponse| { &mut m.country },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "price_sheet_version",
                |m: &CMsgStoreGetUserDataResponse| { &m.price_sheet_version },
                |m: &mut CMsgStoreGetUserDataResponse| { &mut m.price_sheet_version },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "experiment_data",
                |m: &CMsgStoreGetUserDataResponse| { &m.experiment_data },
                |m: &mut CMsgStoreGetUserDataResponse| { &mut m.experiment_data },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "featured_item_idx",
                |m: &CMsgStoreGetUserDataResponse| { &m.featured_item_idx },
                |m: &mut CMsgStoreGetUserDataResponse| { &mut m.featured_item_idx },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "show_hat_descriptions",
                |m: &CMsgStoreGetUserDataResponse| { &m.show_hat_descriptions },
                |m: &mut CMsgStoreGetUserDataResponse| { &mut m.show_hat_descriptions },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "price_sheet",
                |m: &CMsgStoreGetUserDataResponse| { &m.price_sheet },
                |m: &mut CMsgStoreGetUserDataResponse| { &mut m.price_sheet },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "default_item_sort",
                |m: &CMsgStoreGetUserDataResponse| { &m.default_item_sort },
                |m: &mut CMsgStoreGetUserDataResponse| { &mut m.default_item_sort },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "popular_items",
                |m: &CMsgStoreGetUserDataResponse| { &m.popular_items },
                |m: &mut CMsgStoreGetUserDataResponse| { &mut m.popular_items },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgStoreGetUserDataResponse>(
                "CMsgStoreGetUserDataResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgStoreGetUserDataResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgStoreGetUserDataResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgStoreGetUserDataResponse::new)
    }
}

impl ::protobuf::Clear for CMsgStoreGetUserDataResponse {
    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.currency = ::std::option::Option::None;
        self.country.clear();
        self.price_sheet_version = ::std::option::Option::None;
        self.experiment_data = ::std::option::Option::None;
        self.featured_item_idx = ::std::option::Option::None;
        self.show_hat_descriptions = ::std::option::Option::None;
        self.price_sheet.clear();
        self.default_item_sort = ::std::option::Option::None;
        self.popular_items.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgStoreGetUserDataResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgStoreGetUserDataResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgUpdateItemSchema {
    // message fields
    items_game: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    item_schema_version: ::std::option::Option<u32>,
    items_game_url: ::protobuf::SingularField<::std::string::String>,
    signature: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgUpdateItemSchema {
    fn default() -> &'a CMsgUpdateItemSchema {
        <CMsgUpdateItemSchema as ::protobuf::Message>::default_instance()
    }
}

impl CMsgUpdateItemSchema {
    pub fn new() -> CMsgUpdateItemSchema {
        ::std::default::Default::default()
    }

    // optional bytes items_game = 1;


    pub fn get_items_game(&self) -> &[u8] {
        match self.items_game.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_items_game(&mut self) {
        self.items_game.clear();
    }

    pub fn has_items_game(&self) -> bool {
        self.items_game.is_some()
    }

    // Param is passed by value, moved
    pub fn set_items_game(&mut self, v: ::std::vec::Vec<u8>) {
        self.items_game = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_items_game(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.items_game.is_none() {
            self.items_game.set_default();
        }
        self.items_game.as_mut().unwrap()
    }

    // Take field
    pub fn take_items_game(&mut self) -> ::std::vec::Vec<u8> {
        self.items_game.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional fixed32 item_schema_version = 2;


    pub fn get_item_schema_version(&self) -> u32 {
        self.item_schema_version.unwrap_or(0)
    }
    pub fn clear_item_schema_version(&mut self) {
        self.item_schema_version = ::std::option::Option::None;
    }

    pub fn has_item_schema_version(&self) -> bool {
        self.item_schema_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_schema_version(&mut self, v: u32) {
        self.item_schema_version = ::std::option::Option::Some(v);
    }

    // optional string items_game_url = 3;


    pub fn get_items_game_url(&self) -> &str {
        match self.items_game_url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_items_game_url(&mut self) {
        self.items_game_url.clear();
    }

    pub fn has_items_game_url(&self) -> bool {
        self.items_game_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_items_game_url(&mut self, v: ::std::string::String) {
        self.items_game_url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_items_game_url(&mut self) -> &mut ::std::string::String {
        if self.items_game_url.is_none() {
            self.items_game_url.set_default();
        }
        self.items_game_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_items_game_url(&mut self) -> ::std::string::String {
        self.items_game_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes signature = 4;


    pub fn get_signature(&self) -> &[u8] {
        match self.signature.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_signature(&mut self) {
        self.signature.clear();
    }

    pub fn has_signature(&self) -> bool {
        self.signature.is_some()
    }

    // Param is passed by value, moved
    pub fn set_signature(&mut self, v: ::std::vec::Vec<u8>) {
        self.signature = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signature(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.signature.is_none() {
            self.signature.set_default();
        }
        self.signature.as_mut().unwrap()
    }

    // Take field
    pub fn take_signature(&mut self) -> ::std::vec::Vec<u8> {
        self.signature.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgUpdateItemSchema {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.items_game)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.item_schema_version = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.items_game_url)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.signature)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.items_game.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.item_schema_version {
            my_size += 5;
        }
        if let Some(ref v) = self.items_game_url.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.signature.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.items_game.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(v) = self.item_schema_version {
            os.write_fixed32(2, v)?;
        }
        if let Some(ref v) = self.items_game_url.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.signature.as_ref() {
            os.write_bytes(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgUpdateItemSchema {
        CMsgUpdateItemSchema::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "items_game",
                |m: &CMsgUpdateItemSchema| { &m.items_game },
                |m: &mut CMsgUpdateItemSchema| { &mut m.items_game },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "item_schema_version",
                |m: &CMsgUpdateItemSchema| { &m.item_schema_version },
                |m: &mut CMsgUpdateItemSchema| { &mut m.item_schema_version },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "items_game_url",
                |m: &CMsgUpdateItemSchema| { &m.items_game_url },
                |m: &mut CMsgUpdateItemSchema| { &mut m.items_game_url },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "signature",
                |m: &CMsgUpdateItemSchema| { &m.signature },
                |m: &mut CMsgUpdateItemSchema| { &mut m.signature },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgUpdateItemSchema>(
                "CMsgUpdateItemSchema",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgUpdateItemSchema {
        static instance: ::protobuf::rt::LazyV2<CMsgUpdateItemSchema> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgUpdateItemSchema::new)
    }
}

impl ::protobuf::Clear for CMsgUpdateItemSchema {
    fn clear(&mut self) {
        self.items_game.clear();
        self.item_schema_version = ::std::option::Option::None;
        self.items_game_url.clear();
        self.signature.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgUpdateItemSchema {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgUpdateItemSchema {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCError {
    // message fields
    error_text: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCError {
    fn default() -> &'a CMsgGCError {
        <CMsgGCError as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCError {
    pub fn new() -> CMsgGCError {
        ::std::default::Default::default()
    }

    // optional string error_text = 1;


    pub fn get_error_text(&self) -> &str {
        match self.error_text.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_error_text(&mut self) {
        self.error_text.clear();
    }

    pub fn has_error_text(&self) -> bool {
        self.error_text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error_text(&mut self, v: ::std::string::String) {
        self.error_text = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error_text(&mut self) -> &mut ::std::string::String {
        if self.error_text.is_none() {
            self.error_text.set_default();
        }
        self.error_text.as_mut().unwrap()
    }

    // Take field
    pub fn take_error_text(&mut self) -> ::std::string::String {
        self.error_text.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgGCError {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.error_text)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.error_text.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.error_text.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCError {
        CMsgGCError::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "error_text",
                |m: &CMsgGCError| { &m.error_text },
                |m: &mut CMsgGCError| { &mut m.error_text },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCError>(
                "CMsgGCError",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCError {
        static instance: ::protobuf::rt::LazyV2<CMsgGCError> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCError::new)
    }
}

impl ::protobuf::Clear for CMsgGCError {
    fn clear(&mut self) {
        self.error_text.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCError {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgRequestInventoryRefresh {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgRequestInventoryRefresh {
    fn default() -> &'a CMsgRequestInventoryRefresh {
        <CMsgRequestInventoryRefresh as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRequestInventoryRefresh {
    pub fn new() -> CMsgRequestInventoryRefresh {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgRequestInventoryRefresh {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgRequestInventoryRefresh {
        CMsgRequestInventoryRefresh::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgRequestInventoryRefresh>(
                "CMsgRequestInventoryRefresh",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgRequestInventoryRefresh {
        static instance: ::protobuf::rt::LazyV2<CMsgRequestInventoryRefresh> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgRequestInventoryRefresh::new)
    }
}

impl ::protobuf::Clear for CMsgRequestInventoryRefresh {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgRequestInventoryRefresh {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgRequestInventoryRefresh {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgConVarValue {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    value: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgConVarValue {
    fn default() -> &'a CMsgConVarValue {
        <CMsgConVarValue as ::protobuf::Message>::default_instance()
    }
}

impl CMsgConVarValue {
    pub fn new() -> CMsgConVarValue {
        ::std::default::Default::default()
    }

    // optional string name = 1;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string value = 2;


    pub fn get_value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgConVarValue {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.value.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgConVarValue {
        CMsgConVarValue::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &CMsgConVarValue| { &m.name },
                |m: &mut CMsgConVarValue| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "value",
                |m: &CMsgConVarValue| { &m.value },
                |m: &mut CMsgConVarValue| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgConVarValue>(
                "CMsgConVarValue",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgConVarValue {
        static instance: ::protobuf::rt::LazyV2<CMsgConVarValue> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgConVarValue::new)
    }
}

impl ::protobuf::Clear for CMsgConVarValue {
    fn clear(&mut self) {
        self.name.clear();
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgConVarValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgConVarValue {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgReplicateConVars {
    // message fields
    pub convars: ::protobuf::RepeatedField<CMsgConVarValue>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgReplicateConVars {
    fn default() -> &'a CMsgReplicateConVars {
        <CMsgReplicateConVars as ::protobuf::Message>::default_instance()
    }
}

impl CMsgReplicateConVars {
    pub fn new() -> CMsgReplicateConVars {
        ::std::default::Default::default()
    }

    // repeated .CMsgConVarValue convars = 1;


    pub fn get_convars(&self) -> &[CMsgConVarValue] {
        &self.convars
    }
    pub fn clear_convars(&mut self) {
        self.convars.clear();
    }

    // Param is passed by value, moved
    pub fn set_convars(&mut self, v: ::protobuf::RepeatedField<CMsgConVarValue>) {
        self.convars = v;
    }

    // Mutable pointer to the field.
    pub fn mut_convars(&mut self) -> &mut ::protobuf::RepeatedField<CMsgConVarValue> {
        &mut self.convars
    }

    // Take field
    pub fn take_convars(&mut self) -> ::protobuf::RepeatedField<CMsgConVarValue> {
        ::std::mem::replace(&mut self.convars, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgReplicateConVars {
    fn is_initialized(&self) -> bool {
        for v in &self.convars {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.convars)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.convars {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.convars {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgReplicateConVars {
        CMsgReplicateConVars::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgConVarValue>>(
                "convars",
                |m: &CMsgReplicateConVars| { &m.convars },
                |m: &mut CMsgReplicateConVars| { &mut m.convars },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgReplicateConVars>(
                "CMsgReplicateConVars",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgReplicateConVars {
        static instance: ::protobuf::rt::LazyV2<CMsgReplicateConVars> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgReplicateConVars::new)
    }
}

impl ::protobuf::Clear for CMsgReplicateConVars {
    fn clear(&mut self) {
        self.convars.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgReplicateConVars {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgReplicateConVars {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgUseItem {
    // message fields
    item_id: ::std::option::Option<u64>,
    target_steam_id: ::std::option::Option<u64>,
    pub gift__potential_targets: ::std::vec::Vec<u32>,
    duel__class_lock: ::std::option::Option<u32>,
    initiator_steam_id: ::std::option::Option<u64>,
    itempack__ack_immediately: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgUseItem {
    fn default() -> &'a CMsgUseItem {
        <CMsgUseItem as ::protobuf::Message>::default_instance()
    }
}

impl CMsgUseItem {
    pub fn new() -> CMsgUseItem {
        ::std::default::Default::default()
    }

    // optional uint64 item_id = 1;


    pub fn get_item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }
    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 target_steam_id = 2;


    pub fn get_target_steam_id(&self) -> u64 {
        self.target_steam_id.unwrap_or(0)
    }
    pub fn clear_target_steam_id(&mut self) {
        self.target_steam_id = ::std::option::Option::None;
    }

    pub fn has_target_steam_id(&self) -> bool {
        self.target_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_steam_id(&mut self, v: u64) {
        self.target_steam_id = ::std::option::Option::Some(v);
    }

    // repeated uint32 gift__potential_targets = 3;


    pub fn get_gift__potential_targets(&self) -> &[u32] {
        &self.gift__potential_targets
    }
    pub fn clear_gift__potential_targets(&mut self) {
        self.gift__potential_targets.clear();
    }

    // Param is passed by value, moved
    pub fn set_gift__potential_targets(&mut self, v: ::std::vec::Vec<u32>) {
        self.gift__potential_targets = v;
    }

    // Mutable pointer to the field.
    pub fn mut_gift__potential_targets(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.gift__potential_targets
    }

    // Take field
    pub fn take_gift__potential_targets(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.gift__potential_targets, ::std::vec::Vec::new())
    }

    // optional uint32 duel__class_lock = 4;


    pub fn get_duel__class_lock(&self) -> u32 {
        self.duel__class_lock.unwrap_or(0)
    }
    pub fn clear_duel__class_lock(&mut self) {
        self.duel__class_lock = ::std::option::Option::None;
    }

    pub fn has_duel__class_lock(&self) -> bool {
        self.duel__class_lock.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duel__class_lock(&mut self, v: u32) {
        self.duel__class_lock = ::std::option::Option::Some(v);
    }

    // optional fixed64 initiator_steam_id = 5;


    pub fn get_initiator_steam_id(&self) -> u64 {
        self.initiator_steam_id.unwrap_or(0)
    }
    pub fn clear_initiator_steam_id(&mut self) {
        self.initiator_steam_id = ::std::option::Option::None;
    }

    pub fn has_initiator_steam_id(&self) -> bool {
        self.initiator_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initiator_steam_id(&mut self, v: u64) {
        self.initiator_steam_id = ::std::option::Option::Some(v);
    }

    // optional bool itempack__ack_immediately = 6;


    pub fn get_itempack__ack_immediately(&self) -> bool {
        self.itempack__ack_immediately.unwrap_or(false)
    }
    pub fn clear_itempack__ack_immediately(&mut self) {
        self.itempack__ack_immediately = ::std::option::Option::None;
    }

    pub fn has_itempack__ack_immediately(&self) -> bool {
        self.itempack__ack_immediately.is_some()
    }

    // Param is passed by value, moved
    pub fn set_itempack__ack_immediately(&mut self, v: bool) {
        self.itempack__ack_immediately = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgUseItem {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.item_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.target_steam_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.gift__potential_targets)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.duel__class_lock = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.initiator_steam_id = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.itempack__ack_immediately = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.target_steam_id {
            my_size += 9;
        }
        for value in &self.gift__potential_targets {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.duel__class_lock {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.initiator_steam_id {
            my_size += 9;
        }
        if let Some(v) = self.itempack__ack_immediately {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.target_steam_id {
            os.write_fixed64(2, v)?;
        }
        for v in &self.gift__potential_targets {
            os.write_uint32(3, *v)?;
        };
        if let Some(v) = self.duel__class_lock {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.initiator_steam_id {
            os.write_fixed64(5, v)?;
        }
        if let Some(v) = self.itempack__ack_immediately {
            os.write_bool(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgUseItem {
        CMsgUseItem::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "item_id",
                |m: &CMsgUseItem| { &m.item_id },
                |m: &mut CMsgUseItem| { &mut m.item_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "target_steam_id",
                |m: &CMsgUseItem| { &m.target_steam_id },
                |m: &mut CMsgUseItem| { &mut m.target_steam_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "gift__potential_targets",
                |m: &CMsgUseItem| { &m.gift__potential_targets },
                |m: &mut CMsgUseItem| { &mut m.gift__potential_targets },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "duel__class_lock",
                |m: &CMsgUseItem| { &m.duel__class_lock },
                |m: &mut CMsgUseItem| { &mut m.duel__class_lock },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "initiator_steam_id",
                |m: &CMsgUseItem| { &m.initiator_steam_id },
                |m: &mut CMsgUseItem| { &mut m.initiator_steam_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "itempack__ack_immediately",
                |m: &CMsgUseItem| { &m.itempack__ack_immediately },
                |m: &mut CMsgUseItem| { &mut m.itempack__ack_immediately },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgUseItem>(
                "CMsgUseItem",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgUseItem {
        static instance: ::protobuf::rt::LazyV2<CMsgUseItem> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgUseItem::new)
    }
}

impl ::protobuf::Clear for CMsgUseItem {
    fn clear(&mut self) {
        self.item_id = ::std::option::Option::None;
        self.target_steam_id = ::std::option::Option::None;
        self.gift__potential_targets.clear();
        self.duel__class_lock = ::std::option::Option::None;
        self.initiator_steam_id = ::std::option::Option::None;
        self.itempack__ack_immediately = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgUseItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgUseItem {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgReplayUploadedToYouTube {
    // message fields
    youtube_url: ::protobuf::SingularField<::std::string::String>,
    youtube_account_name: ::protobuf::SingularField<::std::string::String>,
    session_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgReplayUploadedToYouTube {
    fn default() -> &'a CMsgReplayUploadedToYouTube {
        <CMsgReplayUploadedToYouTube as ::protobuf::Message>::default_instance()
    }
}

impl CMsgReplayUploadedToYouTube {
    pub fn new() -> CMsgReplayUploadedToYouTube {
        ::std::default::Default::default()
    }

    // optional string youtube_url = 1;


    pub fn get_youtube_url(&self) -> &str {
        match self.youtube_url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_youtube_url(&mut self) {
        self.youtube_url.clear();
    }

    pub fn has_youtube_url(&self) -> bool {
        self.youtube_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_youtube_url(&mut self, v: ::std::string::String) {
        self.youtube_url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_youtube_url(&mut self) -> &mut ::std::string::String {
        if self.youtube_url.is_none() {
            self.youtube_url.set_default();
        }
        self.youtube_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_youtube_url(&mut self) -> ::std::string::String {
        self.youtube_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string youtube_account_name = 2;


    pub fn get_youtube_account_name(&self) -> &str {
        match self.youtube_account_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_youtube_account_name(&mut self) {
        self.youtube_account_name.clear();
    }

    pub fn has_youtube_account_name(&self) -> bool {
        self.youtube_account_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_youtube_account_name(&mut self, v: ::std::string::String) {
        self.youtube_account_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_youtube_account_name(&mut self) -> &mut ::std::string::String {
        if self.youtube_account_name.is_none() {
            self.youtube_account_name.set_default();
        }
        self.youtube_account_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_youtube_account_name(&mut self) -> ::std::string::String {
        self.youtube_account_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 session_id = 3;


    pub fn get_session_id(&self) -> u64 {
        self.session_id.unwrap_or(0)
    }
    pub fn clear_session_id(&mut self) {
        self.session_id = ::std::option::Option::None;
    }

    pub fn has_session_id(&self) -> bool {
        self.session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_session_id(&mut self, v: u64) {
        self.session_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgReplayUploadedToYouTube {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.youtube_url)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.youtube_account_name)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.session_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.youtube_url.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.youtube_account_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.session_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.youtube_url.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.youtube_account_name.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.session_id {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgReplayUploadedToYouTube {
        CMsgReplayUploadedToYouTube::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "youtube_url",
                |m: &CMsgReplayUploadedToYouTube| { &m.youtube_url },
                |m: &mut CMsgReplayUploadedToYouTube| { &mut m.youtube_url },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "youtube_account_name",
                |m: &CMsgReplayUploadedToYouTube| { &m.youtube_account_name },
                |m: &mut CMsgReplayUploadedToYouTube| { &mut m.youtube_account_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "session_id",
                |m: &CMsgReplayUploadedToYouTube| { &m.session_id },
                |m: &mut CMsgReplayUploadedToYouTube| { &mut m.session_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgReplayUploadedToYouTube>(
                "CMsgReplayUploadedToYouTube",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgReplayUploadedToYouTube {
        static instance: ::protobuf::rt::LazyV2<CMsgReplayUploadedToYouTube> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgReplayUploadedToYouTube::new)
    }
}

impl ::protobuf::Clear for CMsgReplayUploadedToYouTube {
    fn clear(&mut self) {
        self.youtube_url.clear();
        self.youtube_account_name.clear();
        self.session_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgReplayUploadedToYouTube {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgReplayUploadedToYouTube {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgConsumableExhausted {
    // message fields
    item_def_id: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgConsumableExhausted {
    fn default() -> &'a CMsgConsumableExhausted {
        <CMsgConsumableExhausted as ::protobuf::Message>::default_instance()
    }
}

impl CMsgConsumableExhausted {
    pub fn new() -> CMsgConsumableExhausted {
        ::std::default::Default::default()
    }

    // optional int32 item_def_id = 1;


    pub fn get_item_def_id(&self) -> i32 {
        self.item_def_id.unwrap_or(0)
    }
    pub fn clear_item_def_id(&mut self) {
        self.item_def_id = ::std::option::Option::None;
    }

    pub fn has_item_def_id(&self) -> bool {
        self.item_def_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_def_id(&mut self, v: i32) {
        self.item_def_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgConsumableExhausted {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.item_def_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.item_def_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.item_def_id {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgConsumableExhausted {
        CMsgConsumableExhausted::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "item_def_id",
                |m: &CMsgConsumableExhausted| { &m.item_def_id },
                |m: &mut CMsgConsumableExhausted| { &mut m.item_def_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgConsumableExhausted>(
                "CMsgConsumableExhausted",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgConsumableExhausted {
        static instance: ::protobuf::rt::LazyV2<CMsgConsumableExhausted> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgConsumableExhausted::new)
    }
}

impl ::protobuf::Clear for CMsgConsumableExhausted {
    fn clear(&mut self) {
        self.item_def_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgConsumableExhausted {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgConsumableExhausted {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgItemAcknowledged {
    // message fields
    account_id: ::std::option::Option<u32>,
    inventory: ::std::option::Option<u32>,
    def_index: ::std::option::Option<u32>,
    quality: ::std::option::Option<u32>,
    rarity: ::std::option::Option<u32>,
    origin: ::std::option::Option<u32>,
    is_strange: ::std::option::Option<u32>,
    is_unusual: ::std::option::Option<u32>,
    wear: ::std::option::Option<f32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgItemAcknowledged {
    fn default() -> &'a CMsgItemAcknowledged {
        <CMsgItemAcknowledged as ::protobuf::Message>::default_instance()
    }
}

impl CMsgItemAcknowledged {
    pub fn new() -> CMsgItemAcknowledged {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;


    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }
    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 inventory = 2;


    pub fn get_inventory(&self) -> u32 {
        self.inventory.unwrap_or(0)
    }
    pub fn clear_inventory(&mut self) {
        self.inventory = ::std::option::Option::None;
    }

    pub fn has_inventory(&self) -> bool {
        self.inventory.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inventory(&mut self, v: u32) {
        self.inventory = ::std::option::Option::Some(v);
    }

    // optional uint32 def_index = 3;


    pub fn get_def_index(&self) -> u32 {
        self.def_index.unwrap_or(0)
    }
    pub fn clear_def_index(&mut self) {
        self.def_index = ::std::option::Option::None;
    }

    pub fn has_def_index(&self) -> bool {
        self.def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_def_index(&mut self, v: u32) {
        self.def_index = ::std::option::Option::Some(v);
    }

    // optional uint32 quality = 4;


    pub fn get_quality(&self) -> u32 {
        self.quality.unwrap_or(0)
    }
    pub fn clear_quality(&mut self) {
        self.quality = ::std::option::Option::None;
    }

    pub fn has_quality(&self) -> bool {
        self.quality.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality(&mut self, v: u32) {
        self.quality = ::std::option::Option::Some(v);
    }

    // optional uint32 rarity = 5;


    pub fn get_rarity(&self) -> u32 {
        self.rarity.unwrap_or(0)
    }
    pub fn clear_rarity(&mut self) {
        self.rarity = ::std::option::Option::None;
    }

    pub fn has_rarity(&self) -> bool {
        self.rarity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rarity(&mut self, v: u32) {
        self.rarity = ::std::option::Option::Some(v);
    }

    // optional uint32 origin = 6;


    pub fn get_origin(&self) -> u32 {
        self.origin.unwrap_or(0)
    }
    pub fn clear_origin(&mut self) {
        self.origin = ::std::option::Option::None;
    }

    pub fn has_origin(&self) -> bool {
        self.origin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_origin(&mut self, v: u32) {
        self.origin = ::std::option::Option::Some(v);
    }

    // optional uint32 is_strange = 7;


    pub fn get_is_strange(&self) -> u32 {
        self.is_strange.unwrap_or(0)
    }
    pub fn clear_is_strange(&mut self) {
        self.is_strange = ::std::option::Option::None;
    }

    pub fn has_is_strange(&self) -> bool {
        self.is_strange.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_strange(&mut self, v: u32) {
        self.is_strange = ::std::option::Option::Some(v);
    }

    // optional uint32 is_unusual = 8;


    pub fn get_is_unusual(&self) -> u32 {
        self.is_unusual.unwrap_or(0)
    }
    pub fn clear_is_unusual(&mut self) {
        self.is_unusual = ::std::option::Option::None;
    }

    pub fn has_is_unusual(&self) -> bool {
        self.is_unusual.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_unusual(&mut self, v: u32) {
        self.is_unusual = ::std::option::Option::Some(v);
    }

    // optional float wear = 9;


    pub fn get_wear(&self) -> f32 {
        self.wear.unwrap_or(0.)
    }
    pub fn clear_wear(&mut self) {
        self.wear = ::std::option::Option::None;
    }

    pub fn has_wear(&self) -> bool {
        self.wear.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wear(&mut self, v: f32) {
        self.wear = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgItemAcknowledged {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.inventory = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.def_index = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.quality = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rarity = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.origin = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.is_strange = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.is_unusual = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.wear = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.inventory {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.def_index {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.quality {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rarity {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.origin {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.is_strange {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.is_unusual {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.wear {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.inventory {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.def_index {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.quality {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.rarity {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.origin {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.is_strange {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.is_unusual {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.wear {
            os.write_float(9, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgItemAcknowledged {
        CMsgItemAcknowledged::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "account_id",
                |m: &CMsgItemAcknowledged| { &m.account_id },
                |m: &mut CMsgItemAcknowledged| { &mut m.account_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "inventory",
                |m: &CMsgItemAcknowledged| { &m.inventory },
                |m: &mut CMsgItemAcknowledged| { &mut m.inventory },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "def_index",
                |m: &CMsgItemAcknowledged| { &m.def_index },
                |m: &mut CMsgItemAcknowledged| { &mut m.def_index },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "quality",
                |m: &CMsgItemAcknowledged| { &m.quality },
                |m: &mut CMsgItemAcknowledged| { &mut m.quality },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "rarity",
                |m: &CMsgItemAcknowledged| { &m.rarity },
                |m: &mut CMsgItemAcknowledged| { &mut m.rarity },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "origin",
                |m: &CMsgItemAcknowledged| { &m.origin },
                |m: &mut CMsgItemAcknowledged| { &mut m.origin },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "is_strange",
                |m: &CMsgItemAcknowledged| { &m.is_strange },
                |m: &mut CMsgItemAcknowledged| { &mut m.is_strange },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "is_unusual",
                |m: &CMsgItemAcknowledged| { &m.is_unusual },
                |m: &mut CMsgItemAcknowledged| { &mut m.is_unusual },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "wear",
                |m: &CMsgItemAcknowledged| { &m.wear },
                |m: &mut CMsgItemAcknowledged| { &mut m.wear },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgItemAcknowledged>(
                "CMsgItemAcknowledged",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgItemAcknowledged {
        static instance: ::protobuf::rt::LazyV2<CMsgItemAcknowledged> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgItemAcknowledged::new)
    }
}

impl ::protobuf::Clear for CMsgItemAcknowledged {
    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.inventory = ::std::option::Option::None;
        self.def_index = ::std::option::Option::None;
        self.quality = ::std::option::Option::None;
        self.rarity = ::std::option::Option::None;
        self.origin = ::std::option::Option::None;
        self.is_strange = ::std::option::Option::None;
        self.is_unusual = ::std::option::Option::None;
        self.wear = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgItemAcknowledged {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgItemAcknowledged {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSetPresetItemPosition {
    // message fields
    class_id: ::std::option::Option<u32>,
    preset_id: ::std::option::Option<u32>,
    slot_id: ::std::option::Option<u32>,
    item_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSetPresetItemPosition {
    fn default() -> &'a CMsgSetPresetItemPosition {
        <CMsgSetPresetItemPosition as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSetPresetItemPosition {
    pub fn new() -> CMsgSetPresetItemPosition {
        ::std::default::Default::default()
    }

    // optional uint32 class_id = 1;


    pub fn get_class_id(&self) -> u32 {
        self.class_id.unwrap_or(0)
    }
    pub fn clear_class_id(&mut self) {
        self.class_id = ::std::option::Option::None;
    }

    pub fn has_class_id(&self) -> bool {
        self.class_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_class_id(&mut self, v: u32) {
        self.class_id = ::std::option::Option::Some(v);
    }

    // optional uint32 preset_id = 2;


    pub fn get_preset_id(&self) -> u32 {
        self.preset_id.unwrap_or(0)
    }
    pub fn clear_preset_id(&mut self) {
        self.preset_id = ::std::option::Option::None;
    }

    pub fn has_preset_id(&self) -> bool {
        self.preset_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preset_id(&mut self, v: u32) {
        self.preset_id = ::std::option::Option::Some(v);
    }

    // optional uint32 slot_id = 3;


    pub fn get_slot_id(&self) -> u32 {
        self.slot_id.unwrap_or(0)
    }
    pub fn clear_slot_id(&mut self) {
        self.slot_id = ::std::option::Option::None;
    }

    pub fn has_slot_id(&self) -> bool {
        self.slot_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slot_id(&mut self, v: u32) {
        self.slot_id = ::std::option::Option::Some(v);
    }

    // optional uint64 item_id = 4;


    pub fn get_item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }
    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSetPresetItemPosition {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.class_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.preset_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.slot_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.item_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.class_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.preset_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.slot_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.class_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.preset_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.slot_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.item_id {
            os.write_uint64(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSetPresetItemPosition {
        CMsgSetPresetItemPosition::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "class_id",
                |m: &CMsgSetPresetItemPosition| { &m.class_id },
                |m: &mut CMsgSetPresetItemPosition| { &mut m.class_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "preset_id",
                |m: &CMsgSetPresetItemPosition| { &m.preset_id },
                |m: &mut CMsgSetPresetItemPosition| { &mut m.preset_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "slot_id",
                |m: &CMsgSetPresetItemPosition| { &m.slot_id },
                |m: &mut CMsgSetPresetItemPosition| { &mut m.slot_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "item_id",
                |m: &CMsgSetPresetItemPosition| { &m.item_id },
                |m: &mut CMsgSetPresetItemPosition| { &mut m.item_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSetPresetItemPosition>(
                "CMsgSetPresetItemPosition",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSetPresetItemPosition {
        static instance: ::protobuf::rt::LazyV2<CMsgSetPresetItemPosition> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSetPresetItemPosition::new)
    }
}

impl ::protobuf::Clear for CMsgSetPresetItemPosition {
    fn clear(&mut self) {
        self.class_id = ::std::option::Option::None;
        self.preset_id = ::std::option::Option::None;
        self.slot_id = ::std::option::Option::None;
        self.item_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSetPresetItemPosition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSetPresetItemPosition {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSetItemPositions {
    // message fields
    pub item_positions: ::protobuf::RepeatedField<CMsgSetItemPositions_ItemPosition>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSetItemPositions {
    fn default() -> &'a CMsgSetItemPositions {
        <CMsgSetItemPositions as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSetItemPositions {
    pub fn new() -> CMsgSetItemPositions {
        ::std::default::Default::default()
    }

    // repeated .CMsgSetItemPositions.ItemPosition item_positions = 1;


    pub fn get_item_positions(&self) -> &[CMsgSetItemPositions_ItemPosition] {
        &self.item_positions
    }
    pub fn clear_item_positions(&mut self) {
        self.item_positions.clear();
    }

    // Param is passed by value, moved
    pub fn set_item_positions(&mut self, v: ::protobuf::RepeatedField<CMsgSetItemPositions_ItemPosition>) {
        self.item_positions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_item_positions(&mut self) -> &mut ::protobuf::RepeatedField<CMsgSetItemPositions_ItemPosition> {
        &mut self.item_positions
    }

    // Take field
    pub fn take_item_positions(&mut self) -> ::protobuf::RepeatedField<CMsgSetItemPositions_ItemPosition> {
        ::std::mem::replace(&mut self.item_positions, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgSetItemPositions {
    fn is_initialized(&self) -> bool {
        for v in &self.item_positions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.item_positions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.item_positions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.item_positions {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSetItemPositions {
        CMsgSetItemPositions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgSetItemPositions_ItemPosition>>(
                "item_positions",
                |m: &CMsgSetItemPositions| { &m.item_positions },
                |m: &mut CMsgSetItemPositions| { &mut m.item_positions },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSetItemPositions>(
                "CMsgSetItemPositions",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSetItemPositions {
        static instance: ::protobuf::rt::LazyV2<CMsgSetItemPositions> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSetItemPositions::new)
    }
}

impl ::protobuf::Clear for CMsgSetItemPositions {
    fn clear(&mut self) {
        self.item_positions.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSetItemPositions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSetItemPositions {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSetItemPositions_ItemPosition {
    // message fields
    item_id: ::std::option::Option<u64>,
    position: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSetItemPositions_ItemPosition {
    fn default() -> &'a CMsgSetItemPositions_ItemPosition {
        <CMsgSetItemPositions_ItemPosition as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSetItemPositions_ItemPosition {
    pub fn new() -> CMsgSetItemPositions_ItemPosition {
        ::std::default::Default::default()
    }

    // optional uint64 item_id = 1;


    pub fn get_item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }
    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    // optional uint32 position = 2;


    pub fn get_position(&self) -> u32 {
        self.position.unwrap_or(0)
    }
    pub fn clear_position(&mut self) {
        self.position = ::std::option::Option::None;
    }

    pub fn has_position(&self) -> bool {
        self.position.is_some()
    }

    // Param is passed by value, moved
    pub fn set_position(&mut self, v: u32) {
        self.position = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSetItemPositions_ItemPosition {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.item_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.position = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.position {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.position {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSetItemPositions_ItemPosition {
        CMsgSetItemPositions_ItemPosition::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "item_id",
                |m: &CMsgSetItemPositions_ItemPosition| { &m.item_id },
                |m: &mut CMsgSetItemPositions_ItemPosition| { &mut m.item_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "position",
                |m: &CMsgSetItemPositions_ItemPosition| { &m.position },
                |m: &mut CMsgSetItemPositions_ItemPosition| { &mut m.position },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSetItemPositions_ItemPosition>(
                "CMsgSetItemPositions.ItemPosition",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSetItemPositions_ItemPosition {
        static instance: ::protobuf::rt::LazyV2<CMsgSetItemPositions_ItemPosition> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSetItemPositions_ItemPosition::new)
    }
}

impl ::protobuf::Clear for CMsgSetItemPositions_ItemPosition {
    fn clear(&mut self) {
        self.item_id = ::std::option::Option::None;
        self.position = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSetItemPositions_ItemPosition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSetItemPositions_ItemPosition {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CSOEconItemPresetInstance {
    // message fields
    class_id: ::std::option::Option<u32>,
    preset_id: ::std::option::Option<u32>,
    slot_id: ::std::option::Option<u32>,
    item_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CSOEconItemPresetInstance {
    fn default() -> &'a CSOEconItemPresetInstance {
        <CSOEconItemPresetInstance as ::protobuf::Message>::default_instance()
    }
}

impl CSOEconItemPresetInstance {
    pub fn new() -> CSOEconItemPresetInstance {
        ::std::default::Default::default()
    }

    // optional uint32 class_id = 2;


    pub fn get_class_id(&self) -> u32 {
        self.class_id.unwrap_or(0)
    }
    pub fn clear_class_id(&mut self) {
        self.class_id = ::std::option::Option::None;
    }

    pub fn has_class_id(&self) -> bool {
        self.class_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_class_id(&mut self, v: u32) {
        self.class_id = ::std::option::Option::Some(v);
    }

    // optional uint32 preset_id = 3;


    pub fn get_preset_id(&self) -> u32 {
        self.preset_id.unwrap_or(0)
    }
    pub fn clear_preset_id(&mut self) {
        self.preset_id = ::std::option::Option::None;
    }

    pub fn has_preset_id(&self) -> bool {
        self.preset_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preset_id(&mut self, v: u32) {
        self.preset_id = ::std::option::Option::Some(v);
    }

    // optional uint32 slot_id = 4;


    pub fn get_slot_id(&self) -> u32 {
        self.slot_id.unwrap_or(0)
    }
    pub fn clear_slot_id(&mut self) {
        self.slot_id = ::std::option::Option::None;
    }

    pub fn has_slot_id(&self) -> bool {
        self.slot_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slot_id(&mut self, v: u32) {
        self.slot_id = ::std::option::Option::Some(v);
    }

    // optional uint64 item_id = 5;


    pub fn get_item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }
    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CSOEconItemPresetInstance {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.class_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.preset_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.slot_id = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.item_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.class_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.preset_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.slot_id {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.class_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.preset_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.slot_id {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.item_id {
            os.write_uint64(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CSOEconItemPresetInstance {
        CSOEconItemPresetInstance::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "class_id",
                |m: &CSOEconItemPresetInstance| { &m.class_id },
                |m: &mut CSOEconItemPresetInstance| { &mut m.class_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "preset_id",
                |m: &CSOEconItemPresetInstance| { &m.preset_id },
                |m: &mut CSOEconItemPresetInstance| { &mut m.preset_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "slot_id",
                |m: &CSOEconItemPresetInstance| { &m.slot_id },
                |m: &mut CSOEconItemPresetInstance| { &mut m.slot_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "item_id",
                |m: &CSOEconItemPresetInstance| { &m.item_id },
                |m: &mut CSOEconItemPresetInstance| { &mut m.item_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CSOEconItemPresetInstance>(
                "CSOEconItemPresetInstance",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CSOEconItemPresetInstance {
        static instance: ::protobuf::rt::LazyV2<CSOEconItemPresetInstance> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CSOEconItemPresetInstance::new)
    }
}

impl ::protobuf::Clear for CSOEconItemPresetInstance {
    fn clear(&mut self) {
        self.class_id = ::std::option::Option::None;
        self.preset_id = ::std::option::Option::None;
        self.slot_id = ::std::option::Option::None;
        self.item_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSOEconItemPresetInstance {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOEconItemPresetInstance {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSelectPresetForClass {
    // message fields
    class_id: ::std::option::Option<u32>,
    preset_id: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSelectPresetForClass {
    fn default() -> &'a CMsgSelectPresetForClass {
        <CMsgSelectPresetForClass as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSelectPresetForClass {
    pub fn new() -> CMsgSelectPresetForClass {
        ::std::default::Default::default()
    }

    // optional uint32 class_id = 1;


    pub fn get_class_id(&self) -> u32 {
        self.class_id.unwrap_or(0)
    }
    pub fn clear_class_id(&mut self) {
        self.class_id = ::std::option::Option::None;
    }

    pub fn has_class_id(&self) -> bool {
        self.class_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_class_id(&mut self, v: u32) {
        self.class_id = ::std::option::Option::Some(v);
    }

    // optional uint32 preset_id = 2;


    pub fn get_preset_id(&self) -> u32 {
        self.preset_id.unwrap_or(0)
    }
    pub fn clear_preset_id(&mut self) {
        self.preset_id = ::std::option::Option::None;
    }

    pub fn has_preset_id(&self) -> bool {
        self.preset_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preset_id(&mut self, v: u32) {
        self.preset_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSelectPresetForClass {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.class_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.preset_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.class_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.preset_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.class_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.preset_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSelectPresetForClass {
        CMsgSelectPresetForClass::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "class_id",
                |m: &CMsgSelectPresetForClass| { &m.class_id },
                |m: &mut CMsgSelectPresetForClass| { &mut m.class_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "preset_id",
                |m: &CMsgSelectPresetForClass| { &m.preset_id },
                |m: &mut CMsgSelectPresetForClass| { &mut m.preset_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSelectPresetForClass>(
                "CMsgSelectPresetForClass",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSelectPresetForClass {
        static instance: ::protobuf::rt::LazyV2<CMsgSelectPresetForClass> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSelectPresetForClass::new)
    }
}

impl ::protobuf::Clear for CMsgSelectPresetForClass {
    fn clear(&mut self) {
        self.class_id = ::std::option::Option::None;
        self.preset_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSelectPresetForClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSelectPresetForClass {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CSOClassPresetClientData {
    // message fields
    account_id: ::std::option::Option<u32>,
    class_id: ::std::option::Option<u32>,
    active_preset_id: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CSOClassPresetClientData {
    fn default() -> &'a CSOClassPresetClientData {
        <CSOClassPresetClientData as ::protobuf::Message>::default_instance()
    }
}

impl CSOClassPresetClientData {
    pub fn new() -> CSOClassPresetClientData {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;


    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }
    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 class_id = 2;


    pub fn get_class_id(&self) -> u32 {
        self.class_id.unwrap_or(0)
    }
    pub fn clear_class_id(&mut self) {
        self.class_id = ::std::option::Option::None;
    }

    pub fn has_class_id(&self) -> bool {
        self.class_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_class_id(&mut self, v: u32) {
        self.class_id = ::std::option::Option::Some(v);
    }

    // optional uint32 active_preset_id = 3;


    pub fn get_active_preset_id(&self) -> u32 {
        self.active_preset_id.unwrap_or(0)
    }
    pub fn clear_active_preset_id(&mut self) {
        self.active_preset_id = ::std::option::Option::None;
    }

    pub fn has_active_preset_id(&self) -> bool {
        self.active_preset_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_active_preset_id(&mut self, v: u32) {
        self.active_preset_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CSOClassPresetClientData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.class_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.active_preset_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.class_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.active_preset_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.class_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.active_preset_id {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CSOClassPresetClientData {
        CSOClassPresetClientData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "account_id",
                |m: &CSOClassPresetClientData| { &m.account_id },
                |m: &mut CSOClassPresetClientData| { &mut m.account_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "class_id",
                |m: &CSOClassPresetClientData| { &m.class_id },
                |m: &mut CSOClassPresetClientData| { &mut m.class_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "active_preset_id",
                |m: &CSOClassPresetClientData| { &m.active_preset_id },
                |m: &mut CSOClassPresetClientData| { &mut m.active_preset_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CSOClassPresetClientData>(
                "CSOClassPresetClientData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CSOClassPresetClientData {
        static instance: ::protobuf::rt::LazyV2<CSOClassPresetClientData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CSOClassPresetClientData::new)
    }
}

impl ::protobuf::Clear for CSOClassPresetClientData {
    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.class_id = ::std::option::Option::None;
        self.active_preset_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSOClassPresetClientData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOClassPresetClientData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCReportAbuse {
    // message fields
    target_steam_id: ::std::option::Option<u64>,
    description: ::protobuf::SingularField<::std::string::String>,
    gid: ::std::option::Option<u64>,
    abuse_type: ::std::option::Option<u32>,
    content_type: ::std::option::Option<u32>,
    target_game_server_ip: ::std::option::Option<u32>,
    target_game_server_port: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCReportAbuse {
    fn default() -> &'a CMsgGCReportAbuse {
        <CMsgGCReportAbuse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCReportAbuse {
    pub fn new() -> CMsgGCReportAbuse {
        ::std::default::Default::default()
    }

    // optional fixed64 target_steam_id = 1;


    pub fn get_target_steam_id(&self) -> u64 {
        self.target_steam_id.unwrap_or(0)
    }
    pub fn clear_target_steam_id(&mut self) {
        self.target_steam_id = ::std::option::Option::None;
    }

    pub fn has_target_steam_id(&self) -> bool {
        self.target_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_steam_id(&mut self, v: u64) {
        self.target_steam_id = ::std::option::Option::Some(v);
    }

    // optional string description = 4;


    pub fn get_description(&self) -> &str {
        match self.description.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    pub fn has_description(&self) -> bool {
        self.description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        if self.description.is_none() {
            self.description.set_default();
        }
        self.description.as_mut().unwrap()
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        self.description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 gid = 5;


    pub fn get_gid(&self) -> u64 {
        self.gid.unwrap_or(0)
    }
    pub fn clear_gid(&mut self) {
        self.gid = ::std::option::Option::None;
    }

    pub fn has_gid(&self) -> bool {
        self.gid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gid(&mut self, v: u64) {
        self.gid = ::std::option::Option::Some(v);
    }

    // optional uint32 abuse_type = 2;


    pub fn get_abuse_type(&self) -> u32 {
        self.abuse_type.unwrap_or(0)
    }
    pub fn clear_abuse_type(&mut self) {
        self.abuse_type = ::std::option::Option::None;
    }

    pub fn has_abuse_type(&self) -> bool {
        self.abuse_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_abuse_type(&mut self, v: u32) {
        self.abuse_type = ::std::option::Option::Some(v);
    }

    // optional uint32 content_type = 3;


    pub fn get_content_type(&self) -> u32 {
        self.content_type.unwrap_or(0)
    }
    pub fn clear_content_type(&mut self) {
        self.content_type = ::std::option::Option::None;
    }

    pub fn has_content_type(&self) -> bool {
        self.content_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_content_type(&mut self, v: u32) {
        self.content_type = ::std::option::Option::Some(v);
    }

    // optional fixed32 target_game_server_ip = 6;


    pub fn get_target_game_server_ip(&self) -> u32 {
        self.target_game_server_ip.unwrap_or(0)
    }
    pub fn clear_target_game_server_ip(&mut self) {
        self.target_game_server_ip = ::std::option::Option::None;
    }

    pub fn has_target_game_server_ip(&self) -> bool {
        self.target_game_server_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_game_server_ip(&mut self, v: u32) {
        self.target_game_server_ip = ::std::option::Option::Some(v);
    }

    // optional uint32 target_game_server_port = 7;


    pub fn get_target_game_server_port(&self) -> u32 {
        self.target_game_server_port.unwrap_or(0)
    }
    pub fn clear_target_game_server_port(&mut self) {
        self.target_game_server_port = ::std::option::Option::None;
    }

    pub fn has_target_game_server_port(&self) -> bool {
        self.target_game_server_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_game_server_port(&mut self, v: u32) {
        self.target_game_server_port = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCReportAbuse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.target_steam_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.description)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.gid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.abuse_type = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.content_type = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.target_game_server_ip = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.target_game_server_port = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.target_steam_id {
            my_size += 9;
        }
        if let Some(ref v) = self.description.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.gid {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.abuse_type {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.content_type {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.target_game_server_ip {
            my_size += 5;
        }
        if let Some(v) = self.target_game_server_port {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.target_steam_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(ref v) = self.description.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(v) = self.gid {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.abuse_type {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.content_type {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.target_game_server_ip {
            os.write_fixed32(6, v)?;
        }
        if let Some(v) = self.target_game_server_port {
            os.write_uint32(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCReportAbuse {
        CMsgGCReportAbuse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "target_steam_id",
                |m: &CMsgGCReportAbuse| { &m.target_steam_id },
                |m: &mut CMsgGCReportAbuse| { &mut m.target_steam_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "description",
                |m: &CMsgGCReportAbuse| { &m.description },
                |m: &mut CMsgGCReportAbuse| { &mut m.description },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "gid",
                |m: &CMsgGCReportAbuse| { &m.gid },
                |m: &mut CMsgGCReportAbuse| { &mut m.gid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "abuse_type",
                |m: &CMsgGCReportAbuse| { &m.abuse_type },
                |m: &mut CMsgGCReportAbuse| { &mut m.abuse_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "content_type",
                |m: &CMsgGCReportAbuse| { &m.content_type },
                |m: &mut CMsgGCReportAbuse| { &mut m.content_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "target_game_server_ip",
                |m: &CMsgGCReportAbuse| { &m.target_game_server_ip },
                |m: &mut CMsgGCReportAbuse| { &mut m.target_game_server_ip },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "target_game_server_port",
                |m: &CMsgGCReportAbuse| { &m.target_game_server_port },
                |m: &mut CMsgGCReportAbuse| { &mut m.target_game_server_port },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCReportAbuse>(
                "CMsgGCReportAbuse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCReportAbuse {
        static instance: ::protobuf::rt::LazyV2<CMsgGCReportAbuse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCReportAbuse::new)
    }
}

impl ::protobuf::Clear for CMsgGCReportAbuse {
    fn clear(&mut self) {
        self.target_steam_id = ::std::option::Option::None;
        self.description.clear();
        self.gid = ::std::option::Option::None;
        self.abuse_type = ::std::option::Option::None;
        self.content_type = ::std::option::Option::None;
        self.target_game_server_ip = ::std::option::Option::None;
        self.target_game_server_port = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCReportAbuse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCReportAbuse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCReportAbuseResponse {
    // message fields
    target_steam_id: ::std::option::Option<u64>,
    result: ::std::option::Option<u32>,
    error_message: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCReportAbuseResponse {
    fn default() -> &'a CMsgGCReportAbuseResponse {
        <CMsgGCReportAbuseResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCReportAbuseResponse {
    pub fn new() -> CMsgGCReportAbuseResponse {
        ::std::default::Default::default()
    }

    // optional fixed64 target_steam_id = 1;


    pub fn get_target_steam_id(&self) -> u64 {
        self.target_steam_id.unwrap_or(0)
    }
    pub fn clear_target_steam_id(&mut self) {
        self.target_steam_id = ::std::option::Option::None;
    }

    pub fn has_target_steam_id(&self) -> bool {
        self.target_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_steam_id(&mut self, v: u64) {
        self.target_steam_id = ::std::option::Option::Some(v);
    }

    // optional uint32 result = 2;


    pub fn get_result(&self) -> u32 {
        self.result.unwrap_or(0)
    }
    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: u32) {
        self.result = ::std::option::Option::Some(v);
    }

    // optional string error_message = 3;


    pub fn get_error_message(&self) -> &str {
        match self.error_message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_error_message(&mut self) {
        self.error_message.clear();
    }

    pub fn has_error_message(&self) -> bool {
        self.error_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error_message(&mut self, v: ::std::string::String) {
        self.error_message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error_message(&mut self) -> &mut ::std::string::String {
        if self.error_message.is_none() {
            self.error_message.set_default();
        }
        self.error_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_error_message(&mut self) -> ::std::string::String {
        self.error_message.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgGCReportAbuseResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.target_steam_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.error_message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.target_steam_id {
            my_size += 9;
        }
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.error_message.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.target_steam_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.result {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.error_message.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCReportAbuseResponse {
        CMsgGCReportAbuseResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "target_steam_id",
                |m: &CMsgGCReportAbuseResponse| { &m.target_steam_id },
                |m: &mut CMsgGCReportAbuseResponse| { &mut m.target_steam_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "result",
                |m: &CMsgGCReportAbuseResponse| { &m.result },
                |m: &mut CMsgGCReportAbuseResponse| { &mut m.result },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "error_message",
                |m: &CMsgGCReportAbuseResponse| { &m.error_message },
                |m: &mut CMsgGCReportAbuseResponse| { &mut m.error_message },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCReportAbuseResponse>(
                "CMsgGCReportAbuseResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCReportAbuseResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgGCReportAbuseResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCReportAbuseResponse::new)
    }
}

impl ::protobuf::Clear for CMsgGCReportAbuseResponse {
    fn clear(&mut self) {
        self.target_steam_id = ::std::option::Option::None;
        self.result = ::std::option::Option::None;
        self.error_message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCReportAbuseResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCReportAbuseResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCNameItemNotification {
    // message fields
    player_steamid: ::std::option::Option<u64>,
    item_def_index: ::std::option::Option<u32>,
    item_name_custom: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCNameItemNotification {
    fn default() -> &'a CMsgGCNameItemNotification {
        <CMsgGCNameItemNotification as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCNameItemNotification {
    pub fn new() -> CMsgGCNameItemNotification {
        ::std::default::Default::default()
    }

    // optional fixed64 player_steamid = 1;


    pub fn get_player_steamid(&self) -> u64 {
        self.player_steamid.unwrap_or(0)
    }
    pub fn clear_player_steamid(&mut self) {
        self.player_steamid = ::std::option::Option::None;
    }

    pub fn has_player_steamid(&self) -> bool {
        self.player_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_steamid(&mut self, v: u64) {
        self.player_steamid = ::std::option::Option::Some(v);
    }

    // optional uint32 item_def_index = 2;


    pub fn get_item_def_index(&self) -> u32 {
        self.item_def_index.unwrap_or(0)
    }
    pub fn clear_item_def_index(&mut self) {
        self.item_def_index = ::std::option::Option::None;
    }

    pub fn has_item_def_index(&self) -> bool {
        self.item_def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_def_index(&mut self, v: u32) {
        self.item_def_index = ::std::option::Option::Some(v);
    }

    // optional string item_name_custom = 3;


    pub fn get_item_name_custom(&self) -> &str {
        match self.item_name_custom.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_item_name_custom(&mut self) {
        self.item_name_custom.clear();
    }

    pub fn has_item_name_custom(&self) -> bool {
        self.item_name_custom.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_name_custom(&mut self, v: ::std::string::String) {
        self.item_name_custom = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_item_name_custom(&mut self) -> &mut ::std::string::String {
        if self.item_name_custom.is_none() {
            self.item_name_custom.set_default();
        }
        self.item_name_custom.as_mut().unwrap()
    }

    // Take field
    pub fn take_item_name_custom(&mut self) -> ::std::string::String {
        self.item_name_custom.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgGCNameItemNotification {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.player_steamid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.item_def_index = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.item_name_custom)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.player_steamid {
            my_size += 9;
        }
        if let Some(v) = self.item_def_index {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.item_name_custom.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.player_steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.item_def_index {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.item_name_custom.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCNameItemNotification {
        CMsgGCNameItemNotification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "player_steamid",
                |m: &CMsgGCNameItemNotification| { &m.player_steamid },
                |m: &mut CMsgGCNameItemNotification| { &mut m.player_steamid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "item_def_index",
                |m: &CMsgGCNameItemNotification| { &m.item_def_index },
                |m: &mut CMsgGCNameItemNotification| { &mut m.item_def_index },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "item_name_custom",
                |m: &CMsgGCNameItemNotification| { &m.item_name_custom },
                |m: &mut CMsgGCNameItemNotification| { &mut m.item_name_custom },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCNameItemNotification>(
                "CMsgGCNameItemNotification",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCNameItemNotification {
        static instance: ::protobuf::rt::LazyV2<CMsgGCNameItemNotification> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCNameItemNotification::new)
    }
}

impl ::protobuf::Clear for CMsgGCNameItemNotification {
    fn clear(&mut self) {
        self.player_steamid = ::std::option::Option::None;
        self.item_def_index = ::std::option::Option::None;
        self.item_name_custom.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCNameItemNotification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCNameItemNotification {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCClientDisplayNotification {
    // message fields
    notification_title_localization_key: ::protobuf::SingularField<::std::string::String>,
    notification_body_localization_key: ::protobuf::SingularField<::std::string::String>,
    pub body_substring_keys: ::protobuf::RepeatedField<::std::string::String>,
    pub body_substring_values: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCClientDisplayNotification {
    fn default() -> &'a CMsgGCClientDisplayNotification {
        <CMsgGCClientDisplayNotification as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCClientDisplayNotification {
    pub fn new() -> CMsgGCClientDisplayNotification {
        ::std::default::Default::default()
    }

    // optional string notification_title_localization_key = 1;


    pub fn get_notification_title_localization_key(&self) -> &str {
        match self.notification_title_localization_key.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_notification_title_localization_key(&mut self) {
        self.notification_title_localization_key.clear();
    }

    pub fn has_notification_title_localization_key(&self) -> bool {
        self.notification_title_localization_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_notification_title_localization_key(&mut self, v: ::std::string::String) {
        self.notification_title_localization_key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_notification_title_localization_key(&mut self) -> &mut ::std::string::String {
        if self.notification_title_localization_key.is_none() {
            self.notification_title_localization_key.set_default();
        }
        self.notification_title_localization_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_notification_title_localization_key(&mut self) -> ::std::string::String {
        self.notification_title_localization_key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string notification_body_localization_key = 2;


    pub fn get_notification_body_localization_key(&self) -> &str {
        match self.notification_body_localization_key.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_notification_body_localization_key(&mut self) {
        self.notification_body_localization_key.clear();
    }

    pub fn has_notification_body_localization_key(&self) -> bool {
        self.notification_body_localization_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_notification_body_localization_key(&mut self, v: ::std::string::String) {
        self.notification_body_localization_key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_notification_body_localization_key(&mut self) -> &mut ::std::string::String {
        if self.notification_body_localization_key.is_none() {
            self.notification_body_localization_key.set_default();
        }
        self.notification_body_localization_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_notification_body_localization_key(&mut self) -> ::std::string::String {
        self.notification_body_localization_key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated string body_substring_keys = 3;


    pub fn get_body_substring_keys(&self) -> &[::std::string::String] {
        &self.body_substring_keys
    }
    pub fn clear_body_substring_keys(&mut self) {
        self.body_substring_keys.clear();
    }

    // Param is passed by value, moved
    pub fn set_body_substring_keys(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.body_substring_keys = v;
    }

    // Mutable pointer to the field.
    pub fn mut_body_substring_keys(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.body_substring_keys
    }

    // Take field
    pub fn take_body_substring_keys(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.body_substring_keys, ::protobuf::RepeatedField::new())
    }

    // repeated string body_substring_values = 4;


    pub fn get_body_substring_values(&self) -> &[::std::string::String] {
        &self.body_substring_values
    }
    pub fn clear_body_substring_values(&mut self) {
        self.body_substring_values.clear();
    }

    // Param is passed by value, moved
    pub fn set_body_substring_values(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.body_substring_values = v;
    }

    // Mutable pointer to the field.
    pub fn mut_body_substring_values(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.body_substring_values
    }

    // Take field
    pub fn take_body_substring_values(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.body_substring_values, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgGCClientDisplayNotification {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.notification_title_localization_key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.notification_body_localization_key)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.body_substring_keys)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.body_substring_values)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.notification_title_localization_key.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.notification_body_localization_key.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.body_substring_keys {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.body_substring_values {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.notification_title_localization_key.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.notification_body_localization_key.as_ref() {
            os.write_string(2, &v)?;
        }
        for v in &self.body_substring_keys {
            os.write_string(3, &v)?;
        };
        for v in &self.body_substring_values {
            os.write_string(4, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCClientDisplayNotification {
        CMsgGCClientDisplayNotification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "notification_title_localization_key",
                |m: &CMsgGCClientDisplayNotification| { &m.notification_title_localization_key },
                |m: &mut CMsgGCClientDisplayNotification| { &mut m.notification_title_localization_key },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "notification_body_localization_key",
                |m: &CMsgGCClientDisplayNotification| { &m.notification_body_localization_key },
                |m: &mut CMsgGCClientDisplayNotification| { &mut m.notification_body_localization_key },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "body_substring_keys",
                |m: &CMsgGCClientDisplayNotification| { &m.body_substring_keys },
                |m: &mut CMsgGCClientDisplayNotification| { &mut m.body_substring_keys },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "body_substring_values",
                |m: &CMsgGCClientDisplayNotification| { &m.body_substring_values },
                |m: &mut CMsgGCClientDisplayNotification| { &mut m.body_substring_values },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCClientDisplayNotification>(
                "CMsgGCClientDisplayNotification",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCClientDisplayNotification {
        static instance: ::protobuf::rt::LazyV2<CMsgGCClientDisplayNotification> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCClientDisplayNotification::new)
    }
}

impl ::protobuf::Clear for CMsgGCClientDisplayNotification {
    fn clear(&mut self) {
        self.notification_title_localization_key.clear();
        self.notification_body_localization_key.clear();
        self.body_substring_keys.clear();
        self.body_substring_values.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCClientDisplayNotification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCClientDisplayNotification {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCShowItemsPickedUp {
    // message fields
    player_steamid: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCShowItemsPickedUp {
    fn default() -> &'a CMsgGCShowItemsPickedUp {
        <CMsgGCShowItemsPickedUp as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCShowItemsPickedUp {
    pub fn new() -> CMsgGCShowItemsPickedUp {
        ::std::default::Default::default()
    }

    // optional fixed64 player_steamid = 1;


    pub fn get_player_steamid(&self) -> u64 {
        self.player_steamid.unwrap_or(0)
    }
    pub fn clear_player_steamid(&mut self) {
        self.player_steamid = ::std::option::Option::None;
    }

    pub fn has_player_steamid(&self) -> bool {
        self.player_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_steamid(&mut self, v: u64) {
        self.player_steamid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCShowItemsPickedUp {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.player_steamid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.player_steamid {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.player_steamid {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCShowItemsPickedUp {
        CMsgGCShowItemsPickedUp::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "player_steamid",
                |m: &CMsgGCShowItemsPickedUp| { &m.player_steamid },
                |m: &mut CMsgGCShowItemsPickedUp| { &mut m.player_steamid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCShowItemsPickedUp>(
                "CMsgGCShowItemsPickedUp",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCShowItemsPickedUp {
        static instance: ::protobuf::rt::LazyV2<CMsgGCShowItemsPickedUp> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCShowItemsPickedUp::new)
    }
}

impl ::protobuf::Clear for CMsgGCShowItemsPickedUp {
    fn clear(&mut self) {
        self.player_steamid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCShowItemsPickedUp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCShowItemsPickedUp {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgUpdatePeriodicEvent {
    // message fields
    account_id: ::std::option::Option<u32>,
    event_type: ::std::option::Option<u32>,
    amount: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgUpdatePeriodicEvent {
    fn default() -> &'a CMsgUpdatePeriodicEvent {
        <CMsgUpdatePeriodicEvent as ::protobuf::Message>::default_instance()
    }
}

impl CMsgUpdatePeriodicEvent {
    pub fn new() -> CMsgUpdatePeriodicEvent {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;


    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }
    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 event_type = 2;


    pub fn get_event_type(&self) -> u32 {
        self.event_type.unwrap_or(0)
    }
    pub fn clear_event_type(&mut self) {
        self.event_type = ::std::option::Option::None;
    }

    pub fn has_event_type(&self) -> bool {
        self.event_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_type(&mut self, v: u32) {
        self.event_type = ::std::option::Option::Some(v);
    }

    // optional uint32 amount = 3;


    pub fn get_amount(&self) -> u32 {
        self.amount.unwrap_or(0)
    }
    pub fn clear_amount(&mut self) {
        self.amount = ::std::option::Option::None;
    }

    pub fn has_amount(&self) -> bool {
        self.amount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: u32) {
        self.amount = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgUpdatePeriodicEvent {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.event_type = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.amount = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.event_type {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.amount {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.event_type {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.amount {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgUpdatePeriodicEvent {
        CMsgUpdatePeriodicEvent::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "account_id",
                |m: &CMsgUpdatePeriodicEvent| { &m.account_id },
                |m: &mut CMsgUpdatePeriodicEvent| { &mut m.account_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "event_type",
                |m: &CMsgUpdatePeriodicEvent| { &m.event_type },
                |m: &mut CMsgUpdatePeriodicEvent| { &mut m.event_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "amount",
                |m: &CMsgUpdatePeriodicEvent| { &m.amount },
                |m: &mut CMsgUpdatePeriodicEvent| { &mut m.amount },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgUpdatePeriodicEvent>(
                "CMsgUpdatePeriodicEvent",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgUpdatePeriodicEvent {
        static instance: ::protobuf::rt::LazyV2<CMsgUpdatePeriodicEvent> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgUpdatePeriodicEvent::new)
    }
}

impl ::protobuf::Clear for CMsgUpdatePeriodicEvent {
    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.event_type = ::std::option::Option::None;
        self.amount = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgUpdatePeriodicEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgUpdatePeriodicEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCIncrementKillCountResponse {
    // message fields
    killer_account_id: ::std::option::Option<u32>,
    num_kills: ::std::option::Option<u32>,
    item_def: ::std::option::Option<u32>,
    level_type: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCIncrementKillCountResponse {
    fn default() -> &'a CMsgGCIncrementKillCountResponse {
        <CMsgGCIncrementKillCountResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCIncrementKillCountResponse {
    pub fn new() -> CMsgGCIncrementKillCountResponse {
        ::std::default::Default::default()
    }

    // optional uint32 killer_account_id = 1;


    pub fn get_killer_account_id(&self) -> u32 {
        self.killer_account_id.unwrap_or(0)
    }
    pub fn clear_killer_account_id(&mut self) {
        self.killer_account_id = ::std::option::Option::None;
    }

    pub fn has_killer_account_id(&self) -> bool {
        self.killer_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_killer_account_id(&mut self, v: u32) {
        self.killer_account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 num_kills = 2;


    pub fn get_num_kills(&self) -> u32 {
        self.num_kills.unwrap_or(0)
    }
    pub fn clear_num_kills(&mut self) {
        self.num_kills = ::std::option::Option::None;
    }

    pub fn has_num_kills(&self) -> bool {
        self.num_kills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_kills(&mut self, v: u32) {
        self.num_kills = ::std::option::Option::Some(v);
    }

    // optional uint32 item_def = 3;


    pub fn get_item_def(&self) -> u32 {
        self.item_def.unwrap_or(0)
    }
    pub fn clear_item_def(&mut self) {
        self.item_def = ::std::option::Option::None;
    }

    pub fn has_item_def(&self) -> bool {
        self.item_def.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_def(&mut self, v: u32) {
        self.item_def = ::std::option::Option::Some(v);
    }

    // optional uint32 level_type = 4;


    pub fn get_level_type(&self) -> u32 {
        self.level_type.unwrap_or(0)
    }
    pub fn clear_level_type(&mut self) {
        self.level_type = ::std::option::Option::None;
    }

    pub fn has_level_type(&self) -> bool {
        self.level_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_level_type(&mut self, v: u32) {
        self.level_type = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCIncrementKillCountResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.killer_account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.num_kills = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.item_def = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.level_type = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.killer_account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.num_kills {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.item_def {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.level_type {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.killer_account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.num_kills {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.item_def {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.level_type {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCIncrementKillCountResponse {
        CMsgGCIncrementKillCountResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "killer_account_id",
                |m: &CMsgGCIncrementKillCountResponse| { &m.killer_account_id },
                |m: &mut CMsgGCIncrementKillCountResponse| { &mut m.killer_account_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "num_kills",
                |m: &CMsgGCIncrementKillCountResponse| { &m.num_kills },
                |m: &mut CMsgGCIncrementKillCountResponse| { &mut m.num_kills },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "item_def",
                |m: &CMsgGCIncrementKillCountResponse| { &m.item_def },
                |m: &mut CMsgGCIncrementKillCountResponse| { &mut m.item_def },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "level_type",
                |m: &CMsgGCIncrementKillCountResponse| { &m.level_type },
                |m: &mut CMsgGCIncrementKillCountResponse| { &mut m.level_type },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCIncrementKillCountResponse>(
                "CMsgGCIncrementKillCountResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCIncrementKillCountResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgGCIncrementKillCountResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCIncrementKillCountResponse::new)
    }
}

impl ::protobuf::Clear for CMsgGCIncrementKillCountResponse {
    fn clear(&mut self) {
        self.killer_account_id = ::std::option::Option::None;
        self.num_kills = ::std::option::Option::None;
        self.item_def = ::std::option::Option::None;
        self.level_type = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCIncrementKillCountResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCIncrementKillCountResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCRemoveStrangePart {
    // message fields
    item_id: ::std::option::Option<u64>,
    strange_part_score_type: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCRemoveStrangePart {
    fn default() -> &'a CMsgGCRemoveStrangePart {
        <CMsgGCRemoveStrangePart as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCRemoveStrangePart {
    pub fn new() -> CMsgGCRemoveStrangePart {
        ::std::default::Default::default()
    }

    // optional uint64 item_id = 1;


    pub fn get_item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }
    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    // optional uint32 strange_part_score_type = 2;


    pub fn get_strange_part_score_type(&self) -> u32 {
        self.strange_part_score_type.unwrap_or(0)
    }
    pub fn clear_strange_part_score_type(&mut self) {
        self.strange_part_score_type = ::std::option::Option::None;
    }

    pub fn has_strange_part_score_type(&self) -> bool {
        self.strange_part_score_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_strange_part_score_type(&mut self, v: u32) {
        self.strange_part_score_type = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCRemoveStrangePart {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.item_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.strange_part_score_type = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.strange_part_score_type {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.strange_part_score_type {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCRemoveStrangePart {
        CMsgGCRemoveStrangePart::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "item_id",
                |m: &CMsgGCRemoveStrangePart| { &m.item_id },
                |m: &mut CMsgGCRemoveStrangePart| { &mut m.item_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "strange_part_score_type",
                |m: &CMsgGCRemoveStrangePart| { &m.strange_part_score_type },
                |m: &mut CMsgGCRemoveStrangePart| { &mut m.strange_part_score_type },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCRemoveStrangePart>(
                "CMsgGCRemoveStrangePart",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCRemoveStrangePart {
        static instance: ::protobuf::rt::LazyV2<CMsgGCRemoveStrangePart> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCRemoveStrangePart::new)
    }
}

impl ::protobuf::Clear for CMsgGCRemoveStrangePart {
    fn clear(&mut self) {
        self.item_id = ::std::option::Option::None;
        self.strange_part_score_type = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCRemoveStrangePart {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCRemoveStrangePart {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCRemoveUpgradeCard {
    // message fields
    item_id: ::std::option::Option<u64>,
    attribute_index: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCRemoveUpgradeCard {
    fn default() -> &'a CMsgGCRemoveUpgradeCard {
        <CMsgGCRemoveUpgradeCard as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCRemoveUpgradeCard {
    pub fn new() -> CMsgGCRemoveUpgradeCard {
        ::std::default::Default::default()
    }

    // optional uint64 item_id = 1;


    pub fn get_item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }
    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    // optional uint32 attribute_index = 2;


    pub fn get_attribute_index(&self) -> u32 {
        self.attribute_index.unwrap_or(0)
    }
    pub fn clear_attribute_index(&mut self) {
        self.attribute_index = ::std::option::Option::None;
    }

    pub fn has_attribute_index(&self) -> bool {
        self.attribute_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attribute_index(&mut self, v: u32) {
        self.attribute_index = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCRemoveUpgradeCard {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.item_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.attribute_index = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.attribute_index {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.attribute_index {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCRemoveUpgradeCard {
        CMsgGCRemoveUpgradeCard::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "item_id",
                |m: &CMsgGCRemoveUpgradeCard| { &m.item_id },
                |m: &mut CMsgGCRemoveUpgradeCard| { &mut m.item_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "attribute_index",
                |m: &CMsgGCRemoveUpgradeCard| { &m.attribute_index },
                |m: &mut CMsgGCRemoveUpgradeCard| { &mut m.attribute_index },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCRemoveUpgradeCard>(
                "CMsgGCRemoveUpgradeCard",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCRemoveUpgradeCard {
        static instance: ::protobuf::rt::LazyV2<CMsgGCRemoveUpgradeCard> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCRemoveUpgradeCard::new)
    }
}

impl ::protobuf::Clear for CMsgGCRemoveUpgradeCard {
    fn clear(&mut self) {
        self.item_id = ::std::option::Option::None;
        self.attribute_index = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCRemoveUpgradeCard {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCRemoveUpgradeCard {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCRemoveCustomizationAttributeSimple {
    // message fields
    item_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCRemoveCustomizationAttributeSimple {
    fn default() -> &'a CMsgGCRemoveCustomizationAttributeSimple {
        <CMsgGCRemoveCustomizationAttributeSimple as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCRemoveCustomizationAttributeSimple {
    pub fn new() -> CMsgGCRemoveCustomizationAttributeSimple {
        ::std::default::Default::default()
    }

    // optional uint64 item_id = 1;


    pub fn get_item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }
    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCRemoveCustomizationAttributeSimple {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.item_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.item_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCRemoveCustomizationAttributeSimple {
        CMsgGCRemoveCustomizationAttributeSimple::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "item_id",
                |m: &CMsgGCRemoveCustomizationAttributeSimple| { &m.item_id },
                |m: &mut CMsgGCRemoveCustomizationAttributeSimple| { &mut m.item_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCRemoveCustomizationAttributeSimple>(
                "CMsgGCRemoveCustomizationAttributeSimple",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCRemoveCustomizationAttributeSimple {
        static instance: ::protobuf::rt::LazyV2<CMsgGCRemoveCustomizationAttributeSimple> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCRemoveCustomizationAttributeSimple::new)
    }
}

impl ::protobuf::Clear for CMsgGCRemoveCustomizationAttributeSimple {
    fn clear(&mut self) {
        self.item_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCRemoveCustomizationAttributeSimple {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCRemoveCustomizationAttributeSimple {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCResetStrangeScores {
    // message fields
    item_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCResetStrangeScores {
    fn default() -> &'a CMsgGCResetStrangeScores {
        <CMsgGCResetStrangeScores as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCResetStrangeScores {
    pub fn new() -> CMsgGCResetStrangeScores {
        ::std::default::Default::default()
    }

    // optional uint64 item_id = 1;


    pub fn get_item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }
    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCResetStrangeScores {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.item_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.item_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCResetStrangeScores {
        CMsgGCResetStrangeScores::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "item_id",
                |m: &CMsgGCResetStrangeScores| { &m.item_id },
                |m: &mut CMsgGCResetStrangeScores| { &mut m.item_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCResetStrangeScores>(
                "CMsgGCResetStrangeScores",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCResetStrangeScores {
        static instance: ::protobuf::rt::LazyV2<CMsgGCResetStrangeScores> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCResetStrangeScores::new)
    }
}

impl ::protobuf::Clear for CMsgGCResetStrangeScores {
    fn clear(&mut self) {
        self.item_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCResetStrangeScores {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCResetStrangeScores {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCItemPreviewItemBoughtNotification {
    // message fields
    item_def_index: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCItemPreviewItemBoughtNotification {
    fn default() -> &'a CMsgGCItemPreviewItemBoughtNotification {
        <CMsgGCItemPreviewItemBoughtNotification as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCItemPreviewItemBoughtNotification {
    pub fn new() -> CMsgGCItemPreviewItemBoughtNotification {
        ::std::default::Default::default()
    }

    // optional uint32 item_def_index = 1;


    pub fn get_item_def_index(&self) -> u32 {
        self.item_def_index.unwrap_or(0)
    }
    pub fn clear_item_def_index(&mut self) {
        self.item_def_index = ::std::option::Option::None;
    }

    pub fn has_item_def_index(&self) -> bool {
        self.item_def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_def_index(&mut self, v: u32) {
        self.item_def_index = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCItemPreviewItemBoughtNotification {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.item_def_index = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.item_def_index {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.item_def_index {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCItemPreviewItemBoughtNotification {
        CMsgGCItemPreviewItemBoughtNotification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "item_def_index",
                |m: &CMsgGCItemPreviewItemBoughtNotification| { &m.item_def_index },
                |m: &mut CMsgGCItemPreviewItemBoughtNotification| { &mut m.item_def_index },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCItemPreviewItemBoughtNotification>(
                "CMsgGCItemPreviewItemBoughtNotification",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCItemPreviewItemBoughtNotification {
        static instance: ::protobuf::rt::LazyV2<CMsgGCItemPreviewItemBoughtNotification> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCItemPreviewItemBoughtNotification::new)
    }
}

impl ::protobuf::Clear for CMsgGCItemPreviewItemBoughtNotification {
    fn clear(&mut self) {
        self.item_def_index = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCItemPreviewItemBoughtNotification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCItemPreviewItemBoughtNotification {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCStorePurchaseCancel {
    // message fields
    txn_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCStorePurchaseCancel {
    fn default() -> &'a CMsgGCStorePurchaseCancel {
        <CMsgGCStorePurchaseCancel as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCStorePurchaseCancel {
    pub fn new() -> CMsgGCStorePurchaseCancel {
        ::std::default::Default::default()
    }

    // optional uint64 txn_id = 1;


    pub fn get_txn_id(&self) -> u64 {
        self.txn_id.unwrap_or(0)
    }
    pub fn clear_txn_id(&mut self) {
        self.txn_id = ::std::option::Option::None;
    }

    pub fn has_txn_id(&self) -> bool {
        self.txn_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txn_id(&mut self, v: u64) {
        self.txn_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCStorePurchaseCancel {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.txn_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.txn_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.txn_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCStorePurchaseCancel {
        CMsgGCStorePurchaseCancel::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "txn_id",
                |m: &CMsgGCStorePurchaseCancel| { &m.txn_id },
                |m: &mut CMsgGCStorePurchaseCancel| { &mut m.txn_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCStorePurchaseCancel>(
                "CMsgGCStorePurchaseCancel",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCStorePurchaseCancel {
        static instance: ::protobuf::rt::LazyV2<CMsgGCStorePurchaseCancel> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCStorePurchaseCancel::new)
    }
}

impl ::protobuf::Clear for CMsgGCStorePurchaseCancel {
    fn clear(&mut self) {
        self.txn_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCStorePurchaseCancel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCStorePurchaseCancel {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCStorePurchaseCancelResponse {
    // message fields
    result: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCStorePurchaseCancelResponse {
    fn default() -> &'a CMsgGCStorePurchaseCancelResponse {
        <CMsgGCStorePurchaseCancelResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCStorePurchaseCancelResponse {
    pub fn new() -> CMsgGCStorePurchaseCancelResponse {
        ::std::default::Default::default()
    }

    // optional uint32 result = 1;


    pub fn get_result(&self) -> u32 {
        self.result.unwrap_or(0)
    }
    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: u32) {
        self.result = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCStorePurchaseCancelResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCStorePurchaseCancelResponse {
        CMsgGCStorePurchaseCancelResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "result",
                |m: &CMsgGCStorePurchaseCancelResponse| { &m.result },
                |m: &mut CMsgGCStorePurchaseCancelResponse| { &mut m.result },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCStorePurchaseCancelResponse>(
                "CMsgGCStorePurchaseCancelResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCStorePurchaseCancelResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgGCStorePurchaseCancelResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCStorePurchaseCancelResponse::new)
    }
}

impl ::protobuf::Clear for CMsgGCStorePurchaseCancelResponse {
    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCStorePurchaseCancelResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCStorePurchaseCancelResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCStorePurchaseFinalize {
    // message fields
    txn_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCStorePurchaseFinalize {
    fn default() -> &'a CMsgGCStorePurchaseFinalize {
        <CMsgGCStorePurchaseFinalize as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCStorePurchaseFinalize {
    pub fn new() -> CMsgGCStorePurchaseFinalize {
        ::std::default::Default::default()
    }

    // optional uint64 txn_id = 1;


    pub fn get_txn_id(&self) -> u64 {
        self.txn_id.unwrap_or(0)
    }
    pub fn clear_txn_id(&mut self) {
        self.txn_id = ::std::option::Option::None;
    }

    pub fn has_txn_id(&self) -> bool {
        self.txn_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txn_id(&mut self, v: u64) {
        self.txn_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCStorePurchaseFinalize {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.txn_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.txn_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.txn_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCStorePurchaseFinalize {
        CMsgGCStorePurchaseFinalize::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "txn_id",
                |m: &CMsgGCStorePurchaseFinalize| { &m.txn_id },
                |m: &mut CMsgGCStorePurchaseFinalize| { &mut m.txn_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCStorePurchaseFinalize>(
                "CMsgGCStorePurchaseFinalize",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCStorePurchaseFinalize {
        static instance: ::protobuf::rt::LazyV2<CMsgGCStorePurchaseFinalize> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCStorePurchaseFinalize::new)
    }
}

impl ::protobuf::Clear for CMsgGCStorePurchaseFinalize {
    fn clear(&mut self) {
        self.txn_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCStorePurchaseFinalize {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCStorePurchaseFinalize {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCStorePurchaseFinalizeResponse {
    // message fields
    result: ::std::option::Option<u32>,
    pub item_ids: ::std::vec::Vec<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCStorePurchaseFinalizeResponse {
    fn default() -> &'a CMsgGCStorePurchaseFinalizeResponse {
        <CMsgGCStorePurchaseFinalizeResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCStorePurchaseFinalizeResponse {
    pub fn new() -> CMsgGCStorePurchaseFinalizeResponse {
        ::std::default::Default::default()
    }

    // optional uint32 result = 1;


    pub fn get_result(&self) -> u32 {
        self.result.unwrap_or(0)
    }
    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: u32) {
        self.result = ::std::option::Option::Some(v);
    }

    // repeated uint64 item_ids = 2;


    pub fn get_item_ids(&self) -> &[u64] {
        &self.item_ids
    }
    pub fn clear_item_ids(&mut self) {
        self.item_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_item_ids(&mut self, v: ::std::vec::Vec<u64>) {
        self.item_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_item_ids(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.item_ids
    }

    // Take field
    pub fn take_item_ids(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.item_ids, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgGCStorePurchaseFinalizeResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.item_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.item_ids {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_uint32(1, v)?;
        }
        for v in &self.item_ids {
            os.write_uint64(2, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCStorePurchaseFinalizeResponse {
        CMsgGCStorePurchaseFinalizeResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "result",
                |m: &CMsgGCStorePurchaseFinalizeResponse| { &m.result },
                |m: &mut CMsgGCStorePurchaseFinalizeResponse| { &mut m.result },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "item_ids",
                |m: &CMsgGCStorePurchaseFinalizeResponse| { &m.item_ids },
                |m: &mut CMsgGCStorePurchaseFinalizeResponse| { &mut m.item_ids },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCStorePurchaseFinalizeResponse>(
                "CMsgGCStorePurchaseFinalizeResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCStorePurchaseFinalizeResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgGCStorePurchaseFinalizeResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCStorePurchaseFinalizeResponse::new)
    }
}

impl ::protobuf::Clear for CMsgGCStorePurchaseFinalizeResponse {
    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.item_ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCStorePurchaseFinalizeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCStorePurchaseFinalizeResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCBannedWordListRequest {
    // message fields
    ban_list_group_id: ::std::option::Option<u32>,
    word_id: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCBannedWordListRequest {
    fn default() -> &'a CMsgGCBannedWordListRequest {
        <CMsgGCBannedWordListRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCBannedWordListRequest {
    pub fn new() -> CMsgGCBannedWordListRequest {
        ::std::default::Default::default()
    }

    // optional uint32 ban_list_group_id = 1;


    pub fn get_ban_list_group_id(&self) -> u32 {
        self.ban_list_group_id.unwrap_or(0)
    }
    pub fn clear_ban_list_group_id(&mut self) {
        self.ban_list_group_id = ::std::option::Option::None;
    }

    pub fn has_ban_list_group_id(&self) -> bool {
        self.ban_list_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ban_list_group_id(&mut self, v: u32) {
        self.ban_list_group_id = ::std::option::Option::Some(v);
    }

    // optional uint32 word_id = 2;


    pub fn get_word_id(&self) -> u32 {
        self.word_id.unwrap_or(0)
    }
    pub fn clear_word_id(&mut self) {
        self.word_id = ::std::option::Option::None;
    }

    pub fn has_word_id(&self) -> bool {
        self.word_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_word_id(&mut self, v: u32) {
        self.word_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCBannedWordListRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ban_list_group_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.word_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.ban_list_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.word_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.ban_list_group_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.word_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCBannedWordListRequest {
        CMsgGCBannedWordListRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ban_list_group_id",
                |m: &CMsgGCBannedWordListRequest| { &m.ban_list_group_id },
                |m: &mut CMsgGCBannedWordListRequest| { &mut m.ban_list_group_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "word_id",
                |m: &CMsgGCBannedWordListRequest| { &m.word_id },
                |m: &mut CMsgGCBannedWordListRequest| { &mut m.word_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCBannedWordListRequest>(
                "CMsgGCBannedWordListRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCBannedWordListRequest {
        static instance: ::protobuf::rt::LazyV2<CMsgGCBannedWordListRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCBannedWordListRequest::new)
    }
}

impl ::protobuf::Clear for CMsgGCBannedWordListRequest {
    fn clear(&mut self) {
        self.ban_list_group_id = ::std::option::Option::None;
        self.word_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCBannedWordListRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCBannedWordListRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCGiftedItems {
    // message fields
    gifter_steam_id: ::std::option::Option<u64>,
    was_random_person: ::std::option::Option<bool>,
    pub recipient_account_ids: ::std::vec::Vec<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCGiftedItems {
    fn default() -> &'a CMsgGCGiftedItems {
        <CMsgGCGiftedItems as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCGiftedItems {
    pub fn new() -> CMsgGCGiftedItems {
        ::std::default::Default::default()
    }

    // optional uint64 gifter_steam_id = 1;


    pub fn get_gifter_steam_id(&self) -> u64 {
        self.gifter_steam_id.unwrap_or(0)
    }
    pub fn clear_gifter_steam_id(&mut self) {
        self.gifter_steam_id = ::std::option::Option::None;
    }

    pub fn has_gifter_steam_id(&self) -> bool {
        self.gifter_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gifter_steam_id(&mut self, v: u64) {
        self.gifter_steam_id = ::std::option::Option::Some(v);
    }

    // optional bool was_random_person = 2;


    pub fn get_was_random_person(&self) -> bool {
        self.was_random_person.unwrap_or(false)
    }
    pub fn clear_was_random_person(&mut self) {
        self.was_random_person = ::std::option::Option::None;
    }

    pub fn has_was_random_person(&self) -> bool {
        self.was_random_person.is_some()
    }

    // Param is passed by value, moved
    pub fn set_was_random_person(&mut self, v: bool) {
        self.was_random_person = ::std::option::Option::Some(v);
    }

    // repeated uint32 recipient_account_ids = 3;


    pub fn get_recipient_account_ids(&self) -> &[u32] {
        &self.recipient_account_ids
    }
    pub fn clear_recipient_account_ids(&mut self) {
        self.recipient_account_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_recipient_account_ids(&mut self, v: ::std::vec::Vec<u32>) {
        self.recipient_account_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_recipient_account_ids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.recipient_account_ids
    }

    // Take field
    pub fn take_recipient_account_ids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.recipient_account_ids, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgGCGiftedItems {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.gifter_steam_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.was_random_person = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.recipient_account_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.gifter_steam_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.was_random_person {
            my_size += 2;
        }
        for value in &self.recipient_account_ids {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.gifter_steam_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.was_random_person {
            os.write_bool(2, v)?;
        }
        for v in &self.recipient_account_ids {
            os.write_uint32(3, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCGiftedItems {
        CMsgGCGiftedItems::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "gifter_steam_id",
                |m: &CMsgGCGiftedItems| { &m.gifter_steam_id },
                |m: &mut CMsgGCGiftedItems| { &mut m.gifter_steam_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "was_random_person",
                |m: &CMsgGCGiftedItems| { &m.was_random_person },
                |m: &mut CMsgGCGiftedItems| { &mut m.was_random_person },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "recipient_account_ids",
                |m: &CMsgGCGiftedItems| { &m.recipient_account_ids },
                |m: &mut CMsgGCGiftedItems| { &mut m.recipient_account_ids },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCGiftedItems>(
                "CMsgGCGiftedItems",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCGiftedItems {
        static instance: ::protobuf::rt::LazyV2<CMsgGCGiftedItems> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCGiftedItems::new)
    }
}

impl ::protobuf::Clear for CMsgGCGiftedItems {
    fn clear(&mut self) {
        self.gifter_steam_id = ::std::option::Option::None;
        self.was_random_person = ::std::option::Option::None;
        self.recipient_account_ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCGiftedItems {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCGiftedItems {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCCollectItem {
    // message fields
    collection_item_id: ::std::option::Option<u64>,
    subject_item_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCCollectItem {
    fn default() -> &'a CMsgGCCollectItem {
        <CMsgGCCollectItem as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCollectItem {
    pub fn new() -> CMsgGCCollectItem {
        ::std::default::Default::default()
    }

    // optional uint64 collection_item_id = 1;


    pub fn get_collection_item_id(&self) -> u64 {
        self.collection_item_id.unwrap_or(0)
    }
    pub fn clear_collection_item_id(&mut self) {
        self.collection_item_id = ::std::option::Option::None;
    }

    pub fn has_collection_item_id(&self) -> bool {
        self.collection_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_collection_item_id(&mut self, v: u64) {
        self.collection_item_id = ::std::option::Option::Some(v);
    }

    // optional uint64 subject_item_id = 2;


    pub fn get_subject_item_id(&self) -> u64 {
        self.subject_item_id.unwrap_or(0)
    }
    pub fn clear_subject_item_id(&mut self) {
        self.subject_item_id = ::std::option::Option::None;
    }

    pub fn has_subject_item_id(&self) -> bool {
        self.subject_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subject_item_id(&mut self, v: u64) {
        self.subject_item_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCCollectItem {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.collection_item_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.subject_item_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.collection_item_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.subject_item_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.collection_item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.subject_item_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCCollectItem {
        CMsgGCCollectItem::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "collection_item_id",
                |m: &CMsgGCCollectItem| { &m.collection_item_id },
                |m: &mut CMsgGCCollectItem| { &mut m.collection_item_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "subject_item_id",
                |m: &CMsgGCCollectItem| { &m.subject_item_id },
                |m: &mut CMsgGCCollectItem| { &mut m.subject_item_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCCollectItem>(
                "CMsgGCCollectItem",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCCollectItem {
        static instance: ::protobuf::rt::LazyV2<CMsgGCCollectItem> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCCollectItem::new)
    }
}

impl ::protobuf::Clear for CMsgGCCollectItem {
    fn clear(&mut self) {
        self.collection_item_id = ::std::option::Option::None;
        self.subject_item_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCCollectItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCollectItem {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCClientMarketDataRequest {
    // message fields
    user_currency: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCClientMarketDataRequest {
    fn default() -> &'a CMsgGCClientMarketDataRequest {
        <CMsgGCClientMarketDataRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCClientMarketDataRequest {
    pub fn new() -> CMsgGCClientMarketDataRequest {
        ::std::default::Default::default()
    }

    // optional uint32 user_currency = 1;


    pub fn get_user_currency(&self) -> u32 {
        self.user_currency.unwrap_or(0)
    }
    pub fn clear_user_currency(&mut self) {
        self.user_currency = ::std::option::Option::None;
    }

    pub fn has_user_currency(&self) -> bool {
        self.user_currency.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_currency(&mut self, v: u32) {
        self.user_currency = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCClientMarketDataRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.user_currency = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.user_currency {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.user_currency {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCClientMarketDataRequest {
        CMsgGCClientMarketDataRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "user_currency",
                |m: &CMsgGCClientMarketDataRequest| { &m.user_currency },
                |m: &mut CMsgGCClientMarketDataRequest| { &mut m.user_currency },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCClientMarketDataRequest>(
                "CMsgGCClientMarketDataRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCClientMarketDataRequest {
        static instance: ::protobuf::rt::LazyV2<CMsgGCClientMarketDataRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCClientMarketDataRequest::new)
    }
}

impl ::protobuf::Clear for CMsgGCClientMarketDataRequest {
    fn clear(&mut self) {
        self.user_currency = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCClientMarketDataRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCClientMarketDataRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCClientMarketDataEntry {
    // message fields
    item_def_index: ::std::option::Option<u32>,
    item_quality: ::std::option::Option<u32>,
    item_sell_listings: ::std::option::Option<u32>,
    price_in_local_currency: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCClientMarketDataEntry {
    fn default() -> &'a CMsgGCClientMarketDataEntry {
        <CMsgGCClientMarketDataEntry as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCClientMarketDataEntry {
    pub fn new() -> CMsgGCClientMarketDataEntry {
        ::std::default::Default::default()
    }

    // optional uint32 item_def_index = 1;


    pub fn get_item_def_index(&self) -> u32 {
        self.item_def_index.unwrap_or(0)
    }
    pub fn clear_item_def_index(&mut self) {
        self.item_def_index = ::std::option::Option::None;
    }

    pub fn has_item_def_index(&self) -> bool {
        self.item_def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_def_index(&mut self, v: u32) {
        self.item_def_index = ::std::option::Option::Some(v);
    }

    // optional uint32 item_quality = 2;


    pub fn get_item_quality(&self) -> u32 {
        self.item_quality.unwrap_or(0)
    }
    pub fn clear_item_quality(&mut self) {
        self.item_quality = ::std::option::Option::None;
    }

    pub fn has_item_quality(&self) -> bool {
        self.item_quality.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_quality(&mut self, v: u32) {
        self.item_quality = ::std::option::Option::Some(v);
    }

    // optional uint32 item_sell_listings = 3;


    pub fn get_item_sell_listings(&self) -> u32 {
        self.item_sell_listings.unwrap_or(0)
    }
    pub fn clear_item_sell_listings(&mut self) {
        self.item_sell_listings = ::std::option::Option::None;
    }

    pub fn has_item_sell_listings(&self) -> bool {
        self.item_sell_listings.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_sell_listings(&mut self, v: u32) {
        self.item_sell_listings = ::std::option::Option::Some(v);
    }

    // optional uint32 price_in_local_currency = 4;


    pub fn get_price_in_local_currency(&self) -> u32 {
        self.price_in_local_currency.unwrap_or(0)
    }
    pub fn clear_price_in_local_currency(&mut self) {
        self.price_in_local_currency = ::std::option::Option::None;
    }

    pub fn has_price_in_local_currency(&self) -> bool {
        self.price_in_local_currency.is_some()
    }

    // Param is passed by value, moved
    pub fn set_price_in_local_currency(&mut self, v: u32) {
        self.price_in_local_currency = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgGCClientMarketDataEntry {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.item_def_index = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.item_quality = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.item_sell_listings = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.price_in_local_currency = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.item_def_index {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.item_quality {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.item_sell_listings {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.price_in_local_currency {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.item_def_index {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.item_quality {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.item_sell_listings {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.price_in_local_currency {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCClientMarketDataEntry {
        CMsgGCClientMarketDataEntry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "item_def_index",
                |m: &CMsgGCClientMarketDataEntry| { &m.item_def_index },
                |m: &mut CMsgGCClientMarketDataEntry| { &mut m.item_def_index },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "item_quality",
                |m: &CMsgGCClientMarketDataEntry| { &m.item_quality },
                |m: &mut CMsgGCClientMarketDataEntry| { &mut m.item_quality },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "item_sell_listings",
                |m: &CMsgGCClientMarketDataEntry| { &m.item_sell_listings },
                |m: &mut CMsgGCClientMarketDataEntry| { &mut m.item_sell_listings },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "price_in_local_currency",
                |m: &CMsgGCClientMarketDataEntry| { &m.price_in_local_currency },
                |m: &mut CMsgGCClientMarketDataEntry| { &mut m.price_in_local_currency },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCClientMarketDataEntry>(
                "CMsgGCClientMarketDataEntry",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCClientMarketDataEntry {
        static instance: ::protobuf::rt::LazyV2<CMsgGCClientMarketDataEntry> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCClientMarketDataEntry::new)
    }
}

impl ::protobuf::Clear for CMsgGCClientMarketDataEntry {
    fn clear(&mut self) {
        self.item_def_index = ::std::option::Option::None;
        self.item_quality = ::std::option::Option::None;
        self.item_sell_listings = ::std::option::Option::None;
        self.price_in_local_currency = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCClientMarketDataEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCClientMarketDataEntry {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgGCClientMarketData {
    // message fields
    pub entries: ::protobuf::RepeatedField<CMsgGCClientMarketDataEntry>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgGCClientMarketData {
    fn default() -> &'a CMsgGCClientMarketData {
        <CMsgGCClientMarketData as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCClientMarketData {
    pub fn new() -> CMsgGCClientMarketData {
        ::std::default::Default::default()
    }

    // repeated .CMsgGCClientMarketDataEntry entries = 1;


    pub fn get_entries(&self) -> &[CMsgGCClientMarketDataEntry] {
        &self.entries
    }
    pub fn clear_entries(&mut self) {
        self.entries.clear();
    }

    // Param is passed by value, moved
    pub fn set_entries(&mut self, v: ::protobuf::RepeatedField<CMsgGCClientMarketDataEntry>) {
        self.entries = v;
    }

    // Mutable pointer to the field.
    pub fn mut_entries(&mut self) -> &mut ::protobuf::RepeatedField<CMsgGCClientMarketDataEntry> {
        &mut self.entries
    }

    // Take field
    pub fn take_entries(&mut self) -> ::protobuf::RepeatedField<CMsgGCClientMarketDataEntry> {
        ::std::mem::replace(&mut self.entries, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgGCClientMarketData {
    fn is_initialized(&self) -> bool {
        for v in &self.entries {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.entries)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.entries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.entries {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgGCClientMarketData {
        CMsgGCClientMarketData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgGCClientMarketDataEntry>>(
                "entries",
                |m: &CMsgGCClientMarketData| { &m.entries },
                |m: &mut CMsgGCClientMarketData| { &mut m.entries },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgGCClientMarketData>(
                "CMsgGCClientMarketData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgGCClientMarketData {
        static instance: ::protobuf::rt::LazyV2<CMsgGCClientMarketData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgGCClientMarketData::new)
    }
}

impl ::protobuf::Clear for CMsgGCClientMarketData {
    fn clear(&mut self) {
        self.entries.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgGCClientMarketData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCClientMarketData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgApplyToolToItem {
    // message fields
    tool_item_id: ::std::option::Option<u64>,
    subject_item_id: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgApplyToolToItem {
    fn default() -> &'a CMsgApplyToolToItem {
        <CMsgApplyToolToItem as ::protobuf::Message>::default_instance()
    }
}

impl CMsgApplyToolToItem {
    pub fn new() -> CMsgApplyToolToItem {
        ::std::default::Default::default()
    }

    // optional uint64 tool_item_id = 1;


    pub fn get_tool_item_id(&self) -> u64 {
        self.tool_item_id.unwrap_or(0)
    }
    pub fn clear_tool_item_id(&mut self) {
        self.tool_item_id = ::std::option::Option::None;
    }

    pub fn has_tool_item_id(&self) -> bool {
        self.tool_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tool_item_id(&mut self, v: u64) {
        self.tool_item_id = ::std::option::Option::Some(v);
    }

    // optional uint64 subject_item_id = 2;


    pub fn get_subject_item_id(&self) -> u64 {
        self.subject_item_id.unwrap_or(0)
    }
    pub fn clear_subject_item_id(&mut self) {
        self.subject_item_id = ::std::option::Option::None;
    }

    pub fn has_subject_item_id(&self) -> bool {
        self.subject_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subject_item_id(&mut self, v: u64) {
        self.subject_item_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgApplyToolToItem {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.tool_item_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.subject_item_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.tool_item_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.subject_item_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.tool_item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.subject_item_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgApplyToolToItem {
        CMsgApplyToolToItem::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "tool_item_id",
                |m: &CMsgApplyToolToItem| { &m.tool_item_id },
                |m: &mut CMsgApplyToolToItem| { &mut m.tool_item_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "subject_item_id",
                |m: &CMsgApplyToolToItem| { &m.subject_item_id },
                |m: &mut CMsgApplyToolToItem| { &mut m.subject_item_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgApplyToolToItem>(
                "CMsgApplyToolToItem",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgApplyToolToItem {
        static instance: ::protobuf::rt::LazyV2<CMsgApplyToolToItem> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgApplyToolToItem::new)
    }
}

impl ::protobuf::Clear for CMsgApplyToolToItem {
    fn clear(&mut self) {
        self.tool_item_id = ::std::option::Option::None;
        self.subject_item_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgApplyToolToItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgApplyToolToItem {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgApplyToolToBaseItem {
    // message fields
    tool_item_id: ::std::option::Option<u64>,
    baseitem_def_index: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgApplyToolToBaseItem {
    fn default() -> &'a CMsgApplyToolToBaseItem {
        <CMsgApplyToolToBaseItem as ::protobuf::Message>::default_instance()
    }
}

impl CMsgApplyToolToBaseItem {
    pub fn new() -> CMsgApplyToolToBaseItem {
        ::std::default::Default::default()
    }

    // optional uint64 tool_item_id = 1;


    pub fn get_tool_item_id(&self) -> u64 {
        self.tool_item_id.unwrap_or(0)
    }
    pub fn clear_tool_item_id(&mut self) {
        self.tool_item_id = ::std::option::Option::None;
    }

    pub fn has_tool_item_id(&self) -> bool {
        self.tool_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tool_item_id(&mut self, v: u64) {
        self.tool_item_id = ::std::option::Option::Some(v);
    }

    // optional uint32 baseitem_def_index = 2;


    pub fn get_baseitem_def_index(&self) -> u32 {
        self.baseitem_def_index.unwrap_or(0)
    }
    pub fn clear_baseitem_def_index(&mut self) {
        self.baseitem_def_index = ::std::option::Option::None;
    }

    pub fn has_baseitem_def_index(&self) -> bool {
        self.baseitem_def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_baseitem_def_index(&mut self, v: u32) {
        self.baseitem_def_index = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgApplyToolToBaseItem {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.tool_item_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.baseitem_def_index = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.tool_item_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.baseitem_def_index {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.tool_item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.baseitem_def_index {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgApplyToolToBaseItem {
        CMsgApplyToolToBaseItem::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "tool_item_id",
                |m: &CMsgApplyToolToBaseItem| { &m.tool_item_id },
                |m: &mut CMsgApplyToolToBaseItem| { &mut m.tool_item_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "baseitem_def_index",
                |m: &CMsgApplyToolToBaseItem| { &m.baseitem_def_index },
                |m: &mut CMsgApplyToolToBaseItem| { &mut m.baseitem_def_index },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgApplyToolToBaseItem>(
                "CMsgApplyToolToBaseItem",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgApplyToolToBaseItem {
        static instance: ::protobuf::rt::LazyV2<CMsgApplyToolToBaseItem> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgApplyToolToBaseItem::new)
    }
}

impl ::protobuf::Clear for CMsgApplyToolToBaseItem {
    fn clear(&mut self) {
        self.tool_item_id = ::std::option::Option::None;
        self.baseitem_def_index = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgApplyToolToBaseItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgApplyToolToBaseItem {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgRecipeComponent {
    // message fields
    subject_item_id: ::std::option::Option<u64>,
    attribute_index: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgRecipeComponent {
    fn default() -> &'a CMsgRecipeComponent {
        <CMsgRecipeComponent as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRecipeComponent {
    pub fn new() -> CMsgRecipeComponent {
        ::std::default::Default::default()
    }

    // optional uint64 subject_item_id = 1;


    pub fn get_subject_item_id(&self) -> u64 {
        self.subject_item_id.unwrap_or(0)
    }
    pub fn clear_subject_item_id(&mut self) {
        self.subject_item_id = ::std::option::Option::None;
    }

    pub fn has_subject_item_id(&self) -> bool {
        self.subject_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subject_item_id(&mut self, v: u64) {
        self.subject_item_id = ::std::option::Option::Some(v);
    }

    // optional uint64 attribute_index = 2;


    pub fn get_attribute_index(&self) -> u64 {
        self.attribute_index.unwrap_or(0)
    }
    pub fn clear_attribute_index(&mut self) {
        self.attribute_index = ::std::option::Option::None;
    }

    pub fn has_attribute_index(&self) -> bool {
        self.attribute_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attribute_index(&mut self, v: u64) {
        self.attribute_index = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgRecipeComponent {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.subject_item_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.attribute_index = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.subject_item_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.attribute_index {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.subject_item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.attribute_index {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgRecipeComponent {
        CMsgRecipeComponent::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "subject_item_id",
                |m: &CMsgRecipeComponent| { &m.subject_item_id },
                |m: &mut CMsgRecipeComponent| { &mut m.subject_item_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "attribute_index",
                |m: &CMsgRecipeComponent| { &m.attribute_index },
                |m: &mut CMsgRecipeComponent| { &mut m.attribute_index },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgRecipeComponent>(
                "CMsgRecipeComponent",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgRecipeComponent {
        static instance: ::protobuf::rt::LazyV2<CMsgRecipeComponent> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgRecipeComponent::new)
    }
}

impl ::protobuf::Clear for CMsgRecipeComponent {
    fn clear(&mut self) {
        self.subject_item_id = ::std::option::Option::None;
        self.attribute_index = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgRecipeComponent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgRecipeComponent {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgFulfillDynamicRecipeComponent {
    // message fields
    tool_item_id: ::std::option::Option<u64>,
    pub consumption_components: ::protobuf::RepeatedField<CMsgRecipeComponent>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgFulfillDynamicRecipeComponent {
    fn default() -> &'a CMsgFulfillDynamicRecipeComponent {
        <CMsgFulfillDynamicRecipeComponent as ::protobuf::Message>::default_instance()
    }
}

impl CMsgFulfillDynamicRecipeComponent {
    pub fn new() -> CMsgFulfillDynamicRecipeComponent {
        ::std::default::Default::default()
    }

    // optional uint64 tool_item_id = 1;


    pub fn get_tool_item_id(&self) -> u64 {
        self.tool_item_id.unwrap_or(0)
    }
    pub fn clear_tool_item_id(&mut self) {
        self.tool_item_id = ::std::option::Option::None;
    }

    pub fn has_tool_item_id(&self) -> bool {
        self.tool_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tool_item_id(&mut self, v: u64) {
        self.tool_item_id = ::std::option::Option::Some(v);
    }

    // repeated .CMsgRecipeComponent consumption_components = 2;


    pub fn get_consumption_components(&self) -> &[CMsgRecipeComponent] {
        &self.consumption_components
    }
    pub fn clear_consumption_components(&mut self) {
        self.consumption_components.clear();
    }

    // Param is passed by value, moved
    pub fn set_consumption_components(&mut self, v: ::protobuf::RepeatedField<CMsgRecipeComponent>) {
        self.consumption_components = v;
    }

    // Mutable pointer to the field.
    pub fn mut_consumption_components(&mut self) -> &mut ::protobuf::RepeatedField<CMsgRecipeComponent> {
        &mut self.consumption_components
    }

    // Take field
    pub fn take_consumption_components(&mut self) -> ::protobuf::RepeatedField<CMsgRecipeComponent> {
        ::std::mem::replace(&mut self.consumption_components, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgFulfillDynamicRecipeComponent {
    fn is_initialized(&self) -> bool {
        for v in &self.consumption_components {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.tool_item_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.consumption_components)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.tool_item_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.consumption_components {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.tool_item_id {
            os.write_uint64(1, v)?;
        }
        for v in &self.consumption_components {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgFulfillDynamicRecipeComponent {
        CMsgFulfillDynamicRecipeComponent::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "tool_item_id",
                |m: &CMsgFulfillDynamicRecipeComponent| { &m.tool_item_id },
                |m: &mut CMsgFulfillDynamicRecipeComponent| { &mut m.tool_item_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgRecipeComponent>>(
                "consumption_components",
                |m: &CMsgFulfillDynamicRecipeComponent| { &m.consumption_components },
                |m: &mut CMsgFulfillDynamicRecipeComponent| { &mut m.consumption_components },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgFulfillDynamicRecipeComponent>(
                "CMsgFulfillDynamicRecipeComponent",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgFulfillDynamicRecipeComponent {
        static instance: ::protobuf::rt::LazyV2<CMsgFulfillDynamicRecipeComponent> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgFulfillDynamicRecipeComponent::new)
    }
}

impl ::protobuf::Clear for CMsgFulfillDynamicRecipeComponent {
    fn clear(&mut self) {
        self.tool_item_id = ::std::option::Option::None;
        self.consumption_components.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgFulfillDynamicRecipeComponent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgFulfillDynamicRecipeComponent {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSetItemEffectVerticalOffset {
    // message fields
    item_id: ::std::option::Option<u64>,
    offset: ::std::option::Option<f32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSetItemEffectVerticalOffset {
    fn default() -> &'a CMsgSetItemEffectVerticalOffset {
        <CMsgSetItemEffectVerticalOffset as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSetItemEffectVerticalOffset {
    pub fn new() -> CMsgSetItemEffectVerticalOffset {
        ::std::default::Default::default()
    }

    // optional uint64 item_id = 1;


    pub fn get_item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }
    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    // optional float offset = 2;


    pub fn get_offset(&self) -> f32 {
        self.offset.unwrap_or(0.)
    }
    pub fn clear_offset(&mut self) {
        self.offset = ::std::option::Option::None;
    }

    pub fn has_offset(&self) -> bool {
        self.offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: f32) {
        self.offset = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSetItemEffectVerticalOffset {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.item_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.offset = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.offset {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.offset {
            os.write_float(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSetItemEffectVerticalOffset {
        CMsgSetItemEffectVerticalOffset::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "item_id",
                |m: &CMsgSetItemEffectVerticalOffset| { &m.item_id },
                |m: &mut CMsgSetItemEffectVerticalOffset| { &mut m.item_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "offset",
                |m: &CMsgSetItemEffectVerticalOffset| { &m.offset },
                |m: &mut CMsgSetItemEffectVerticalOffset| { &mut m.offset },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSetItemEffectVerticalOffset>(
                "CMsgSetItemEffectVerticalOffset",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSetItemEffectVerticalOffset {
        static instance: ::protobuf::rt::LazyV2<CMsgSetItemEffectVerticalOffset> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSetItemEffectVerticalOffset::new)
    }
}

impl ::protobuf::Clear for CMsgSetItemEffectVerticalOffset {
    fn clear(&mut self) {
        self.item_id = ::std::option::Option::None;
        self.offset = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSetItemEffectVerticalOffset {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSetItemEffectVerticalOffset {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgSetHatEffectUseHeadOrigin {
    // message fields
    item_id: ::std::option::Option<u64>,
    use_head: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgSetHatEffectUseHeadOrigin {
    fn default() -> &'a CMsgSetHatEffectUseHeadOrigin {
        <CMsgSetHatEffectUseHeadOrigin as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSetHatEffectUseHeadOrigin {
    pub fn new() -> CMsgSetHatEffectUseHeadOrigin {
        ::std::default::Default::default()
    }

    // optional uint64 item_id = 1;


    pub fn get_item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }
    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    // optional bool use_head = 2;


    pub fn get_use_head(&self) -> bool {
        self.use_head.unwrap_or(false)
    }
    pub fn clear_use_head(&mut self) {
        self.use_head = ::std::option::Option::None;
    }

    pub fn has_use_head(&self) -> bool {
        self.use_head.is_some()
    }

    // Param is passed by value, moved
    pub fn set_use_head(&mut self, v: bool) {
        self.use_head = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgSetHatEffectUseHeadOrigin {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.item_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.use_head = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.use_head {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.use_head {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgSetHatEffectUseHeadOrigin {
        CMsgSetHatEffectUseHeadOrigin::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "item_id",
                |m: &CMsgSetHatEffectUseHeadOrigin| { &m.item_id },
                |m: &mut CMsgSetHatEffectUseHeadOrigin| { &mut m.item_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "use_head",
                |m: &CMsgSetHatEffectUseHeadOrigin| { &m.use_head },
                |m: &mut CMsgSetHatEffectUseHeadOrigin| { &mut m.use_head },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgSetHatEffectUseHeadOrigin>(
                "CMsgSetHatEffectUseHeadOrigin",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgSetHatEffectUseHeadOrigin {
        static instance: ::protobuf::rt::LazyV2<CMsgSetHatEffectUseHeadOrigin> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgSetHatEffectUseHeadOrigin::new)
    }
}

impl ::protobuf::Clear for CMsgSetHatEffectUseHeadOrigin {
    fn clear(&mut self) {
        self.item_id = ::std::option::Option::None;
        self.use_head = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgSetHatEffectUseHeadOrigin {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSetHatEffectUseHeadOrigin {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CMsgDeliverGiftResponseGiver {
    // message fields
    response_code: ::std::option::Option<u32>,
    receiver_account_name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgDeliverGiftResponseGiver {
    fn default() -> &'a CMsgDeliverGiftResponseGiver {
        <CMsgDeliverGiftResponseGiver as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDeliverGiftResponseGiver {
    pub fn new() -> CMsgDeliverGiftResponseGiver {
        ::std::default::Default::default()
    }

    // optional uint32 response_code = 1;


    pub fn get_response_code(&self) -> u32 {
        self.response_code.unwrap_or(0)
    }
    pub fn clear_response_code(&mut self) {
        self.response_code = ::std::option::Option::None;
    }

    pub fn has_response_code(&self) -> bool {
        self.response_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response_code(&mut self, v: u32) {
        self.response_code = ::std::option::Option::Some(v);
    }

    // optional string receiver_account_name = 2;


    pub fn get_receiver_account_name(&self) -> &str {
        match self.receiver_account_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_receiver_account_name(&mut self) {
        self.receiver_account_name.clear();
    }

    pub fn has_receiver_account_name(&self) -> bool {
        self.receiver_account_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_receiver_account_name(&mut self, v: ::std::string::String) {
        self.receiver_account_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_receiver_account_name(&mut self) -> &mut ::std::string::String {
        if self.receiver_account_name.is_none() {
            self.receiver_account_name.set_default();
        }
        self.receiver_account_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_receiver_account_name(&mut self) -> ::std::string::String {
        self.receiver_account_name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgDeliverGiftResponseGiver {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.response_code = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.receiver_account_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.response_code {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.receiver_account_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.response_code {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.receiver_account_name.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgDeliverGiftResponseGiver {
        CMsgDeliverGiftResponseGiver::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "response_code",
                |m: &CMsgDeliverGiftResponseGiver| { &m.response_code },
                |m: &mut CMsgDeliverGiftResponseGiver| { &mut m.response_code },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "receiver_account_name",
                |m: &CMsgDeliverGiftResponseGiver| { &m.receiver_account_name },
                |m: &mut CMsgDeliverGiftResponseGiver| { &mut m.receiver_account_name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgDeliverGiftResponseGiver>(
                "CMsgDeliverGiftResponseGiver",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgDeliverGiftResponseGiver {
        static instance: ::protobuf::rt::LazyV2<CMsgDeliverGiftResponseGiver> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgDeliverGiftResponseGiver::new)
    }
}

impl ::protobuf::Clear for CMsgDeliverGiftResponseGiver {
    fn clear(&mut self) {
        self.response_code = ::std::option::Option::None;
        self.receiver_account_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgDeliverGiftResponseGiver {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDeliverGiftResponseGiver {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CSOEconGameAccountForGameServers {
    // message fields
    disable_party_quest_progress: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CSOEconGameAccountForGameServers {
    fn default() -> &'a CSOEconGameAccountForGameServers {
        <CSOEconGameAccountForGameServers as ::protobuf::Message>::default_instance()
    }
}

impl CSOEconGameAccountForGameServers {
    pub fn new() -> CSOEconGameAccountForGameServers {
        ::std::default::Default::default()
    }

    // optional bool disable_party_quest_progress = 6;


    pub fn get_disable_party_quest_progress(&self) -> bool {
        self.disable_party_quest_progress.unwrap_or(false)
    }
    pub fn clear_disable_party_quest_progress(&mut self) {
        self.disable_party_quest_progress = ::std::option::Option::None;
    }

    pub fn has_disable_party_quest_progress(&self) -> bool {
        self.disable_party_quest_progress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_disable_party_quest_progress(&mut self, v: bool) {
        self.disable_party_quest_progress = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CSOEconGameAccountForGameServers {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.disable_party_quest_progress = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.disable_party_quest_progress {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.disable_party_quest_progress {
            os.write_bool(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CSOEconGameAccountForGameServers {
        CSOEconGameAccountForGameServers::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "disable_party_quest_progress",
                |m: &CSOEconGameAccountForGameServers| { &m.disable_party_quest_progress },
                |m: &mut CSOEconGameAccountForGameServers| { &mut m.disable_party_quest_progress },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CSOEconGameAccountForGameServers>(
                "CSOEconGameAccountForGameServers",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CSOEconGameAccountForGameServers {
        static instance: ::protobuf::rt::LazyV2<CSOEconGameAccountForGameServers> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CSOEconGameAccountForGameServers::new)
    }
}

impl ::protobuf::Clear for CSOEconGameAccountForGameServers {
    fn clear(&mut self) {
        self.disable_party_quest_progress = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSOEconGameAccountForGameServers {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOEconGameAccountForGameServers {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CWorkshop_PopulateItemDescriptions_Request {
    // message fields
    appid: ::std::option::Option<u32>,
    pub languages: ::protobuf::RepeatedField<CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CWorkshop_PopulateItemDescriptions_Request {
    fn default() -> &'a CWorkshop_PopulateItemDescriptions_Request {
        <CWorkshop_PopulateItemDescriptions_Request as ::protobuf::Message>::default_instance()
    }
}

impl CWorkshop_PopulateItemDescriptions_Request {
    pub fn new() -> CWorkshop_PopulateItemDescriptions_Request {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;


    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }
    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // repeated .CWorkshop_PopulateItemDescriptions_Request.ItemDescriptionsLanguageBlock languages = 2;


    pub fn get_languages(&self) -> &[CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock] {
        &self.languages
    }
    pub fn clear_languages(&mut self) {
        self.languages.clear();
    }

    // Param is passed by value, moved
    pub fn set_languages(&mut self, v: ::protobuf::RepeatedField<CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock>) {
        self.languages = v;
    }

    // Mutable pointer to the field.
    pub fn mut_languages(&mut self) -> &mut ::protobuf::RepeatedField<CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock> {
        &mut self.languages
    }

    // Take field
    pub fn take_languages(&mut self) -> ::protobuf::RepeatedField<CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock> {
        ::std::mem::replace(&mut self.languages, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CWorkshop_PopulateItemDescriptions_Request {
    fn is_initialized(&self) -> bool {
        for v in &self.languages {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.appid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.languages)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.languages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        for v in &self.languages {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CWorkshop_PopulateItemDescriptions_Request {
        CWorkshop_PopulateItemDescriptions_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "appid",
                |m: &CWorkshop_PopulateItemDescriptions_Request| { &m.appid },
                |m: &mut CWorkshop_PopulateItemDescriptions_Request| { &mut m.appid },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock>>(
                "languages",
                |m: &CWorkshop_PopulateItemDescriptions_Request| { &m.languages },
                |m: &mut CWorkshop_PopulateItemDescriptions_Request| { &mut m.languages },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CWorkshop_PopulateItemDescriptions_Request>(
                "CWorkshop_PopulateItemDescriptions_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CWorkshop_PopulateItemDescriptions_Request {
        static instance: ::protobuf::rt::LazyV2<CWorkshop_PopulateItemDescriptions_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CWorkshop_PopulateItemDescriptions_Request::new)
    }
}

impl ::protobuf::Clear for CWorkshop_PopulateItemDescriptions_Request {
    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.languages.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CWorkshop_PopulateItemDescriptions_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CWorkshop_PopulateItemDescriptions_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription {
    // message fields
    gameitemid: ::std::option::Option<u32>,
    item_description: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription {
    fn default() -> &'a CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription {
        <CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription as ::protobuf::Message>::default_instance()
    }
}

impl CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription {
    pub fn new() -> CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription {
        ::std::default::Default::default()
    }

    // optional uint32 gameitemid = 1;


    pub fn get_gameitemid(&self) -> u32 {
        self.gameitemid.unwrap_or(0)
    }
    pub fn clear_gameitemid(&mut self) {
        self.gameitemid = ::std::option::Option::None;
    }

    pub fn has_gameitemid(&self) -> bool {
        self.gameitemid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gameitemid(&mut self, v: u32) {
        self.gameitemid = ::std::option::Option::Some(v);
    }

    // optional string item_description = 2;


    pub fn get_item_description(&self) -> &str {
        match self.item_description.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_item_description(&mut self) {
        self.item_description.clear();
    }

    pub fn has_item_description(&self) -> bool {
        self.item_description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_description(&mut self, v: ::std::string::String) {
        self.item_description = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_item_description(&mut self) -> &mut ::std::string::String {
        if self.item_description.is_none() {
            self.item_description.set_default();
        }
        self.item_description.as_mut().unwrap()
    }

    // Take field
    pub fn take_item_description(&mut self) -> ::std::string::String {
        self.item_description.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.gameitemid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.item_description)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.gameitemid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.item_description.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.gameitemid {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.item_description.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription {
        CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "gameitemid",
                |m: &CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription| { &m.gameitemid },
                |m: &mut CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription| { &mut m.gameitemid },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "item_description",
                |m: &CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription| { &m.item_description },
                |m: &mut CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription| { &mut m.item_description },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription>(
                "CWorkshop_PopulateItemDescriptions_Request.SingleItemDescription",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription {
        static instance: ::protobuf::rt::LazyV2<CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription::new)
    }
}

impl ::protobuf::Clear for CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription {
    fn clear(&mut self) {
        self.gameitemid = ::std::option::Option::None;
        self.item_description.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock {
    // message fields
    language: ::protobuf::SingularField<::std::string::String>,
    pub descriptions: ::protobuf::RepeatedField<CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock {
    fn default() -> &'a CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock {
        <CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock as ::protobuf::Message>::default_instance()
    }
}

impl CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock {
    pub fn new() -> CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock {
        ::std::default::Default::default()
    }

    // optional string language = 1;


    pub fn get_language(&self) -> &str {
        match self.language.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_language(&mut self) {
        self.language.clear();
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: ::std::string::String) {
        self.language = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_language(&mut self) -> &mut ::std::string::String {
        if self.language.is_none() {
            self.language.set_default();
        }
        self.language.as_mut().unwrap()
    }

    // Take field
    pub fn take_language(&mut self) -> ::std::string::String {
        self.language.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .CWorkshop_PopulateItemDescriptions_Request.SingleItemDescription descriptions = 2;


    pub fn get_descriptions(&self) -> &[CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription] {
        &self.descriptions
    }
    pub fn clear_descriptions(&mut self) {
        self.descriptions.clear();
    }

    // Param is passed by value, moved
    pub fn set_descriptions(&mut self, v: ::protobuf::RepeatedField<CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription>) {
        self.descriptions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_descriptions(&mut self) -> &mut ::protobuf::RepeatedField<CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription> {
        &mut self.descriptions
    }

    // Take field
    pub fn take_descriptions(&mut self) -> ::protobuf::RepeatedField<CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription> {
        ::std::mem::replace(&mut self.descriptions, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock {
    fn is_initialized(&self) -> bool {
        for v in &self.descriptions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.language)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.descriptions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.language.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.descriptions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.language.as_ref() {
            os.write_string(1, &v)?;
        }
        for v in &self.descriptions {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock {
        CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "language",
                |m: &CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock| { &m.language },
                |m: &mut CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock| { &mut m.language },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CWorkshop_PopulateItemDescriptions_Request_SingleItemDescription>>(
                "descriptions",
                |m: &CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock| { &m.descriptions },
                |m: &mut CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock| { &mut m.descriptions },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock>(
                "CWorkshop_PopulateItemDescriptions_Request.ItemDescriptionsLanguageBlock",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock {
        static instance: ::protobuf::rt::LazyV2<CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock::new)
    }
}

impl ::protobuf::Clear for CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock {
    fn clear(&mut self) {
        self.language.clear();
        self.descriptions.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CWorkshop_PopulateItemDescriptions_Request_ItemDescriptionsLanguageBlock {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CWorkshop_GetContributors_Request {
    // message fields
    appid: ::std::option::Option<u32>,
    gameitemid: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CWorkshop_GetContributors_Request {
    fn default() -> &'a CWorkshop_GetContributors_Request {
        <CWorkshop_GetContributors_Request as ::protobuf::Message>::default_instance()
    }
}

impl CWorkshop_GetContributors_Request {
    pub fn new() -> CWorkshop_GetContributors_Request {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;


    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }
    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional uint32 gameitemid = 2;


    pub fn get_gameitemid(&self) -> u32 {
        self.gameitemid.unwrap_or(0)
    }
    pub fn clear_gameitemid(&mut self) {
        self.gameitemid = ::std::option::Option::None;
    }

    pub fn has_gameitemid(&self) -> bool {
        self.gameitemid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gameitemid(&mut self, v: u32) {
        self.gameitemid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CWorkshop_GetContributors_Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.appid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.gameitemid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.gameitemid {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.gameitemid {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CWorkshop_GetContributors_Request {
        CWorkshop_GetContributors_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "appid",
                |m: &CWorkshop_GetContributors_Request| { &m.appid },
                |m: &mut CWorkshop_GetContributors_Request| { &mut m.appid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "gameitemid",
                |m: &CWorkshop_GetContributors_Request| { &m.gameitemid },
                |m: &mut CWorkshop_GetContributors_Request| { &mut m.gameitemid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CWorkshop_GetContributors_Request>(
                "CWorkshop_GetContributors_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CWorkshop_GetContributors_Request {
        static instance: ::protobuf::rt::LazyV2<CWorkshop_GetContributors_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CWorkshop_GetContributors_Request::new)
    }
}

impl ::protobuf::Clear for CWorkshop_GetContributors_Request {
    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.gameitemid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CWorkshop_GetContributors_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CWorkshop_GetContributors_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CWorkshop_GetContributors_Response {
    // message fields
    pub contributors: ::std::vec::Vec<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CWorkshop_GetContributors_Response {
    fn default() -> &'a CWorkshop_GetContributors_Response {
        <CWorkshop_GetContributors_Response as ::protobuf::Message>::default_instance()
    }
}

impl CWorkshop_GetContributors_Response {
    pub fn new() -> CWorkshop_GetContributors_Response {
        ::std::default::Default::default()
    }

    // repeated fixed64 contributors = 1;


    pub fn get_contributors(&self) -> &[u64] {
        &self.contributors
    }
    pub fn clear_contributors(&mut self) {
        self.contributors.clear();
    }

    // Param is passed by value, moved
    pub fn set_contributors(&mut self, v: ::std::vec::Vec<u64>) {
        self.contributors = v;
    }

    // Mutable pointer to the field.
    pub fn mut_contributors(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.contributors
    }

    // Take field
    pub fn take_contributors(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.contributors, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CWorkshop_GetContributors_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_fixed64_into(wire_type, is, &mut self.contributors)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += 9 * self.contributors.len() as u32;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.contributors {
            os.write_fixed64(1, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CWorkshop_GetContributors_Response {
        CWorkshop_GetContributors_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "contributors",
                |m: &CWorkshop_GetContributors_Response| { &m.contributors },
                |m: &mut CWorkshop_GetContributors_Response| { &mut m.contributors },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CWorkshop_GetContributors_Response>(
                "CWorkshop_GetContributors_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CWorkshop_GetContributors_Response {
        static instance: ::protobuf::rt::LazyV2<CWorkshop_GetContributors_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CWorkshop_GetContributors_Response::new)
    }
}

impl ::protobuf::Clear for CWorkshop_GetContributors_Response {
    fn clear(&mut self) {
        self.contributors.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CWorkshop_GetContributors_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CWorkshop_GetContributors_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CWorkshop_SetItemPaymentRules_Request {
    // message fields
    appid: ::std::option::Option<u32>,
    gameitemid: ::std::option::Option<u32>,
    pub associated_workshop_files: ::protobuf::RepeatedField<CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule>,
    pub partner_accounts: ::protobuf::RepeatedField<CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CWorkshop_SetItemPaymentRules_Request {
    fn default() -> &'a CWorkshop_SetItemPaymentRules_Request {
        <CWorkshop_SetItemPaymentRules_Request as ::protobuf::Message>::default_instance()
    }
}

impl CWorkshop_SetItemPaymentRules_Request {
    pub fn new() -> CWorkshop_SetItemPaymentRules_Request {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;


    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }
    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional uint32 gameitemid = 2;


    pub fn get_gameitemid(&self) -> u32 {
        self.gameitemid.unwrap_or(0)
    }
    pub fn clear_gameitemid(&mut self) {
        self.gameitemid = ::std::option::Option::None;
    }

    pub fn has_gameitemid(&self) -> bool {
        self.gameitemid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gameitemid(&mut self, v: u32) {
        self.gameitemid = ::std::option::Option::Some(v);
    }

    // repeated .CWorkshop_SetItemPaymentRules_Request.WorkshopItemPaymentRule associated_workshop_files = 3;


    pub fn get_associated_workshop_files(&self) -> &[CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule] {
        &self.associated_workshop_files
    }
    pub fn clear_associated_workshop_files(&mut self) {
        self.associated_workshop_files.clear();
    }

    // Param is passed by value, moved
    pub fn set_associated_workshop_files(&mut self, v: ::protobuf::RepeatedField<CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule>) {
        self.associated_workshop_files = v;
    }

    // Mutable pointer to the field.
    pub fn mut_associated_workshop_files(&mut self) -> &mut ::protobuf::RepeatedField<CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule> {
        &mut self.associated_workshop_files
    }

    // Take field
    pub fn take_associated_workshop_files(&mut self) -> ::protobuf::RepeatedField<CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule> {
        ::std::mem::replace(&mut self.associated_workshop_files, ::protobuf::RepeatedField::new())
    }

    // repeated .CWorkshop_SetItemPaymentRules_Request.PartnerItemPaymentRule partner_accounts = 4;


    pub fn get_partner_accounts(&self) -> &[CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule] {
        &self.partner_accounts
    }
    pub fn clear_partner_accounts(&mut self) {
        self.partner_accounts.clear();
    }

    // Param is passed by value, moved
    pub fn set_partner_accounts(&mut self, v: ::protobuf::RepeatedField<CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule>) {
        self.partner_accounts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_partner_accounts(&mut self) -> &mut ::protobuf::RepeatedField<CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule> {
        &mut self.partner_accounts
    }

    // Take field
    pub fn take_partner_accounts(&mut self) -> ::protobuf::RepeatedField<CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule> {
        ::std::mem::replace(&mut self.partner_accounts, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CWorkshop_SetItemPaymentRules_Request {
    fn is_initialized(&self) -> bool {
        for v in &self.associated_workshop_files {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.partner_accounts {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.appid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.gameitemid = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.associated_workshop_files)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.partner_accounts)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.gameitemid {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.associated_workshop_files {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.partner_accounts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.gameitemid {
            os.write_uint32(2, v)?;
        }
        for v in &self.associated_workshop_files {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.partner_accounts {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CWorkshop_SetItemPaymentRules_Request {
        CWorkshop_SetItemPaymentRules_Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "appid",
                |m: &CWorkshop_SetItemPaymentRules_Request| { &m.appid },
                |m: &mut CWorkshop_SetItemPaymentRules_Request| { &mut m.appid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "gameitemid",
                |m: &CWorkshop_SetItemPaymentRules_Request| { &m.gameitemid },
                |m: &mut CWorkshop_SetItemPaymentRules_Request| { &mut m.gameitemid },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule>>(
                "associated_workshop_files",
                |m: &CWorkshop_SetItemPaymentRules_Request| { &m.associated_workshop_files },
                |m: &mut CWorkshop_SetItemPaymentRules_Request| { &mut m.associated_workshop_files },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule>>(
                "partner_accounts",
                |m: &CWorkshop_SetItemPaymentRules_Request| { &m.partner_accounts },
                |m: &mut CWorkshop_SetItemPaymentRules_Request| { &mut m.partner_accounts },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CWorkshop_SetItemPaymentRules_Request>(
                "CWorkshop_SetItemPaymentRules_Request",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CWorkshop_SetItemPaymentRules_Request {
        static instance: ::protobuf::rt::LazyV2<CWorkshop_SetItemPaymentRules_Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CWorkshop_SetItemPaymentRules_Request::new)
    }
}

impl ::protobuf::Clear for CWorkshop_SetItemPaymentRules_Request {
    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.gameitemid = ::std::option::Option::None;
        self.associated_workshop_files.clear();
        self.partner_accounts.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CWorkshop_SetItemPaymentRules_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CWorkshop_SetItemPaymentRules_Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule {
    // message fields
    workshop_file_id: ::std::option::Option<u64>,
    revenue_percentage: ::std::option::Option<f32>,
    rule_description: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule {
    fn default() -> &'a CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule {
        <CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule as ::protobuf::Message>::default_instance()
    }
}

impl CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule {
    pub fn new() -> CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule {
        ::std::default::Default::default()
    }

    // optional uint64 workshop_file_id = 1;


    pub fn get_workshop_file_id(&self) -> u64 {
        self.workshop_file_id.unwrap_or(0)
    }
    pub fn clear_workshop_file_id(&mut self) {
        self.workshop_file_id = ::std::option::Option::None;
    }

    pub fn has_workshop_file_id(&self) -> bool {
        self.workshop_file_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_workshop_file_id(&mut self, v: u64) {
        self.workshop_file_id = ::std::option::Option::Some(v);
    }

    // optional float revenue_percentage = 2;


    pub fn get_revenue_percentage(&self) -> f32 {
        self.revenue_percentage.unwrap_or(0.)
    }
    pub fn clear_revenue_percentage(&mut self) {
        self.revenue_percentage = ::std::option::Option::None;
    }

    pub fn has_revenue_percentage(&self) -> bool {
        self.revenue_percentage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_revenue_percentage(&mut self, v: f32) {
        self.revenue_percentage = ::std::option::Option::Some(v);
    }

    // optional string rule_description = 3;


    pub fn get_rule_description(&self) -> &str {
        match self.rule_description.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_rule_description(&mut self) {
        self.rule_description.clear();
    }

    pub fn has_rule_description(&self) -> bool {
        self.rule_description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rule_description(&mut self, v: ::std::string::String) {
        self.rule_description = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rule_description(&mut self) -> &mut ::std::string::String {
        if self.rule_description.is_none() {
            self.rule_description.set_default();
        }
        self.rule_description.as_mut().unwrap()
    }

    // Take field
    pub fn take_rule_description(&mut self) -> ::std::string::String {
        self.rule_description.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.workshop_file_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.revenue_percentage = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.rule_description)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.workshop_file_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.revenue_percentage {
            my_size += 5;
        }
        if let Some(ref v) = self.rule_description.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.workshop_file_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.revenue_percentage {
            os.write_float(2, v)?;
        }
        if let Some(ref v) = self.rule_description.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule {
        CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "workshop_file_id",
                |m: &CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule| { &m.workshop_file_id },
                |m: &mut CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule| { &mut m.workshop_file_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "revenue_percentage",
                |m: &CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule| { &m.revenue_percentage },
                |m: &mut CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule| { &mut m.revenue_percentage },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "rule_description",
                |m: &CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule| { &m.rule_description },
                |m: &mut CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule| { &mut m.rule_description },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule>(
                "CWorkshop_SetItemPaymentRules_Request.WorkshopItemPaymentRule",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule {
        static instance: ::protobuf::rt::LazyV2<CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule::new)
    }
}

impl ::protobuf::Clear for CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule {
    fn clear(&mut self) {
        self.workshop_file_id = ::std::option::Option::None;
        self.revenue_percentage = ::std::option::Option::None;
        self.rule_description.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CWorkshop_SetItemPaymentRules_Request_WorkshopItemPaymentRule {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule {
    // message fields
    account_id: ::std::option::Option<u32>,
    revenue_percentage: ::std::option::Option<f32>,
    rule_description: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule {
    fn default() -> &'a CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule {
        <CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule as ::protobuf::Message>::default_instance()
    }
}

impl CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule {
    pub fn new() -> CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;


    pub fn get_account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }
    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional float revenue_percentage = 2;


    pub fn get_revenue_percentage(&self) -> f32 {
        self.revenue_percentage.unwrap_or(0.)
    }
    pub fn clear_revenue_percentage(&mut self) {
        self.revenue_percentage = ::std::option::Option::None;
    }

    pub fn has_revenue_percentage(&self) -> bool {
        self.revenue_percentage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_revenue_percentage(&mut self, v: f32) {
        self.revenue_percentage = ::std::option::Option::Some(v);
    }

    // optional string rule_description = 3;


    pub fn get_rule_description(&self) -> &str {
        match self.rule_description.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_rule_description(&mut self) {
        self.rule_description.clear();
    }

    pub fn has_rule_description(&self) -> bool {
        self.rule_description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rule_description(&mut self, v: ::std::string::String) {
        self.rule_description = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rule_description(&mut self) -> &mut ::std::string::String {
        if self.rule_description.is_none() {
            self.rule_description.set_default();
        }
        self.rule_description.as_mut().unwrap()
    }

    // Take field
    pub fn take_rule_description(&mut self) -> ::std::string::String {
        self.rule_description.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.revenue_percentage = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.rule_description)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.revenue_percentage {
            my_size += 5;
        }
        if let Some(ref v) = self.rule_description.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.revenue_percentage {
            os.write_float(2, v)?;
        }
        if let Some(ref v) = self.rule_description.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule {
        CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "account_id",
                |m: &CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule| { &m.account_id },
                |m: &mut CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule| { &mut m.account_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "revenue_percentage",
                |m: &CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule| { &m.revenue_percentage },
                |m: &mut CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule| { &mut m.revenue_percentage },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "rule_description",
                |m: &CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule| { &m.rule_description },
                |m: &mut CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule| { &mut m.rule_description },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule>(
                "CWorkshop_SetItemPaymentRules_Request.PartnerItemPaymentRule",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule {
        static instance: ::protobuf::rt::LazyV2<CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule::new)
    }
}

impl ::protobuf::Clear for CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule {
    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.revenue_percentage = ::std::option::Option::None;
        self.rule_description.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CWorkshop_SetItemPaymentRules_Request_PartnerItemPaymentRule {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CWorkshop_SetItemPaymentRules_Response {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CWorkshop_SetItemPaymentRules_Response {
    fn default() -> &'a CWorkshop_SetItemPaymentRules_Response {
        <CWorkshop_SetItemPaymentRules_Response as ::protobuf::Message>::default_instance()
    }
}

impl CWorkshop_SetItemPaymentRules_Response {
    pub fn new() -> CWorkshop_SetItemPaymentRules_Response {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CWorkshop_SetItemPaymentRules_Response {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CWorkshop_SetItemPaymentRules_Response {
        CWorkshop_SetItemPaymentRules_Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CWorkshop_SetItemPaymentRules_Response>(
                "CWorkshop_SetItemPaymentRules_Response",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CWorkshop_SetItemPaymentRules_Response {
        static instance: ::protobuf::rt::LazyV2<CWorkshop_SetItemPaymentRules_Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CWorkshop_SetItemPaymentRules_Response::new)
    }
}

impl ::protobuf::Clear for CWorkshop_SetItemPaymentRules_Response {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CWorkshop_SetItemPaymentRules_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CWorkshop_SetItemPaymentRules_Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EGCBaseMsg {
    k_EMsgGCSystemMessage = 4001,
    k_EMsgGCReplicateConVars = 4002,
    k_EMsgGCConVarUpdated = 4003,
    k_EMsgGCServerAvailable = 4506,
    k_EMsgGCClientConnectToServer = 4507,
    k_EMsgGCGameServerInfo = 4508,
    k_EMsgGCError = 4509,
    k_EMsgGCReplay_UploadedToYouTube = 4510,
    k_EMsgGCLANServerAvailable = 4511,
}

impl ::protobuf::ProtobufEnum for EGCBaseMsg {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EGCBaseMsg> {
        match value {
            4001 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCSystemMessage),
            4002 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCReplicateConVars),
            4003 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCConVarUpdated),
            4506 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCServerAvailable),
            4507 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCClientConnectToServer),
            4508 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCGameServerInfo),
            4509 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCError),
            4510 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCReplay_UploadedToYouTube),
            4511 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCLANServerAvailable),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EGCBaseMsg] = &[
            EGCBaseMsg::k_EMsgGCSystemMessage,
            EGCBaseMsg::k_EMsgGCReplicateConVars,
            EGCBaseMsg::k_EMsgGCConVarUpdated,
            EGCBaseMsg::k_EMsgGCServerAvailable,
            EGCBaseMsg::k_EMsgGCClientConnectToServer,
            EGCBaseMsg::k_EMsgGCGameServerInfo,
            EGCBaseMsg::k_EMsgGCError,
            EGCBaseMsg::k_EMsgGCReplay_UploadedToYouTube,
            EGCBaseMsg::k_EMsgGCLANServerAvailable,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<EGCBaseMsg>("EGCBaseMsg", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for EGCBaseMsg {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EGCBaseMsg {
    fn default() -> Self {
        EGCBaseMsg::k_EMsgGCSystemMessage
    }
}

impl ::protobuf::reflect::ProtobufValue for EGCBaseMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EGCBaseProtoObjectTypes {
    k_EProtoObjectPartyInvite = 1001,
    k_EProtoObjectLobbyInvite = 1002,
}

impl ::protobuf::ProtobufEnum for EGCBaseProtoObjectTypes {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EGCBaseProtoObjectTypes> {
        match value {
            1001 => ::std::option::Option::Some(EGCBaseProtoObjectTypes::k_EProtoObjectPartyInvite),
            1002 => ::std::option::Option::Some(EGCBaseProtoObjectTypes::k_EProtoObjectLobbyInvite),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EGCBaseProtoObjectTypes] = &[
            EGCBaseProtoObjectTypes::k_EProtoObjectPartyInvite,
            EGCBaseProtoObjectTypes::k_EProtoObjectLobbyInvite,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<EGCBaseProtoObjectTypes>("EGCBaseProtoObjectTypes", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for EGCBaseProtoObjectTypes {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EGCBaseProtoObjectTypes {
    fn default() -> Self {
        EGCBaseProtoObjectTypes::k_EProtoObjectPartyInvite
    }
}

impl ::protobuf::reflect::ProtobufValue for EGCBaseProtoObjectTypes {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum GCGoodbyeReason {
    GCGoodbyeReason_GC_GOING_DOWN = 1,
    GCGoodbyeReason_NO_SESSION = 2,
}

impl ::protobuf::ProtobufEnum for GCGoodbyeReason {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<GCGoodbyeReason> {
        match value {
            1 => ::std::option::Option::Some(GCGoodbyeReason::GCGoodbyeReason_GC_GOING_DOWN),
            2 => ::std::option::Option::Some(GCGoodbyeReason::GCGoodbyeReason_NO_SESSION),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [GCGoodbyeReason] = &[
            GCGoodbyeReason::GCGoodbyeReason_GC_GOING_DOWN,
            GCGoodbyeReason::GCGoodbyeReason_NO_SESSION,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<GCGoodbyeReason>("GCGoodbyeReason", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for GCGoodbyeReason {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for GCGoodbyeReason {
    fn default() -> Self {
        GCGoodbyeReason::GCGoodbyeReason_GC_GOING_DOWN
    }
}

impl ::protobuf::reflect::ProtobufValue for GCGoodbyeReason {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x15base_gcmessages.proto\x1a\x13steammessages.proto\"\xb5\x01\n\x1dCG\
    CStorePurchaseInit_LineItem\x12\x1e\n\x0bitem_def_id\x18\x01\x20\x01(\rR\
    \titemDefId\x12\x1a\n\x08quantity\x18\x02\x20\x01(\rR\x08quantity\x123\n\
    \x16cost_in_local_currency\x18\x03\x20\x01(\rR\x13costInLocalCurrency\
    \x12#\n\rpurchase_type\x18\x04\x20\x01(\rR\x0cpurchaseType\"\xaa\x01\n\
    \x17CMsgGCStorePurchaseInit\x12\x18\n\x07country\x18\x01\x20\x01(\tR\x07\
    country\x12\x1a\n\x08language\x18\x02\x20\x01(\x05R\x08language\x12\x1a\
    \n\x08currency\x18\x03\x20\x01(\x05R\x08currency\x12=\n\nline_items\x18\
    \x04\x20\x03(\x0b2\x1e.CGCStorePurchaseInit_LineItemR\tlineItems\"P\n\
    \x1fCMsgGCStorePurchaseInitResponse\x12\x16\n\x06result\x18\x01\x20\x01(\
    \x05R\x06result\x12\x15\n\x06txn_id\x18\x02\x20\x01(\x04R\x05txnId\"/\n\
    \x13CMsgSystemBroadcast\x12\x18\n\x07message\x18\x01\x20\x01(\tR\x07mess\
    age\"+\n\x0fCMsgClientHello\x12\x18\n\x07version\x18\x01\x20\x01(\rR\x07\
    version\"+\n\x0fCMsgServerHello\x12\x18\n\x07version\x18\x01\x20\x01(\rR\
    \x07version\"t\n\x11CMsgClientWelcome\x12\x18\n\x07version\x18\x01\x20\
    \x01(\rR\x07version\x12\x1b\n\tgame_data\x18\x02\x20\x01(\x0cR\x08gameDa\
    ta\x12(\n\x10txn_country_code\x18\x03\x20\x01(\tR\x0etxnCountryCode\"j\n\
    \x11CMsgServerWelcome\x12.\n\x13min_allowed_version\x18\x01\x20\x01(\rR\
    \x11minAllowedVersion\x12%\n\x0eactive_version\x18\x02\x20\x01(\rR\racti\
    veVersion\"\\\n\x11CMsgClientGoodbye\x12G\n\x06reason\x18\x01\x20\x01(\
    \x0e2\x10.GCGoodbyeReason:\x1dGCGoodbyeReason_GC_GOING_DOWNR\x06reason\"\
    \\\n\x11CMsgServerGoodbye\x12G\n\x06reason\x18\x01\x20\x01(\x0e2\x10.GCG\
    oodbyeReason:\x1dGCGoodbyeReason_GC_GOING_DOWNR\x06reason\"\x15\n\x13CMs\
    gServerAvailable\"3\n\x16CMsgLANServerAvailable\x12\x19\n\x08lobby_id\
    \x18\x01\x20\x01(\x06R\x07lobbyId\"\xff\x0c\n\x18CSOEconGameAccountClien\
    t\x12=\n\x19additional_backpack_slots\x18\x01\x20\x01(\r:\x010R\x17addit\
    ionalBackpackSlots\x12*\n\rtrial_account\x18\x02\x20\x01(\x08:\x05falseR\
    \x0ctrialAccount\x12I\n\"need_to_choose_most_helpful_friend\x18\x04\x20\
    \x01(\x08R\x1dneedToChooseMostHelpfulFriend\x12&\n\x0fin_coaches_list\
    \x18\x05\x20\x01(\x08R\rinCoachesList\x120\n\x14trade_ban_expiration\x18\
    \x06\x20\x01(\x07R\x12tradeBanExpiration\x12.\n\x13duel_ban_expiration\
    \x18\x07\x20\x01(\x07R\x11duelBanExpiration\x12+\n\x10preview_item_def\
    \x18\x08\x20\x01(\r:\x010R\x0epreviewItemDef\x12,\n\x0ephone_verified\
    \x18\x13\x20\x01(\x08:\x05falseR\rphoneVerified\x12(\n\x10skill_rating_6\
    v6\x18\x14\x20\x01(\rR\x0eskillRating6v6\x12(\n\x10skill_rating_9v9\x18\
    \x15\x20\x01(\rR\x0eskillRating9v9\x124\n\x12competitive_access\x18\x17\
    \x20\x01(\x08:\x05falseR\x11competitiveAccess\x12I\n!matchmaking_ranked_\
    ban_expiration\x18\x12\x20\x01(\rR\x1ematchmakingRankedBanExpiration\x12\
    Z\n*matchmaking_ranked_low_priority_expiration\x18\x18\x20\x01(\rR&match\
    makingRankedLowPriorityExpiration\x12N\n$matchmaking_ranked_ban_last_dur\
    ation\x18\x19\x20\x01(\rR\x20matchmakingRankedBanLastDuration\x12_\n-mat\
    chmaking_ranked_low_priority_last_duration\x18\x1a\x20\x01(\rR(matchmaki\
    ngRankedLowPriorityLastDuration\x12I\n!matchmaking_casual_ban_expiration\
    \x18\x1b\x20\x01(\rR\x1ematchmakingCasualBanExpiration\x12Z\n*matchmakin\
    g_casual_low_priority_expiration\x18\x1c\x20\x01(\rR&matchmakingCasualLo\
    wPriorityExpiration\x12N\n$matchmaking_casual_ban_last_duration\x18\x1d\
    \x20\x01(\rR\x20matchmakingCasualBanLastDuration\x12_\n-matchmaking_casu\
    al_low_priority_last_duration\x18\x1e\x20\x01(\rR(matchmakingCasualLowPr\
    iorityLastDuration\x122\n\x11phone_identifying\x18\x1f\x20\x01(\x08:\x05\
    falseR\x10phoneIdentifying\x12F\n\x1cdisable_party_quest_progress\x18\
    \x20\x20\x01(\x08:\x05falseR\x19disablePartyQuestProgress\x120\n\x14ques\
    t_reward_credits\x18!\x20\x01(\rR\x12questRewardCredits\x12q\n7matchmaki\
    ng_last_casual_excessive_reports_auto_ban_time\x18\"\x20\x01(\rR0matchma\
    kingLastCasualExcessiveReportsAutoBanTime\x12m\n5matchmaking_last_comp_e\
    xcessive_reports_auto_ban_time\x18#\x20\x01(\rR.matchmakingLastCompExces\
    siveReportsAutoBanTime\"\xa0\x01\n\x18CSOItemCriteriaCondition\x12\x0e\n\
    \x02op\x18\x01\x20\x01(\x05R\x02op\x12\x14\n\x05field\x18\x02\x20\x01(\t\
    R\x05field\x12\x1a\n\x08required\x18\x03\x20\x01(\x08R\x08required\x12\
    \x1f\n\x0bfloat_value\x18\x04\x20\x01(\x02R\nfloatValue\x12!\n\x0cstring\
    _value\x18\x05\x20\x01(\tR\x0bstringValue\"\xc0\x03\n\x0fCSOItemCriteria\
    \x12\x1d\n\nitem_level\x18\x01\x20\x01(\rR\titemLevel\x12!\n\x0citem_qua\
    lity\x18\x02\x20\x01(\x05R\x0bitemQuality\x12$\n\x0eitem_level_set\x18\
    \x03\x20\x01(\x08R\x0citemLevelSet\x12(\n\x10item_quality_set\x18\x04\
    \x20\x01(\x08R\x0eitemQualitySet\x12+\n\x11initial_inventory\x18\x05\x20\
    \x01(\rR\x10initialInventory\x12)\n\x10initial_quantity\x18\x06\x20\x01(\
    \rR\x0finitialQuantity\x12.\n\x13ignore_enabled_flag\x18\x08\x20\x01(\
    \x08R\x11ignoreEnabledFlag\x129\n\nconditions\x18\t\x20\x03(\x0b2\x19.CS\
    OItemCriteriaConditionR\nconditions\x12\x1f\n\x0brecent_only\x18\n\x20\
    \x01(\x08R\nrecentOnly\x12\x12\n\x04tags\x18\x0b\x20\x01(\tR\x04tags\x12\
    #\n\requip_regions\x18\x0c\x20\x01(\tR\x0cequipRegions\"\xc0\x05\n\rCSOI\
    temRecipe\x12\x1b\n\tdef_index\x18\x01\x20\x01(\rR\x08defIndex\x12\x12\n\
    \x04name\x18\x02\x20\x01(\tR\x04name\x12\x0f\n\x03n_a\x18\x03\x20\x01(\t\
    R\x02nA\x12\x1f\n\x0bdesc_inputs\x18\x04\x20\x01(\tR\ndescInputs\x12!\n\
    \x0cdesc_outputs\x18\x05\x20\x01(\tR\x0bdescOutputs\x12\x11\n\x04di_a\
    \x18\x06\x20\x01(\tR\x03diA\x12\x11\n\x04di_b\x18\x07\x20\x01(\tR\x03diB\
    \x12\x11\n\x04di_c\x18\x08\x20\x01(\tR\x03diC\x12\x11\n\x04do_a\x18\t\
    \x20\x01(\tR\x03doA\x12\x11\n\x04do_b\x18\n\x20\x01(\tR\x03doB\x12\x11\n\
    \x04do_c\x18\x0b\x20\x01(\tR\x03doC\x125\n\x17requires_all_same_class\
    \x18\x0c\x20\x01(\x08R\x14requiresAllSameClass\x123\n\x16requires_all_sa\
    me_slot\x18\r\x20\x01(\x08R\x13requiresAllSameSlot\x123\n\x16class_usage\
    _for_output\x18\x0e\x20\x01(\x05R\x13classUsageForOutput\x121\n\x15slot_\
    usage_for_output\x18\x0f\x20\x01(\x05R\x12slotUsageForOutput\x12$\n\x0es\
    et_for_output\x18\x10\x20\x01(\x05R\x0csetForOutput\x12B\n\x14input_item\
    s_criteria\x18\x14\x20\x03(\x0b2\x10.CSOItemCriteriaR\x12inputItemsCrite\
    ria\x12D\n\x15output_items_criteria\x18\x15\x20\x03(\x0b2\x10.CSOItemCri\
    teriaR\x13outputItemsCriteria\x123\n\x16input_item_dupe_counts\x18\x16\
    \x20\x03(\rR\x13inputItemDupeCounts\"a\n\x15CMsgDevNewItemRequest\x12\
    \x1a\n\x08receiver\x18\x01\x20\x01(\x06R\x08receiver\x12,\n\x08criteria\
    \x18\x02\x20\x01(\x0b2\x10.CSOItemCriteriaR\x08criteria\"_\n\x1bCMsgDevD\
    ebugRollLootRequest\x12\x1a\n\x08receiver\x18\x01\x20\x01(\x06R\x08recei\
    ver\x12$\n\x0eloot_list_name\x18\x02\x20\x01(\tR\x0clootListName\"\xd2\
    \x01\n\x1fCMsgIncrementKillCountAttribute\x12&\n\x0fkiller_steam_id\x18\
    \x01\x20\x01(\x04R\rkillerSteamId\x12&\n\x0fvictim_steam_id\x18\x02\x20\
    \x01(\x04R\rvictimSteamId\x12\x17\n\x07item_id\x18\x03\x20\x01(\x04R\x06\
    itemId\x12\x1d\n\nevent_type\x18\x04\x20\x01(\rR\teventType\x12'\n\x0fin\
    crement_value\x18\x05\x20\x01(\rR\x0eincrementValue\"`\n(CMsgIncrementKi\
    llCountAttribute_Multiple\x124\n\x04msgs\x18\x01\x20\x03(\x0b2\x20.CMsgI\
    ncrementKillCountAttributeR\x04msgs\"\xa8\x01\n\x1eCMsgTrackUniquePlayer\
    PairEvent\x12&\n\x0fkiller_steam_id\x18\x01\x20\x01(\x04R\rkillerSteamId\
    \x12&\n\x0fvictim_steam_id\x18\x02\x20\x01(\x04R\rvictimSteamId\x12\x17\
    \n\x07item_id\x18\x03\x20\x01(\x04R\x06itemId\x12\x1d\n\nevent_type\x18\
    \x04\x20\x01(\rR\teventType\"\x95\x01\n\x1dCMsgApplyStrangeCountTransfer\
    \x12\x20\n\x0ctool_item_id\x18\x01\x20\x01(\x04R\ntoolItemId\x12'\n\x10i\
    tem_src_item_id\x18\x02\x20\x01(\x04R\ritemSrcItemId\x12)\n\x11item_dest\
    _item_id\x18\x03\x20\x01(\x04R\x0eitemDestItemId\"i\n\x14CMsgApplyStrang\
    ePart\x12/\n\x14strange_part_item_id\x18\x01\x20\x01(\x04R\x11strangePar\
    tItemId\x12\x20\n\x0citem_item_id\x18\x02\x20\x01(\x04R\nitemItemId\"\
    \x9e\x01\n\x1bCMsgApplyStrangeRestriction\x12/\n\x14strange_part_item_id\
    \x18\x01\x20\x01(\x04R\x11strangePartItemId\x12\x20\n\x0citem_item_id\
    \x18\x02\x20\x01(\x04R\nitemItemId\x12,\n\x12strange_attr_index\x18\x03\
    \x20\x01(\rR\x10strangeAttrIndex\"o\n\x14CMsgApplyUpgradeCard\x12/\n\x14\
    upgrade_card_item_id\x18\x01\x20\x01(\x04R\x11upgradeCardItemId\x12&\n\
    \x0fsubject_item_id\x18\x02\x20\x01(\x04R\rsubjectItemId\"j\n\x14CSOEcon\
    ItemAttribute\x12\x1b\n\tdef_index\x18\x01\x20\x01(\rR\x08defIndex\x12\
    \x14\n\x05value\x18\x02\x20\x01(\rR\x05value\x12\x1f\n\x0bvalue_bytes\
    \x18\x03\x20\x01(\x0cR\nvalueBytes\"M\n\x13CSOEconItemEquipped\x12\x1b\n\
    \tnew_class\x18\x01\x20\x01(\rR\x08newClass\x12\x19\n\x08new_slot\x18\
    \x02\x20\x01(\rR\x07newSlot\"\xab\x05\n\x0bCSOEconItem\x12\x0e\n\x02id\
    \x18\x01\x20\x01(\x04R\x02id\x12\x1d\n\naccount_id\x18\x02\x20\x01(\rR\t\
    accountId\x12\x1c\n\tinventory\x18\x03\x20\x01(\rR\tinventory\x12\x1b\n\
    \tdef_index\x18\x04\x20\x01(\rR\x08defIndex\x12\x1a\n\x08quantity\x18\
    \x05\x20\x01(\rR\x08quantity\x12\x14\n\x05level\x18\x06\x20\x01(\rR\x05l\
    evel\x12\x18\n\x07quality\x18\x07\x20\x01(\rR\x07quality\x12\x17\n\x05fl\
    ags\x18\x08\x20\x01(\r:\x010R\x05flags\x12\x16\n\x06origin\x18\t\x20\x01\
    (\rR\x06origin\x12\x1f\n\x0bcustom_name\x18\n\x20\x01(\tR\ncustomName\
    \x12\x1f\n\x0bcustom_desc\x18\x0b\x20\x01(\tR\ncustomDesc\x123\n\tattrib\
    ute\x18\x0c\x20\x03(\x0b2\x15.CSOEconItemAttributeR\tattribute\x121\n\ri\
    nterior_item\x18\r\x20\x01(\x0b2\x0c.CSOEconItemR\x0cinteriorItem\x12\
    \x1c\n\x06in_use\x18\x0e\x20\x01(\x08:\x05falseR\x05inUse\x12\x17\n\x05s\
    tyle\x18\x0f\x20\x01(\r:\x010R\x05style\x12\"\n\x0boriginal_id\x18\x10\
    \x20\x01(\x04:\x010R\noriginalId\x126\n\x17contains_equipped_state\x18\
    \x11\x20\x01(\x08R\x15containsEquippedState\x12;\n\x0eequipped_state\x18\
    \x12\x20\x03(\x0b2\x14.CSOEconItemEquippedR\requippedState\x12;\n\x1acon\
    tains_equipped_state_v2\x18\x13\x20\x01(\x08R\x17containsEquippedStateV2\
    \"n\n\x1bCMsgAdjustItemEquippedState\x12\x17\n\x07item_id\x18\x01\x20\
    \x01(\x04R\x06itemId\x12\x1b\n\tnew_class\x18\x02\x20\x01(\rR\x08newClas\
    s\x12\x19\n\x08new_slot\x18\x03\x20\x01(\rR\x07newSlot\",\n\rCMsgSortIte\
    ms\x12\x1b\n\tsort_type\x18\x01\x20\x01(\rR\x08sortType\"\x87\x01\n\x10C\
    SOEconClaimCode\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\x12\
    \x1b\n\tcode_type\x18\x02\x20\x01(\rR\x08codeType\x12#\n\rtime_acquired\
    \x18\x03\x20\x01(\rR\x0ctimeAcquired\x12\x12\n\x04code\x18\x04\x20\x01(\
    \tR\x04code\"F\n\x14CMsgStoreGetUserData\x12.\n\x13price_sheet_version\
    \x18\x01\x20\x01(\x07R\x11priceSheetVersion\"\xa3\x03\n\x1cCMsgStoreGetU\
    serDataResponse\x12\x16\n\x06result\x18\x01\x20\x01(\x05R\x06result\x12\
    \x1a\n\x08currency\x18\x02\x20\x01(\x05R\x08currency\x12\x18\n\x07countr\
    y\x18\x03\x20\x01(\tR\x07country\x12.\n\x13price_sheet_version\x18\x04\
    \x20\x01(\x07R\x11priceSheetVersion\x12*\n\x0fexperiment_data\x18\x05\
    \x20\x01(\x04:\x010R\x0eexperimentData\x12*\n\x11featured_item_idx\x18\
    \x06\x20\x01(\x05R\x0ffeaturedItemIdx\x128\n\x15show_hat_descriptions\
    \x18\x07\x20\x01(\x08:\x04trueR\x13showHatDescriptions\x12\x1f\n\x0bpric\
    e_sheet\x18\x08\x20\x01(\x0cR\npriceSheet\x12-\n\x11default_item_sort\
    \x18\t\x20\x01(\x05:\x010R\x0fdefaultItemSort\x12#\n\rpopular_items\x18\
    \n\x20\x03(\rR\x0cpopularItems\"\xa9\x01\n\x14CMsgUpdateItemSchema\x12\
    \x1d\n\nitems_game\x18\x01\x20\x01(\x0cR\titemsGame\x12.\n\x13item_schem\
    a_version\x18\x02\x20\x01(\x07R\x11itemSchemaVersion\x12$\n\x0eitems_gam\
    e_url\x18\x03\x20\x01(\tR\x0citemsGameUrl\x12\x1c\n\tsignature\x18\x04\
    \x20\x01(\x0cR\tsignature\",\n\x0bCMsgGCError\x12\x1d\n\nerror_text\x18\
    \x01\x20\x01(\tR\terrorText\"\x1d\n\x1bCMsgRequestInventoryRefresh\";\n\
    \x0fCMsgConVarValue\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\
    \x14\n\x05value\x18\x02\x20\x01(\tR\x05value\"B\n\x14CMsgReplicateConVar\
    s\x12*\n\x07convars\x18\x01\x20\x03(\x0b2\x10.CMsgConVarValueR\x07convar\
    s\"\x97\x02\n\x0bCMsgUseItem\x12\x17\n\x07item_id\x18\x01\x20\x01(\x04R\
    \x06itemId\x12&\n\x0ftarget_steam_id\x18\x02\x20\x01(\x06R\rtargetSteamI\
    d\x125\n\x17gift__potential_targets\x18\x03\x20\x03(\rR\x14giftPotential\
    Targets\x12'\n\x10duel__class_lock\x18\x04\x20\x01(\rR\rduelClassLock\
    \x12,\n\x12initiator_steam_id\x18\x05\x20\x01(\x06R\x10initiatorSteamId\
    \x129\n\x19itempack__ack_immediately\x18\x06\x20\x01(\x08R\x16itempackAc\
    kImmediately\"\x8f\x01\n\x1bCMsgReplayUploadedToYouTube\x12\x1f\n\x0byou\
    tube_url\x18\x01\x20\x01(\tR\nyoutubeUrl\x120\n\x14youtube_account_name\
    \x18\x02\x20\x01(\tR\x12youtubeAccountName\x12\x1d\n\nsession_id\x18\x03\
    \x20\x01(\x04R\tsessionId\"9\n\x17CMsgConsumableExhausted\x12\x1e\n\x0bi\
    tem_def_id\x18\x01\x20\x01(\x05R\titemDefId\"\x8c\x02\n\x14CMsgItemAckno\
    wledged\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\x12\x1c\n\t\
    inventory\x18\x02\x20\x01(\rR\tinventory\x12\x1b\n\tdef_index\x18\x03\
    \x20\x01(\rR\x08defIndex\x12\x18\n\x07quality\x18\x04\x20\x01(\rR\x07qua\
    lity\x12\x16\n\x06rarity\x18\x05\x20\x01(\rR\x06rarity\x12\x16\n\x06orig\
    in\x18\x06\x20\x01(\rR\x06origin\x12\x1d\n\nis_strange\x18\x07\x20\x01(\
    \rR\tisStrange\x12\x1d\n\nis_unusual\x18\x08\x20\x01(\rR\tisUnusual\x12\
    \x12\n\x04wear\x18\t\x20\x01(\x02R\x04wear\"\x85\x01\n\x19CMsgSetPresetI\
    temPosition\x12\x19\n\x08class_id\x18\x01\x20\x01(\rR\x07classId\x12\x1b\
    \n\tpreset_id\x18\x02\x20\x01(\rR\x08presetId\x12\x17\n\x07slot_id\x18\
    \x03\x20\x01(\rR\x06slotId\x12\x17\n\x07item_id\x18\x04\x20\x01(\x04R\
    \x06itemId\"\xa6\x01\n\x14CMsgSetItemPositions\x12I\n\x0eitem_positions\
    \x18\x01\x20\x03(\x0b2\".CMsgSetItemPositions.ItemPositionR\ritemPositio\
    ns\x1aC\n\x0cItemPosition\x12\x17\n\x07item_id\x18\x01\x20\x01(\x04R\x06\
    itemId\x12\x1a\n\x08position\x18\x02\x20\x01(\rR\x08position\"\x97\x01\n\
    \x19CSOEconItemPresetInstance\x12\x1f\n\x08class_id\x18\x02\x20\x01(\rR\
    \x07classIdB\x04\x80\xa6\x1d\x01\x12!\n\tpreset_id\x18\x03\x20\x01(\rR\
    \x08presetIdB\x04\x80\xa6\x1d\x01\x12\x1d\n\x07slot_id\x18\x04\x20\x01(\
    \rR\x06slotIdB\x04\x80\xa6\x1d\x01\x12\x17\n\x07item_id\x18\x05\x20\x01(\
    \x04R\x06itemId\"R\n\x18CMsgSelectPresetForClass\x12\x19\n\x08class_id\
    \x18\x01\x20\x01(\rR\x07classId\x12\x1b\n\tpreset_id\x18\x02\x20\x01(\rR\
    \x08presetId\"~\n\x18CSOClassPresetClientData\x12\x1d\n\naccount_id\x18\
    \x01\x20\x01(\rR\taccountId\x12\x19\n\x08class_id\x18\x02\x20\x01(\rR\
    \x07classId\x12(\n\x10active_preset_id\x18\x03\x20\x01(\rR\x0eactivePres\
    etId\"\x9b\x02\n\x11CMsgGCReportAbuse\x12&\n\x0ftarget_steam_id\x18\x01\
    \x20\x01(\x06R\rtargetSteamId\x12\x20\n\x0bdescription\x18\x04\x20\x01(\
    \tR\x0bdescription\x12\x10\n\x03gid\x18\x05\x20\x01(\x04R\x03gid\x12\x1d\
    \n\nabuse_type\x18\x02\x20\x01(\rR\tabuseType\x12!\n\x0ccontent_type\x18\
    \x03\x20\x01(\rR\x0bcontentType\x121\n\x15target_game_server_ip\x18\x06\
    \x20\x01(\x07R\x12targetGameServerIp\x125\n\x17target_game_server_port\
    \x18\x07\x20\x01(\rR\x14targetGameServerPort\"\x80\x01\n\x19CMsgGCReport\
    AbuseResponse\x12&\n\x0ftarget_steam_id\x18\x01\x20\x01(\x06R\rtargetSte\
    amId\x12\x16\n\x06result\x18\x02\x20\x01(\rR\x06result\x12#\n\rerror_mes\
    sage\x18\x03\x20\x01(\tR\x0cerrorMessage\"\x93\x01\n\x1aCMsgGCNameItemNo\
    tification\x12%\n\x0eplayer_steamid\x18\x01\x20\x01(\x06R\rplayerSteamid\
    \x12$\n\x0eitem_def_index\x18\x02\x20\x01(\rR\x0citemDefIndex\x12(\n\x10\
    item_name_custom\x18\x03\x20\x01(\tR\x0eitemNameCustom\"\xa1\x02\n\x1fCM\
    sgGCClientDisplayNotification\x12M\n#notification_title_localization_key\
    \x18\x01\x20\x01(\tR\x20notificationTitleLocalizationKey\x12K\n\"notific\
    ation_body_localization_key\x18\x02\x20\x01(\tR\x1fnotificationBodyLocal\
    izationKey\x12.\n\x13body_substring_keys\x18\x03\x20\x03(\tR\x11bodySubs\
    tringKeys\x122\n\x15body_substring_values\x18\x04\x20\x03(\tR\x13bodySub\
    stringValues\"@\n\x17CMsgGCShowItemsPickedUp\x12%\n\x0eplayer_steamid\
    \x18\x01\x20\x01(\x06R\rplayerSteamid\"o\n\x17CMsgUpdatePeriodicEvent\
    \x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\x12\x1d\n\nevent_t\
    ype\x18\x02\x20\x01(\rR\teventType\x12\x16\n\x06amount\x18\x03\x20\x01(\
    \rR\x06amount\"\xab\x01\n\x20CMsgGCIncrementKillCountResponse\x120\n\x11\
    killer_account_id\x18\x01\x20\x01(\rR\x0fkillerAccountIdB\x04\x80\xa6\
    \x1d\x01\x12\x1b\n\tnum_kills\x18\x02\x20\x01(\rR\x08numKills\x12\x19\n\
    \x08item_def\x18\x03\x20\x01(\rR\x07itemDef\x12\x1d\n\nlevel_type\x18\
    \x04\x20\x01(\rR\tlevelType\"i\n\x17CMsgGCRemoveStrangePart\x12\x17\n\
    \x07item_id\x18\x01\x20\x01(\x04R\x06itemId\x125\n\x17strange_part_score\
    _type\x18\x02\x20\x01(\rR\x14strangePartScoreType\"[\n\x17CMsgGCRemoveUp\
    gradeCard\x12\x17\n\x07item_id\x18\x01\x20\x01(\x04R\x06itemId\x12'\n\
    \x0fattribute_index\x18\x02\x20\x01(\rR\x0eattributeIndex\"C\n(CMsgGCRem\
    oveCustomizationAttributeSimple\x12\x17\n\x07item_id\x18\x01\x20\x01(\
    \x04R\x06itemId\"3\n\x18CMsgGCResetStrangeScores\x12\x17\n\x07item_id\
    \x18\x01\x20\x01(\x04R\x06itemId\"O\n'CMsgGCItemPreviewItemBoughtNotific\
    ation\x12$\n\x0eitem_def_index\x18\x01\x20\x01(\rR\x0citemDefIndex\"2\n\
    \x19CMsgGCStorePurchaseCancel\x12\x15\n\x06txn_id\x18\x01\x20\x01(\x04R\
    \x05txnId\";\n!CMsgGCStorePurchaseCancelResponse\x12\x16\n\x06result\x18\
    \x01\x20\x01(\rR\x06result\"4\n\x1bCMsgGCStorePurchaseFinalize\x12\x15\n\
    \x06txn_id\x18\x01\x20\x01(\x04R\x05txnId\"X\n#CMsgGCStorePurchaseFinali\
    zeResponse\x12\x16\n\x06result\x18\x01\x20\x01(\rR\x06result\x12\x19\n\
    \x08item_ids\x18\x02\x20\x03(\x04R\x07itemIds\"a\n\x1bCMsgGCBannedWordLi\
    stRequest\x12)\n\x11ban_list_group_id\x18\x01\x20\x01(\rR\x0ebanListGrou\
    pId\x12\x17\n\x07word_id\x18\x02\x20\x01(\rR\x06wordId\"\x9b\x01\n\x11CM\
    sgGCGiftedItems\x12&\n\x0fgifter_steam_id\x18\x01\x20\x01(\x04R\rgifterS\
    teamId\x12*\n\x11was_random_person\x18\x02\x20\x01(\x08R\x0fwasRandomPer\
    son\x122\n\x15recipient_account_ids\x18\x03\x20\x03(\rR\x13recipientAcco\
    untIds\"i\n\x11CMsgGCCollectItem\x12,\n\x12collection_item_id\x18\x01\
    \x20\x01(\x04R\x10collectionItemId\x12&\n\x0fsubject_item_id\x18\x02\x20\
    \x01(\x04R\rsubjectItemId\"D\n\x1dCMsgGCClientMarketDataRequest\x12#\n\r\
    user_currency\x18\x01\x20\x01(\rR\x0cuserCurrency\"\xcb\x01\n\x1bCMsgGCC\
    lientMarketDataEntry\x12$\n\x0eitem_def_index\x18\x01\x20\x01(\rR\x0cite\
    mDefIndex\x12!\n\x0citem_quality\x18\x02\x20\x01(\rR\x0bitemQuality\x12,\
    \n\x12item_sell_listings\x18\x03\x20\x01(\rR\x10itemSellListings\x125\n\
    \x17price_in_local_currency\x18\x04\x20\x01(\rR\x14priceInLocalCurrency\
    \"P\n\x16CMsgGCClientMarketData\x126\n\x07entries\x18\x01\x20\x03(\x0b2\
    \x1c.CMsgGCClientMarketDataEntryR\x07entries\"_\n\x13CMsgApplyToolToItem\
    \x12\x20\n\x0ctool_item_id\x18\x01\x20\x01(\x04R\ntoolItemId\x12&\n\x0fs\
    ubject_item_id\x18\x02\x20\x01(\x04R\rsubjectItemId\"i\n\x17CMsgApplyToo\
    lToBaseItem\x12\x20\n\x0ctool_item_id\x18\x01\x20\x01(\x04R\ntoolItemId\
    \x12,\n\x12baseitem_def_index\x18\x02\x20\x01(\rR\x10baseitemDefIndex\"f\
    \n\x13CMsgRecipeComponent\x12&\n\x0fsubject_item_id\x18\x01\x20\x01(\x04\
    R\rsubjectItemId\x12'\n\x0fattribute_index\x18\x02\x20\x01(\x04R\x0eattr\
    ibuteIndex\"\x92\x01\n!CMsgFulfillDynamicRecipeComponent\x12\x20\n\x0cto\
    ol_item_id\x18\x01\x20\x01(\x04R\ntoolItemId\x12K\n\x16consumption_compo\
    nents\x18\x02\x20\x03(\x0b2\x14.CMsgRecipeComponentR\x15consumptionCompo\
    nents\"R\n\x1fCMsgSetItemEffectVerticalOffset\x12\x17\n\x07item_id\x18\
    \x01\x20\x01(\x04R\x06itemId\x12\x16\n\x06offset\x18\x02\x20\x01(\x02R\
    \x06offset\"S\n\x1dCMsgSetHatEffectUseHeadOrigin\x12\x17\n\x07item_id\
    \x18\x01\x20\x01(\x04R\x06itemId\x12\x19\n\x08use_head\x18\x02\x20\x01(\
    \x08R\x07useHead\"w\n\x1cCMsgDeliverGiftResponseGiver\x12#\n\rresponse_c\
    ode\x18\x01\x20\x01(\rR\x0cresponseCode\x122\n\x15receiver_account_name\
    \x18\x02\x20\x01(\tR\x13receiverAccountName\"j\n\x20CSOEconGameAccountFo\
    rGameServers\x12F\n\x1cdisable_party_quest_progress\x18\x06\x20\x01(\x08\
    :\x05falseR\x19disablePartyQuestProgress\"\xb4\x03\n*CWorkshop_PopulateI\
    temDescriptions_Request\x12\x14\n\x05appid\x18\x01\x20\x01(\rR\x05appid\
    \x12g\n\tlanguages\x18\x02\x20\x03(\x0b2I.CWorkshop_PopulateItemDescript\
    ions_Request.ItemDescriptionsLanguageBlockR\tlanguages\x1ab\n\x15SingleI\
    temDescription\x12\x1e\n\ngameitemid\x18\x01\x20\x01(\rR\ngameitemid\x12\
    )\n\x10item_description\x18\x02\x20\x01(\tR\x0fitemDescription\x1a\xa2\
    \x01\n\x1dItemDescriptionsLanguageBlock\x12\x1a\n\x08language\x18\x01\
    \x20\x01(\tR\x08language\x12e\n\x0cdescriptions\x18\x02\x20\x03(\x0b2A.C\
    Workshop_PopulateItemDescriptions_Request.SingleItemDescriptionR\x0cdesc\
    riptions\"Y\n!CWorkshop_GetContributors_Request\x12\x14\n\x05appid\x18\
    \x01\x20\x01(\rR\x05appid\x12\x1e\n\ngameitemid\x18\x02\x20\x01(\rR\ngam\
    eitemid\"H\n\"CWorkshop_GetContributors_Response\x12\"\n\x0ccontributors\
    \x18\x01\x20\x03(\x06R\x0ccontributors\"\xf7\x04\n%CWorkshop_SetItemPaym\
    entRules_Request\x12\x14\n\x05appid\x18\x01\x20\x01(\rR\x05appid\x12\x1e\
    \n\ngameitemid\x18\x02\x20\x01(\rR\ngameitemid\x12z\n\x19associated_work\
    shop_files\x18\x03\x20\x03(\x0b2>.CWorkshop_SetItemPaymentRules_Request.\
    WorkshopItemPaymentRuleR\x17associatedWorkshopFiles\x12h\n\x10partner_ac\
    counts\x18\x04\x20\x03(\x0b2=.CWorkshop_SetItemPaymentRules_Request.Part\
    nerItemPaymentRuleR\x0fpartnerAccounts\x1a\x9d\x01\n\x17WorkshopItemPaym\
    entRule\x12(\n\x10workshop_file_id\x18\x01\x20\x01(\x04R\x0eworkshopFile\
    Id\x12-\n\x12revenue_percentage\x18\x02\x20\x01(\x02R\x11revenuePercenta\
    ge\x12)\n\x10rule_description\x18\x03\x20\x01(\tR\x0fruleDescription\x1a\
    \x91\x01\n\x16PartnerItemPaymentRule\x12\x1d\n\naccount_id\x18\x01\x20\
    \x01(\rR\taccountId\x12-\n\x12revenue_percentage\x18\x02\x20\x01(\x02R\
    \x11revenuePercentage\x12)\n\x10rule_description\x18\x03\x20\x01(\tR\x0f\
    ruleDescription\"(\n&CWorkshop_SetItemPaymentRules_Response*\x9e\x02\n\n\
    EGCBaseMsg\x12\x1a\n\x15k_EMsgGCSystemMessage\x10\xa1\x1f\x12\x1d\n\x18k\
    _EMsgGCReplicateConVars\x10\xa2\x1f\x12\x1a\n\x15k_EMsgGCConVarUpdated\
    \x10\xa3\x1f\x12\x1c\n\x17k_EMsgGCServerAvailable\x10\x9a#\x12\"\n\x1dk_\
    EMsgGCClientConnectToServer\x10\x9b#\x12\x1b\n\x16k_EMsgGCGameServerInfo\
    \x10\x9c#\x12\x12\n\rk_EMsgGCError\x10\x9d#\x12%\n\x20k_EMsgGCReplay_Upl\
    oadedToYouTube\x10\x9e#\x12\x1f\n\x1ak_EMsgGCLANServerAvailable\x10\x9f#\
    *Y\n\x17EGCBaseProtoObjectTypes\x12\x1e\n\x19k_EProtoObjectPartyInvite\
    \x10\xe9\x07\x12\x1e\n\x19k_EProtoObjectLobbyInvite\x10\xea\x07*T\n\x0fG\
    CGoodbyeReason\x12!\n\x1dGCGoodbyeReason_GC_GOING_DOWN\x10\x01\x12\x1e\n\
    \x1aGCGoodbyeReason_NO_SESSION\x10\x02B\x05H\x01\x80\x01\0J\xaa\xb9\x01\
    \n\x07\x12\x05\0\0\xb0\x04\x01\n\t\n\x02\x03\0\x12\x03\0\x07\x1c\n\x08\n\
    \x01\x08\x12\x03\x02\0\x1c\n\t\n\x02\x08\t\x12\x03\x02\0\x1c\n\x08\n\x01\
    \x08\x12\x03\x03\0#\n\t\n\x02\x08\x10\x12\x03\x03\0#\n\n\n\x02\x05\0\x12\
    \x04\x05\0\x0f\x01\n\n\n\x03\x05\0\x01\x12\x03\x05\x05\x0f\n\x0b\n\x04\
    \x05\0\x02\0\x12\x03\x06\x08%\n\x0c\n\x05\x05\0\x02\0\x01\x12\x03\x06\
    \x08\x1d\n\x0c\n\x05\x05\0\x02\0\x02\x12\x03\x06\x20$\n\x0b\n\x04\x05\0\
    \x02\x01\x12\x03\x07\x08(\n\x0c\n\x05\x05\0\x02\x01\x01\x12\x03\x07\x08\
    \x20\n\x0c\n\x05\x05\0\x02\x01\x02\x12\x03\x07#'\n\x0b\n\x04\x05\0\x02\
    \x02\x12\x03\x08\x08%\n\x0c\n\x05\x05\0\x02\x02\x01\x12\x03\x08\x08\x1d\
    \n\x0c\n\x05\x05\0\x02\x02\x02\x12\x03\x08\x20$\n\x0b\n\x04\x05\0\x02\
    \x03\x12\x03\t\x08'\n\x0c\n\x05\x05\0\x02\x03\x01\x12\x03\t\x08\x1f\n\
    \x0c\n\x05\x05\0\x02\x03\x02\x12\x03\t\"&\n\x0b\n\x04\x05\0\x02\x04\x12\
    \x03\n\x08-\n\x0c\n\x05\x05\0\x02\x04\x01\x12\x03\n\x08%\n\x0c\n\x05\x05\
    \0\x02\x04\x02\x12\x03\n(,\n\x0b\n\x04\x05\0\x02\x05\x12\x03\x0b\x08&\n\
    \x0c\n\x05\x05\0\x02\x05\x01\x12\x03\x0b\x08\x1e\n\x0c\n\x05\x05\0\x02\
    \x05\x02\x12\x03\x0b!%\n\x0b\n\x04\x05\0\x02\x06\x12\x03\x0c\x08\x1d\n\
    \x0c\n\x05\x05\0\x02\x06\x01\x12\x03\x0c\x08\x15\n\x0c\n\x05\x05\0\x02\
    \x06\x02\x12\x03\x0c\x18\x1c\n\x0b\n\x04\x05\0\x02\x07\x12\x03\r\x080\n\
    \x0c\n\x05\x05\0\x02\x07\x01\x12\x03\r\x08(\n\x0c\n\x05\x05\0\x02\x07\
    \x02\x12\x03\r+/\n\x0b\n\x04\x05\0\x02\x08\x12\x03\x0e\x08*\n\x0c\n\x05\
    \x05\0\x02\x08\x01\x12\x03\x0e\x08\"\n\x0c\n\x05\x05\0\x02\x08\x02\x12\
    \x03\x0e%)\n\n\n\x02\x05\x01\x12\x04\x11\0\x14\x01\n\n\n\x03\x05\x01\x01\
    \x12\x03\x11\x05\x1c\n\x0b\n\x04\x05\x01\x02\0\x12\x03\x12\x08)\n\x0c\n\
    \x05\x05\x01\x02\0\x01\x12\x03\x12\x08!\n\x0c\n\x05\x05\x01\x02\0\x02\
    \x12\x03\x12$(\n\x0b\n\x04\x05\x01\x02\x01\x12\x03\x13\x08)\n\x0c\n\x05\
    \x05\x01\x02\x01\x01\x12\x03\x13\x08!\n\x0c\n\x05\x05\x01\x02\x01\x02\
    \x12\x03\x13$(\n\n\n\x02\x05\x02\x12\x04\x16\0\x19\x01\n\n\n\x03\x05\x02\
    \x01\x12\x03\x16\x05\x14\n\x0b\n\x04\x05\x02\x02\0\x12\x03\x17\x08*\n\
    \x0c\n\x05\x05\x02\x02\0\x01\x12\x03\x17\x08%\n\x0c\n\x05\x05\x02\x02\0\
    \x02\x12\x03\x17()\n\x0b\n\x04\x05\x02\x02\x01\x12\x03\x18\x08'\n\x0c\n\
    \x05\x05\x02\x02\x01\x01\x12\x03\x18\x08\"\n\x0c\n\x05\x05\x02\x02\x01\
    \x02\x12\x03\x18%&\n\n\n\x02\x04\0\x12\x04\x1b\0\x20\x01\n\n\n\x03\x04\0\
    \x01\x12\x03\x1b\x08%\n\x0b\n\x04\x04\0\x02\0\x12\x03\x1c\x08(\n\x0c\n\
    \x05\x04\0\x02\0\x04\x12\x03\x1c\x08\x10\n\x0c\n\x05\x04\0\x02\0\x05\x12\
    \x03\x1c\x11\x17\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03\x1c\x18#\n\x0c\n\
    \x05\x04\0\x02\0\x03\x12\x03\x1c&'\n\x0b\n\x04\x04\0\x02\x01\x12\x03\x1d\
    \x08%\n\x0c\n\x05\x04\0\x02\x01\x04\x12\x03\x1d\x08\x10\n\x0c\n\x05\x04\
    \0\x02\x01\x05\x12\x03\x1d\x11\x17\n\x0c\n\x05\x04\0\x02\x01\x01\x12\x03\
    \x1d\x18\x20\n\x0c\n\x05\x04\0\x02\x01\x03\x12\x03\x1d#$\n\x0b\n\x04\x04\
    \0\x02\x02\x12\x03\x1e\x083\n\x0c\n\x05\x04\0\x02\x02\x04\x12\x03\x1e\
    \x08\x10\n\x0c\n\x05\x04\0\x02\x02\x05\x12\x03\x1e\x11\x17\n\x0c\n\x05\
    \x04\0\x02\x02\x01\x12\x03\x1e\x18.\n\x0c\n\x05\x04\0\x02\x02\x03\x12\
    \x03\x1e12\n\x0b\n\x04\x04\0\x02\x03\x12\x03\x1f\x08*\n\x0c\n\x05\x04\0\
    \x02\x03\x04\x12\x03\x1f\x08\x10\n\x0c\n\x05\x04\0\x02\x03\x05\x12\x03\
    \x1f\x11\x17\n\x0c\n\x05\x04\0\x02\x03\x01\x12\x03\x1f\x18%\n\x0c\n\x05\
    \x04\0\x02\x03\x03\x12\x03\x1f()\n\n\n\x02\x04\x01\x12\x04\"\0'\x01\n\n\
    \n\x03\x04\x01\x01\x12\x03\"\x08\x1f\n\x0b\n\x04\x04\x01\x02\0\x12\x03#\
    \x08$\n\x0c\n\x05\x04\x01\x02\0\x04\x12\x03#\x08\x10\n\x0c\n\x05\x04\x01\
    \x02\0\x05\x12\x03#\x11\x17\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03#\x18\
    \x1f\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03#\"#\n\x0b\n\x04\x04\x01\x02\
    \x01\x12\x03$\x08$\n\x0c\n\x05\x04\x01\x02\x01\x04\x12\x03$\x08\x10\n\
    \x0c\n\x05\x04\x01\x02\x01\x05\x12\x03$\x11\x16\n\x0c\n\x05\x04\x01\x02\
    \x01\x01\x12\x03$\x17\x1f\n\x0c\n\x05\x04\x01\x02\x01\x03\x12\x03$\"#\n\
    \x0b\n\x04\x04\x01\x02\x02\x12\x03%\x08$\n\x0c\n\x05\x04\x01\x02\x02\x04\
    \x12\x03%\x08\x10\n\x0c\n\x05\x04\x01\x02\x02\x05\x12\x03%\x11\x16\n\x0c\
    \n\x05\x04\x01\x02\x02\x01\x12\x03%\x17\x1f\n\x0c\n\x05\x04\x01\x02\x02\
    \x03\x12\x03%\"#\n\x0b\n\x04\x04\x01\x02\x03\x12\x03&\x08?\n\x0c\n\x05\
    \x04\x01\x02\x03\x04\x12\x03&\x08\x10\n\x0c\n\x05\x04\x01\x02\x03\x06\
    \x12\x03&\x11/\n\x0c\n\x05\x04\x01\x02\x03\x01\x12\x03&0:\n\x0c\n\x05\
    \x04\x01\x02\x03\x03\x12\x03&=>\n\n\n\x02\x04\x02\x12\x04)\0,\x01\n\n\n\
    \x03\x04\x02\x01\x12\x03)\x08'\n\x0b\n\x04\x04\x02\x02\0\x12\x03*\x08\"\
    \n\x0c\n\x05\x04\x02\x02\0\x04\x12\x03*\x08\x10\n\x0c\n\x05\x04\x02\x02\
    \0\x05\x12\x03*\x11\x16\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x03*\x17\x1d\n\
    \x0c\n\x05\x04\x02\x02\0\x03\x12\x03*\x20!\n\x0b\n\x04\x04\x02\x02\x01\
    \x12\x03+\x08#\n\x0c\n\x05\x04\x02\x02\x01\x04\x12\x03+\x08\x10\n\x0c\n\
    \x05\x04\x02\x02\x01\x05\x12\x03+\x11\x17\n\x0c\n\x05\x04\x02\x02\x01\
    \x01\x12\x03+\x18\x1e\n\x0c\n\x05\x04\x02\x02\x01\x03\x12\x03+!\"\n\n\n\
    \x02\x04\x03\x12\x04.\00\x01\n\n\n\x03\x04\x03\x01\x12\x03.\x08\x1b\n\
    \x0b\n\x04\x04\x03\x02\0\x12\x03/\x08$\n\x0c\n\x05\x04\x03\x02\0\x04\x12\
    \x03/\x08\x10\n\x0c\n\x05\x04\x03\x02\0\x05\x12\x03/\x11\x17\n\x0c\n\x05\
    \x04\x03\x02\0\x01\x12\x03/\x18\x1f\n\x0c\n\x05\x04\x03\x02\0\x03\x12\
    \x03/\"#\n\n\n\x02\x04\x04\x12\x042\04\x01\n\n\n\x03\x04\x04\x01\x12\x03\
    2\x08\x17\n\x0b\n\x04\x04\x04\x02\0\x12\x033\x08$\n\x0c\n\x05\x04\x04\
    \x02\0\x04\x12\x033\x08\x10\n\x0c\n\x05\x04\x04\x02\0\x05\x12\x033\x11\
    \x17\n\x0c\n\x05\x04\x04\x02\0\x01\x12\x033\x18\x1f\n\x0c\n\x05\x04\x04\
    \x02\0\x03\x12\x033\"#\n\n\n\x02\x04\x05\x12\x046\08\x01\n\n\n\x03\x04\
    \x05\x01\x12\x036\x08\x17\n\x0b\n\x04\x04\x05\x02\0\x12\x037\x08$\n\x0c\
    \n\x05\x04\x05\x02\0\x04\x12\x037\x08\x10\n\x0c\n\x05\x04\x05\x02\0\x05\
    \x12\x037\x11\x17\n\x0c\n\x05\x04\x05\x02\0\x01\x12\x037\x18\x1f\n\x0c\n\
    \x05\x04\x05\x02\0\x03\x12\x037\"#\n\n\n\x02\x04\x06\x12\x04:\0>\x01\n\n\
    \n\x03\x04\x06\x01\x12\x03:\x08\x19\n\x0b\n\x04\x04\x06\x02\0\x12\x03;\
    \x08$\n\x0c\n\x05\x04\x06\x02\0\x04\x12\x03;\x08\x10\n\x0c\n\x05\x04\x06\
    \x02\0\x05\x12\x03;\x11\x17\n\x0c\n\x05\x04\x06\x02\0\x01\x12\x03;\x18\
    \x1f\n\x0c\n\x05\x04\x06\x02\0\x03\x12\x03;\"#\n\x0b\n\x04\x04\x06\x02\
    \x01\x12\x03<\x08%\n\x0c\n\x05\x04\x06\x02\x01\x04\x12\x03<\x08\x10\n\
    \x0c\n\x05\x04\x06\x02\x01\x05\x12\x03<\x11\x16\n\x0c\n\x05\x04\x06\x02\
    \x01\x01\x12\x03<\x17\x20\n\x0c\n\x05\x04\x06\x02\x01\x03\x12\x03<#$\n\
    \x0b\n\x04\x04\x06\x02\x02\x12\x03=\x08-\n\x0c\n\x05\x04\x06\x02\x02\x04\
    \x12\x03=\x08\x10\n\x0c\n\x05\x04\x06\x02\x02\x05\x12\x03=\x11\x17\n\x0c\
    \n\x05\x04\x06\x02\x02\x01\x12\x03=\x18(\n\x0c\n\x05\x04\x06\x02\x02\x03\
    \x12\x03=+,\n\n\n\x02\x04\x07\x12\x04@\0C\x01\n\n\n\x03\x04\x07\x01\x12\
    \x03@\x08\x19\n\x0b\n\x04\x04\x07\x02\0\x12\x03A\x080\n\x0c\n\x05\x04\
    \x07\x02\0\x04\x12\x03A\x08\x10\n\x0c\n\x05\x04\x07\x02\0\x05\x12\x03A\
    \x11\x17\n\x0c\n\x05\x04\x07\x02\0\x01\x12\x03A\x18+\n\x0c\n\x05\x04\x07\
    \x02\0\x03\x12\x03A./\n\x0b\n\x04\x04\x07\x02\x01\x12\x03B\x08+\n\x0c\n\
    \x05\x04\x07\x02\x01\x04\x12\x03B\x08\x10\n\x0c\n\x05\x04\x07\x02\x01\
    \x05\x12\x03B\x11\x17\n\x0c\n\x05\x04\x07\x02\x01\x01\x12\x03B\x18&\n\
    \x0c\n\x05\x04\x07\x02\x01\x03\x12\x03B)*\n\n\n\x02\x04\x08\x12\x04E\0G\
    \x01\n\n\n\x03\x04\x08\x01\x12\x03E\x08\x19\n\x0b\n\x04\x04\x08\x02\0\
    \x12\x03F\x08W\n\x0c\n\x05\x04\x08\x02\0\x04\x12\x03F\x08\x10\n\x0c\n\
    \x05\x04\x08\x02\0\x06\x12\x03F\x11!\n\x0c\n\x05\x04\x08\x02\0\x01\x12\
    \x03F\"(\n\x0c\n\x05\x04\x08\x02\0\x03\x12\x03F+,\n\x0c\n\x05\x04\x08\
    \x02\0\x08\x12\x03F-V\n\x0c\n\x05\x04\x08\x02\0\x07\x12\x03F8U\n\n\n\x02\
    \x04\t\x12\x04I\0K\x01\n\n\n\x03\x04\t\x01\x12\x03I\x08\x19\n\x0b\n\x04\
    \x04\t\x02\0\x12\x03J\x08W\n\x0c\n\x05\x04\t\x02\0\x04\x12\x03J\x08\x10\
    \n\x0c\n\x05\x04\t\x02\0\x06\x12\x03J\x11!\n\x0c\n\x05\x04\t\x02\0\x01\
    \x12\x03J\"(\n\x0c\n\x05\x04\t\x02\0\x03\x12\x03J+,\n\x0c\n\x05\x04\t\
    \x02\0\x08\x12\x03J-V\n\x0c\n\x05\x04\t\x02\0\x07\x12\x03J8U\n\n\n\x02\
    \x04\n\x12\x04M\0N\x01\n\n\n\x03\x04\n\x01\x12\x03M\x08\x1b\n\n\n\x02\
    \x04\x0b\x12\x04P\0R\x01\n\n\n\x03\x04\x0b\x01\x12\x03P\x08\x1e\n\x0b\n\
    \x04\x04\x0b\x02\0\x12\x03Q\x08&\n\x0c\n\x05\x04\x0b\x02\0\x04\x12\x03Q\
    \x08\x10\n\x0c\n\x05\x04\x0b\x02\0\x05\x12\x03Q\x11\x18\n\x0c\n\x05\x04\
    \x0b\x02\0\x01\x12\x03Q\x19!\n\x0c\n\x05\x04\x0b\x02\0\x03\x12\x03Q$%\n\
    \n\n\x02\x04\x0c\x12\x04T\0m\x01\n\n\n\x03\x04\x0c\x01\x12\x03T\x08\x20\
    \n\x0b\n\x04\x04\x0c\x02\0\x12\x03U\x08D\n\x0c\n\x05\x04\x0c\x02\0\x04\
    \x12\x03U\x08\x10\n\x0c\n\x05\x04\x0c\x02\0\x05\x12\x03U\x11\x17\n\x0c\n\
    \x05\x04\x0c\x02\0\x01\x12\x03U\x181\n\x0c\n\x05\x04\x0c\x02\0\x03\x12\
    \x03U45\n\x0c\n\x05\x04\x0c\x02\0\x08\x12\x03U6C\n\x0c\n\x05\x04\x0c\x02\
    \0\x07\x12\x03UAB\n\x0b\n\x04\x04\x0c\x02\x01\x12\x03V\x08:\n\x0c\n\x05\
    \x04\x0c\x02\x01\x04\x12\x03V\x08\x10\n\x0c\n\x05\x04\x0c\x02\x01\x05\
    \x12\x03V\x11\x15\n\x0c\n\x05\x04\x0c\x02\x01\x01\x12\x03V\x16#\n\x0c\n\
    \x05\x04\x0c\x02\x01\x03\x12\x03V&'\n\x0c\n\x05\x04\x0c\x02\x01\x08\x12\
    \x03V(9\n\x0c\n\x05\x04\x0c\x02\x01\x07\x12\x03V38\n\x0b\n\x04\x04\x0c\
    \x02\x02\x12\x03W\x08=\n\x0c\n\x05\x04\x0c\x02\x02\x04\x12\x03W\x08\x10\
    \n\x0c\n\x05\x04\x0c\x02\x02\x05\x12\x03W\x11\x15\n\x0c\n\x05\x04\x0c\
    \x02\x02\x01\x12\x03W\x168\n\x0c\n\x05\x04\x0c\x02\x02\x03\x12\x03W;<\n\
    \x0b\n\x04\x04\x0c\x02\x03\x12\x03X\x08*\n\x0c\n\x05\x04\x0c\x02\x03\x04\
    \x12\x03X\x08\x10\n\x0c\n\x05\x04\x0c\x02\x03\x05\x12\x03X\x11\x15\n\x0c\
    \n\x05\x04\x0c\x02\x03\x01\x12\x03X\x16%\n\x0c\n\x05\x04\x0c\x02\x03\x03\
    \x12\x03X()\n\x0b\n\x04\x04\x0c\x02\x04\x12\x03Y\x082\n\x0c\n\x05\x04\
    \x0c\x02\x04\x04\x12\x03Y\x08\x10\n\x0c\n\x05\x04\x0c\x02\x04\x05\x12\
    \x03Y\x11\x18\n\x0c\n\x05\x04\x0c\x02\x04\x01\x12\x03Y\x19-\n\x0c\n\x05\
    \x04\x0c\x02\x04\x03\x12\x03Y01\n\x0b\n\x04\x04\x0c\x02\x05\x12\x03Z\x08\
    1\n\x0c\n\x05\x04\x0c\x02\x05\x04\x12\x03Z\x08\x10\n\x0c\n\x05\x04\x0c\
    \x02\x05\x05\x12\x03Z\x11\x18\n\x0c\n\x05\x04\x0c\x02\x05\x01\x12\x03Z\
    \x19,\n\x0c\n\x05\x04\x0c\x02\x05\x03\x12\x03Z/0\n\x0b\n\x04\x04\x0c\x02\
    \x06\x12\x03[\x08;\n\x0c\n\x05\x04\x0c\x02\x06\x04\x12\x03[\x08\x10\n\
    \x0c\n\x05\x04\x0c\x02\x06\x05\x12\x03[\x11\x17\n\x0c\n\x05\x04\x0c\x02\
    \x06\x01\x12\x03[\x18(\n\x0c\n\x05\x04\x0c\x02\x06\x03\x12\x03[+,\n\x0c\
    \n\x05\x04\x0c\x02\x06\x08\x12\x03[-:\n\x0c\n\x05\x04\x0c\x02\x06\x07\
    \x12\x03[89\n\x0b\n\x04\x04\x0c\x02\x07\x12\x03\\\x08<\n\x0c\n\x05\x04\
    \x0c\x02\x07\x04\x12\x03\\\x08\x10\n\x0c\n\x05\x04\x0c\x02\x07\x05\x12\
    \x03\\\x11\x15\n\x0c\n\x05\x04\x0c\x02\x07\x01\x12\x03\\\x16$\n\x0c\n\
    \x05\x04\x0c\x02\x07\x03\x12\x03\\')\n\x0c\n\x05\x04\x0c\x02\x07\x08\x12\
    \x03\\*;\n\x0c\n\x05\x04\x0c\x02\x07\x07\x12\x03\\5:\n\x0b\n\x04\x04\x0c\
    \x02\x08\x12\x03]\x08.\n\x0c\n\x05\x04\x0c\x02\x08\x04\x12\x03]\x08\x10\
    \n\x0c\n\x05\x04\x0c\x02\x08\x05\x12\x03]\x11\x17\n\x0c\n\x05\x04\x0c\
    \x02\x08\x01\x12\x03]\x18(\n\x0c\n\x05\x04\x0c\x02\x08\x03\x12\x03]+-\n\
    \x0b\n\x04\x04\x0c\x02\t\x12\x03^\x08.\n\x0c\n\x05\x04\x0c\x02\t\x04\x12\
    \x03^\x08\x10\n\x0c\n\x05\x04\x0c\x02\t\x05\x12\x03^\x11\x17\n\x0c\n\x05\
    \x04\x0c\x02\t\x01\x12\x03^\x18(\n\x0c\n\x05\x04\x0c\x02\t\x03\x12\x03^+\
    -\n\x0b\n\x04\x04\x0c\x02\n\x12\x03_\x08@\n\x0c\n\x05\x04\x0c\x02\n\x04\
    \x12\x03_\x08\x10\n\x0c\n\x05\x04\x0c\x02\n\x05\x12\x03_\x11\x15\n\x0c\n\
    \x05\x04\x0c\x02\n\x01\x12\x03_\x16(\n\x0c\n\x05\x04\x0c\x02\n\x03\x12\
    \x03_+-\n\x0c\n\x05\x04\x0c\x02\n\x08\x12\x03_.?\n\x0c\n\x05\x04\x0c\x02\
    \n\x07\x12\x03_9>\n\x0b\n\x04\x04\x0c\x02\x0b\x12\x03`\x08?\n\x0c\n\x05\
    \x04\x0c\x02\x0b\x04\x12\x03`\x08\x10\n\x0c\n\x05\x04\x0c\x02\x0b\x05\
    \x12\x03`\x11\x17\n\x0c\n\x05\x04\x0c\x02\x0b\x01\x12\x03`\x189\n\x0c\n\
    \x05\x04\x0c\x02\x0b\x03\x12\x03`<>\n\x0b\n\x04\x04\x0c\x02\x0c\x12\x03a\
    \x08H\n\x0c\n\x05\x04\x0c\x02\x0c\x04\x12\x03a\x08\x10\n\x0c\n\x05\x04\
    \x0c\x02\x0c\x05\x12\x03a\x11\x17\n\x0c\n\x05\x04\x0c\x02\x0c\x01\x12\
    \x03a\x18B\n\x0c\n\x05\x04\x0c\x02\x0c\x03\x12\x03aEG\n\x0b\n\x04\x04\
    \x0c\x02\r\x12\x03b\x08B\n\x0c\n\x05\x04\x0c\x02\r\x04\x12\x03b\x08\x10\
    \n\x0c\n\x05\x04\x0c\x02\r\x05\x12\x03b\x11\x17\n\x0c\n\x05\x04\x0c\x02\
    \r\x01\x12\x03b\x18<\n\x0c\n\x05\x04\x0c\x02\r\x03\x12\x03b?A\n\x0b\n\
    \x04\x04\x0c\x02\x0e\x12\x03c\x08K\n\x0c\n\x05\x04\x0c\x02\x0e\x04\x12\
    \x03c\x08\x10\n\x0c\n\x05\x04\x0c\x02\x0e\x05\x12\x03c\x11\x17\n\x0c\n\
    \x05\x04\x0c\x02\x0e\x01\x12\x03c\x18E\n\x0c\n\x05\x04\x0c\x02\x0e\x03\
    \x12\x03cHJ\n\x0b\n\x04\x04\x0c\x02\x0f\x12\x03d\x08?\n\x0c\n\x05\x04\
    \x0c\x02\x0f\x04\x12\x03d\x08\x10\n\x0c\n\x05\x04\x0c\x02\x0f\x05\x12\
    \x03d\x11\x17\n\x0c\n\x05\x04\x0c\x02\x0f\x01\x12\x03d\x189\n\x0c\n\x05\
    \x04\x0c\x02\x0f\x03\x12\x03d<>\n\x0b\n\x04\x04\x0c\x02\x10\x12\x03e\x08\
    H\n\x0c\n\x05\x04\x0c\x02\x10\x04\x12\x03e\x08\x10\n\x0c\n\x05\x04\x0c\
    \x02\x10\x05\x12\x03e\x11\x17\n\x0c\n\x05\x04\x0c\x02\x10\x01\x12\x03e\
    \x18B\n\x0c\n\x05\x04\x0c\x02\x10\x03\x12\x03eEG\n\x0b\n\x04\x04\x0c\x02\
    \x11\x12\x03f\x08B\n\x0c\n\x05\x04\x0c\x02\x11\x04\x12\x03f\x08\x10\n\
    \x0c\n\x05\x04\x0c\x02\x11\x05\x12\x03f\x11\x17\n\x0c\n\x05\x04\x0c\x02\
    \x11\x01\x12\x03f\x18<\n\x0c\n\x05\x04\x0c\x02\x11\x03\x12\x03f?A\n\x0b\
    \n\x04\x04\x0c\x02\x12\x12\x03g\x08K\n\x0c\n\x05\x04\x0c\x02\x12\x04\x12\
    \x03g\x08\x10\n\x0c\n\x05\x04\x0c\x02\x12\x05\x12\x03g\x11\x17\n\x0c\n\
    \x05\x04\x0c\x02\x12\x01\x12\x03g\x18E\n\x0c\n\x05\x04\x0c\x02\x12\x03\
    \x12\x03gHJ\n\x0b\n\x04\x04\x0c\x02\x13\x12\x03h\x08?\n\x0c\n\x05\x04\
    \x0c\x02\x13\x04\x12\x03h\x08\x10\n\x0c\n\x05\x04\x0c\x02\x13\x05\x12\
    \x03h\x11\x15\n\x0c\n\x05\x04\x0c\x02\x13\x01\x12\x03h\x16'\n\x0c\n\x05\
    \x04\x0c\x02\x13\x03\x12\x03h*,\n\x0c\n\x05\x04\x0c\x02\x13\x08\x12\x03h\
    ->\n\x0c\n\x05\x04\x0c\x02\x13\x07\x12\x03h8=\n\x0b\n\x04\x04\x0c\x02\
    \x14\x12\x03i\x08J\n\x0c\n\x05\x04\x0c\x02\x14\x04\x12\x03i\x08\x10\n\
    \x0c\n\x05\x04\x0c\x02\x14\x05\x12\x03i\x11\x15\n\x0c\n\x05\x04\x0c\x02\
    \x14\x01\x12\x03i\x162\n\x0c\n\x05\x04\x0c\x02\x14\x03\x12\x03i57\n\x0c\
    \n\x05\x04\x0c\x02\x14\x08\x12\x03i8I\n\x0c\n\x05\x04\x0c\x02\x14\x07\
    \x12\x03iCH\n\x0b\n\x04\x04\x0c\x02\x15\x12\x03j\x082\n\x0c\n\x05\x04\
    \x0c\x02\x15\x04\x12\x03j\x08\x10\n\x0c\n\x05\x04\x0c\x02\x15\x05\x12\
    \x03j\x11\x17\n\x0c\n\x05\x04\x0c\x02\x15\x01\x12\x03j\x18,\n\x0c\n\x05\
    \x04\x0c\x02\x15\x03\x12\x03j/1\n\x0b\n\x04\x04\x0c\x02\x16\x12\x03k\x08\
    U\n\x0c\n\x05\x04\x0c\x02\x16\x04\x12\x03k\x08\x10\n\x0c\n\x05\x04\x0c\
    \x02\x16\x05\x12\x03k\x11\x17\n\x0c\n\x05\x04\x0c\x02\x16\x01\x12\x03k\
    \x18O\n\x0c\n\x05\x04\x0c\x02\x16\x03\x12\x03kRT\n\x0b\n\x04\x04\x0c\x02\
    \x17\x12\x03l\x08S\n\x0c\n\x05\x04\x0c\x02\x17\x04\x12\x03l\x08\x10\n\
    \x0c\n\x05\x04\x0c\x02\x17\x05\x12\x03l\x11\x17\n\x0c\n\x05\x04\x0c\x02\
    \x17\x01\x12\x03l\x18M\n\x0c\n\x05\x04\x0c\x02\x17\x03\x12\x03lPR\n\n\n\
    \x02\x04\r\x12\x04o\0u\x01\n\n\n\x03\x04\r\x01\x12\x03o\x08\x20\n\x0b\n\
    \x04\x04\r\x02\0\x12\x03p\x08\x1e\n\x0c\n\x05\x04\r\x02\0\x04\x12\x03p\
    \x08\x10\n\x0c\n\x05\x04\r\x02\0\x05\x12\x03p\x11\x16\n\x0c\n\x05\x04\r\
    \x02\0\x01\x12\x03p\x17\x19\n\x0c\n\x05\x04\r\x02\0\x03\x12\x03p\x1c\x1d\
    \n\x0b\n\x04\x04\r\x02\x01\x12\x03q\x08\"\n\x0c\n\x05\x04\r\x02\x01\x04\
    \x12\x03q\x08\x10\n\x0c\n\x05\x04\r\x02\x01\x05\x12\x03q\x11\x17\n\x0c\n\
    \x05\x04\r\x02\x01\x01\x12\x03q\x18\x1d\n\x0c\n\x05\x04\r\x02\x01\x03\
    \x12\x03q\x20!\n\x0b\n\x04\x04\r\x02\x02\x12\x03r\x08#\n\x0c\n\x05\x04\r\
    \x02\x02\x04\x12\x03r\x08\x10\n\x0c\n\x05\x04\r\x02\x02\x05\x12\x03r\x11\
    \x15\n\x0c\n\x05\x04\r\x02\x02\x01\x12\x03r\x16\x1e\n\x0c\n\x05\x04\r\
    \x02\x02\x03\x12\x03r!\"\n\x0b\n\x04\x04\r\x02\x03\x12\x03s\x08'\n\x0c\n\
    \x05\x04\r\x02\x03\x04\x12\x03s\x08\x10\n\x0c\n\x05\x04\r\x02\x03\x05\
    \x12\x03s\x11\x16\n\x0c\n\x05\x04\r\x02\x03\x01\x12\x03s\x17\"\n\x0c\n\
    \x05\x04\r\x02\x03\x03\x12\x03s%&\n\x0b\n\x04\x04\r\x02\x04\x12\x03t\x08\
    )\n\x0c\n\x05\x04\r\x02\x04\x04\x12\x03t\x08\x10\n\x0c\n\x05\x04\r\x02\
    \x04\x05\x12\x03t\x11\x17\n\x0c\n\x05\x04\r\x02\x04\x01\x12\x03t\x18$\n\
    \x0c\n\x05\x04\r\x02\x04\x03\x12\x03t'(\n\x0b\n\x02\x04\x0e\x12\x05w\0\
    \x83\x01\x01\n\n\n\x03\x04\x0e\x01\x12\x03w\x08\x17\n\x0b\n\x04\x04\x0e\
    \x02\0\x12\x03x\x08'\n\x0c\n\x05\x04\x0e\x02\0\x04\x12\x03x\x08\x10\n\
    \x0c\n\x05\x04\x0e\x02\0\x05\x12\x03x\x11\x17\n\x0c\n\x05\x04\x0e\x02\0\
    \x01\x12\x03x\x18\"\n\x0c\n\x05\x04\x0e\x02\0\x03\x12\x03x%&\n\x0b\n\x04\
    \x04\x0e\x02\x01\x12\x03y\x08(\n\x0c\n\x05\x04\x0e\x02\x01\x04\x12\x03y\
    \x08\x10\n\x0c\n\x05\x04\x0e\x02\x01\x05\x12\x03y\x11\x16\n\x0c\n\x05\
    \x04\x0e\x02\x01\x01\x12\x03y\x17#\n\x0c\n\x05\x04\x0e\x02\x01\x03\x12\
    \x03y&'\n\x0b\n\x04\x04\x0e\x02\x02\x12\x03z\x08)\n\x0c\n\x05\x04\x0e\
    \x02\x02\x04\x12\x03z\x08\x10\n\x0c\n\x05\x04\x0e\x02\x02\x05\x12\x03z\
    \x11\x15\n\x0c\n\x05\x04\x0e\x02\x02\x01\x12\x03z\x16$\n\x0c\n\x05\x04\
    \x0e\x02\x02\x03\x12\x03z'(\n\x0b\n\x04\x04\x0e\x02\x03\x12\x03{\x08+\n\
    \x0c\n\x05\x04\x0e\x02\x03\x04\x12\x03{\x08\x10\n\x0c\n\x05\x04\x0e\x02\
    \x03\x05\x12\x03{\x11\x15\n\x0c\n\x05\x04\x0e\x02\x03\x01\x12\x03{\x16&\
    \n\x0c\n\x05\x04\x0e\x02\x03\x03\x12\x03{)*\n\x0b\n\x04\x04\x0e\x02\x04\
    \x12\x03|\x08.\n\x0c\n\x05\x04\x0e\x02\x04\x04\x12\x03|\x08\x10\n\x0c\n\
    \x05\x04\x0e\x02\x04\x05\x12\x03|\x11\x17\n\x0c\n\x05\x04\x0e\x02\x04\
    \x01\x12\x03|\x18)\n\x0c\n\x05\x04\x0e\x02\x04\x03\x12\x03|,-\n\x0b\n\
    \x04\x04\x0e\x02\x05\x12\x03}\x08-\n\x0c\n\x05\x04\x0e\x02\x05\x04\x12\
    \x03}\x08\x10\n\x0c\n\x05\x04\x0e\x02\x05\x05\x12\x03}\x11\x17\n\x0c\n\
    \x05\x04\x0e\x02\x05\x01\x12\x03}\x18(\n\x0c\n\x05\x04\x0e\x02\x05\x03\
    \x12\x03}+,\n\x0b\n\x04\x04\x0e\x02\x06\x12\x03~\x08.\n\x0c\n\x05\x04\
    \x0e\x02\x06\x04\x12\x03~\x08\x10\n\x0c\n\x05\x04\x0e\x02\x06\x05\x12\
    \x03~\x11\x15\n\x0c\n\x05\x04\x0e\x02\x06\x01\x12\x03~\x16)\n\x0c\n\x05\
    \x04\x0e\x02\x06\x03\x12\x03~,-\n\x0b\n\x04\x04\x0e\x02\x07\x12\x03\x7f\
    \x08:\n\x0c\n\x05\x04\x0e\x02\x07\x04\x12\x03\x7f\x08\x10\n\x0c\n\x05\
    \x04\x0e\x02\x07\x06\x12\x03\x7f\x11*\n\x0c\n\x05\x04\x0e\x02\x07\x01\
    \x12\x03\x7f+5\n\x0c\n\x05\x04\x0e\x02\x07\x03\x12\x03\x7f89\n\x0c\n\x04\
    \x04\x0e\x02\x08\x12\x04\x80\x01\x08'\n\r\n\x05\x04\x0e\x02\x08\x04\x12\
    \x04\x80\x01\x08\x10\n\r\n\x05\x04\x0e\x02\x08\x05\x12\x04\x80\x01\x11\
    \x15\n\r\n\x05\x04\x0e\x02\x08\x01\x12\x04\x80\x01\x16!\n\r\n\x05\x04\
    \x0e\x02\x08\x03\x12\x04\x80\x01$&\n\x0c\n\x04\x04\x0e\x02\t\x12\x04\x81\
    \x01\x08\"\n\r\n\x05\x04\x0e\x02\t\x04\x12\x04\x81\x01\x08\x10\n\r\n\x05\
    \x04\x0e\x02\t\x05\x12\x04\x81\x01\x11\x17\n\r\n\x05\x04\x0e\x02\t\x01\
    \x12\x04\x81\x01\x18\x1c\n\r\n\x05\x04\x0e\x02\t\x03\x12\x04\x81\x01\x1f\
    !\n\x0c\n\x04\x04\x0e\x02\n\x12\x04\x82\x01\x08+\n\r\n\x05\x04\x0e\x02\n\
    \x04\x12\x04\x82\x01\x08\x10\n\r\n\x05\x04\x0e\x02\n\x05\x12\x04\x82\x01\
    \x11\x17\n\r\n\x05\x04\x0e\x02\n\x01\x12\x04\x82\x01\x18%\n\r\n\x05\x04\
    \x0e\x02\n\x03\x12\x04\x82\x01(*\n\x0c\n\x02\x04\x0f\x12\x06\x85\x01\0\
    \x99\x01\x01\n\x0b\n\x03\x04\x0f\x01\x12\x04\x85\x01\x08\x15\n\x0c\n\x04\
    \x04\x0f\x02\0\x12\x04\x86\x01\x08&\n\r\n\x05\x04\x0f\x02\0\x04\x12\x04\
    \x86\x01\x08\x10\n\r\n\x05\x04\x0f\x02\0\x05\x12\x04\x86\x01\x11\x17\n\r\
    \n\x05\x04\x0f\x02\0\x01\x12\x04\x86\x01\x18!\n\r\n\x05\x04\x0f\x02\0\
    \x03\x12\x04\x86\x01$%\n\x0c\n\x04\x04\x0f\x02\x01\x12\x04\x87\x01\x08!\
    \n\r\n\x05\x04\x0f\x02\x01\x04\x12\x04\x87\x01\x08\x10\n\r\n\x05\x04\x0f\
    \x02\x01\x05\x12\x04\x87\x01\x11\x17\n\r\n\x05\x04\x0f\x02\x01\x01\x12\
    \x04\x87\x01\x18\x1c\n\r\n\x05\x04\x0f\x02\x01\x03\x12\x04\x87\x01\x1f\
    \x20\n\x0c\n\x04\x04\x0f\x02\x02\x12\x04\x88\x01\x08\x20\n\r\n\x05\x04\
    \x0f\x02\x02\x04\x12\x04\x88\x01\x08\x10\n\r\n\x05\x04\x0f\x02\x02\x05\
    \x12\x04\x88\x01\x11\x17\n\r\n\x05\x04\x0f\x02\x02\x01\x12\x04\x88\x01\
    \x18\x1b\n\r\n\x05\x04\x0f\x02\x02\x03\x12\x04\x88\x01\x1e\x1f\n\x0c\n\
    \x04\x04\x0f\x02\x03\x12\x04\x89\x01\x08(\n\r\n\x05\x04\x0f\x02\x03\x04\
    \x12\x04\x89\x01\x08\x10\n\r\n\x05\x04\x0f\x02\x03\x05\x12\x04\x89\x01\
    \x11\x17\n\r\n\x05\x04\x0f\x02\x03\x01\x12\x04\x89\x01\x18#\n\r\n\x05\
    \x04\x0f\x02\x03\x03\x12\x04\x89\x01&'\n\x0c\n\x04\x04\x0f\x02\x04\x12\
    \x04\x8a\x01\x08)\n\r\n\x05\x04\x0f\x02\x04\x04\x12\x04\x8a\x01\x08\x10\
    \n\r\n\x05\x04\x0f\x02\x04\x05\x12\x04\x8a\x01\x11\x17\n\r\n\x05\x04\x0f\
    \x02\x04\x01\x12\x04\x8a\x01\x18$\n\r\n\x05\x04\x0f\x02\x04\x03\x12\x04\
    \x8a\x01'(\n\x0c\n\x04\x04\x0f\x02\x05\x12\x04\x8b\x01\x08!\n\r\n\x05\
    \x04\x0f\x02\x05\x04\x12\x04\x8b\x01\x08\x10\n\r\n\x05\x04\x0f\x02\x05\
    \x05\x12\x04\x8b\x01\x11\x17\n\r\n\x05\x04\x0f\x02\x05\x01\x12\x04\x8b\
    \x01\x18\x1c\n\r\n\x05\x04\x0f\x02\x05\x03\x12\x04\x8b\x01\x1f\x20\n\x0c\
    \n\x04\x04\x0f\x02\x06\x12\x04\x8c\x01\x08!\n\r\n\x05\x04\x0f\x02\x06\
    \x04\x12\x04\x8c\x01\x08\x10\n\r\n\x05\x04\x0f\x02\x06\x05\x12\x04\x8c\
    \x01\x11\x17\n\r\n\x05\x04\x0f\x02\x06\x01\x12\x04\x8c\x01\x18\x1c\n\r\n\
    \x05\x04\x0f\x02\x06\x03\x12\x04\x8c\x01\x1f\x20\n\x0c\n\x04\x04\x0f\x02\
    \x07\x12\x04\x8d\x01\x08!\n\r\n\x05\x04\x0f\x02\x07\x04\x12\x04\x8d\x01\
    \x08\x10\n\r\n\x05\x04\x0f\x02\x07\x05\x12\x04\x8d\x01\x11\x17\n\r\n\x05\
    \x04\x0f\x02\x07\x01\x12\x04\x8d\x01\x18\x1c\n\r\n\x05\x04\x0f\x02\x07\
    \x03\x12\x04\x8d\x01\x1f\x20\n\x0c\n\x04\x04\x0f\x02\x08\x12\x04\x8e\x01\
    \x08!\n\r\n\x05\x04\x0f\x02\x08\x04\x12\x04\x8e\x01\x08\x10\n\r\n\x05\
    \x04\x0f\x02\x08\x05\x12\x04\x8e\x01\x11\x17\n\r\n\x05\x04\x0f\x02\x08\
    \x01\x12\x04\x8e\x01\x18\x1c\n\r\n\x05\x04\x0f\x02\x08\x03\x12\x04\x8e\
    \x01\x1f\x20\n\x0c\n\x04\x04\x0f\x02\t\x12\x04\x8f\x01\x08\"\n\r\n\x05\
    \x04\x0f\x02\t\x04\x12\x04\x8f\x01\x08\x10\n\r\n\x05\x04\x0f\x02\t\x05\
    \x12\x04\x8f\x01\x11\x17\n\r\n\x05\x04\x0f\x02\t\x01\x12\x04\x8f\x01\x18\
    \x1c\n\r\n\x05\x04\x0f\x02\t\x03\x12\x04\x8f\x01\x1f!\n\x0c\n\x04\x04\
    \x0f\x02\n\x12\x04\x90\x01\x08\"\n\r\n\x05\x04\x0f\x02\n\x04\x12\x04\x90\
    \x01\x08\x10\n\r\n\x05\x04\x0f\x02\n\x05\x12\x04\x90\x01\x11\x17\n\r\n\
    \x05\x04\x0f\x02\n\x01\x12\x04\x90\x01\x18\x1c\n\r\n\x05\x04\x0f\x02\n\
    \x03\x12\x04\x90\x01\x1f!\n\x0c\n\x04\x04\x0f\x02\x0b\x12\x04\x91\x01\
    \x083\n\r\n\x05\x04\x0f\x02\x0b\x04\x12\x04\x91\x01\x08\x10\n\r\n\x05\
    \x04\x0f\x02\x0b\x05\x12\x04\x91\x01\x11\x15\n\r\n\x05\x04\x0f\x02\x0b\
    \x01\x12\x04\x91\x01\x16-\n\r\n\x05\x04\x0f\x02\x0b\x03\x12\x04\x91\x010\
    2\n\x0c\n\x04\x04\x0f\x02\x0c\x12\x04\x92\x01\x082\n\r\n\x05\x04\x0f\x02\
    \x0c\x04\x12\x04\x92\x01\x08\x10\n\r\n\x05\x04\x0f\x02\x0c\x05\x12\x04\
    \x92\x01\x11\x15\n\r\n\x05\x04\x0f\x02\x0c\x01\x12\x04\x92\x01\x16,\n\r\
    \n\x05\x04\x0f\x02\x0c\x03\x12\x04\x92\x01/1\n\x0c\n\x04\x04\x0f\x02\r\
    \x12\x04\x93\x01\x083\n\r\n\x05\x04\x0f\x02\r\x04\x12\x04\x93\x01\x08\
    \x10\n\r\n\x05\x04\x0f\x02\r\x05\x12\x04\x93\x01\x11\x16\n\r\n\x05\x04\
    \x0f\x02\r\x01\x12\x04\x93\x01\x17-\n\r\n\x05\x04\x0f\x02\r\x03\x12\x04\
    \x93\x0102\n\x0c\n\x04\x04\x0f\x02\x0e\x12\x04\x94\x01\x082\n\r\n\x05\
    \x04\x0f\x02\x0e\x04\x12\x04\x94\x01\x08\x10\n\r\n\x05\x04\x0f\x02\x0e\
    \x05\x12\x04\x94\x01\x11\x16\n\r\n\x05\x04\x0f\x02\x0e\x01\x12\x04\x94\
    \x01\x17,\n\r\n\x05\x04\x0f\x02\x0e\x03\x12\x04\x94\x01/1\n\x0c\n\x04\
    \x04\x0f\x02\x0f\x12\x04\x95\x01\x08+\n\r\n\x05\x04\x0f\x02\x0f\x04\x12\
    \x04\x95\x01\x08\x10\n\r\n\x05\x04\x0f\x02\x0f\x05\x12\x04\x95\x01\x11\
    \x16\n\r\n\x05\x04\x0f\x02\x0f\x01\x12\x04\x95\x01\x17%\n\r\n\x05\x04\
    \x0f\x02\x0f\x03\x12\x04\x95\x01(*\n\x0c\n\x04\x04\x0f\x02\x10\x12\x04\
    \x96\x01\x08<\n\r\n\x05\x04\x0f\x02\x10\x04\x12\x04\x96\x01\x08\x10\n\r\
    \n\x05\x04\x0f\x02\x10\x06\x12\x04\x96\x01\x11!\n\r\n\x05\x04\x0f\x02\
    \x10\x01\x12\x04\x96\x01\"6\n\r\n\x05\x04\x0f\x02\x10\x03\x12\x04\x96\
    \x019;\n\x0c\n\x04\x04\x0f\x02\x11\x12\x04\x97\x01\x08=\n\r\n\x05\x04\
    \x0f\x02\x11\x04\x12\x04\x97\x01\x08\x10\n\r\n\x05\x04\x0f\x02\x11\x06\
    \x12\x04\x97\x01\x11!\n\r\n\x05\x04\x0f\x02\x11\x01\x12\x04\x97\x01\"7\n\
    \r\n\x05\x04\x0f\x02\x11\x03\x12\x04\x97\x01:<\n\x0c\n\x04\x04\x0f\x02\
    \x12\x12\x04\x98\x01\x084\n\r\n\x05\x04\x0f\x02\x12\x04\x12\x04\x98\x01\
    \x08\x10\n\r\n\x05\x04\x0f\x02\x12\x05\x12\x04\x98\x01\x11\x17\n\r\n\x05\
    \x04\x0f\x02\x12\x01\x12\x04\x98\x01\x18.\n\r\n\x05\x04\x0f\x02\x12\x03\
    \x12\x04\x98\x0113\n\x0c\n\x02\x04\x10\x12\x06\x9b\x01\0\x9e\x01\x01\n\
    \x0b\n\x03\x04\x10\x01\x12\x04\x9b\x01\x08\x1d\n\x0c\n\x04\x04\x10\x02\0\
    \x12\x04\x9c\x01\x08&\n\r\n\x05\x04\x10\x02\0\x04\x12\x04\x9c\x01\x08\
    \x10\n\r\n\x05\x04\x10\x02\0\x05\x12\x04\x9c\x01\x11\x18\n\r\n\x05\x04\
    \x10\x02\0\x01\x12\x04\x9c\x01\x19!\n\r\n\x05\x04\x10\x02\0\x03\x12\x04\
    \x9c\x01$%\n\x0c\n\x04\x04\x10\x02\x01\x12\x04\x9d\x01\x08/\n\r\n\x05\
    \x04\x10\x02\x01\x04\x12\x04\x9d\x01\x08\x10\n\r\n\x05\x04\x10\x02\x01\
    \x06\x12\x04\x9d\x01\x11!\n\r\n\x05\x04\x10\x02\x01\x01\x12\x04\x9d\x01\
    \"*\n\r\n\x05\x04\x10\x02\x01\x03\x12\x04\x9d\x01-.\n\x0c\n\x02\x04\x11\
    \x12\x06\xa0\x01\0\xa3\x01\x01\n\x0b\n\x03\x04\x11\x01\x12\x04\xa0\x01\
    \x08#\n\x0c\n\x04\x04\x11\x02\0\x12\x04\xa1\x01\x08&\n\r\n\x05\x04\x11\
    \x02\0\x04\x12\x04\xa1\x01\x08\x10\n\r\n\x05\x04\x11\x02\0\x05\x12\x04\
    \xa1\x01\x11\x18\n\r\n\x05\x04\x11\x02\0\x01\x12\x04\xa1\x01\x19!\n\r\n\
    \x05\x04\x11\x02\0\x03\x12\x04\xa1\x01$%\n\x0c\n\x04\x04\x11\x02\x01\x12\
    \x04\xa2\x01\x08+\n\r\n\x05\x04\x11\x02\x01\x04\x12\x04\xa2\x01\x08\x10\
    \n\r\n\x05\x04\x11\x02\x01\x05\x12\x04\xa2\x01\x11\x17\n\r\n\x05\x04\x11\
    \x02\x01\x01\x12\x04\xa2\x01\x18&\n\r\n\x05\x04\x11\x02\x01\x03\x12\x04\
    \xa2\x01)*\n\x0c\n\x02\x04\x12\x12\x06\xa5\x01\0\xab\x01\x01\n\x0b\n\x03\
    \x04\x12\x01\x12\x04\xa5\x01\x08'\n\x0c\n\x04\x04\x12\x02\0\x12\x04\xa6\
    \x01\x08,\n\r\n\x05\x04\x12\x02\0\x04\x12\x04\xa6\x01\x08\x10\n\r\n\x05\
    \x04\x12\x02\0\x05\x12\x04\xa6\x01\x11\x17\n\r\n\x05\x04\x12\x02\0\x01\
    \x12\x04\xa6\x01\x18'\n\r\n\x05\x04\x12\x02\0\x03\x12\x04\xa6\x01*+\n\
    \x0c\n\x04\x04\x12\x02\x01\x12\x04\xa7\x01\x08,\n\r\n\x05\x04\x12\x02\
    \x01\x04\x12\x04\xa7\x01\x08\x10\n\r\n\x05\x04\x12\x02\x01\x05\x12\x04\
    \xa7\x01\x11\x17\n\r\n\x05\x04\x12\x02\x01\x01\x12\x04\xa7\x01\x18'\n\r\
    \n\x05\x04\x12\x02\x01\x03\x12\x04\xa7\x01*+\n\x0c\n\x04\x04\x12\x02\x02\
    \x12\x04\xa8\x01\x08$\n\r\n\x05\x04\x12\x02\x02\x04\x12\x04\xa8\x01\x08\
    \x10\n\r\n\x05\x04\x12\x02\x02\x05\x12\x04\xa8\x01\x11\x17\n\r\n\x05\x04\
    \x12\x02\x02\x01\x12\x04\xa8\x01\x18\x1f\n\r\n\x05\x04\x12\x02\x02\x03\
    \x12\x04\xa8\x01\"#\n\x0c\n\x04\x04\x12\x02\x03\x12\x04\xa9\x01\x08'\n\r\
    \n\x05\x04\x12\x02\x03\x04\x12\x04\xa9\x01\x08\x10\n\r\n\x05\x04\x12\x02\
    \x03\x05\x12\x04\xa9\x01\x11\x17\n\r\n\x05\x04\x12\x02\x03\x01\x12\x04\
    \xa9\x01\x18\"\n\r\n\x05\x04\x12\x02\x03\x03\x12\x04\xa9\x01%&\n\x0c\n\
    \x04\x04\x12\x02\x04\x12\x04\xaa\x01\x08,\n\r\n\x05\x04\x12\x02\x04\x04\
    \x12\x04\xaa\x01\x08\x10\n\r\n\x05\x04\x12\x02\x04\x05\x12\x04\xaa\x01\
    \x11\x17\n\r\n\x05\x04\x12\x02\x04\x01\x12\x04\xaa\x01\x18'\n\r\n\x05\
    \x04\x12\x02\x04\x03\x12\x04\xaa\x01*+\n\x0c\n\x02\x04\x13\x12\x06\xad\
    \x01\0\xaf\x01\x01\n\x0b\n\x03\x04\x13\x01\x12\x04\xad\x01\x080\n\x0c\n\
    \x04\x04\x13\x02\0\x12\x04\xae\x01\x08;\n\r\n\x05\x04\x13\x02\0\x04\x12\
    \x04\xae\x01\x08\x10\n\r\n\x05\x04\x13\x02\0\x06\x12\x04\xae\x01\x111\n\
    \r\n\x05\x04\x13\x02\0\x01\x12\x04\xae\x0126\n\r\n\x05\x04\x13\x02\0\x03\
    \x12\x04\xae\x019:\n\x0c\n\x02\x04\x14\x12\x06\xb1\x01\0\xb6\x01\x01\n\
    \x0b\n\x03\x04\x14\x01\x12\x04\xb1\x01\x08&\n\x0c\n\x04\x04\x14\x02\0\
    \x12\x04\xb2\x01\x08,\n\r\n\x05\x04\x14\x02\0\x04\x12\x04\xb2\x01\x08\
    \x10\n\r\n\x05\x04\x14\x02\0\x05\x12\x04\xb2\x01\x11\x17\n\r\n\x05\x04\
    \x14\x02\0\x01\x12\x04\xb2\x01\x18'\n\r\n\x05\x04\x14\x02\0\x03\x12\x04\
    \xb2\x01*+\n\x0c\n\x04\x04\x14\x02\x01\x12\x04\xb3\x01\x08,\n\r\n\x05\
    \x04\x14\x02\x01\x04\x12\x04\xb3\x01\x08\x10\n\r\n\x05\x04\x14\x02\x01\
    \x05\x12\x04\xb3\x01\x11\x17\n\r\n\x05\x04\x14\x02\x01\x01\x12\x04\xb3\
    \x01\x18'\n\r\n\x05\x04\x14\x02\x01\x03\x12\x04\xb3\x01*+\n\x0c\n\x04\
    \x04\x14\x02\x02\x12\x04\xb4\x01\x08$\n\r\n\x05\x04\x14\x02\x02\x04\x12\
    \x04\xb4\x01\x08\x10\n\r\n\x05\x04\x14\x02\x02\x05\x12\x04\xb4\x01\x11\
    \x17\n\r\n\x05\x04\x14\x02\x02\x01\x12\x04\xb4\x01\x18\x1f\n\r\n\x05\x04\
    \x14\x02\x02\x03\x12\x04\xb4\x01\"#\n\x0c\n\x04\x04\x14\x02\x03\x12\x04\
    \xb5\x01\x08'\n\r\n\x05\x04\x14\x02\x03\x04\x12\x04\xb5\x01\x08\x10\n\r\
    \n\x05\x04\x14\x02\x03\x05\x12\x04\xb5\x01\x11\x17\n\r\n\x05\x04\x14\x02\
    \x03\x01\x12\x04\xb5\x01\x18\"\n\r\n\x05\x04\x14\x02\x03\x03\x12\x04\xb5\
    \x01%&\n\x0c\n\x02\x04\x15\x12\x06\xb8\x01\0\xbc\x01\x01\n\x0b\n\x03\x04\
    \x15\x01\x12\x04\xb8\x01\x08%\n\x0c\n\x04\x04\x15\x02\0\x12\x04\xb9\x01\
    \x08)\n\r\n\x05\x04\x15\x02\0\x04\x12\x04\xb9\x01\x08\x10\n\r\n\x05\x04\
    \x15\x02\0\x05\x12\x04\xb9\x01\x11\x17\n\r\n\x05\x04\x15\x02\0\x01\x12\
    \x04\xb9\x01\x18$\n\r\n\x05\x04\x15\x02\0\x03\x12\x04\xb9\x01'(\n\x0c\n\
    \x04\x04\x15\x02\x01\x12\x04\xba\x01\x08-\n\r\n\x05\x04\x15\x02\x01\x04\
    \x12\x04\xba\x01\x08\x10\n\r\n\x05\x04\x15\x02\x01\x05\x12\x04\xba\x01\
    \x11\x17\n\r\n\x05\x04\x15\x02\x01\x01\x12\x04\xba\x01\x18(\n\r\n\x05\
    \x04\x15\x02\x01\x03\x12\x04\xba\x01+,\n\x0c\n\x04\x04\x15\x02\x02\x12\
    \x04\xbb\x01\x08.\n\r\n\x05\x04\x15\x02\x02\x04\x12\x04\xbb\x01\x08\x10\
    \n\r\n\x05\x04\x15\x02\x02\x05\x12\x04\xbb\x01\x11\x17\n\r\n\x05\x04\x15\
    \x02\x02\x01\x12\x04\xbb\x01\x18)\n\r\n\x05\x04\x15\x02\x02\x03\x12\x04\
    \xbb\x01,-\n\x0c\n\x02\x04\x16\x12\x06\xbe\x01\0\xc1\x01\x01\n\x0b\n\x03\
    \x04\x16\x01\x12\x04\xbe\x01\x08\x1c\n\x0c\n\x04\x04\x16\x02\0\x12\x04\
    \xbf\x01\x081\n\r\n\x05\x04\x16\x02\0\x04\x12\x04\xbf\x01\x08\x10\n\r\n\
    \x05\x04\x16\x02\0\x05\x12\x04\xbf\x01\x11\x17\n\r\n\x05\x04\x16\x02\0\
    \x01\x12\x04\xbf\x01\x18,\n\r\n\x05\x04\x16\x02\0\x03\x12\x04\xbf\x01/0\
    \n\x0c\n\x04\x04\x16\x02\x01\x12\x04\xc0\x01\x08)\n\r\n\x05\x04\x16\x02\
    \x01\x04\x12\x04\xc0\x01\x08\x10\n\r\n\x05\x04\x16\x02\x01\x05\x12\x04\
    \xc0\x01\x11\x17\n\r\n\x05\x04\x16\x02\x01\x01\x12\x04\xc0\x01\x18$\n\r\
    \n\x05\x04\x16\x02\x01\x03\x12\x04\xc0\x01'(\n\x0c\n\x02\x04\x17\x12\x06\
    \xc3\x01\0\xc7\x01\x01\n\x0b\n\x03\x04\x17\x01\x12\x04\xc3\x01\x08#\n\
    \x0c\n\x04\x04\x17\x02\0\x12\x04\xc4\x01\x081\n\r\n\x05\x04\x17\x02\0\
    \x04\x12\x04\xc4\x01\x08\x10\n\r\n\x05\x04\x17\x02\0\x05\x12\x04\xc4\x01\
    \x11\x17\n\r\n\x05\x04\x17\x02\0\x01\x12\x04\xc4\x01\x18,\n\r\n\x05\x04\
    \x17\x02\0\x03\x12\x04\xc4\x01/0\n\x0c\n\x04\x04\x17\x02\x01\x12\x04\xc5\
    \x01\x08)\n\r\n\x05\x04\x17\x02\x01\x04\x12\x04\xc5\x01\x08\x10\n\r\n\
    \x05\x04\x17\x02\x01\x05\x12\x04\xc5\x01\x11\x17\n\r\n\x05\x04\x17\x02\
    \x01\x01\x12\x04\xc5\x01\x18$\n\r\n\x05\x04\x17\x02\x01\x03\x12\x04\xc5\
    \x01'(\n\x0c\n\x04\x04\x17\x02\x02\x12\x04\xc6\x01\x08/\n\r\n\x05\x04\
    \x17\x02\x02\x04\x12\x04\xc6\x01\x08\x10\n\r\n\x05\x04\x17\x02\x02\x05\
    \x12\x04\xc6\x01\x11\x17\n\r\n\x05\x04\x17\x02\x02\x01\x12\x04\xc6\x01\
    \x18*\n\r\n\x05\x04\x17\x02\x02\x03\x12\x04\xc6\x01-.\n\x0c\n\x02\x04\
    \x18\x12\x06\xc9\x01\0\xcc\x01\x01\n\x0b\n\x03\x04\x18\x01\x12\x04\xc9\
    \x01\x08\x1c\n\x0c\n\x04\x04\x18\x02\0\x12\x04\xca\x01\x081\n\r\n\x05\
    \x04\x18\x02\0\x04\x12\x04\xca\x01\x08\x10\n\r\n\x05\x04\x18\x02\0\x05\
    \x12\x04\xca\x01\x11\x17\n\r\n\x05\x04\x18\x02\0\x01\x12\x04\xca\x01\x18\
    ,\n\r\n\x05\x04\x18\x02\0\x03\x12\x04\xca\x01/0\n\x0c\n\x04\x04\x18\x02\
    \x01\x12\x04\xcb\x01\x08,\n\r\n\x05\x04\x18\x02\x01\x04\x12\x04\xcb\x01\
    \x08\x10\n\r\n\x05\x04\x18\x02\x01\x05\x12\x04\xcb\x01\x11\x17\n\r\n\x05\
    \x04\x18\x02\x01\x01\x12\x04\xcb\x01\x18'\n\r\n\x05\x04\x18\x02\x01\x03\
    \x12\x04\xcb\x01*+\n\x0c\n\x02\x04\x19\x12\x06\xce\x01\0\xd2\x01\x01\n\
    \x0b\n\x03\x04\x19\x01\x12\x04\xce\x01\x08\x1c\n\x0c\n\x04\x04\x19\x02\0\
    \x12\x04\xcf\x01\x08&\n\r\n\x05\x04\x19\x02\0\x04\x12\x04\xcf\x01\x08\
    \x10\n\r\n\x05\x04\x19\x02\0\x05\x12\x04\xcf\x01\x11\x17\n\r\n\x05\x04\
    \x19\x02\0\x01\x12\x04\xcf\x01\x18!\n\r\n\x05\x04\x19\x02\0\x03\x12\x04\
    \xcf\x01$%\n\x0c\n\x04\x04\x19\x02\x01\x12\x04\xd0\x01\x08\"\n\r\n\x05\
    \x04\x19\x02\x01\x04\x12\x04\xd0\x01\x08\x10\n\r\n\x05\x04\x19\x02\x01\
    \x05\x12\x04\xd0\x01\x11\x17\n\r\n\x05\x04\x19\x02\x01\x01\x12\x04\xd0\
    \x01\x18\x1d\n\r\n\x05\x04\x19\x02\x01\x03\x12\x04\xd0\x01\x20!\n\x0c\n\
    \x04\x04\x19\x02\x02\x12\x04\xd1\x01\x08'\n\r\n\x05\x04\x19\x02\x02\x04\
    \x12\x04\xd1\x01\x08\x10\n\r\n\x05\x04\x19\x02\x02\x05\x12\x04\xd1\x01\
    \x11\x16\n\r\n\x05\x04\x19\x02\x02\x01\x12\x04\xd1\x01\x17\"\n\r\n\x05\
    \x04\x19\x02\x02\x03\x12\x04\xd1\x01%&\n\x0c\n\x02\x04\x1a\x12\x06\xd4\
    \x01\0\xd7\x01\x01\n\x0b\n\x03\x04\x1a\x01\x12\x04\xd4\x01\x08\x1b\n\x0c\
    \n\x04\x04\x1a\x02\0\x12\x04\xd5\x01\x08&\n\r\n\x05\x04\x1a\x02\0\x04\
    \x12\x04\xd5\x01\x08\x10\n\r\n\x05\x04\x1a\x02\0\x05\x12\x04\xd5\x01\x11\
    \x17\n\r\n\x05\x04\x1a\x02\0\x01\x12\x04\xd5\x01\x18!\n\r\n\x05\x04\x1a\
    \x02\0\x03\x12\x04\xd5\x01$%\n\x0c\n\x04\x04\x1a\x02\x01\x12\x04\xd6\x01\
    \x08%\n\r\n\x05\x04\x1a\x02\x01\x04\x12\x04\xd6\x01\x08\x10\n\r\n\x05\
    \x04\x1a\x02\x01\x05\x12\x04\xd6\x01\x11\x17\n\r\n\x05\x04\x1a\x02\x01\
    \x01\x12\x04\xd6\x01\x18\x20\n\r\n\x05\x04\x1a\x02\x01\x03\x12\x04\xd6\
    \x01#$\n\x0c\n\x02\x04\x1b\x12\x06\xd9\x01\0\xed\x01\x01\n\x0b\n\x03\x04\
    \x1b\x01\x12\x04\xd9\x01\x08\x13\n\x0c\n\x04\x04\x1b\x02\0\x12\x04\xda\
    \x01\x08\x1f\n\r\n\x05\x04\x1b\x02\0\x04\x12\x04\xda\x01\x08\x10\n\r\n\
    \x05\x04\x1b\x02\0\x05\x12\x04\xda\x01\x11\x17\n\r\n\x05\x04\x1b\x02\0\
    \x01\x12\x04\xda\x01\x18\x1a\n\r\n\x05\x04\x1b\x02\0\x03\x12\x04\xda\x01\
    \x1d\x1e\n\x0c\n\x04\x04\x1b\x02\x01\x12\x04\xdb\x01\x08'\n\r\n\x05\x04\
    \x1b\x02\x01\x04\x12\x04\xdb\x01\x08\x10\n\r\n\x05\x04\x1b\x02\x01\x05\
    \x12\x04\xdb\x01\x11\x17\n\r\n\x05\x04\x1b\x02\x01\x01\x12\x04\xdb\x01\
    \x18\"\n\r\n\x05\x04\x1b\x02\x01\x03\x12\x04\xdb\x01%&\n\x0c\n\x04\x04\
    \x1b\x02\x02\x12\x04\xdc\x01\x08&\n\r\n\x05\x04\x1b\x02\x02\x04\x12\x04\
    \xdc\x01\x08\x10\n\r\n\x05\x04\x1b\x02\x02\x05\x12\x04\xdc\x01\x11\x17\n\
    \r\n\x05\x04\x1b\x02\x02\x01\x12\x04\xdc\x01\x18!\n\r\n\x05\x04\x1b\x02\
    \x02\x03\x12\x04\xdc\x01$%\n\x0c\n\x04\x04\x1b\x02\x03\x12\x04\xdd\x01\
    \x08&\n\r\n\x05\x04\x1b\x02\x03\x04\x12\x04\xdd\x01\x08\x10\n\r\n\x05\
    \x04\x1b\x02\x03\x05\x12\x04\xdd\x01\x11\x17\n\r\n\x05\x04\x1b\x02\x03\
    \x01\x12\x04\xdd\x01\x18!\n\r\n\x05\x04\x1b\x02\x03\x03\x12\x04\xdd\x01$\
    %\n\x0c\n\x04\x04\x1b\x02\x04\x12\x04\xde\x01\x08%\n\r\n\x05\x04\x1b\x02\
    \x04\x04\x12\x04\xde\x01\x08\x10\n\r\n\x05\x04\x1b\x02\x04\x05\x12\x04\
    \xde\x01\x11\x17\n\r\n\x05\x04\x1b\x02\x04\x01\x12\x04\xde\x01\x18\x20\n\
    \r\n\x05\x04\x1b\x02\x04\x03\x12\x04\xde\x01#$\n\x0c\n\x04\x04\x1b\x02\
    \x05\x12\x04\xdf\x01\x08\"\n\r\n\x05\x04\x1b\x02\x05\x04\x12\x04\xdf\x01\
    \x08\x10\n\r\n\x05\x04\x1b\x02\x05\x05\x12\x04\xdf\x01\x11\x17\n\r\n\x05\
    \x04\x1b\x02\x05\x01\x12\x04\xdf\x01\x18\x1d\n\r\n\x05\x04\x1b\x02\x05\
    \x03\x12\x04\xdf\x01\x20!\n\x0c\n\x04\x04\x1b\x02\x06\x12\x04\xe0\x01\
    \x08$\n\r\n\x05\x04\x1b\x02\x06\x04\x12\x04\xe0\x01\x08\x10\n\r\n\x05\
    \x04\x1b\x02\x06\x05\x12\x04\xe0\x01\x11\x17\n\r\n\x05\x04\x1b\x02\x06\
    \x01\x12\x04\xe0\x01\x18\x1f\n\r\n\x05\x04\x1b\x02\x06\x03\x12\x04\xe0\
    \x01\"#\n\x0c\n\x04\x04\x1b\x02\x07\x12\x04\xe1\x01\x080\n\r\n\x05\x04\
    \x1b\x02\x07\x04\x12\x04\xe1\x01\x08\x10\n\r\n\x05\x04\x1b\x02\x07\x05\
    \x12\x04\xe1\x01\x11\x17\n\r\n\x05\x04\x1b\x02\x07\x01\x12\x04\xe1\x01\
    \x18\x1d\n\r\n\x05\x04\x1b\x02\x07\x03\x12\x04\xe1\x01\x20!\n\r\n\x05\
    \x04\x1b\x02\x07\x08\x12\x04\xe1\x01\"/\n\r\n\x05\x04\x1b\x02\x07\x07\
    \x12\x04\xe1\x01-.\n\x0c\n\x04\x04\x1b\x02\x08\x12\x04\xe2\x01\x08#\n\r\
    \n\x05\x04\x1b\x02\x08\x04\x12\x04\xe2\x01\x08\x10\n\r\n\x05\x04\x1b\x02\
    \x08\x05\x12\x04\xe2\x01\x11\x17\n\r\n\x05\x04\x1b\x02\x08\x01\x12\x04\
    \xe2\x01\x18\x1e\n\r\n\x05\x04\x1b\x02\x08\x03\x12\x04\xe2\x01!\"\n\x0c\
    \n\x04\x04\x1b\x02\t\x12\x04\xe3\x01\x08)\n\r\n\x05\x04\x1b\x02\t\x04\
    \x12\x04\xe3\x01\x08\x10\n\r\n\x05\x04\x1b\x02\t\x05\x12\x04\xe3\x01\x11\
    \x17\n\r\n\x05\x04\x1b\x02\t\x01\x12\x04\xe3\x01\x18#\n\r\n\x05\x04\x1b\
    \x02\t\x03\x12\x04\xe3\x01&(\n\x0c\n\x04\x04\x1b\x02\n\x12\x04\xe4\x01\
    \x08)\n\r\n\x05\x04\x1b\x02\n\x04\x12\x04\xe4\x01\x08\x10\n\r\n\x05\x04\
    \x1b\x02\n\x05\x12\x04\xe4\x01\x11\x17\n\r\n\x05\x04\x1b\x02\n\x01\x12\
    \x04\xe4\x01\x18#\n\r\n\x05\x04\x1b\x02\n\x03\x12\x04\xe4\x01&(\n\x0c\n\
    \x04\x04\x1b\x02\x0b\x12\x04\xe5\x01\x086\n\r\n\x05\x04\x1b\x02\x0b\x04\
    \x12\x04\xe5\x01\x08\x10\n\r\n\x05\x04\x1b\x02\x0b\x06\x12\x04\xe5\x01\
    \x11&\n\r\n\x05\x04\x1b\x02\x0b\x01\x12\x04\xe5\x01'0\n\r\n\x05\x04\x1b\
    \x02\x0b\x03\x12\x04\xe5\x0135\n\x0c\n\x04\x04\x1b\x02\x0c\x12\x04\xe6\
    \x01\x081\n\r\n\x05\x04\x1b\x02\x0c\x04\x12\x04\xe6\x01\x08\x10\n\r\n\
    \x05\x04\x1b\x02\x0c\x06\x12\x04\xe6\x01\x11\x1d\n\r\n\x05\x04\x1b\x02\
    \x0c\x01\x12\x04\xe6\x01\x1e+\n\r\n\x05\x04\x1b\x02\x0c\x03\x12\x04\xe6\
    \x01.0\n\x0c\n\x04\x04\x1b\x02\r\x12\x04\xe7\x01\x084\n\r\n\x05\x04\x1b\
    \x02\r\x04\x12\x04\xe7\x01\x08\x10\n\r\n\x05\x04\x1b\x02\r\x05\x12\x04\
    \xe7\x01\x11\x15\n\r\n\x05\x04\x1b\x02\r\x01\x12\x04\xe7\x01\x16\x1c\n\r\
    \n\x05\x04\x1b\x02\r\x03\x12\x04\xe7\x01\x1f!\n\r\n\x05\x04\x1b\x02\r\
    \x08\x12\x04\xe7\x01\"3\n\r\n\x05\x04\x1b\x02\r\x07\x12\x04\xe7\x01-2\n\
    \x0c\n\x04\x04\x1b\x02\x0e\x12\x04\xe8\x01\x081\n\r\n\x05\x04\x1b\x02\
    \x0e\x04\x12\x04\xe8\x01\x08\x10\n\r\n\x05\x04\x1b\x02\x0e\x05\x12\x04\
    \xe8\x01\x11\x17\n\r\n\x05\x04\x1b\x02\x0e\x01\x12\x04\xe8\x01\x18\x1d\n\
    \r\n\x05\x04\x1b\x02\x0e\x03\x12\x04\xe8\x01\x20\"\n\r\n\x05\x04\x1b\x02\
    \x0e\x08\x12\x04\xe8\x01#0\n\r\n\x05\x04\x1b\x02\x0e\x07\x12\x04\xe8\x01\
    ./\n\x0c\n\x04\x04\x1b\x02\x0f\x12\x04\xe9\x01\x087\n\r\n\x05\x04\x1b\
    \x02\x0f\x04\x12\x04\xe9\x01\x08\x10\n\r\n\x05\x04\x1b\x02\x0f\x05\x12\
    \x04\xe9\x01\x11\x17\n\r\n\x05\x04\x1b\x02\x0f\x01\x12\x04\xe9\x01\x18#\
    \n\r\n\x05\x04\x1b\x02\x0f\x03\x12\x04\xe9\x01&(\n\r\n\x05\x04\x1b\x02\
    \x0f\x08\x12\x04\xe9\x01)6\n\r\n\x05\x04\x1b\x02\x0f\x07\x12\x04\xe9\x01\
    45\n\x0c\n\x04\x04\x1b\x02\x10\x12\x04\xea\x01\x083\n\r\n\x05\x04\x1b\
    \x02\x10\x04\x12\x04\xea\x01\x08\x10\n\r\n\x05\x04\x1b\x02\x10\x05\x12\
    \x04\xea\x01\x11\x15\n\r\n\x05\x04\x1b\x02\x10\x01\x12\x04\xea\x01\x16-\
    \n\r\n\x05\x04\x1b\x02\x10\x03\x12\x04\xea\x0102\n\x0c\n\x04\x04\x1b\x02\
    \x11\x12\x04\xeb\x01\x08:\n\r\n\x05\x04\x1b\x02\x11\x04\x12\x04\xeb\x01\
    \x08\x10\n\r\n\x05\x04\x1b\x02\x11\x06\x12\x04\xeb\x01\x11%\n\r\n\x05\
    \x04\x1b\x02\x11\x01\x12\x04\xeb\x01&4\n\r\n\x05\x04\x1b\x02\x11\x03\x12\
    \x04\xeb\x0179\n\x0c\n\x04\x04\x1b\x02\x12\x12\x04\xec\x01\x086\n\r\n\
    \x05\x04\x1b\x02\x12\x04\x12\x04\xec\x01\x08\x10\n\r\n\x05\x04\x1b\x02\
    \x12\x05\x12\x04\xec\x01\x11\x15\n\r\n\x05\x04\x1b\x02\x12\x01\x12\x04\
    \xec\x01\x160\n\r\n\x05\x04\x1b\x02\x12\x03\x12\x04\xec\x0135\n\x0c\n\
    \x02\x04\x1c\x12\x06\xef\x01\0\xf3\x01\x01\n\x0b\n\x03\x04\x1c\x01\x12\
    \x04\xef\x01\x08#\n\x0c\n\x04\x04\x1c\x02\0\x12\x04\xf0\x01\x08$\n\r\n\
    \x05\x04\x1c\x02\0\x04\x12\x04\xf0\x01\x08\x10\n\r\n\x05\x04\x1c\x02\0\
    \x05\x12\x04\xf0\x01\x11\x17\n\r\n\x05\x04\x1c\x02\0\x01\x12\x04\xf0\x01\
    \x18\x1f\n\r\n\x05\x04\x1c\x02\0\x03\x12\x04\xf0\x01\"#\n\x0c\n\x04\x04\
    \x1c\x02\x01\x12\x04\xf1\x01\x08&\n\r\n\x05\x04\x1c\x02\x01\x04\x12\x04\
    \xf1\x01\x08\x10\n\r\n\x05\x04\x1c\x02\x01\x05\x12\x04\xf1\x01\x11\x17\n\
    \r\n\x05\x04\x1c\x02\x01\x01\x12\x04\xf1\x01\x18!\n\r\n\x05\x04\x1c\x02\
    \x01\x03\x12\x04\xf1\x01$%\n\x0c\n\x04\x04\x1c\x02\x02\x12\x04\xf2\x01\
    \x08%\n\r\n\x05\x04\x1c\x02\x02\x04\x12\x04\xf2\x01\x08\x10\n\r\n\x05\
    \x04\x1c\x02\x02\x05\x12\x04\xf2\x01\x11\x17\n\r\n\x05\x04\x1c\x02\x02\
    \x01\x12\x04\xf2\x01\x18\x20\n\r\n\x05\x04\x1c\x02\x02\x03\x12\x04\xf2\
    \x01#$\n\x0c\n\x02\x04\x1d\x12\x06\xf5\x01\0\xf7\x01\x01\n\x0b\n\x03\x04\
    \x1d\x01\x12\x04\xf5\x01\x08\x15\n\x0c\n\x04\x04\x1d\x02\0\x12\x04\xf6\
    \x01\x08&\n\r\n\x05\x04\x1d\x02\0\x04\x12\x04\xf6\x01\x08\x10\n\r\n\x05\
    \x04\x1d\x02\0\x05\x12\x04\xf6\x01\x11\x17\n\r\n\x05\x04\x1d\x02\0\x01\
    \x12\x04\xf6\x01\x18!\n\r\n\x05\x04\x1d\x02\0\x03\x12\x04\xf6\x01$%\n\
    \x0c\n\x02\x04\x1e\x12\x06\xf9\x01\0\xfe\x01\x01\n\x0b\n\x03\x04\x1e\x01\
    \x12\x04\xf9\x01\x08\x18\n\x0c\n\x04\x04\x1e\x02\0\x12\x04\xfa\x01\x08'\
    \n\r\n\x05\x04\x1e\x02\0\x04\x12\x04\xfa\x01\x08\x10\n\r\n\x05\x04\x1e\
    \x02\0\x05\x12\x04\xfa\x01\x11\x17\n\r\n\x05\x04\x1e\x02\0\x01\x12\x04\
    \xfa\x01\x18\"\n\r\n\x05\x04\x1e\x02\0\x03\x12\x04\xfa\x01%&\n\x0c\n\x04\
    \x04\x1e\x02\x01\x12\x04\xfb\x01\x08&\n\r\n\x05\x04\x1e\x02\x01\x04\x12\
    \x04\xfb\x01\x08\x10\n\r\n\x05\x04\x1e\x02\x01\x05\x12\x04\xfb\x01\x11\
    \x17\n\r\n\x05\x04\x1e\x02\x01\x01\x12\x04\xfb\x01\x18!\n\r\n\x05\x04\
    \x1e\x02\x01\x03\x12\x04\xfb\x01$%\n\x0c\n\x04\x04\x1e\x02\x02\x12\x04\
    \xfc\x01\x08*\n\r\n\x05\x04\x1e\x02\x02\x04\x12\x04\xfc\x01\x08\x10\n\r\
    \n\x05\x04\x1e\x02\x02\x05\x12\x04\xfc\x01\x11\x17\n\r\n\x05\x04\x1e\x02\
    \x02\x01\x12\x04\xfc\x01\x18%\n\r\n\x05\x04\x1e\x02\x02\x03\x12\x04\xfc\
    \x01()\n\x0c\n\x04\x04\x1e\x02\x03\x12\x04\xfd\x01\x08!\n\r\n\x05\x04\
    \x1e\x02\x03\x04\x12\x04\xfd\x01\x08\x10\n\r\n\x05\x04\x1e\x02\x03\x05\
    \x12\x04\xfd\x01\x11\x17\n\r\n\x05\x04\x1e\x02\x03\x01\x12\x04\xfd\x01\
    \x18\x1c\n\r\n\x05\x04\x1e\x02\x03\x03\x12\x04\xfd\x01\x1f\x20\n\x0c\n\
    \x02\x04\x1f\x12\x06\x80\x02\0\x82\x02\x01\n\x0b\n\x03\x04\x1f\x01\x12\
    \x04\x80\x02\x08\x1c\n\x0c\n\x04\x04\x1f\x02\0\x12\x04\x81\x02\x081\n\r\
    \n\x05\x04\x1f\x02\0\x04\x12\x04\x81\x02\x08\x10\n\r\n\x05\x04\x1f\x02\0\
    \x05\x12\x04\x81\x02\x11\x18\n\r\n\x05\x04\x1f\x02\0\x01\x12\x04\x81\x02\
    \x19,\n\r\n\x05\x04\x1f\x02\0\x03\x12\x04\x81\x02/0\n\x0c\n\x02\x04\x20\
    \x12\x06\x84\x02\0\x8f\x02\x01\n\x0b\n\x03\x04\x20\x01\x12\x04\x84\x02\
    \x08$\n\x0c\n\x04\x04\x20\x02\0\x12\x04\x85\x02\x08\"\n\r\n\x05\x04\x20\
    \x02\0\x04\x12\x04\x85\x02\x08\x10\n\r\n\x05\x04\x20\x02\0\x05\x12\x04\
    \x85\x02\x11\x16\n\r\n\x05\x04\x20\x02\0\x01\x12\x04\x85\x02\x17\x1d\n\r\
    \n\x05\x04\x20\x02\0\x03\x12\x04\x85\x02\x20!\n\x0c\n\x04\x04\x20\x02\
    \x01\x12\x04\x86\x02\x08$\n\r\n\x05\x04\x20\x02\x01\x04\x12\x04\x86\x02\
    \x08\x10\n\r\n\x05\x04\x20\x02\x01\x05\x12\x04\x86\x02\x11\x16\n\r\n\x05\
    \x04\x20\x02\x01\x01\x12\x04\x86\x02\x17\x1f\n\r\n\x05\x04\x20\x02\x01\
    \x03\x12\x04\x86\x02\"#\n\x0c\n\x04\x04\x20\x02\x02\x12\x04\x87\x02\x08$\
    \n\r\n\x05\x04\x20\x02\x02\x04\x12\x04\x87\x02\x08\x10\n\r\n\x05\x04\x20\
    \x02\x02\x05\x12\x04\x87\x02\x11\x17\n\r\n\x05\x04\x20\x02\x02\x01\x12\
    \x04\x87\x02\x18\x1f\n\r\n\x05\x04\x20\x02\x02\x03\x12\x04\x87\x02\"#\n\
    \x0c\n\x04\x04\x20\x02\x03\x12\x04\x88\x02\x081\n\r\n\x05\x04\x20\x02\
    \x03\x04\x12\x04\x88\x02\x08\x10\n\r\n\x05\x04\x20\x02\x03\x05\x12\x04\
    \x88\x02\x11\x18\n\r\n\x05\x04\x20\x02\x03\x01\x12\x04\x88\x02\x19,\n\r\
    \n\x05\x04\x20\x02\x03\x03\x12\x04\x88\x02/0\n\x0c\n\x04\x04\x20\x02\x04\
    \x12\x04\x89\x02\x08:\n\r\n\x05\x04\x20\x02\x04\x04\x12\x04\x89\x02\x08\
    \x10\n\r\n\x05\x04\x20\x02\x04\x05\x12\x04\x89\x02\x11\x17\n\r\n\x05\x04\
    \x20\x02\x04\x01\x12\x04\x89\x02\x18'\n\r\n\x05\x04\x20\x02\x04\x03\x12\
    \x04\x89\x02*+\n\r\n\x05\x04\x20\x02\x04\x08\x12\x04\x89\x02,9\n\r\n\x05\
    \x04\x20\x02\x04\x07\x12\x04\x89\x0278\n\x0c\n\x04\x04\x20\x02\x05\x12\
    \x04\x8a\x02\x08-\n\r\n\x05\x04\x20\x02\x05\x04\x12\x04\x8a\x02\x08\x10\
    \n\r\n\x05\x04\x20\x02\x05\x05\x12\x04\x8a\x02\x11\x16\n\r\n\x05\x04\x20\
    \x02\x05\x01\x12\x04\x8a\x02\x17(\n\r\n\x05\x04\x20\x02\x05\x03\x12\x04\
    \x8a\x02+,\n\x0c\n\x04\x04\x20\x02\x06\x12\x04\x8b\x02\x08A\n\r\n\x05\
    \x04\x20\x02\x06\x04\x12\x04\x8b\x02\x08\x10\n\r\n\x05\x04\x20\x02\x06\
    \x05\x12\x04\x8b\x02\x11\x15\n\r\n\x05\x04\x20\x02\x06\x01\x12\x04\x8b\
    \x02\x16+\n\r\n\x05\x04\x20\x02\x06\x03\x12\x04\x8b\x02./\n\r\n\x05\x04\
    \x20\x02\x06\x08\x12\x04\x8b\x020@\n\r\n\x05\x04\x20\x02\x06\x07\x12\x04\
    \x8b\x02;?\n\x0c\n\x04\x04\x20\x02\x07\x12\x04\x8c\x02\x08'\n\r\n\x05\
    \x04\x20\x02\x07\x04\x12\x04\x8c\x02\x08\x10\n\r\n\x05\x04\x20\x02\x07\
    \x05\x12\x04\x8c\x02\x11\x16\n\r\n\x05\x04\x20\x02\x07\x01\x12\x04\x8c\
    \x02\x17\"\n\r\n\x05\x04\x20\x02\x07\x03\x12\x04\x8c\x02%&\n\x0c\n\x04\
    \x04\x20\x02\x08\x12\x04\x8d\x02\x08;\n\r\n\x05\x04\x20\x02\x08\x04\x12\
    \x04\x8d\x02\x08\x10\n\r\n\x05\x04\x20\x02\x08\x05\x12\x04\x8d\x02\x11\
    \x16\n\r\n\x05\x04\x20\x02\x08\x01\x12\x04\x8d\x02\x17(\n\r\n\x05\x04\
    \x20\x02\x08\x03\x12\x04\x8d\x02+,\n\r\n\x05\x04\x20\x02\x08\x08\x12\x04\
    \x8d\x02-:\n\r\n\x05\x04\x20\x02\x08\x07\x12\x04\x8d\x0289\n\x0c\n\x04\
    \x04\x20\x02\t\x12\x04\x8e\x02\x08+\n\r\n\x05\x04\x20\x02\t\x04\x12\x04\
    \x8e\x02\x08\x10\n\r\n\x05\x04\x20\x02\t\x05\x12\x04\x8e\x02\x11\x17\n\r\
    \n\x05\x04\x20\x02\t\x01\x12\x04\x8e\x02\x18%\n\r\n\x05\x04\x20\x02\t\
    \x03\x12\x04\x8e\x02(*\n\x0c\n\x02\x04!\x12\x06\x91\x02\0\x96\x02\x01\n\
    \x0b\n\x03\x04!\x01\x12\x04\x91\x02\x08\x1c\n\x0c\n\x04\x04!\x02\0\x12\
    \x04\x92\x02\x08&\n\r\n\x05\x04!\x02\0\x04\x12\x04\x92\x02\x08\x10\n\r\n\
    \x05\x04!\x02\0\x05\x12\x04\x92\x02\x11\x16\n\r\n\x05\x04!\x02\0\x01\x12\
    \x04\x92\x02\x17!\n\r\n\x05\x04!\x02\0\x03\x12\x04\x92\x02$%\n\x0c\n\x04\
    \x04!\x02\x01\x12\x04\x93\x02\x081\n\r\n\x05\x04!\x02\x01\x04\x12\x04\
    \x93\x02\x08\x10\n\r\n\x05\x04!\x02\x01\x05\x12\x04\x93\x02\x11\x18\n\r\
    \n\x05\x04!\x02\x01\x01\x12\x04\x93\x02\x19,\n\r\n\x05\x04!\x02\x01\x03\
    \x12\x04\x93\x02/0\n\x0c\n\x04\x04!\x02\x02\x12\x04\x94\x02\x08+\n\r\n\
    \x05\x04!\x02\x02\x04\x12\x04\x94\x02\x08\x10\n\r\n\x05\x04!\x02\x02\x05\
    \x12\x04\x94\x02\x11\x17\n\r\n\x05\x04!\x02\x02\x01\x12\x04\x94\x02\x18&\
    \n\r\n\x05\x04!\x02\x02\x03\x12\x04\x94\x02)*\n\x0c\n\x04\x04!\x02\x03\
    \x12\x04\x95\x02\x08%\n\r\n\x05\x04!\x02\x03\x04\x12\x04\x95\x02\x08\x10\
    \n\r\n\x05\x04!\x02\x03\x05\x12\x04\x95\x02\x11\x16\n\r\n\x05\x04!\x02\
    \x03\x01\x12\x04\x95\x02\x17\x20\n\r\n\x05\x04!\x02\x03\x03\x12\x04\x95\
    \x02#$\n\x0c\n\x02\x04\"\x12\x06\x98\x02\0\x9a\x02\x01\n\x0b\n\x03\x04\"\
    \x01\x12\x04\x98\x02\x08\x13\n\x0c\n\x04\x04\"\x02\0\x12\x04\x99\x02\x08\
    '\n\r\n\x05\x04\"\x02\0\x04\x12\x04\x99\x02\x08\x10\n\r\n\x05\x04\"\x02\
    \0\x05\x12\x04\x99\x02\x11\x17\n\r\n\x05\x04\"\x02\0\x01\x12\x04\x99\x02\
    \x18\"\n\r\n\x05\x04\"\x02\0\x03\x12\x04\x99\x02%&\n\x0c\n\x02\x04#\x12\
    \x06\x9c\x02\0\x9d\x02\x01\n\x0b\n\x03\x04#\x01\x12\x04\x9c\x02\x08#\n\
    \x0c\n\x02\x04$\x12\x06\x9f\x02\0\xa2\x02\x01\n\x0b\n\x03\x04$\x01\x12\
    \x04\x9f\x02\x08\x17\n\x0c\n\x04\x04$\x02\0\x12\x04\xa0\x02\x08!\n\r\n\
    \x05\x04$\x02\0\x04\x12\x04\xa0\x02\x08\x10\n\r\n\x05\x04$\x02\0\x05\x12\
    \x04\xa0\x02\x11\x17\n\r\n\x05\x04$\x02\0\x01\x12\x04\xa0\x02\x18\x1c\n\
    \r\n\x05\x04$\x02\0\x03\x12\x04\xa0\x02\x1f\x20\n\x0c\n\x04\x04$\x02\x01\
    \x12\x04\xa1\x02\x08\"\n\r\n\x05\x04$\x02\x01\x04\x12\x04\xa1\x02\x08\
    \x10\n\r\n\x05\x04$\x02\x01\x05\x12\x04\xa1\x02\x11\x17\n\r\n\x05\x04$\
    \x02\x01\x01\x12\x04\xa1\x02\x18\x1d\n\r\n\x05\x04$\x02\x01\x03\x12\x04\
    \xa1\x02\x20!\n\x0c\n\x02\x04%\x12\x06\xa4\x02\0\xa6\x02\x01\n\x0b\n\x03\
    \x04%\x01\x12\x04\xa4\x02\x08\x1c\n\x0c\n\x04\x04%\x02\0\x12\x04\xa5\x02\
    \x08.\n\r\n\x05\x04%\x02\0\x04\x12\x04\xa5\x02\x08\x10\n\r\n\x05\x04%\
    \x02\0\x06\x12\x04\xa5\x02\x11!\n\r\n\x05\x04%\x02\0\x01\x12\x04\xa5\x02\
    \")\n\r\n\x05\x04%\x02\0\x03\x12\x04\xa5\x02,-\n\x0c\n\x02\x04&\x12\x06\
    \xa8\x02\0\xaf\x02\x01\n\x0b\n\x03\x04&\x01\x12\x04\xa8\x02\x08\x13\n\
    \x0c\n\x04\x04&\x02\0\x12\x04\xa9\x02\x08$\n\r\n\x05\x04&\x02\0\x04\x12\
    \x04\xa9\x02\x08\x10\n\r\n\x05\x04&\x02\0\x05\x12\x04\xa9\x02\x11\x17\n\
    \r\n\x05\x04&\x02\0\x01\x12\x04\xa9\x02\x18\x1f\n\r\n\x05\x04&\x02\0\x03\
    \x12\x04\xa9\x02\"#\n\x0c\n\x04\x04&\x02\x01\x12\x04\xaa\x02\x08-\n\r\n\
    \x05\x04&\x02\x01\x04\x12\x04\xaa\x02\x08\x10\n\r\n\x05\x04&\x02\x01\x05\
    \x12\x04\xaa\x02\x11\x18\n\r\n\x05\x04&\x02\x01\x01\x12\x04\xaa\x02\x19(\
    \n\r\n\x05\x04&\x02\x01\x03\x12\x04\xaa\x02+,\n\x0c\n\x04\x04&\x02\x02\
    \x12\x04\xab\x02\x084\n\r\n\x05\x04&\x02\x02\x04\x12\x04\xab\x02\x08\x10\
    \n\r\n\x05\x04&\x02\x02\x05\x12\x04\xab\x02\x11\x17\n\r\n\x05\x04&\x02\
    \x02\x01\x12\x04\xab\x02\x18/\n\r\n\x05\x04&\x02\x02\x03\x12\x04\xab\x02\
    23\n\x0c\n\x04\x04&\x02\x03\x12\x04\xac\x02\x08-\n\r\n\x05\x04&\x02\x03\
    \x04\x12\x04\xac\x02\x08\x10\n\r\n\x05\x04&\x02\x03\x05\x12\x04\xac\x02\
    \x11\x17\n\r\n\x05\x04&\x02\x03\x01\x12\x04\xac\x02\x18(\n\r\n\x05\x04&\
    \x02\x03\x03\x12\x04\xac\x02+,\n\x0c\n\x04\x04&\x02\x04\x12\x04\xad\x02\
    \x080\n\r\n\x05\x04&\x02\x04\x04\x12\x04\xad\x02\x08\x10\n\r\n\x05\x04&\
    \x02\x04\x05\x12\x04\xad\x02\x11\x18\n\r\n\x05\x04&\x02\x04\x01\x12\x04\
    \xad\x02\x19+\n\r\n\x05\x04&\x02\x04\x03\x12\x04\xad\x02./\n\x0c\n\x04\
    \x04&\x02\x05\x12\x04\xae\x02\x084\n\r\n\x05\x04&\x02\x05\x04\x12\x04\
    \xae\x02\x08\x10\n\r\n\x05\x04&\x02\x05\x05\x12\x04\xae\x02\x11\x15\n\r\
    \n\x05\x04&\x02\x05\x01\x12\x04\xae\x02\x16/\n\r\n\x05\x04&\x02\x05\x03\
    \x12\x04\xae\x0223\n\x0c\n\x02\x04'\x12\x06\xb1\x02\0\xb5\x02\x01\n\x0b\
    \n\x03\x04'\x01\x12\x04\xb1\x02\x08#\n\x0c\n\x04\x04'\x02\0\x12\x04\xb2\
    \x02\x08(\n\r\n\x05\x04'\x02\0\x04\x12\x04\xb2\x02\x08\x10\n\r\n\x05\x04\
    '\x02\0\x05\x12\x04\xb2\x02\x11\x17\n\r\n\x05\x04'\x02\0\x01\x12\x04\xb2\
    \x02\x18#\n\r\n\x05\x04'\x02\0\x03\x12\x04\xb2\x02&'\n\x0c\n\x04\x04'\
    \x02\x01\x12\x04\xb3\x02\x081\n\r\n\x05\x04'\x02\x01\x04\x12\x04\xb3\x02\
    \x08\x10\n\r\n\x05\x04'\x02\x01\x05\x12\x04\xb3\x02\x11\x17\n\r\n\x05\
    \x04'\x02\x01\x01\x12\x04\xb3\x02\x18,\n\r\n\x05\x04'\x02\x01\x03\x12\
    \x04\xb3\x02/0\n\x0c\n\x04\x04'\x02\x02\x12\x04\xb4\x02\x08'\n\r\n\x05\
    \x04'\x02\x02\x04\x12\x04\xb4\x02\x08\x10\n\r\n\x05\x04'\x02\x02\x05\x12\
    \x04\xb4\x02\x11\x17\n\r\n\x05\x04'\x02\x02\x01\x12\x04\xb4\x02\x18\"\n\
    \r\n\x05\x04'\x02\x02\x03\x12\x04\xb4\x02%&\n\x0c\n\x02\x04(\x12\x06\xb7\
    \x02\0\xb9\x02\x01\n\x0b\n\x03\x04(\x01\x12\x04\xb7\x02\x08\x1f\n\x0c\n\
    \x04\x04(\x02\0\x12\x04\xb8\x02\x08'\n\r\n\x05\x04(\x02\0\x04\x12\x04\
    \xb8\x02\x08\x10\n\r\n\x05\x04(\x02\0\x05\x12\x04\xb8\x02\x11\x16\n\r\n\
    \x05\x04(\x02\0\x01\x12\x04\xb8\x02\x17\"\n\r\n\x05\x04(\x02\0\x03\x12\
    \x04\xb8\x02%&\n\x0c\n\x02\x04)\x12\x06\xbb\x02\0\xc5\x02\x01\n\x0b\n\
    \x03\x04)\x01\x12\x04\xbb\x02\x08\x1c\n\x0c\n\x04\x04)\x02\0\x12\x04\xbc\
    \x02\x08'\n\r\n\x05\x04)\x02\0\x04\x12\x04\xbc\x02\x08\x10\n\r\n\x05\x04\
    )\x02\0\x05\x12\x04\xbc\x02\x11\x17\n\r\n\x05\x04)\x02\0\x01\x12\x04\xbc\
    \x02\x18\"\n\r\n\x05\x04)\x02\0\x03\x12\x04\xbc\x02%&\n\x0c\n\x04\x04)\
    \x02\x01\x12\x04\xbd\x02\x08&\n\r\n\x05\x04)\x02\x01\x04\x12\x04\xbd\x02\
    \x08\x10\n\r\n\x05\x04)\x02\x01\x05\x12\x04\xbd\x02\x11\x17\n\r\n\x05\
    \x04)\x02\x01\x01\x12\x04\xbd\x02\x18!\n\r\n\x05\x04)\x02\x01\x03\x12\
    \x04\xbd\x02$%\n\x0c\n\x04\x04)\x02\x02\x12\x04\xbe\x02\x08&\n\r\n\x05\
    \x04)\x02\x02\x04\x12\x04\xbe\x02\x08\x10\n\r\n\x05\x04)\x02\x02\x05\x12\
    \x04\xbe\x02\x11\x17\n\r\n\x05\x04)\x02\x02\x01\x12\x04\xbe\x02\x18!\n\r\
    \n\x05\x04)\x02\x02\x03\x12\x04\xbe\x02$%\n\x0c\n\x04\x04)\x02\x03\x12\
    \x04\xbf\x02\x08$\n\r\n\x05\x04)\x02\x03\x04\x12\x04\xbf\x02\x08\x10\n\r\
    \n\x05\x04)\x02\x03\x05\x12\x04\xbf\x02\x11\x17\n\r\n\x05\x04)\x02\x03\
    \x01\x12\x04\xbf\x02\x18\x1f\n\r\n\x05\x04)\x02\x03\x03\x12\x04\xbf\x02\
    \"#\n\x0c\n\x04\x04)\x02\x04\x12\x04\xc0\x02\x08#\n\r\n\x05\x04)\x02\x04\
    \x04\x12\x04\xc0\x02\x08\x10\n\r\n\x05\x04)\x02\x04\x05\x12\x04\xc0\x02\
    \x11\x17\n\r\n\x05\x04)\x02\x04\x01\x12\x04\xc0\x02\x18\x1e\n\r\n\x05\
    \x04)\x02\x04\x03\x12\x04\xc0\x02!\"\n\x0c\n\x04\x04)\x02\x05\x12\x04\
    \xc1\x02\x08#\n\r\n\x05\x04)\x02\x05\x04\x12\x04\xc1\x02\x08\x10\n\r\n\
    \x05\x04)\x02\x05\x05\x12\x04\xc1\x02\x11\x17\n\r\n\x05\x04)\x02\x05\x01\
    \x12\x04\xc1\x02\x18\x1e\n\r\n\x05\x04)\x02\x05\x03\x12\x04\xc1\x02!\"\n\
    \x0c\n\x04\x04)\x02\x06\x12\x04\xc2\x02\x08'\n\r\n\x05\x04)\x02\x06\x04\
    \x12\x04\xc2\x02\x08\x10\n\r\n\x05\x04)\x02\x06\x05\x12\x04\xc2\x02\x11\
    \x17\n\r\n\x05\x04)\x02\x06\x01\x12\x04\xc2\x02\x18\"\n\r\n\x05\x04)\x02\
    \x06\x03\x12\x04\xc2\x02%&\n\x0c\n\x04\x04)\x02\x07\x12\x04\xc3\x02\x08'\
    \n\r\n\x05\x04)\x02\x07\x04\x12\x04\xc3\x02\x08\x10\n\r\n\x05\x04)\x02\
    \x07\x05\x12\x04\xc3\x02\x11\x17\n\r\n\x05\x04)\x02\x07\x01\x12\x04\xc3\
    \x02\x18\"\n\r\n\x05\x04)\x02\x07\x03\x12\x04\xc3\x02%&\n\x0c\n\x04\x04)\
    \x02\x08\x12\x04\xc4\x02\x08\x20\n\r\n\x05\x04)\x02\x08\x04\x12\x04\xc4\
    \x02\x08\x10\n\r\n\x05\x04)\x02\x08\x05\x12\x04\xc4\x02\x11\x16\n\r\n\
    \x05\x04)\x02\x08\x01\x12\x04\xc4\x02\x17\x1b\n\r\n\x05\x04)\x02\x08\x03\
    \x12\x04\xc4\x02\x1e\x1f\n\x0c\n\x02\x04*\x12\x06\xc7\x02\0\xcc\x02\x01\
    \n\x0b\n\x03\x04*\x01\x12\x04\xc7\x02\x08!\n\x0c\n\x04\x04*\x02\0\x12\
    \x04\xc8\x02\x08%\n\r\n\x05\x04*\x02\0\x04\x12\x04\xc8\x02\x08\x10\n\r\n\
    \x05\x04*\x02\0\x05\x12\x04\xc8\x02\x11\x17\n\r\n\x05\x04*\x02\0\x01\x12\
    \x04\xc8\x02\x18\x20\n\r\n\x05\x04*\x02\0\x03\x12\x04\xc8\x02#$\n\x0c\n\
    \x04\x04*\x02\x01\x12\x04\xc9\x02\x08&\n\r\n\x05\x04*\x02\x01\x04\x12\
    \x04\xc9\x02\x08\x10\n\r\n\x05\x04*\x02\x01\x05\x12\x04\xc9\x02\x11\x17\
    \n\r\n\x05\x04*\x02\x01\x01\x12\x04\xc9\x02\x18!\n\r\n\x05\x04*\x02\x01\
    \x03\x12\x04\xc9\x02$%\n\x0c\n\x04\x04*\x02\x02\x12\x04\xca\x02\x08$\n\r\
    \n\x05\x04*\x02\x02\x04\x12\x04\xca\x02\x08\x10\n\r\n\x05\x04*\x02\x02\
    \x05\x12\x04\xca\x02\x11\x17\n\r\n\x05\x04*\x02\x02\x01\x12\x04\xca\x02\
    \x18\x1f\n\r\n\x05\x04*\x02\x02\x03\x12\x04\xca\x02\"#\n\x0c\n\x04\x04*\
    \x02\x03\x12\x04\xcb\x02\x08$\n\r\n\x05\x04*\x02\x03\x04\x12\x04\xcb\x02\
    \x08\x10\n\r\n\x05\x04*\x02\x03\x05\x12\x04\xcb\x02\x11\x17\n\r\n\x05\
    \x04*\x02\x03\x01\x12\x04\xcb\x02\x18\x1f\n\r\n\x05\x04*\x02\x03\x03\x12\
    \x04\xcb\x02\"#\n\x0c\n\x02\x04+\x12\x06\xce\x02\0\xd5\x02\x01\n\x0b\n\
    \x03\x04+\x01\x12\x04\xce\x02\x08\x1c\n\x0e\n\x04\x04+\x03\0\x12\x06\xcf\
    \x02\x08\xd2\x02\t\n\r\n\x05\x04+\x03\0\x01\x12\x04\xcf\x02\x10\x1c\n\
    \x0e\n\x06\x04+\x03\0\x02\0\x12\x04\xd0\x02\x10,\n\x0f\n\x07\x04+\x03\0\
    \x02\0\x04\x12\x04\xd0\x02\x10\x18\n\x0f\n\x07\x04+\x03\0\x02\0\x05\x12\
    \x04\xd0\x02\x19\x1f\n\x0f\n\x07\x04+\x03\0\x02\0\x01\x12\x04\xd0\x02\
    \x20'\n\x0f\n\x07\x04+\x03\0\x02\0\x03\x12\x04\xd0\x02*+\n\x0e\n\x06\x04\
    +\x03\0\x02\x01\x12\x04\xd1\x02\x10-\n\x0f\n\x07\x04+\x03\0\x02\x01\x04\
    \x12\x04\xd1\x02\x10\x18\n\x0f\n\x07\x04+\x03\0\x02\x01\x05\x12\x04\xd1\
    \x02\x19\x1f\n\x0f\n\x07\x04+\x03\0\x02\x01\x01\x12\x04\xd1\x02\x20(\n\
    \x0f\n\x07\x04+\x03\0\x02\x01\x03\x12\x04\xd1\x02+,\n\x0c\n\x04\x04+\x02\
    \0\x12\x04\xd4\x02\x08G\n\r\n\x05\x04+\x02\0\x04\x12\x04\xd4\x02\x08\x10\
    \n\r\n\x05\x04+\x02\0\x06\x12\x04\xd4\x02\x113\n\r\n\x05\x04+\x02\0\x01\
    \x12\x04\xd4\x024B\n\r\n\x05\x04+\x02\0\x03\x12\x04\xd4\x02EF\n\x0c\n\
    \x02\x04,\x12\x06\xd7\x02\0\xdc\x02\x01\n\x0b\n\x03\x04,\x01\x12\x04\xd7\
    \x02\x08!\n\x0c\n\x04\x04,\x02\0\x12\x04\xd8\x02\x08:\n\r\n\x05\x04,\x02\
    \0\x04\x12\x04\xd8\x02\x08\x10\n\r\n\x05\x04,\x02\0\x05\x12\x04\xd8\x02\
    \x11\x17\n\r\n\x05\x04,\x02\0\x01\x12\x04\xd8\x02\x18\x20\n\r\n\x05\x04,\
    \x02\0\x03\x12\x04\xd8\x02#$\n\r\n\x05\x04,\x02\0\x08\x12\x04\xd8\x02%9\
    \n\x10\n\x08\x04,\x02\0\x08\xe0\xd4\x03\x12\x04\xd8\x02&8\n\x0c\n\x04\
    \x04,\x02\x01\x12\x04\xd9\x02\x08;\n\r\n\x05\x04,\x02\x01\x04\x12\x04\
    \xd9\x02\x08\x10\n\r\n\x05\x04,\x02\x01\x05\x12\x04\xd9\x02\x11\x17\n\r\
    \n\x05\x04,\x02\x01\x01\x12\x04\xd9\x02\x18!\n\r\n\x05\x04,\x02\x01\x03\
    \x12\x04\xd9\x02$%\n\r\n\x05\x04,\x02\x01\x08\x12\x04\xd9\x02&:\n\x10\n\
    \x08\x04,\x02\x01\x08\xe0\xd4\x03\x12\x04\xd9\x02'9\n\x0c\n\x04\x04,\x02\
    \x02\x12\x04\xda\x02\x089\n\r\n\x05\x04,\x02\x02\x04\x12\x04\xda\x02\x08\
    \x10\n\r\n\x05\x04,\x02\x02\x05\x12\x04\xda\x02\x11\x17\n\r\n\x05\x04,\
    \x02\x02\x01\x12\x04\xda\x02\x18\x1f\n\r\n\x05\x04,\x02\x02\x03\x12\x04\
    \xda\x02\"#\n\r\n\x05\x04,\x02\x02\x08\x12\x04\xda\x02$8\n\x10\n\x08\x04\
    ,\x02\x02\x08\xe0\xd4\x03\x12\x04\xda\x02%7\n\x0c\n\x04\x04,\x02\x03\x12\
    \x04\xdb\x02\x08$\n\r\n\x05\x04,\x02\x03\x04\x12\x04\xdb\x02\x08\x10\n\r\
    \n\x05\x04,\x02\x03\x05\x12\x04\xdb\x02\x11\x17\n\r\n\x05\x04,\x02\x03\
    \x01\x12\x04\xdb\x02\x18\x1f\n\r\n\x05\x04,\x02\x03\x03\x12\x04\xdb\x02\
    \"#\n\x0c\n\x02\x04-\x12\x06\xde\x02\0\xe1\x02\x01\n\x0b\n\x03\x04-\x01\
    \x12\x04\xde\x02\x08\x20\n\x0c\n\x04\x04-\x02\0\x12\x04\xdf\x02\x08%\n\r\
    \n\x05\x04-\x02\0\x04\x12\x04\xdf\x02\x08\x10\n\r\n\x05\x04-\x02\0\x05\
    \x12\x04\xdf\x02\x11\x17\n\r\n\x05\x04-\x02\0\x01\x12\x04\xdf\x02\x18\
    \x20\n\r\n\x05\x04-\x02\0\x03\x12\x04\xdf\x02#$\n\x0c\n\x04\x04-\x02\x01\
    \x12\x04\xe0\x02\x08&\n\r\n\x05\x04-\x02\x01\x04\x12\x04\xe0\x02\x08\x10\
    \n\r\n\x05\x04-\x02\x01\x05\x12\x04\xe0\x02\x11\x17\n\r\n\x05\x04-\x02\
    \x01\x01\x12\x04\xe0\x02\x18!\n\r\n\x05\x04-\x02\x01\x03\x12\x04\xe0\x02\
    $%\n\x0c\n\x02\x04.\x12\x06\xe3\x02\0\xe7\x02\x01\n\x0b\n\x03\x04.\x01\
    \x12\x04\xe3\x02\x08\x20\n\x0c\n\x04\x04.\x02\0\x12\x04\xe4\x02\x08'\n\r\
    \n\x05\x04.\x02\0\x04\x12\x04\xe4\x02\x08\x10\n\r\n\x05\x04.\x02\0\x05\
    \x12\x04\xe4\x02\x11\x17\n\r\n\x05\x04.\x02\0\x01\x12\x04\xe4\x02\x18\"\
    \n\r\n\x05\x04.\x02\0\x03\x12\x04\xe4\x02%&\n\x0c\n\x04\x04.\x02\x01\x12\
    \x04\xe5\x02\x08%\n\r\n\x05\x04.\x02\x01\x04\x12\x04\xe5\x02\x08\x10\n\r\
    \n\x05\x04.\x02\x01\x05\x12\x04\xe5\x02\x11\x17\n\r\n\x05\x04.\x02\x01\
    \x01\x12\x04\xe5\x02\x18\x20\n\r\n\x05\x04.\x02\x01\x03\x12\x04\xe5\x02#\
    $\n\x0c\n\x04\x04.\x02\x02\x12\x04\xe6\x02\x08-\n\r\n\x05\x04.\x02\x02\
    \x04\x12\x04\xe6\x02\x08\x10\n\r\n\x05\x04.\x02\x02\x05\x12\x04\xe6\x02\
    \x11\x17\n\r\n\x05\x04.\x02\x02\x01\x12\x04\xe6\x02\x18(\n\r\n\x05\x04.\
    \x02\x02\x03\x12\x04\xe6\x02+,\n\x0c\n\x02\x04/\x12\x06\xe9\x02\0\xf1\
    \x02\x01\n\x0b\n\x03\x04/\x01\x12\x04\xe9\x02\x08\x19\n\x0c\n\x04\x04/\
    \x02\0\x12\x04\xea\x02\x08-\n\r\n\x05\x04/\x02\0\x04\x12\x04\xea\x02\x08\
    \x10\n\r\n\x05\x04/\x02\0\x05\x12\x04\xea\x02\x11\x18\n\r\n\x05\x04/\x02\
    \0\x01\x12\x04\xea\x02\x19(\n\r\n\x05\x04/\x02\0\x03\x12\x04\xea\x02+,\n\
    \x0c\n\x04\x04/\x02\x01\x12\x04\xeb\x02\x08(\n\r\n\x05\x04/\x02\x01\x04\
    \x12\x04\xeb\x02\x08\x10\n\r\n\x05\x04/\x02\x01\x05\x12\x04\xeb\x02\x11\
    \x17\n\r\n\x05\x04/\x02\x01\x01\x12\x04\xeb\x02\x18#\n\r\n\x05\x04/\x02\
    \x01\x03\x12\x04\xeb\x02&'\n\x0c\n\x04\x04/\x02\x02\x12\x04\xec\x02\x08\
    \x20\n\r\n\x05\x04/\x02\x02\x04\x12\x04\xec\x02\x08\x10\n\r\n\x05\x04/\
    \x02\x02\x05\x12\x04\xec\x02\x11\x17\n\r\n\x05\x04/\x02\x02\x01\x12\x04\
    \xec\x02\x18\x1b\n\r\n\x05\x04/\x02\x02\x03\x12\x04\xec\x02\x1e\x1f\n\
    \x0c\n\x04\x04/\x02\x03\x12\x04\xed\x02\x08'\n\r\n\x05\x04/\x02\x03\x04\
    \x12\x04\xed\x02\x08\x10\n\r\n\x05\x04/\x02\x03\x05\x12\x04\xed\x02\x11\
    \x17\n\r\n\x05\x04/\x02\x03\x01\x12\x04\xed\x02\x18\"\n\r\n\x05\x04/\x02\
    \x03\x03\x12\x04\xed\x02%&\n\x0c\n\x04\x04/\x02\x04\x12\x04\xee\x02\x08)\
    \n\r\n\x05\x04/\x02\x04\x04\x12\x04\xee\x02\x08\x10\n\r\n\x05\x04/\x02\
    \x04\x05\x12\x04\xee\x02\x11\x17\n\r\n\x05\x04/\x02\x04\x01\x12\x04\xee\
    \x02\x18$\n\r\n\x05\x04/\x02\x04\x03\x12\x04\xee\x02'(\n\x0c\n\x04\x04/\
    \x02\x05\x12\x04\xef\x02\x083\n\r\n\x05\x04/\x02\x05\x04\x12\x04\xef\x02\
    \x08\x10\n\r\n\x05\x04/\x02\x05\x05\x12\x04\xef\x02\x11\x18\n\r\n\x05\
    \x04/\x02\x05\x01\x12\x04\xef\x02\x19.\n\r\n\x05\x04/\x02\x05\x03\x12\
    \x04\xef\x0212\n\x0c\n\x04\x04/\x02\x06\x12\x04\xf0\x02\x084\n\r\n\x05\
    \x04/\x02\x06\x04\x12\x04\xf0\x02\x08\x10\n\r\n\x05\x04/\x02\x06\x05\x12\
    \x04\xf0\x02\x11\x17\n\r\n\x05\x04/\x02\x06\x01\x12\x04\xf0\x02\x18/\n\r\
    \n\x05\x04/\x02\x06\x03\x12\x04\xf0\x0223\n\x0c\n\x02\x040\x12\x06\xf3\
    \x02\0\xf7\x02\x01\n\x0b\n\x03\x040\x01\x12\x04\xf3\x02\x08!\n\x0c\n\x04\
    \x040\x02\0\x12\x04\xf4\x02\x08-\n\r\n\x05\x040\x02\0\x04\x12\x04\xf4\
    \x02\x08\x10\n\r\n\x05\x040\x02\0\x05\x12\x04\xf4\x02\x11\x18\n\r\n\x05\
    \x040\x02\0\x01\x12\x04\xf4\x02\x19(\n\r\n\x05\x040\x02\0\x03\x12\x04\
    \xf4\x02+,\n\x0c\n\x04\x040\x02\x01\x12\x04\xf5\x02\x08#\n\r\n\x05\x040\
    \x02\x01\x04\x12\x04\xf5\x02\x08\x10\n\r\n\x05\x040\x02\x01\x05\x12\x04\
    \xf5\x02\x11\x17\n\r\n\x05\x040\x02\x01\x01\x12\x04\xf5\x02\x18\x1e\n\r\
    \n\x05\x040\x02\x01\x03\x12\x04\xf5\x02!\"\n\x0c\n\x04\x040\x02\x02\x12\
    \x04\xf6\x02\x08*\n\r\n\x05\x040\x02\x02\x04\x12\x04\xf6\x02\x08\x10\n\r\
    \n\x05\x040\x02\x02\x05\x12\x04\xf6\x02\x11\x17\n\r\n\x05\x040\x02\x02\
    \x01\x12\x04\xf6\x02\x18%\n\r\n\x05\x040\x02\x02\x03\x12\x04\xf6\x02()\n\
    \x0c\n\x02\x041\x12\x06\xf9\x02\0\xfd\x02\x01\n\x0b\n\x03\x041\x01\x12\
    \x04\xf9\x02\x08\"\n\x0c\n\x04\x041\x02\0\x12\x04\xfa\x02\x08,\n\r\n\x05\
    \x041\x02\0\x04\x12\x04\xfa\x02\x08\x10\n\r\n\x05\x041\x02\0\x05\x12\x04\
    \xfa\x02\x11\x18\n\r\n\x05\x041\x02\0\x01\x12\x04\xfa\x02\x19'\n\r\n\x05\
    \x041\x02\0\x03\x12\x04\xfa\x02*+\n\x0c\n\x04\x041\x02\x01\x12\x04\xfb\
    \x02\x08+\n\r\n\x05\x041\x02\x01\x04\x12\x04\xfb\x02\x08\x10\n\r\n\x05\
    \x041\x02\x01\x05\x12\x04\xfb\x02\x11\x17\n\r\n\x05\x041\x02\x01\x01\x12\
    \x04\xfb\x02\x18&\n\r\n\x05\x041\x02\x01\x03\x12\x04\xfb\x02)*\n\x0c\n\
    \x04\x041\x02\x02\x12\x04\xfc\x02\x08-\n\r\n\x05\x041\x02\x02\x04\x12\
    \x04\xfc\x02\x08\x10\n\r\n\x05\x041\x02\x02\x05\x12\x04\xfc\x02\x11\x17\
    \n\r\n\x05\x041\x02\x02\x01\x12\x04\xfc\x02\x18(\n\r\n\x05\x041\x02\x02\
    \x03\x12\x04\xfc\x02+,\n\x0c\n\x02\x042\x12\x06\xff\x02\0\x84\x03\x01\n\
    \x0b\n\x03\x042\x01\x12\x04\xff\x02\x08'\n\x0c\n\x04\x042\x02\0\x12\x04\
    \x80\x03\x08@\n\r\n\x05\x042\x02\0\x04\x12\x04\x80\x03\x08\x10\n\r\n\x05\
    \x042\x02\0\x05\x12\x04\x80\x03\x11\x17\n\r\n\x05\x042\x02\0\x01\x12\x04\
    \x80\x03\x18;\n\r\n\x05\x042\x02\0\x03\x12\x04\x80\x03>?\n\x0c\n\x04\x04\
    2\x02\x01\x12\x04\x81\x03\x08?\n\r\n\x05\x042\x02\x01\x04\x12\x04\x81\
    \x03\x08\x10\n\r\n\x05\x042\x02\x01\x05\x12\x04\x81\x03\x11\x17\n\r\n\
    \x05\x042\x02\x01\x01\x12\x04\x81\x03\x18:\n\r\n\x05\x042\x02\x01\x03\
    \x12\x04\x81\x03=>\n\x0c\n\x04\x042\x02\x02\x12\x04\x82\x03\x080\n\r\n\
    \x05\x042\x02\x02\x04\x12\x04\x82\x03\x08\x10\n\r\n\x05\x042\x02\x02\x05\
    \x12\x04\x82\x03\x11\x17\n\r\n\x05\x042\x02\x02\x01\x12\x04\x82\x03\x18+\
    \n\r\n\x05\x042\x02\x02\x03\x12\x04\x82\x03./\n\x0c\n\x04\x042\x02\x03\
    \x12\x04\x83\x03\x082\n\r\n\x05\x042\x02\x03\x04\x12\x04\x83\x03\x08\x10\
    \n\r\n\x05\x042\x02\x03\x05\x12\x04\x83\x03\x11\x17\n\r\n\x05\x042\x02\
    \x03\x01\x12\x04\x83\x03\x18-\n\r\n\x05\x042\x02\x03\x03\x12\x04\x83\x03\
    01\n\x0c\n\x02\x043\x12\x06\x86\x03\0\x88\x03\x01\n\x0b\n\x03\x043\x01\
    \x12\x04\x86\x03\x08\x1f\n\x0c\n\x04\x043\x02\0\x12\x04\x87\x03\x08,\n\r\
    \n\x05\x043\x02\0\x04\x12\x04\x87\x03\x08\x10\n\r\n\x05\x043\x02\0\x05\
    \x12\x04\x87\x03\x11\x18\n\r\n\x05\x043\x02\0\x01\x12\x04\x87\x03\x19'\n\
    \r\n\x05\x043\x02\0\x03\x12\x04\x87\x03*+\n\x0c\n\x02\x044\x12\x06\x8a\
    \x03\0\x8e\x03\x01\n\x0b\n\x03\x044\x01\x12\x04\x8a\x03\x08\x1f\n\x0c\n\
    \x04\x044\x02\0\x12\x04\x8b\x03\x08'\n\r\n\x05\x044\x02\0\x04\x12\x04\
    \x8b\x03\x08\x10\n\r\n\x05\x044\x02\0\x05\x12\x04\x8b\x03\x11\x17\n\r\n\
    \x05\x044\x02\0\x01\x12\x04\x8b\x03\x18\"\n\r\n\x05\x044\x02\0\x03\x12\
    \x04\x8b\x03%&\n\x0c\n\x04\x044\x02\x01\x12\x04\x8c\x03\x08'\n\r\n\x05\
    \x044\x02\x01\x04\x12\x04\x8c\x03\x08\x10\n\r\n\x05\x044\x02\x01\x05\x12\
    \x04\x8c\x03\x11\x17\n\r\n\x05\x044\x02\x01\x01\x12\x04\x8c\x03\x18\"\n\
    \r\n\x05\x044\x02\x01\x03\x12\x04\x8c\x03%&\n\x0c\n\x04\x044\x02\x02\x12\
    \x04\x8d\x03\x08#\n\r\n\x05\x044\x02\x02\x04\x12\x04\x8d\x03\x08\x10\n\r\
    \n\x05\x044\x02\x02\x05\x12\x04\x8d\x03\x11\x17\n\r\n\x05\x044\x02\x02\
    \x01\x12\x04\x8d\x03\x18\x1e\n\r\n\x05\x044\x02\x02\x03\x12\x04\x8d\x03!\
    \"\n\x0c\n\x02\x045\x12\x06\x90\x03\0\x95\x03\x01\n\x0b\n\x03\x045\x01\
    \x12\x04\x90\x03\x08(\n\x0c\n\x04\x045\x02\0\x12\x04\x91\x03\x08C\n\r\n\
    \x05\x045\x02\0\x04\x12\x04\x91\x03\x08\x10\n\r\n\x05\x045\x02\0\x05\x12\
    \x04\x91\x03\x11\x17\n\r\n\x05\x045\x02\0\x01\x12\x04\x91\x03\x18)\n\r\n\
    \x05\x045\x02\0\x03\x12\x04\x91\x03,-\n\r\n\x05\x045\x02\0\x08\x12\x04\
    \x91\x03.B\n\x10\n\x08\x045\x02\0\x08\xe0\xd4\x03\x12\x04\x91\x03/A\n\
    \x0c\n\x04\x045\x02\x01\x12\x04\x92\x03\x08&\n\r\n\x05\x045\x02\x01\x04\
    \x12\x04\x92\x03\x08\x10\n\r\n\x05\x045\x02\x01\x05\x12\x04\x92\x03\x11\
    \x17\n\r\n\x05\x045\x02\x01\x01\x12\x04\x92\x03\x18!\n\r\n\x05\x045\x02\
    \x01\x03\x12\x04\x92\x03$%\n\x0c\n\x04\x045\x02\x02\x12\x04\x93\x03\x08%\
    \n\r\n\x05\x045\x02\x02\x04\x12\x04\x93\x03\x08\x10\n\r\n\x05\x045\x02\
    \x02\x05\x12\x04\x93\x03\x11\x17\n\r\n\x05\x045\x02\x02\x01\x12\x04\x93\
    \x03\x18\x20\n\r\n\x05\x045\x02\x02\x03\x12\x04\x93\x03#$\n\x0c\n\x04\
    \x045\x02\x03\x12\x04\x94\x03\x08'\n\r\n\x05\x045\x02\x03\x04\x12\x04\
    \x94\x03\x08\x10\n\r\n\x05\x045\x02\x03\x05\x12\x04\x94\x03\x11\x17\n\r\
    \n\x05\x045\x02\x03\x01\x12\x04\x94\x03\x18\"\n\r\n\x05\x045\x02\x03\x03\
    \x12\x04\x94\x03%&\n\x0c\n\x02\x046\x12\x06\x97\x03\0\x9a\x03\x01\n\x0b\
    \n\x03\x046\x01\x12\x04\x97\x03\x08\x1f\n\x0c\n\x04\x046\x02\0\x12\x04\
    \x98\x03\x08$\n\r\n\x05\x046\x02\0\x04\x12\x04\x98\x03\x08\x10\n\r\n\x05\
    \x046\x02\0\x05\x12\x04\x98\x03\x11\x17\n\r\n\x05\x046\x02\0\x01\x12\x04\
    \x98\x03\x18\x1f\n\r\n\x05\x046\x02\0\x03\x12\x04\x98\x03\"#\n\x0c\n\x04\
    \x046\x02\x01\x12\x04\x99\x03\x084\n\r\n\x05\x046\x02\x01\x04\x12\x04\
    \x99\x03\x08\x10\n\r\n\x05\x046\x02\x01\x05\x12\x04\x99\x03\x11\x17\n\r\
    \n\x05\x046\x02\x01\x01\x12\x04\x99\x03\x18/\n\r\n\x05\x046\x02\x01\x03\
    \x12\x04\x99\x0323\n\x0c\n\x02\x047\x12\x06\x9c\x03\0\x9f\x03\x01\n\x0b\
    \n\x03\x047\x01\x12\x04\x9c\x03\x08\x1f\n\x0c\n\x04\x047\x02\0\x12\x04\
    \x9d\x03\x08$\n\r\n\x05\x047\x02\0\x04\x12\x04\x9d\x03\x08\x10\n\r\n\x05\
    \x047\x02\0\x05\x12\x04\x9d\x03\x11\x17\n\r\n\x05\x047\x02\0\x01\x12\x04\
    \x9d\x03\x18\x1f\n\r\n\x05\x047\x02\0\x03\x12\x04\x9d\x03\"#\n\x0c\n\x04\
    \x047\x02\x01\x12\x04\x9e\x03\x08,\n\r\n\x05\x047\x02\x01\x04\x12\x04\
    \x9e\x03\x08\x10\n\r\n\x05\x047\x02\x01\x05\x12\x04\x9e\x03\x11\x17\n\r\
    \n\x05\x047\x02\x01\x01\x12\x04\x9e\x03\x18'\n\r\n\x05\x047\x02\x01\x03\
    \x12\x04\x9e\x03*+\n\x0c\n\x02\x048\x12\x06\xa1\x03\0\xa3\x03\x01\n\x0b\
    \n\x03\x048\x01\x12\x04\xa1\x03\x080\n\x0c\n\x04\x048\x02\0\x12\x04\xa2\
    \x03\x08$\n\r\n\x05\x048\x02\0\x04\x12\x04\xa2\x03\x08\x10\n\r\n\x05\x04\
    8\x02\0\x05\x12\x04\xa2\x03\x11\x17\n\r\n\x05\x048\x02\0\x01\x12\x04\xa2\
    \x03\x18\x1f\n\r\n\x05\x048\x02\0\x03\x12\x04\xa2\x03\"#\n\x0c\n\x02\x04\
    9\x12\x06\xa5\x03\0\xa7\x03\x01\n\x0b\n\x03\x049\x01\x12\x04\xa5\x03\x08\
    \x20\n\x0c\n\x04\x049\x02\0\x12\x04\xa6\x03\x08$\n\r\n\x05\x049\x02\0\
    \x04\x12\x04\xa6\x03\x08\x10\n\r\n\x05\x049\x02\0\x05\x12\x04\xa6\x03\
    \x11\x17\n\r\n\x05\x049\x02\0\x01\x12\x04\xa6\x03\x18\x1f\n\r\n\x05\x049\
    \x02\0\x03\x12\x04\xa6\x03\"#\n\x0c\n\x02\x04:\x12\x06\xa9\x03\0\xab\x03\
    \x01\n\x0b\n\x03\x04:\x01\x12\x04\xa9\x03\x08/\n\x0c\n\x04\x04:\x02\0\
    \x12\x04\xaa\x03\x08+\n\r\n\x05\x04:\x02\0\x04\x12\x04\xaa\x03\x08\x10\n\
    \r\n\x05\x04:\x02\0\x05\x12\x04\xaa\x03\x11\x17\n\r\n\x05\x04:\x02\0\x01\
    \x12\x04\xaa\x03\x18&\n\r\n\x05\x04:\x02\0\x03\x12\x04\xaa\x03)*\n\x0c\n\
    \x02\x04;\x12\x06\xad\x03\0\xaf\x03\x01\n\x0b\n\x03\x04;\x01\x12\x04\xad\
    \x03\x08!\n\x0c\n\x04\x04;\x02\0\x12\x04\xae\x03\x08#\n\r\n\x05\x04;\x02\
    \0\x04\x12\x04\xae\x03\x08\x10\n\r\n\x05\x04;\x02\0\x05\x12\x04\xae\x03\
    \x11\x17\n\r\n\x05\x04;\x02\0\x01\x12\x04\xae\x03\x18\x1e\n\r\n\x05\x04;\
    \x02\0\x03\x12\x04\xae\x03!\"\n\x0c\n\x02\x04<\x12\x06\xb1\x03\0\xb3\x03\
    \x01\n\x0b\n\x03\x04<\x01\x12\x04\xb1\x03\x08)\n\x0c\n\x04\x04<\x02\0\
    \x12\x04\xb2\x03\x08#\n\r\n\x05\x04<\x02\0\x04\x12\x04\xb2\x03\x08\x10\n\
    \r\n\x05\x04<\x02\0\x05\x12\x04\xb2\x03\x11\x17\n\r\n\x05\x04<\x02\0\x01\
    \x12\x04\xb2\x03\x18\x1e\n\r\n\x05\x04<\x02\0\x03\x12\x04\xb2\x03!\"\n\
    \x0c\n\x02\x04=\x12\x06\xb5\x03\0\xb7\x03\x01\n\x0b\n\x03\x04=\x01\x12\
    \x04\xb5\x03\x08#\n\x0c\n\x04\x04=\x02\0\x12\x04\xb6\x03\x08#\n\r\n\x05\
    \x04=\x02\0\x04\x12\x04\xb6\x03\x08\x10\n\r\n\x05\x04=\x02\0\x05\x12\x04\
    \xb6\x03\x11\x17\n\r\n\x05\x04=\x02\0\x01\x12\x04\xb6\x03\x18\x1e\n\r\n\
    \x05\x04=\x02\0\x03\x12\x04\xb6\x03!\"\n\x0c\n\x02\x04>\x12\x06\xb9\x03\
    \0\xbc\x03\x01\n\x0b\n\x03\x04>\x01\x12\x04\xb9\x03\x08+\n\x0c\n\x04\x04\
    >\x02\0\x12\x04\xba\x03\x08#\n\r\n\x05\x04>\x02\0\x04\x12\x04\xba\x03\
    \x08\x10\n\r\n\x05\x04>\x02\0\x05\x12\x04\xba\x03\x11\x17\n\r\n\x05\x04>\
    \x02\0\x01\x12\x04\xba\x03\x18\x1e\n\r\n\x05\x04>\x02\0\x03\x12\x04\xba\
    \x03!\"\n\x0c\n\x04\x04>\x02\x01\x12\x04\xbb\x03\x08%\n\r\n\x05\x04>\x02\
    \x01\x04\x12\x04\xbb\x03\x08\x10\n\r\n\x05\x04>\x02\x01\x05\x12\x04\xbb\
    \x03\x11\x17\n\r\n\x05\x04>\x02\x01\x01\x12\x04\xbb\x03\x18\x20\n\r\n\
    \x05\x04>\x02\x01\x03\x12\x04\xbb\x03#$\n\x0c\n\x02\x04?\x12\x06\xbe\x03\
    \0\xc1\x03\x01\n\x0b\n\x03\x04?\x01\x12\x04\xbe\x03\x08#\n\x0c\n\x04\x04\
    ?\x02\0\x12\x04\xbf\x03\x08.\n\r\n\x05\x04?\x02\0\x04\x12\x04\xbf\x03\
    \x08\x10\n\r\n\x05\x04?\x02\0\x05\x12\x04\xbf\x03\x11\x17\n\r\n\x05\x04?\
    \x02\0\x01\x12\x04\xbf\x03\x18)\n\r\n\x05\x04?\x02\0\x03\x12\x04\xbf\x03\
    ,-\n\x0c\n\x04\x04?\x02\x01\x12\x04\xc0\x03\x08$\n\r\n\x05\x04?\x02\x01\
    \x04\x12\x04\xc0\x03\x08\x10\n\r\n\x05\x04?\x02\x01\x05\x12\x04\xc0\x03\
    \x11\x17\n\r\n\x05\x04?\x02\x01\x01\x12\x04\xc0\x03\x18\x1f\n\r\n\x05\
    \x04?\x02\x01\x03\x12\x04\xc0\x03\"#\n\x0c\n\x02\x04@\x12\x06\xc3\x03\0\
    \xc7\x03\x01\n\x0b\n\x03\x04@\x01\x12\x04\xc3\x03\x08\x19\n\x0c\n\x04\
    \x04@\x02\0\x12\x04\xc4\x03\x08,\n\r\n\x05\x04@\x02\0\x04\x12\x04\xc4\
    \x03\x08\x10\n\r\n\x05\x04@\x02\0\x05\x12\x04\xc4\x03\x11\x17\n\r\n\x05\
    \x04@\x02\0\x01\x12\x04\xc4\x03\x18'\n\r\n\x05\x04@\x02\0\x03\x12\x04\
    \xc4\x03*+\n\x0c\n\x04\x04@\x02\x01\x12\x04\xc5\x03\x08,\n\r\n\x05\x04@\
    \x02\x01\x04\x12\x04\xc5\x03\x08\x10\n\r\n\x05\x04@\x02\x01\x05\x12\x04\
    \xc5\x03\x11\x15\n\r\n\x05\x04@\x02\x01\x01\x12\x04\xc5\x03\x16'\n\r\n\
    \x05\x04@\x02\x01\x03\x12\x04\xc5\x03*+\n\x0c\n\x04\x04@\x02\x02\x12\x04\
    \xc6\x03\x082\n\r\n\x05\x04@\x02\x02\x04\x12\x04\xc6\x03\x08\x10\n\r\n\
    \x05\x04@\x02\x02\x05\x12\x04\xc6\x03\x11\x17\n\r\n\x05\x04@\x02\x02\x01\
    \x12\x04\xc6\x03\x18-\n\r\n\x05\x04@\x02\x02\x03\x12\x04\xc6\x0301\n\x0c\
    \n\x02\x04A\x12\x06\xc9\x03\0\xcc\x03\x01\n\x0b\n\x03\x04A\x01\x12\x04\
    \xc9\x03\x08\x19\n\x0c\n\x04\x04A\x02\0\x12\x04\xca\x03\x08/\n\r\n\x05\
    \x04A\x02\0\x04\x12\x04\xca\x03\x08\x10\n\r\n\x05\x04A\x02\0\x05\x12\x04\
    \xca\x03\x11\x17\n\r\n\x05\x04A\x02\0\x01\x12\x04\xca\x03\x18*\n\r\n\x05\
    \x04A\x02\0\x03\x12\x04\xca\x03-.\n\x0c\n\x04\x04A\x02\x01\x12\x04\xcb\
    \x03\x08,\n\r\n\x05\x04A\x02\x01\x04\x12\x04\xcb\x03\x08\x10\n\r\n\x05\
    \x04A\x02\x01\x05\x12\x04\xcb\x03\x11\x17\n\r\n\x05\x04A\x02\x01\x01\x12\
    \x04\xcb\x03\x18'\n\r\n\x05\x04A\x02\x01\x03\x12\x04\xcb\x03*+\n\x0c\n\
    \x02\x04B\x12\x06\xce\x03\0\xd0\x03\x01\n\x0b\n\x03\x04B\x01\x12\x04\xce\
    \x03\x08%\n\x0c\n\x04\x04B\x02\0\x12\x04\xcf\x03\x08*\n\r\n\x05\x04B\x02\
    \0\x04\x12\x04\xcf\x03\x08\x10\n\r\n\x05\x04B\x02\0\x05\x12\x04\xcf\x03\
    \x11\x17\n\r\n\x05\x04B\x02\0\x01\x12\x04\xcf\x03\x18%\n\r\n\x05\x04B\
    \x02\0\x03\x12\x04\xcf\x03()\n\x0c\n\x02\x04C\x12\x06\xd2\x03\0\xd7\x03\
    \x01\n\x0b\n\x03\x04C\x01\x12\x04\xd2\x03\x08#\n\x0c\n\x04\x04C\x02\0\
    \x12\x04\xd3\x03\x08+\n\r\n\x05\x04C\x02\0\x04\x12\x04\xd3\x03\x08\x10\n\
    \r\n\x05\x04C\x02\0\x05\x12\x04\xd3\x03\x11\x17\n\r\n\x05\x04C\x02\0\x01\
    \x12\x04\xd3\x03\x18&\n\r\n\x05\x04C\x02\0\x03\x12\x04\xd3\x03)*\n\x0c\n\
    \x04\x04C\x02\x01\x12\x04\xd4\x03\x08)\n\r\n\x05\x04C\x02\x01\x04\x12\
    \x04\xd4\x03\x08\x10\n\r\n\x05\x04C\x02\x01\x05\x12\x04\xd4\x03\x11\x17\
    \n\r\n\x05\x04C\x02\x01\x01\x12\x04\xd4\x03\x18$\n\r\n\x05\x04C\x02\x01\
    \x03\x12\x04\xd4\x03'(\n\x0c\n\x04\x04C\x02\x02\x12\x04\xd5\x03\x08/\n\r\
    \n\x05\x04C\x02\x02\x04\x12\x04\xd5\x03\x08\x10\n\r\n\x05\x04C\x02\x02\
    \x05\x12\x04\xd5\x03\x11\x17\n\r\n\x05\x04C\x02\x02\x01\x12\x04\xd5\x03\
    \x18*\n\r\n\x05\x04C\x02\x02\x03\x12\x04\xd5\x03-.\n\x0c\n\x04\x04C\x02\
    \x03\x12\x04\xd6\x03\x084\n\r\n\x05\x04C\x02\x03\x04\x12\x04\xd6\x03\x08\
    \x10\n\r\n\x05\x04C\x02\x03\x05\x12\x04\xd6\x03\x11\x17\n\r\n\x05\x04C\
    \x02\x03\x01\x12\x04\xd6\x03\x18/\n\r\n\x05\x04C\x02\x03\x03\x12\x04\xd6\
    \x0323\n\x0c\n\x02\x04D\x12\x06\xd9\x03\0\xdb\x03\x01\n\x0b\n\x03\x04D\
    \x01\x12\x04\xd9\x03\x08\x1e\n\x0c\n\x04\x04D\x02\0\x12\x04\xda\x03\x08:\
    \n\r\n\x05\x04D\x02\0\x04\x12\x04\xda\x03\x08\x10\n\r\n\x05\x04D\x02\0\
    \x06\x12\x04\xda\x03\x11-\n\r\n\x05\x04D\x02\0\x01\x12\x04\xda\x03.5\n\r\
    \n\x05\x04D\x02\0\x03\x12\x04\xda\x0389\n\x0c\n\x02\x04E\x12\x06\xdd\x03\
    \0\xe0\x03\x01\n\x0b\n\x03\x04E\x01\x12\x04\xdd\x03\x08\x1b\n\x0c\n\x04\
    \x04E\x02\0\x12\x04\xde\x03\x08)\n\r\n\x05\x04E\x02\0\x04\x12\x04\xde\
    \x03\x08\x10\n\r\n\x05\x04E\x02\0\x05\x12\x04\xde\x03\x11\x17\n\r\n\x05\
    \x04E\x02\0\x01\x12\x04\xde\x03\x18$\n\r\n\x05\x04E\x02\0\x03\x12\x04\
    \xde\x03'(\n\x0c\n\x04\x04E\x02\x01\x12\x04\xdf\x03\x08,\n\r\n\x05\x04E\
    \x02\x01\x04\x12\x04\xdf\x03\x08\x10\n\r\n\x05\x04E\x02\x01\x05\x12\x04\
    \xdf\x03\x11\x17\n\r\n\x05\x04E\x02\x01\x01\x12\x04\xdf\x03\x18'\n\r\n\
    \x05\x04E\x02\x01\x03\x12\x04\xdf\x03*+\n\x0c\n\x02\x04F\x12\x06\xe2\x03\
    \0\xe5\x03\x01\n\x0b\n\x03\x04F\x01\x12\x04\xe2\x03\x08\x1f\n\x0c\n\x04\
    \x04F\x02\0\x12\x04\xe3\x03\x08)\n\r\n\x05\x04F\x02\0\x04\x12\x04\xe3\
    \x03\x08\x10\n\r\n\x05\x04F\x02\0\x05\x12\x04\xe3\x03\x11\x17\n\r\n\x05\
    \x04F\x02\0\x01\x12\x04\xe3\x03\x18$\n\r\n\x05\x04F\x02\0\x03\x12\x04\
    \xe3\x03'(\n\x0c\n\x04\x04F\x02\x01\x12\x04\xe4\x03\x08/\n\r\n\x05\x04F\
    \x02\x01\x04\x12\x04\xe4\x03\x08\x10\n\r\n\x05\x04F\x02\x01\x05\x12\x04\
    \xe4\x03\x11\x17\n\r\n\x05\x04F\x02\x01\x01\x12\x04\xe4\x03\x18*\n\r\n\
    \x05\x04F\x02\x01\x03\x12\x04\xe4\x03-.\n\x0c\n\x02\x04G\x12\x06\xe7\x03\
    \0\xea\x03\x01\n\x0b\n\x03\x04G\x01\x12\x04\xe7\x03\x08\x1b\n\x0c\n\x04\
    \x04G\x02\0\x12\x04\xe8\x03\x08,\n\r\n\x05\x04G\x02\0\x04\x12\x04\xe8\
    \x03\x08\x10\n\r\n\x05\x04G\x02\0\x05\x12\x04\xe8\x03\x11\x17\n\r\n\x05\
    \x04G\x02\0\x01\x12\x04\xe8\x03\x18'\n\r\n\x05\x04G\x02\0\x03\x12\x04\
    \xe8\x03*+\n\x0c\n\x04\x04G\x02\x01\x12\x04\xe9\x03\x08,\n\r\n\x05\x04G\
    \x02\x01\x04\x12\x04\xe9\x03\x08\x10\n\r\n\x05\x04G\x02\x01\x05\x12\x04\
    \xe9\x03\x11\x17\n\r\n\x05\x04G\x02\x01\x01\x12\x04\xe9\x03\x18'\n\r\n\
    \x05\x04G\x02\x01\x03\x12\x04\xe9\x03*+\n\x0c\n\x02\x04H\x12\x06\xec\x03\
    \0\xef\x03\x01\n\x0b\n\x03\x04H\x01\x12\x04\xec\x03\x08)\n\x0c\n\x04\x04\
    H\x02\0\x12\x04\xed\x03\x08)\n\r\n\x05\x04H\x02\0\x04\x12\x04\xed\x03\
    \x08\x10\n\r\n\x05\x04H\x02\0\x05\x12\x04\xed\x03\x11\x17\n\r\n\x05\x04H\
    \x02\0\x01\x12\x04\xed\x03\x18$\n\r\n\x05\x04H\x02\0\x03\x12\x04\xed\x03\
    '(\n\x0c\n\x04\x04H\x02\x01\x12\x04\xee\x03\x08A\n\r\n\x05\x04H\x02\x01\
    \x04\x12\x04\xee\x03\x08\x10\n\r\n\x05\x04H\x02\x01\x06\x12\x04\xee\x03\
    \x11%\n\r\n\x05\x04H\x02\x01\x01\x12\x04\xee\x03&<\n\r\n\x05\x04H\x02\
    \x01\x03\x12\x04\xee\x03?@\n\x0c\n\x02\x04I\x12\x06\xf1\x03\0\xf4\x03\
    \x01\n\x0b\n\x03\x04I\x01\x12\x04\xf1\x03\x08'\n\x0c\n\x04\x04I\x02\0\
    \x12\x04\xf2\x03\x08$\n\r\n\x05\x04I\x02\0\x04\x12\x04\xf2\x03\x08\x10\n\
    \r\n\x05\x04I\x02\0\x05\x12\x04\xf2\x03\x11\x17\n\r\n\x05\x04I\x02\0\x01\
    \x12\x04\xf2\x03\x18\x1f\n\r\n\x05\x04I\x02\0\x03\x12\x04\xf2\x03\"#\n\
    \x0c\n\x04\x04I\x02\x01\x12\x04\xf3\x03\x08\"\n\r\n\x05\x04I\x02\x01\x04\
    \x12\x04\xf3\x03\x08\x10\n\r\n\x05\x04I\x02\x01\x05\x12\x04\xf3\x03\x11\
    \x16\n\r\n\x05\x04I\x02\x01\x01\x12\x04\xf3\x03\x17\x1d\n\r\n\x05\x04I\
    \x02\x01\x03\x12\x04\xf3\x03\x20!\n\x0c\n\x02\x04J\x12\x06\xf6\x03\0\xf9\
    \x03\x01\n\x0b\n\x03\x04J\x01\x12\x04\xf6\x03\x08%\n\x0c\n\x04\x04J\x02\
    \0\x12\x04\xf7\x03\x08$\n\r\n\x05\x04J\x02\0\x04\x12\x04\xf7\x03\x08\x10\
    \n\r\n\x05\x04J\x02\0\x05\x12\x04\xf7\x03\x11\x17\n\r\n\x05\x04J\x02\0\
    \x01\x12\x04\xf7\x03\x18\x1f\n\r\n\x05\x04J\x02\0\x03\x12\x04\xf7\x03\"#\
    \n\x0c\n\x04\x04J\x02\x01\x12\x04\xf8\x03\x08#\n\r\n\x05\x04J\x02\x01\
    \x04\x12\x04\xf8\x03\x08\x10\n\r\n\x05\x04J\x02\x01\x05\x12\x04\xf8\x03\
    \x11\x15\n\r\n\x05\x04J\x02\x01\x01\x12\x04\xf8\x03\x16\x1e\n\r\n\x05\
    \x04J\x02\x01\x03\x12\x04\xf8\x03!\"\n\x0c\n\x02\x04K\x12\x06\xfb\x03\0\
    \xfe\x03\x01\n\x0b\n\x03\x04K\x01\x12\x04\xfb\x03\x08$\n\x0c\n\x04\x04K\
    \x02\0\x12\x04\xfc\x03\x08*\n\r\n\x05\x04K\x02\0\x04\x12\x04\xfc\x03\x08\
    \x10\n\r\n\x05\x04K\x02\0\x05\x12\x04\xfc\x03\x11\x17\n\r\n\x05\x04K\x02\
    \0\x01\x12\x04\xfc\x03\x18%\n\r\n\x05\x04K\x02\0\x03\x12\x04\xfc\x03()\n\
    \x0c\n\x04\x04K\x02\x01\x12\x04\xfd\x03\x082\n\r\n\x05\x04K\x02\x01\x04\
    \x12\x04\xfd\x03\x08\x10\n\r\n\x05\x04K\x02\x01\x05\x12\x04\xfd\x03\x11\
    \x17\n\r\n\x05\x04K\x02\x01\x01\x12\x04\xfd\x03\x18-\n\r\n\x05\x04K\x02\
    \x01\x03\x12\x04\xfd\x0301\n\x0c\n\x02\x04L\x12\x06\x80\x04\0\x82\x04\
    \x01\n\x0b\n\x03\x04L\x01\x12\x04\x80\x04\x08(\n\x0c\n\x04\x04L\x02\0\
    \x12\x04\x81\x04\x08I\n\r\n\x05\x04L\x02\0\x04\x12\x04\x81\x04\x08\x10\n\
    \r\n\x05\x04L\x02\0\x05\x12\x04\x81\x04\x11\x15\n\r\n\x05\x04L\x02\0\x01\
    \x12\x04\x81\x04\x162\n\r\n\x05\x04L\x02\0\x03\x12\x04\x81\x0456\n\r\n\
    \x05\x04L\x02\0\x08\x12\x04\x81\x047H\n\r\n\x05\x04L\x02\0\x07\x12\x04\
    \x81\x04BG\n\x0c\n\x02\x04M\x12\x06\x84\x04\0\x91\x04\x01\n\x0b\n\x03\
    \x04M\x01\x12\x04\x84\x04\x082\n\x0e\n\x04\x04M\x03\0\x12\x06\x85\x04\
    \x08\x88\x04\t\n\r\n\x05\x04M\x03\0\x01\x12\x04\x85\x04\x10%\n\x0e\n\x06\
    \x04M\x03\0\x02\0\x12\x04\x86\x04\x10/\n\x0f\n\x07\x04M\x03\0\x02\0\x04\
    \x12\x04\x86\x04\x10\x18\n\x0f\n\x07\x04M\x03\0\x02\0\x05\x12\x04\x86\
    \x04\x19\x1f\n\x0f\n\x07\x04M\x03\0\x02\0\x01\x12\x04\x86\x04\x20*\n\x0f\
    \n\x07\x04M\x03\0\x02\0\x03\x12\x04\x86\x04-.\n\x0e\n\x06\x04M\x03\0\x02\
    \x01\x12\x04\x87\x04\x105\n\x0f\n\x07\x04M\x03\0\x02\x01\x04\x12\x04\x87\
    \x04\x10\x18\n\x0f\n\x07\x04M\x03\0\x02\x01\x05\x12\x04\x87\x04\x19\x1f\
    \n\x0f\n\x07\x04M\x03\0\x02\x01\x01\x12\x04\x87\x04\x200\n\x0f\n\x07\x04\
    M\x03\0\x02\x01\x03\x12\x04\x87\x0434\n\x0e\n\x04\x04M\x03\x01\x12\x06\
    \x8a\x04\x08\x8d\x04\t\n\r\n\x05\x04M\x03\x01\x01\x12\x04\x8a\x04\x10-\n\
    \x0e\n\x06\x04M\x03\x01\x02\0\x12\x04\x8b\x04\x10-\n\x0f\n\x07\x04M\x03\
    \x01\x02\0\x04\x12\x04\x8b\x04\x10\x18\n\x0f\n\x07\x04M\x03\x01\x02\0\
    \x05\x12\x04\x8b\x04\x19\x1f\n\x0f\n\x07\x04M\x03\x01\x02\0\x01\x12\x04\
    \x8b\x04\x20(\n\x0f\n\x07\x04M\x03\x01\x02\0\x03\x12\x04\x8b\x04+,\n\x0e\
    \n\x06\x04M\x03\x01\x02\x01\x12\x04\x8c\x04\x10l\n\x0f\n\x07\x04M\x03\
    \x01\x02\x01\x04\x12\x04\x8c\x04\x10\x18\n\x0f\n\x07\x04M\x03\x01\x02\
    \x01\x06\x12\x04\x8c\x04\x19Z\n\x0f\n\x07\x04M\x03\x01\x02\x01\x01\x12\
    \x04\x8c\x04[g\n\x0f\n\x07\x04M\x03\x01\x02\x01\x03\x12\x04\x8c\x04jk\n\
    \x0c\n\x04\x04M\x02\0\x12\x04\x8f\x04\x08\"\n\r\n\x05\x04M\x02\0\x04\x12\
    \x04\x8f\x04\x08\x10\n\r\n\x05\x04M\x02\0\x05\x12\x04\x8f\x04\x11\x17\n\
    \r\n\x05\x04M\x02\0\x01\x12\x04\x8f\x04\x18\x1d\n\r\n\x05\x04M\x02\0\x03\
    \x12\x04\x8f\x04\x20!\n\x0c\n\x04\x04M\x02\x01\x12\x04\x90\x04\x08i\n\r\
    \n\x05\x04M\x02\x01\x04\x12\x04\x90\x04\x08\x10\n\r\n\x05\x04M\x02\x01\
    \x06\x12\x04\x90\x04\x11Z\n\r\n\x05\x04M\x02\x01\x01\x12\x04\x90\x04[d\n\
    \r\n\x05\x04M\x02\x01\x03\x12\x04\x90\x04gh\n\x0c\n\x02\x04N\x12\x06\x93\
    \x04\0\x96\x04\x01\n\x0b\n\x03\x04N\x01\x12\x04\x93\x04\x08)\n\x0c\n\x04\
    \x04N\x02\0\x12\x04\x94\x04\x08\"\n\r\n\x05\x04N\x02\0\x04\x12\x04\x94\
    \x04\x08\x10\n\r\n\x05\x04N\x02\0\x05\x12\x04\x94\x04\x11\x17\n\r\n\x05\
    \x04N\x02\0\x01\x12\x04\x94\x04\x18\x1d\n\r\n\x05\x04N\x02\0\x03\x12\x04\
    \x94\x04\x20!\n\x0c\n\x04\x04N\x02\x01\x12\x04\x95\x04\x08'\n\r\n\x05\
    \x04N\x02\x01\x04\x12\x04\x95\x04\x08\x10\n\r\n\x05\x04N\x02\x01\x05\x12\
    \x04\x95\x04\x11\x17\n\r\n\x05\x04N\x02\x01\x01\x12\x04\x95\x04\x18\"\n\
    \r\n\x05\x04N\x02\x01\x03\x12\x04\x95\x04%&\n\x0c\n\x02\x04O\x12\x06\x98\
    \x04\0\x9a\x04\x01\n\x0b\n\x03\x04O\x01\x12\x04\x98\x04\x08*\n\x0c\n\x04\
    \x04O\x02\0\x12\x04\x99\x04\x08*\n\r\n\x05\x04O\x02\0\x04\x12\x04\x99\
    \x04\x08\x10\n\r\n\x05\x04O\x02\0\x05\x12\x04\x99\x04\x11\x18\n\r\n\x05\
    \x04O\x02\0\x01\x12\x04\x99\x04\x19%\n\r\n\x05\x04O\x02\0\x03\x12\x04\
    \x99\x04()\n\x0c\n\x02\x04P\x12\x06\x9c\x04\0\xad\x04\x01\n\x0b\n\x03\
    \x04P\x01\x12\x04\x9c\x04\x08-\n\x0e\n\x04\x04P\x03\0\x12\x06\x9d\x04\
    \x08\xa1\x04\t\n\r\n\x05\x04P\x03\0\x01\x12\x04\x9d\x04\x10'\n\x0e\n\x06\
    \x04P\x03\0\x02\0\x12\x04\x9e\x04\x105\n\x0f\n\x07\x04P\x03\0\x02\0\x04\
    \x12\x04\x9e\x04\x10\x18\n\x0f\n\x07\x04P\x03\0\x02\0\x05\x12\x04\x9e\
    \x04\x19\x1f\n\x0f\n\x07\x04P\x03\0\x02\0\x01\x12\x04\x9e\x04\x200\n\x0f\
    \n\x07\x04P\x03\0\x02\0\x03\x12\x04\x9e\x0434\n\x0e\n\x06\x04P\x03\0\x02\
    \x01\x12\x04\x9f\x04\x106\n\x0f\n\x07\x04P\x03\0\x02\x01\x04\x12\x04\x9f\
    \x04\x10\x18\n\x0f\n\x07\x04P\x03\0\x02\x01\x05\x12\x04\x9f\x04\x19\x1e\
    \n\x0f\n\x07\x04P\x03\0\x02\x01\x01\x12\x04\x9f\x04\x1f1\n\x0f\n\x07\x04\
    P\x03\0\x02\x01\x03\x12\x04\x9f\x0445\n\x0e\n\x06\x04P\x03\0\x02\x02\x12\
    \x04\xa0\x04\x105\n\x0f\n\x07\x04P\x03\0\x02\x02\x04\x12\x04\xa0\x04\x10\
    \x18\n\x0f\n\x07\x04P\x03\0\x02\x02\x05\x12\x04\xa0\x04\x19\x1f\n\x0f\n\
    \x07\x04P\x03\0\x02\x02\x01\x12\x04\xa0\x04\x200\n\x0f\n\x07\x04P\x03\0\
    \x02\x02\x03\x12\x04\xa0\x0434\n\x0e\n\x04\x04P\x03\x01\x12\x06\xa3\x04\
    \x08\xa7\x04\t\n\r\n\x05\x04P\x03\x01\x01\x12\x04\xa3\x04\x10&\n\x0e\n\
    \x06\x04P\x03\x01\x02\0\x12\x04\xa4\x04\x10/\n\x0f\n\x07\x04P\x03\x01\
    \x02\0\x04\x12\x04\xa4\x04\x10\x18\n\x0f\n\x07\x04P\x03\x01\x02\0\x05\
    \x12\x04\xa4\x04\x19\x1f\n\x0f\n\x07\x04P\x03\x01\x02\0\x01\x12\x04\xa4\
    \x04\x20*\n\x0f\n\x07\x04P\x03\x01\x02\0\x03\x12\x04\xa4\x04-.\n\x0e\n\
    \x06\x04P\x03\x01\x02\x01\x12\x04\xa5\x04\x106\n\x0f\n\x07\x04P\x03\x01\
    \x02\x01\x04\x12\x04\xa5\x04\x10\x18\n\x0f\n\x07\x04P\x03\x01\x02\x01\
    \x05\x12\x04\xa5\x04\x19\x1e\n\x0f\n\x07\x04P\x03\x01\x02\x01\x01\x12\
    \x04\xa5\x04\x1f1\n\x0f\n\x07\x04P\x03\x01\x02\x01\x03\x12\x04\xa5\x0445\
    \n\x0e\n\x06\x04P\x03\x01\x02\x02\x12\x04\xa6\x04\x105\n\x0f\n\x07\x04P\
    \x03\x01\x02\x02\x04\x12\x04\xa6\x04\x10\x18\n\x0f\n\x07\x04P\x03\x01\
    \x02\x02\x05\x12\x04\xa6\x04\x19\x1f\n\x0f\n\x07\x04P\x03\x01\x02\x02\
    \x01\x12\x04\xa6\x04\x200\n\x0f\n\x07\x04P\x03\x01\x02\x02\x03\x12\x04\
    \xa6\x0434\n\x0c\n\x04\x04P\x02\0\x12\x04\xa9\x04\x08\"\n\r\n\x05\x04P\
    \x02\0\x04\x12\x04\xa9\x04\x08\x10\n\r\n\x05\x04P\x02\0\x05\x12\x04\xa9\
    \x04\x11\x17\n\r\n\x05\x04P\x02\0\x01\x12\x04\xa9\x04\x18\x1d\n\r\n\x05\
    \x04P\x02\0\x03\x12\x04\xa9\x04\x20!\n\x0c\n\x04\x04P\x02\x01\x12\x04\
    \xaa\x04\x08'\n\r\n\x05\x04P\x02\x01\x04\x12\x04\xaa\x04\x08\x10\n\r\n\
    \x05\x04P\x02\x01\x05\x12\x04\xaa\x04\x11\x17\n\r\n\x05\x04P\x02\x01\x01\
    \x12\x04\xaa\x04\x18\"\n\r\n\x05\x04P\x02\x01\x03\x12\x04\xaa\x04%&\n\
    \x0c\n\x04\x04P\x02\x02\x12\x04\xab\x04\x08n\n\r\n\x05\x04P\x02\x02\x04\
    \x12\x04\xab\x04\x08\x10\n\r\n\x05\x04P\x02\x02\x06\x12\x04\xab\x04\x11O\
    \n\r\n\x05\x04P\x02\x02\x01\x12\x04\xab\x04Pi\n\r\n\x05\x04P\x02\x02\x03\
    \x12\x04\xab\x04lm\n\x0c\n\x04\x04P\x02\x03\x12\x04\xac\x04\x08d\n\r\n\
    \x05\x04P\x02\x03\x04\x12\x04\xac\x04\x08\x10\n\r\n\x05\x04P\x02\x03\x06\
    \x12\x04\xac\x04\x11N\n\r\n\x05\x04P\x02\x03\x01\x12\x04\xac\x04O_\n\r\n\
    \x05\x04P\x02\x03\x03\x12\x04\xac\x04bc\n\x0c\n\x02\x04Q\x12\x06\xaf\x04\
    \0\xb0\x04\x01\n\x0b\n\x03\x04Q\x01\x12\x04\xaf\x04\x08.\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
