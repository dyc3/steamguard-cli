// This file is generated by rust-protobuf 3.1.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `base_gcmessages.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_1_0;

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CGCStorePurchaseInit_LineItem)
pub struct CGCStorePurchaseInit_LineItem {
    // message fields
    // @@protoc_insertion_point(field:CGCStorePurchaseInit_LineItem.item_def_id)
    pub item_def_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CGCStorePurchaseInit_LineItem.quantity)
    pub quantity: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CGCStorePurchaseInit_LineItem.cost_in_local_currency)
    pub cost_in_local_currency: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CGCStorePurchaseInit_LineItem.purchase_type)
    pub purchase_type: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CGCStorePurchaseInit_LineItem.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGCStorePurchaseInit_LineItem {
    fn default() -> &'a CGCStorePurchaseInit_LineItem {
        <CGCStorePurchaseInit_LineItem as ::protobuf::Message>::default_instance()
    }
}

impl CGCStorePurchaseInit_LineItem {
    pub fn new() -> CGCStorePurchaseInit_LineItem {
        ::std::default::Default::default()
    }

    // optional uint32 item_def_id = 1;

    pub fn item_def_id(&self) -> u32 {
        self.item_def_id.unwrap_or(0)
    }

    pub fn clear_item_def_id(&mut self) {
        self.item_def_id = ::std::option::Option::None;
    }

    pub fn has_item_def_id(&self) -> bool {
        self.item_def_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_def_id(&mut self, v: u32) {
        self.item_def_id = ::std::option::Option::Some(v);
    }

    // optional uint32 quantity = 2;

    pub fn quantity(&self) -> u32 {
        self.quantity.unwrap_or(0)
    }

    pub fn clear_quantity(&mut self) {
        self.quantity = ::std::option::Option::None;
    }

    pub fn has_quantity(&self) -> bool {
        self.quantity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quantity(&mut self, v: u32) {
        self.quantity = ::std::option::Option::Some(v);
    }

    // optional uint32 cost_in_local_currency = 3;

    pub fn cost_in_local_currency(&self) -> u32 {
        self.cost_in_local_currency.unwrap_or(0)
    }

    pub fn clear_cost_in_local_currency(&mut self) {
        self.cost_in_local_currency = ::std::option::Option::None;
    }

    pub fn has_cost_in_local_currency(&self) -> bool {
        self.cost_in_local_currency.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cost_in_local_currency(&mut self, v: u32) {
        self.cost_in_local_currency = ::std::option::Option::Some(v);
    }

    // optional uint32 purchase_type = 4;

    pub fn purchase_type(&self) -> u32 {
        self.purchase_type.unwrap_or(0)
    }

    pub fn clear_purchase_type(&mut self) {
        self.purchase_type = ::std::option::Option::None;
    }

    pub fn has_purchase_type(&self) -> bool {
        self.purchase_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_purchase_type(&mut self, v: u32) {
        self.purchase_type = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_def_id",
            |m: &CGCStorePurchaseInit_LineItem| { &m.item_def_id },
            |m: &mut CGCStorePurchaseInit_LineItem| { &mut m.item_def_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "quantity",
            |m: &CGCStorePurchaseInit_LineItem| { &m.quantity },
            |m: &mut CGCStorePurchaseInit_LineItem| { &mut m.quantity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cost_in_local_currency",
            |m: &CGCStorePurchaseInit_LineItem| { &m.cost_in_local_currency },
            |m: &mut CGCStorePurchaseInit_LineItem| { &mut m.cost_in_local_currency },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "purchase_type",
            |m: &CGCStorePurchaseInit_LineItem| { &m.purchase_type },
            |m: &mut CGCStorePurchaseInit_LineItem| { &mut m.purchase_type },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CGCStorePurchaseInit_LineItem>(
            "CGCStorePurchaseInit_LineItem",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CGCStorePurchaseInit_LineItem {
    const NAME: &'static str = "CGCStorePurchaseInit_LineItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_def_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.quantity = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.cost_in_local_currency = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.purchase_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_def_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.quantity {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.cost_in_local_currency {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.purchase_type {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.item_def_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.quantity {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.cost_in_local_currency {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.purchase_type {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGCStorePurchaseInit_LineItem {
        CGCStorePurchaseInit_LineItem::new()
    }

    fn clear(&mut self) {
        self.item_def_id = ::std::option::Option::None;
        self.quantity = ::std::option::Option::None;
        self.cost_in_local_currency = ::std::option::Option::None;
        self.purchase_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGCStorePurchaseInit_LineItem {
        static instance: CGCStorePurchaseInit_LineItem = CGCStorePurchaseInit_LineItem {
            item_def_id: ::std::option::Option::None,
            quantity: ::std::option::Option::None,
            cost_in_local_currency: ::std::option::Option::None,
            purchase_type: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CGCStorePurchaseInit_LineItem {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CGCStorePurchaseInit_LineItem").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CGCStorePurchaseInit_LineItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CGCStorePurchaseInit_LineItem {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCStorePurchaseInit)
pub struct CMsgGCStorePurchaseInit {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCStorePurchaseInit.country)
    pub country: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGCStorePurchaseInit.language)
    pub language: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgGCStorePurchaseInit.currency)
    pub currency: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgGCStorePurchaseInit.line_items)
    pub line_items: ::std::vec::Vec<CGCStorePurchaseInit_LineItem>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCStorePurchaseInit.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCStorePurchaseInit {
    fn default() -> &'a CMsgGCStorePurchaseInit {
        <CMsgGCStorePurchaseInit as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCStorePurchaseInit {
    pub fn new() -> CMsgGCStorePurchaseInit {
        ::std::default::Default::default()
    }

    // optional string country = 1;

    pub fn country(&self) -> &str {
        match self.country.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_country(&mut self) {
        self.country = ::std::option::Option::None;
    }

    pub fn has_country(&self) -> bool {
        self.country.is_some()
    }

    // Param is passed by value, moved
    pub fn set_country(&mut self, v: ::std::string::String) {
        self.country = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_country(&mut self) -> &mut ::std::string::String {
        if self.country.is_none() {
            self.country = ::std::option::Option::Some(::std::string::String::new());
        }
        self.country.as_mut().unwrap()
    }

    // Take field
    pub fn take_country(&mut self) -> ::std::string::String {
        self.country.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 language = 2;

    pub fn language(&self) -> i32 {
        self.language.unwrap_or(0)
    }

    pub fn clear_language(&mut self) {
        self.language = ::std::option::Option::None;
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: i32) {
        self.language = ::std::option::Option::Some(v);
    }

    // optional int32 currency = 3;

    pub fn currency(&self) -> i32 {
        self.currency.unwrap_or(0)
    }

    pub fn clear_currency(&mut self) {
        self.currency = ::std::option::Option::None;
    }

    pub fn has_currency(&self) -> bool {
        self.currency.is_some()
    }

    // Param is passed by value, moved
    pub fn set_currency(&mut self, v: i32) {
        self.currency = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "country",
            |m: &CMsgGCStorePurchaseInit| { &m.country },
            |m: &mut CMsgGCStorePurchaseInit| { &mut m.country },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "language",
            |m: &CMsgGCStorePurchaseInit| { &m.language },
            |m: &mut CMsgGCStorePurchaseInit| { &mut m.language },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "currency",
            |m: &CMsgGCStorePurchaseInit| { &m.currency },
            |m: &mut CMsgGCStorePurchaseInit| { &mut m.currency },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "line_items",
            |m: &CMsgGCStorePurchaseInit| { &m.line_items },
            |m: &mut CMsgGCStorePurchaseInit| { &mut m.line_items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCStorePurchaseInit>(
            "CMsgGCStorePurchaseInit",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCStorePurchaseInit {
    const NAME: &'static str = "CMsgGCStorePurchaseInit";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.country = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.language = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.currency = ::std::option::Option::Some(is.read_int32()?);
                },
                34 => {
                    self.line_items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.country.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.language {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.currency {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        for value in &self.line_items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.country.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.language {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.currency {
            os.write_int32(3, v)?;
        }
        for v in &self.line_items {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCStorePurchaseInit {
        CMsgGCStorePurchaseInit::new()
    }

    fn clear(&mut self) {
        self.country = ::std::option::Option::None;
        self.language = ::std::option::Option::None;
        self.currency = ::std::option::Option::None;
        self.line_items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCStorePurchaseInit {
        static instance: CMsgGCStorePurchaseInit = CMsgGCStorePurchaseInit {
            country: ::std::option::Option::None,
            language: ::std::option::Option::None,
            currency: ::std::option::Option::None,
            line_items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCStorePurchaseInit {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCStorePurchaseInit").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCStorePurchaseInit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCStorePurchaseInit {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCStorePurchaseInitResponse)
pub struct CMsgGCStorePurchaseInitResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCStorePurchaseInitResponse.result)
    pub result: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgGCStorePurchaseInitResponse.txn_id)
    pub txn_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCStorePurchaseInitResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCStorePurchaseInitResponse {
    fn default() -> &'a CMsgGCStorePurchaseInitResponse {
        <CMsgGCStorePurchaseInitResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCStorePurchaseInitResponse {
    pub fn new() -> CMsgGCStorePurchaseInitResponse {
        ::std::default::Default::default()
    }

    // optional int32 result = 1;

    pub fn result(&self) -> i32 {
        self.result.unwrap_or(0)
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: i32) {
        self.result = ::std::option::Option::Some(v);
    }

    // optional uint64 txn_id = 2;

    pub fn txn_id(&self) -> u64 {
        self.txn_id.unwrap_or(0)
    }

    pub fn clear_txn_id(&mut self) {
        self.txn_id = ::std::option::Option::None;
    }

    pub fn has_txn_id(&self) -> bool {
        self.txn_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txn_id(&mut self, v: u64) {
        self.txn_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &CMsgGCStorePurchaseInitResponse| { &m.result },
            |m: &mut CMsgGCStorePurchaseInitResponse| { &mut m.result },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "txn_id",
            |m: &CMsgGCStorePurchaseInitResponse| { &m.txn_id },
            |m: &mut CMsgGCStorePurchaseInitResponse| { &mut m.txn_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCStorePurchaseInitResponse>(
            "CMsgGCStorePurchaseInitResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCStorePurchaseInitResponse {
    const NAME: &'static str = "CMsgGCStorePurchaseInitResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.txn_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.txn_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.txn_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCStorePurchaseInitResponse {
        CMsgGCStorePurchaseInitResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.txn_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCStorePurchaseInitResponse {
        static instance: CMsgGCStorePurchaseInitResponse = CMsgGCStorePurchaseInitResponse {
            result: ::std::option::Option::None,
            txn_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCStorePurchaseInitResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCStorePurchaseInitResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCStorePurchaseInitResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCStorePurchaseInitResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgSystemBroadcast)
pub struct CMsgSystemBroadcast {
    // message fields
    // @@protoc_insertion_point(field:CMsgSystemBroadcast.message)
    pub message: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSystemBroadcast.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSystemBroadcast {
    fn default() -> &'a CMsgSystemBroadcast {
        <CMsgSystemBroadcast as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSystemBroadcast {
    pub fn new() -> CMsgSystemBroadcast {
        ::std::default::Default::default()
    }

    // optional string message = 1;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "message",
            |m: &CMsgSystemBroadcast| { &m.message },
            |m: &mut CMsgSystemBroadcast| { &mut m.message },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSystemBroadcast>(
            "CMsgSystemBroadcast",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSystemBroadcast {
    const NAME: &'static str = "CMsgSystemBroadcast";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.message.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSystemBroadcast {
        CMsgSystemBroadcast::new()
    }

    fn clear(&mut self) {
        self.message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSystemBroadcast {
        static instance: CMsgSystemBroadcast = CMsgSystemBroadcast {
            message: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSystemBroadcast {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSystemBroadcast").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSystemBroadcast {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSystemBroadcast {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgClientHello)
pub struct CMsgClientHello {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientHello.version)
    pub version: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientHello.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientHello {
    fn default() -> &'a CMsgClientHello {
        <CMsgClientHello as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientHello {
    pub fn new() -> CMsgClientHello {
        ::std::default::Default::default()
    }

    // optional uint32 version = 1;

    pub fn version(&self) -> u32 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u32) {
        self.version = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &CMsgClientHello| { &m.version },
            |m: &mut CMsgClientHello| { &mut m.version },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientHello>(
            "CMsgClientHello",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientHello {
    const NAME: &'static str = "CMsgClientHello";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.version = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.version {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientHello {
        CMsgClientHello::new()
    }

    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientHello {
        static instance: CMsgClientHello = CMsgClientHello {
            version: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientHello {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientHello").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientHello {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientHello {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgServerHello)
pub struct CMsgServerHello {
    // message fields
    // @@protoc_insertion_point(field:CMsgServerHello.version)
    pub version: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgServerHello.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgServerHello {
    fn default() -> &'a CMsgServerHello {
        <CMsgServerHello as ::protobuf::Message>::default_instance()
    }
}

impl CMsgServerHello {
    pub fn new() -> CMsgServerHello {
        ::std::default::Default::default()
    }

    // optional uint32 version = 1;

    pub fn version(&self) -> u32 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u32) {
        self.version = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &CMsgServerHello| { &m.version },
            |m: &mut CMsgServerHello| { &mut m.version },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgServerHello>(
            "CMsgServerHello",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgServerHello {
    const NAME: &'static str = "CMsgServerHello";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.version = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.version {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgServerHello {
        CMsgServerHello::new()
    }

    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgServerHello {
        static instance: CMsgServerHello = CMsgServerHello {
            version: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgServerHello {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgServerHello").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgServerHello {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgServerHello {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgClientWelcome)
pub struct CMsgClientWelcome {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientWelcome.version)
    pub version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientWelcome.game_data)
    pub game_data: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgClientWelcome.txn_country_code)
    pub txn_country_code: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientWelcome.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientWelcome {
    fn default() -> &'a CMsgClientWelcome {
        <CMsgClientWelcome as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientWelcome {
    pub fn new() -> CMsgClientWelcome {
        ::std::default::Default::default()
    }

    // optional uint32 version = 1;

    pub fn version(&self) -> u32 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u32) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional bytes game_data = 2;

    pub fn game_data(&self) -> &[u8] {
        match self.game_data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_game_data(&mut self) {
        self.game_data = ::std::option::Option::None;
    }

    pub fn has_game_data(&self) -> bool {
        self.game_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.game_data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.game_data.is_none() {
            self.game_data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.game_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_data(&mut self) -> ::std::vec::Vec<u8> {
        self.game_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string txn_country_code = 3;

    pub fn txn_country_code(&self) -> &str {
        match self.txn_country_code.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_txn_country_code(&mut self) {
        self.txn_country_code = ::std::option::Option::None;
    }

    pub fn has_txn_country_code(&self) -> bool {
        self.txn_country_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txn_country_code(&mut self, v: ::std::string::String) {
        self.txn_country_code = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_txn_country_code(&mut self) -> &mut ::std::string::String {
        if self.txn_country_code.is_none() {
            self.txn_country_code = ::std::option::Option::Some(::std::string::String::new());
        }
        self.txn_country_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_txn_country_code(&mut self) -> ::std::string::String {
        self.txn_country_code.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &CMsgClientWelcome| { &m.version },
            |m: &mut CMsgClientWelcome| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_data",
            |m: &CMsgClientWelcome| { &m.game_data },
            |m: &mut CMsgClientWelcome| { &mut m.game_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "txn_country_code",
            |m: &CMsgClientWelcome| { &m.txn_country_code },
            |m: &mut CMsgClientWelcome| { &mut m.txn_country_code },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientWelcome>(
            "CMsgClientWelcome",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientWelcome {
    const NAME: &'static str = "CMsgClientWelcome";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.version = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.game_data = ::std::option::Option::Some(is.read_bytes()?);
                },
                26 => {
                    self.txn_country_code = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.game_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.txn_country_code.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.version {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.game_data.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.txn_country_code.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientWelcome {
        CMsgClientWelcome::new()
    }

    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.game_data = ::std::option::Option::None;
        self.txn_country_code = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientWelcome {
        static instance: CMsgClientWelcome = CMsgClientWelcome {
            version: ::std::option::Option::None,
            game_data: ::std::option::Option::None,
            txn_country_code: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientWelcome {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientWelcome").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientWelcome {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientWelcome {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgServerWelcome)
pub struct CMsgServerWelcome {
    // message fields
    // @@protoc_insertion_point(field:CMsgServerWelcome.min_allowed_version)
    pub min_allowed_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgServerWelcome.active_version)
    pub active_version: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgServerWelcome.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgServerWelcome {
    fn default() -> &'a CMsgServerWelcome {
        <CMsgServerWelcome as ::protobuf::Message>::default_instance()
    }
}

impl CMsgServerWelcome {
    pub fn new() -> CMsgServerWelcome {
        ::std::default::Default::default()
    }

    // optional uint32 min_allowed_version = 1;

    pub fn min_allowed_version(&self) -> u32 {
        self.min_allowed_version.unwrap_or(0)
    }

    pub fn clear_min_allowed_version(&mut self) {
        self.min_allowed_version = ::std::option::Option::None;
    }

    pub fn has_min_allowed_version(&self) -> bool {
        self.min_allowed_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_min_allowed_version(&mut self, v: u32) {
        self.min_allowed_version = ::std::option::Option::Some(v);
    }

    // optional uint32 active_version = 2;

    pub fn active_version(&self) -> u32 {
        self.active_version.unwrap_or(0)
    }

    pub fn clear_active_version(&mut self) {
        self.active_version = ::std::option::Option::None;
    }

    pub fn has_active_version(&self) -> bool {
        self.active_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_active_version(&mut self, v: u32) {
        self.active_version = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "min_allowed_version",
            |m: &CMsgServerWelcome| { &m.min_allowed_version },
            |m: &mut CMsgServerWelcome| { &mut m.min_allowed_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "active_version",
            |m: &CMsgServerWelcome| { &m.active_version },
            |m: &mut CMsgServerWelcome| { &mut m.active_version },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgServerWelcome>(
            "CMsgServerWelcome",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgServerWelcome {
    const NAME: &'static str = "CMsgServerWelcome";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.min_allowed_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.active_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.min_allowed_version {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.active_version {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.min_allowed_version {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.active_version {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgServerWelcome {
        CMsgServerWelcome::new()
    }

    fn clear(&mut self) {
        self.min_allowed_version = ::std::option::Option::None;
        self.active_version = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgServerWelcome {
        static instance: CMsgServerWelcome = CMsgServerWelcome {
            min_allowed_version: ::std::option::Option::None,
            active_version: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgServerWelcome {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgServerWelcome").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgServerWelcome {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgServerWelcome {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgClientGoodbye)
pub struct CMsgClientGoodbye {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientGoodbye.reason)
    pub reason: ::std::option::Option<::protobuf::EnumOrUnknown<GCGoodbyeReason>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientGoodbye.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientGoodbye {
    fn default() -> &'a CMsgClientGoodbye {
        <CMsgClientGoodbye as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientGoodbye {
    pub fn new() -> CMsgClientGoodbye {
        ::std::default::Default::default()
    }

    // optional .GCGoodbyeReason reason = 1;

    pub fn reason(&self) -> GCGoodbyeReason {
        match self.reason {
            Some(e) => e.enum_value_or(GCGoodbyeReason::GCGoodbyeReason_GC_GOING_DOWN),
            None => GCGoodbyeReason::GCGoodbyeReason_GC_GOING_DOWN,
        }
    }

    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: GCGoodbyeReason) {
        self.reason = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reason",
            |m: &CMsgClientGoodbye| { &m.reason },
            |m: &mut CMsgClientGoodbye| { &mut m.reason },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientGoodbye>(
            "CMsgClientGoodbye",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientGoodbye {
    const NAME: &'static str = "CMsgClientGoodbye";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.reason = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.reason {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.reason {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientGoodbye {
        CMsgClientGoodbye::new()
    }

    fn clear(&mut self) {
        self.reason = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientGoodbye {
        static instance: CMsgClientGoodbye = CMsgClientGoodbye {
            reason: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientGoodbye {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientGoodbye").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientGoodbye {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientGoodbye {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgServerGoodbye)
pub struct CMsgServerGoodbye {
    // message fields
    // @@protoc_insertion_point(field:CMsgServerGoodbye.reason)
    pub reason: ::std::option::Option<::protobuf::EnumOrUnknown<GCGoodbyeReason>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgServerGoodbye.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgServerGoodbye {
    fn default() -> &'a CMsgServerGoodbye {
        <CMsgServerGoodbye as ::protobuf::Message>::default_instance()
    }
}

impl CMsgServerGoodbye {
    pub fn new() -> CMsgServerGoodbye {
        ::std::default::Default::default()
    }

    // optional .GCGoodbyeReason reason = 1;

    pub fn reason(&self) -> GCGoodbyeReason {
        match self.reason {
            Some(e) => e.enum_value_or(GCGoodbyeReason::GCGoodbyeReason_GC_GOING_DOWN),
            None => GCGoodbyeReason::GCGoodbyeReason_GC_GOING_DOWN,
        }
    }

    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: GCGoodbyeReason) {
        self.reason = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reason",
            |m: &CMsgServerGoodbye| { &m.reason },
            |m: &mut CMsgServerGoodbye| { &mut m.reason },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgServerGoodbye>(
            "CMsgServerGoodbye",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgServerGoodbye {
    const NAME: &'static str = "CMsgServerGoodbye";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.reason = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.reason {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.reason {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgServerGoodbye {
        CMsgServerGoodbye::new()
    }

    fn clear(&mut self) {
        self.reason = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgServerGoodbye {
        static instance: CMsgServerGoodbye = CMsgServerGoodbye {
            reason: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgServerGoodbye {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgServerGoodbye").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgServerGoodbye {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgServerGoodbye {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgServerAvailable)
pub struct CMsgServerAvailable {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgServerAvailable.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgServerAvailable {
    fn default() -> &'a CMsgServerAvailable {
        <CMsgServerAvailable as ::protobuf::Message>::default_instance()
    }
}

impl CMsgServerAvailable {
    pub fn new() -> CMsgServerAvailable {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgServerAvailable>(
            "CMsgServerAvailable",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgServerAvailable {
    const NAME: &'static str = "CMsgServerAvailable";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgServerAvailable {
        CMsgServerAvailable::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgServerAvailable {
        static instance: CMsgServerAvailable = CMsgServerAvailable {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgServerAvailable {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgServerAvailable").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgServerAvailable {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgServerAvailable {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgLANServerAvailable)
pub struct CMsgLANServerAvailable {
    // message fields
    // @@protoc_insertion_point(field:CMsgLANServerAvailable.lobby_id)
    pub lobby_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgLANServerAvailable.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgLANServerAvailable {
    fn default() -> &'a CMsgLANServerAvailable {
        <CMsgLANServerAvailable as ::protobuf::Message>::default_instance()
    }
}

impl CMsgLANServerAvailable {
    pub fn new() -> CMsgLANServerAvailable {
        ::std::default::Default::default()
    }

    // optional fixed64 lobby_id = 1;

    pub fn lobby_id(&self) -> u64 {
        self.lobby_id.unwrap_or(0)
    }

    pub fn clear_lobby_id(&mut self) {
        self.lobby_id = ::std::option::Option::None;
    }

    pub fn has_lobby_id(&self) -> bool {
        self.lobby_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_id(&mut self, v: u64) {
        self.lobby_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lobby_id",
            |m: &CMsgLANServerAvailable| { &m.lobby_id },
            |m: &mut CMsgLANServerAvailable| { &mut m.lobby_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgLANServerAvailable>(
            "CMsgLANServerAvailable",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgLANServerAvailable {
    const NAME: &'static str = "CMsgLANServerAvailable";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.lobby_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.lobby_id {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.lobby_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgLANServerAvailable {
        CMsgLANServerAvailable::new()
    }

    fn clear(&mut self) {
        self.lobby_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgLANServerAvailable {
        static instance: CMsgLANServerAvailable = CMsgLANServerAvailable {
            lobby_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgLANServerAvailable {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgLANServerAvailable").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgLANServerAvailable {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgLANServerAvailable {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CSOEconGameAccountClient)
pub struct CSOEconGameAccountClient {
    // message fields
    // @@protoc_insertion_point(field:CSOEconGameAccountClient.additional_backpack_slots)
    pub additional_backpack_slots: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconGameAccountClient.trial_account)
    pub trial_account: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSOEconGameAccountClient.need_to_choose_most_helpful_friend)
    pub need_to_choose_most_helpful_friend: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSOEconGameAccountClient.in_coaches_list)
    pub in_coaches_list: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSOEconGameAccountClient.trade_ban_expiration)
    pub trade_ban_expiration: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconGameAccountClient.duel_ban_expiration)
    pub duel_ban_expiration: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconGameAccountClient.preview_item_def)
    pub preview_item_def: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconGameAccountClient.phone_verified)
    pub phone_verified: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSOEconGameAccountClient.skill_rating_6v6)
    pub skill_rating_6v6: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconGameAccountClient.skill_rating_9v9)
    pub skill_rating_9v9: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconGameAccountClient.competitive_access)
    pub competitive_access: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSOEconGameAccountClient.matchmaking_ranked_ban_expiration)
    pub matchmaking_ranked_ban_expiration: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconGameAccountClient.matchmaking_ranked_low_priority_expiration)
    pub matchmaking_ranked_low_priority_expiration: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconGameAccountClient.matchmaking_ranked_ban_last_duration)
    pub matchmaking_ranked_ban_last_duration: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconGameAccountClient.matchmaking_ranked_low_priority_last_duration)
    pub matchmaking_ranked_low_priority_last_duration: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconGameAccountClient.matchmaking_casual_ban_expiration)
    pub matchmaking_casual_ban_expiration: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconGameAccountClient.matchmaking_casual_low_priority_expiration)
    pub matchmaking_casual_low_priority_expiration: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconGameAccountClient.matchmaking_casual_ban_last_duration)
    pub matchmaking_casual_ban_last_duration: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconGameAccountClient.matchmaking_casual_low_priority_last_duration)
    pub matchmaking_casual_low_priority_last_duration: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconGameAccountClient.phone_identifying)
    pub phone_identifying: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSOEconGameAccountClient.disable_party_quest_progress)
    pub disable_party_quest_progress: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSOEconGameAccountClient.quest_reward_credits)
    pub quest_reward_credits: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconGameAccountClient.matchmaking_last_casual_excessive_reports_auto_ban_time)
    pub matchmaking_last_casual_excessive_reports_auto_ban_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconGameAccountClient.matchmaking_last_comp_excessive_reports_auto_ban_time)
    pub matchmaking_last_comp_excessive_reports_auto_ban_time: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSOEconGameAccountClient.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSOEconGameAccountClient {
    fn default() -> &'a CSOEconGameAccountClient {
        <CSOEconGameAccountClient as ::protobuf::Message>::default_instance()
    }
}

impl CSOEconGameAccountClient {
    pub fn new() -> CSOEconGameAccountClient {
        ::std::default::Default::default()
    }

    // optional uint32 additional_backpack_slots = 1;

    pub fn additional_backpack_slots(&self) -> u32 {
        self.additional_backpack_slots.unwrap_or(0u32)
    }

    pub fn clear_additional_backpack_slots(&mut self) {
        self.additional_backpack_slots = ::std::option::Option::None;
    }

    pub fn has_additional_backpack_slots(&self) -> bool {
        self.additional_backpack_slots.is_some()
    }

    // Param is passed by value, moved
    pub fn set_additional_backpack_slots(&mut self, v: u32) {
        self.additional_backpack_slots = ::std::option::Option::Some(v);
    }

    // optional bool trial_account = 2;

    pub fn trial_account(&self) -> bool {
        self.trial_account.unwrap_or(false)
    }

    pub fn clear_trial_account(&mut self) {
        self.trial_account = ::std::option::Option::None;
    }

    pub fn has_trial_account(&self) -> bool {
        self.trial_account.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trial_account(&mut self, v: bool) {
        self.trial_account = ::std::option::Option::Some(v);
    }

    // optional bool need_to_choose_most_helpful_friend = 4;

    pub fn need_to_choose_most_helpful_friend(&self) -> bool {
        self.need_to_choose_most_helpful_friend.unwrap_or(false)
    }

    pub fn clear_need_to_choose_most_helpful_friend(&mut self) {
        self.need_to_choose_most_helpful_friend = ::std::option::Option::None;
    }

    pub fn has_need_to_choose_most_helpful_friend(&self) -> bool {
        self.need_to_choose_most_helpful_friend.is_some()
    }

    // Param is passed by value, moved
    pub fn set_need_to_choose_most_helpful_friend(&mut self, v: bool) {
        self.need_to_choose_most_helpful_friend = ::std::option::Option::Some(v);
    }

    // optional bool in_coaches_list = 5;

    pub fn in_coaches_list(&self) -> bool {
        self.in_coaches_list.unwrap_or(false)
    }

    pub fn clear_in_coaches_list(&mut self) {
        self.in_coaches_list = ::std::option::Option::None;
    }

    pub fn has_in_coaches_list(&self) -> bool {
        self.in_coaches_list.is_some()
    }

    // Param is passed by value, moved
    pub fn set_in_coaches_list(&mut self, v: bool) {
        self.in_coaches_list = ::std::option::Option::Some(v);
    }

    // optional fixed32 trade_ban_expiration = 6;

    pub fn trade_ban_expiration(&self) -> u32 {
        self.trade_ban_expiration.unwrap_or(0)
    }

    pub fn clear_trade_ban_expiration(&mut self) {
        self.trade_ban_expiration = ::std::option::Option::None;
    }

    pub fn has_trade_ban_expiration(&self) -> bool {
        self.trade_ban_expiration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trade_ban_expiration(&mut self, v: u32) {
        self.trade_ban_expiration = ::std::option::Option::Some(v);
    }

    // optional fixed32 duel_ban_expiration = 7;

    pub fn duel_ban_expiration(&self) -> u32 {
        self.duel_ban_expiration.unwrap_or(0)
    }

    pub fn clear_duel_ban_expiration(&mut self) {
        self.duel_ban_expiration = ::std::option::Option::None;
    }

    pub fn has_duel_ban_expiration(&self) -> bool {
        self.duel_ban_expiration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duel_ban_expiration(&mut self, v: u32) {
        self.duel_ban_expiration = ::std::option::Option::Some(v);
    }

    // optional uint32 preview_item_def = 8;

    pub fn preview_item_def(&self) -> u32 {
        self.preview_item_def.unwrap_or(0u32)
    }

    pub fn clear_preview_item_def(&mut self) {
        self.preview_item_def = ::std::option::Option::None;
    }

    pub fn has_preview_item_def(&self) -> bool {
        self.preview_item_def.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preview_item_def(&mut self, v: u32) {
        self.preview_item_def = ::std::option::Option::Some(v);
    }

    // optional bool phone_verified = 19;

    pub fn phone_verified(&self) -> bool {
        self.phone_verified.unwrap_or(false)
    }

    pub fn clear_phone_verified(&mut self) {
        self.phone_verified = ::std::option::Option::None;
    }

    pub fn has_phone_verified(&self) -> bool {
        self.phone_verified.is_some()
    }

    // Param is passed by value, moved
    pub fn set_phone_verified(&mut self, v: bool) {
        self.phone_verified = ::std::option::Option::Some(v);
    }

    // optional uint32 skill_rating_6v6 = 20;

    pub fn skill_rating_6v6(&self) -> u32 {
        self.skill_rating_6v6.unwrap_or(0)
    }

    pub fn clear_skill_rating_6v6(&mut self) {
        self.skill_rating_6v6 = ::std::option::Option::None;
    }

    pub fn has_skill_rating_6v6(&self) -> bool {
        self.skill_rating_6v6.is_some()
    }

    // Param is passed by value, moved
    pub fn set_skill_rating_6v6(&mut self, v: u32) {
        self.skill_rating_6v6 = ::std::option::Option::Some(v);
    }

    // optional uint32 skill_rating_9v9 = 21;

    pub fn skill_rating_9v9(&self) -> u32 {
        self.skill_rating_9v9.unwrap_or(0)
    }

    pub fn clear_skill_rating_9v9(&mut self) {
        self.skill_rating_9v9 = ::std::option::Option::None;
    }

    pub fn has_skill_rating_9v9(&self) -> bool {
        self.skill_rating_9v9.is_some()
    }

    // Param is passed by value, moved
    pub fn set_skill_rating_9v9(&mut self, v: u32) {
        self.skill_rating_9v9 = ::std::option::Option::Some(v);
    }

    // optional bool competitive_access = 23;

    pub fn competitive_access(&self) -> bool {
        self.competitive_access.unwrap_or(false)
    }

    pub fn clear_competitive_access(&mut self) {
        self.competitive_access = ::std::option::Option::None;
    }

    pub fn has_competitive_access(&self) -> bool {
        self.competitive_access.is_some()
    }

    // Param is passed by value, moved
    pub fn set_competitive_access(&mut self, v: bool) {
        self.competitive_access = ::std::option::Option::Some(v);
    }

    // optional uint32 matchmaking_ranked_ban_expiration = 18;

    pub fn matchmaking_ranked_ban_expiration(&self) -> u32 {
        self.matchmaking_ranked_ban_expiration.unwrap_or(0)
    }

    pub fn clear_matchmaking_ranked_ban_expiration(&mut self) {
        self.matchmaking_ranked_ban_expiration = ::std::option::Option::None;
    }

    pub fn has_matchmaking_ranked_ban_expiration(&self) -> bool {
        self.matchmaking_ranked_ban_expiration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matchmaking_ranked_ban_expiration(&mut self, v: u32) {
        self.matchmaking_ranked_ban_expiration = ::std::option::Option::Some(v);
    }

    // optional uint32 matchmaking_ranked_low_priority_expiration = 24;

    pub fn matchmaking_ranked_low_priority_expiration(&self) -> u32 {
        self.matchmaking_ranked_low_priority_expiration.unwrap_or(0)
    }

    pub fn clear_matchmaking_ranked_low_priority_expiration(&mut self) {
        self.matchmaking_ranked_low_priority_expiration = ::std::option::Option::None;
    }

    pub fn has_matchmaking_ranked_low_priority_expiration(&self) -> bool {
        self.matchmaking_ranked_low_priority_expiration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matchmaking_ranked_low_priority_expiration(&mut self, v: u32) {
        self.matchmaking_ranked_low_priority_expiration = ::std::option::Option::Some(v);
    }

    // optional uint32 matchmaking_ranked_ban_last_duration = 25;

    pub fn matchmaking_ranked_ban_last_duration(&self) -> u32 {
        self.matchmaking_ranked_ban_last_duration.unwrap_or(0)
    }

    pub fn clear_matchmaking_ranked_ban_last_duration(&mut self) {
        self.matchmaking_ranked_ban_last_duration = ::std::option::Option::None;
    }

    pub fn has_matchmaking_ranked_ban_last_duration(&self) -> bool {
        self.matchmaking_ranked_ban_last_duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matchmaking_ranked_ban_last_duration(&mut self, v: u32) {
        self.matchmaking_ranked_ban_last_duration = ::std::option::Option::Some(v);
    }

    // optional uint32 matchmaking_ranked_low_priority_last_duration = 26;

    pub fn matchmaking_ranked_low_priority_last_duration(&self) -> u32 {
        self.matchmaking_ranked_low_priority_last_duration.unwrap_or(0)
    }

    pub fn clear_matchmaking_ranked_low_priority_last_duration(&mut self) {
        self.matchmaking_ranked_low_priority_last_duration = ::std::option::Option::None;
    }

    pub fn has_matchmaking_ranked_low_priority_last_duration(&self) -> bool {
        self.matchmaking_ranked_low_priority_last_duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matchmaking_ranked_low_priority_last_duration(&mut self, v: u32) {
        self.matchmaking_ranked_low_priority_last_duration = ::std::option::Option::Some(v);
    }

    // optional uint32 matchmaking_casual_ban_expiration = 27;

    pub fn matchmaking_casual_ban_expiration(&self) -> u32 {
        self.matchmaking_casual_ban_expiration.unwrap_or(0)
    }

    pub fn clear_matchmaking_casual_ban_expiration(&mut self) {
        self.matchmaking_casual_ban_expiration = ::std::option::Option::None;
    }

    pub fn has_matchmaking_casual_ban_expiration(&self) -> bool {
        self.matchmaking_casual_ban_expiration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matchmaking_casual_ban_expiration(&mut self, v: u32) {
        self.matchmaking_casual_ban_expiration = ::std::option::Option::Some(v);
    }

    // optional uint32 matchmaking_casual_low_priority_expiration = 28;

    pub fn matchmaking_casual_low_priority_expiration(&self) -> u32 {
        self.matchmaking_casual_low_priority_expiration.unwrap_or(0)
    }

    pub fn clear_matchmaking_casual_low_priority_expiration(&mut self) {
        self.matchmaking_casual_low_priority_expiration = ::std::option::Option::None;
    }

    pub fn has_matchmaking_casual_low_priority_expiration(&self) -> bool {
        self.matchmaking_casual_low_priority_expiration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matchmaking_casual_low_priority_expiration(&mut self, v: u32) {
        self.matchmaking_casual_low_priority_expiration = ::std::option::Option::Some(v);
    }

    // optional uint32 matchmaking_casual_ban_last_duration = 29;

    pub fn matchmaking_casual_ban_last_duration(&self) -> u32 {
        self.matchmaking_casual_ban_last_duration.unwrap_or(0)
    }

    pub fn clear_matchmaking_casual_ban_last_duration(&mut self) {
        self.matchmaking_casual_ban_last_duration = ::std::option::Option::None;
    }

    pub fn has_matchmaking_casual_ban_last_duration(&self) -> bool {
        self.matchmaking_casual_ban_last_duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matchmaking_casual_ban_last_duration(&mut self, v: u32) {
        self.matchmaking_casual_ban_last_duration = ::std::option::Option::Some(v);
    }

    // optional uint32 matchmaking_casual_low_priority_last_duration = 30;

    pub fn matchmaking_casual_low_priority_last_duration(&self) -> u32 {
        self.matchmaking_casual_low_priority_last_duration.unwrap_or(0)
    }

    pub fn clear_matchmaking_casual_low_priority_last_duration(&mut self) {
        self.matchmaking_casual_low_priority_last_duration = ::std::option::Option::None;
    }

    pub fn has_matchmaking_casual_low_priority_last_duration(&self) -> bool {
        self.matchmaking_casual_low_priority_last_duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matchmaking_casual_low_priority_last_duration(&mut self, v: u32) {
        self.matchmaking_casual_low_priority_last_duration = ::std::option::Option::Some(v);
    }

    // optional bool phone_identifying = 31;

    pub fn phone_identifying(&self) -> bool {
        self.phone_identifying.unwrap_or(false)
    }

    pub fn clear_phone_identifying(&mut self) {
        self.phone_identifying = ::std::option::Option::None;
    }

    pub fn has_phone_identifying(&self) -> bool {
        self.phone_identifying.is_some()
    }

    // Param is passed by value, moved
    pub fn set_phone_identifying(&mut self, v: bool) {
        self.phone_identifying = ::std::option::Option::Some(v);
    }

    // optional bool disable_party_quest_progress = 32;

    pub fn disable_party_quest_progress(&self) -> bool {
        self.disable_party_quest_progress.unwrap_or(false)
    }

    pub fn clear_disable_party_quest_progress(&mut self) {
        self.disable_party_quest_progress = ::std::option::Option::None;
    }

    pub fn has_disable_party_quest_progress(&self) -> bool {
        self.disable_party_quest_progress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_disable_party_quest_progress(&mut self, v: bool) {
        self.disable_party_quest_progress = ::std::option::Option::Some(v);
    }

    // optional uint32 quest_reward_credits = 33;

    pub fn quest_reward_credits(&self) -> u32 {
        self.quest_reward_credits.unwrap_or(0)
    }

    pub fn clear_quest_reward_credits(&mut self) {
        self.quest_reward_credits = ::std::option::Option::None;
    }

    pub fn has_quest_reward_credits(&self) -> bool {
        self.quest_reward_credits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quest_reward_credits(&mut self, v: u32) {
        self.quest_reward_credits = ::std::option::Option::Some(v);
    }

    // optional uint32 matchmaking_last_casual_excessive_reports_auto_ban_time = 34;

    pub fn matchmaking_last_casual_excessive_reports_auto_ban_time(&self) -> u32 {
        self.matchmaking_last_casual_excessive_reports_auto_ban_time.unwrap_or(0)
    }

    pub fn clear_matchmaking_last_casual_excessive_reports_auto_ban_time(&mut self) {
        self.matchmaking_last_casual_excessive_reports_auto_ban_time = ::std::option::Option::None;
    }

    pub fn has_matchmaking_last_casual_excessive_reports_auto_ban_time(&self) -> bool {
        self.matchmaking_last_casual_excessive_reports_auto_ban_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matchmaking_last_casual_excessive_reports_auto_ban_time(&mut self, v: u32) {
        self.matchmaking_last_casual_excessive_reports_auto_ban_time = ::std::option::Option::Some(v);
    }

    // optional uint32 matchmaking_last_comp_excessive_reports_auto_ban_time = 35;

    pub fn matchmaking_last_comp_excessive_reports_auto_ban_time(&self) -> u32 {
        self.matchmaking_last_comp_excessive_reports_auto_ban_time.unwrap_or(0)
    }

    pub fn clear_matchmaking_last_comp_excessive_reports_auto_ban_time(&mut self) {
        self.matchmaking_last_comp_excessive_reports_auto_ban_time = ::std::option::Option::None;
    }

    pub fn has_matchmaking_last_comp_excessive_reports_auto_ban_time(&self) -> bool {
        self.matchmaking_last_comp_excessive_reports_auto_ban_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matchmaking_last_comp_excessive_reports_auto_ban_time(&mut self, v: u32) {
        self.matchmaking_last_comp_excessive_reports_auto_ban_time = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(24);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "additional_backpack_slots",
            |m: &CSOEconGameAccountClient| { &m.additional_backpack_slots },
            |m: &mut CSOEconGameAccountClient| { &mut m.additional_backpack_slots },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "trial_account",
            |m: &CSOEconGameAccountClient| { &m.trial_account },
            |m: &mut CSOEconGameAccountClient| { &mut m.trial_account },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "need_to_choose_most_helpful_friend",
            |m: &CSOEconGameAccountClient| { &m.need_to_choose_most_helpful_friend },
            |m: &mut CSOEconGameAccountClient| { &mut m.need_to_choose_most_helpful_friend },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "in_coaches_list",
            |m: &CSOEconGameAccountClient| { &m.in_coaches_list },
            |m: &mut CSOEconGameAccountClient| { &mut m.in_coaches_list },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "trade_ban_expiration",
            |m: &CSOEconGameAccountClient| { &m.trade_ban_expiration },
            |m: &mut CSOEconGameAccountClient| { &mut m.trade_ban_expiration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "duel_ban_expiration",
            |m: &CSOEconGameAccountClient| { &m.duel_ban_expiration },
            |m: &mut CSOEconGameAccountClient| { &mut m.duel_ban_expiration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "preview_item_def",
            |m: &CSOEconGameAccountClient| { &m.preview_item_def },
            |m: &mut CSOEconGameAccountClient| { &mut m.preview_item_def },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "phone_verified",
            |m: &CSOEconGameAccountClient| { &m.phone_verified },
            |m: &mut CSOEconGameAccountClient| { &mut m.phone_verified },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "skill_rating_6v6",
            |m: &CSOEconGameAccountClient| { &m.skill_rating_6v6 },
            |m: &mut CSOEconGameAccountClient| { &mut m.skill_rating_6v6 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "skill_rating_9v9",
            |m: &CSOEconGameAccountClient| { &m.skill_rating_9v9 },
            |m: &mut CSOEconGameAccountClient| { &mut m.skill_rating_9v9 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "competitive_access",
            |m: &CSOEconGameAccountClient| { &m.competitive_access },
            |m: &mut CSOEconGameAccountClient| { &mut m.competitive_access },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "matchmaking_ranked_ban_expiration",
            |m: &CSOEconGameAccountClient| { &m.matchmaking_ranked_ban_expiration },
            |m: &mut CSOEconGameAccountClient| { &mut m.matchmaking_ranked_ban_expiration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "matchmaking_ranked_low_priority_expiration",
            |m: &CSOEconGameAccountClient| { &m.matchmaking_ranked_low_priority_expiration },
            |m: &mut CSOEconGameAccountClient| { &mut m.matchmaking_ranked_low_priority_expiration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "matchmaking_ranked_ban_last_duration",
            |m: &CSOEconGameAccountClient| { &m.matchmaking_ranked_ban_last_duration },
            |m: &mut CSOEconGameAccountClient| { &mut m.matchmaking_ranked_ban_last_duration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "matchmaking_ranked_low_priority_last_duration",
            |m: &CSOEconGameAccountClient| { &m.matchmaking_ranked_low_priority_last_duration },
            |m: &mut CSOEconGameAccountClient| { &mut m.matchmaking_ranked_low_priority_last_duration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "matchmaking_casual_ban_expiration",
            |m: &CSOEconGameAccountClient| { &m.matchmaking_casual_ban_expiration },
            |m: &mut CSOEconGameAccountClient| { &mut m.matchmaking_casual_ban_expiration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "matchmaking_casual_low_priority_expiration",
            |m: &CSOEconGameAccountClient| { &m.matchmaking_casual_low_priority_expiration },
            |m: &mut CSOEconGameAccountClient| { &mut m.matchmaking_casual_low_priority_expiration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "matchmaking_casual_ban_last_duration",
            |m: &CSOEconGameAccountClient| { &m.matchmaking_casual_ban_last_duration },
            |m: &mut CSOEconGameAccountClient| { &mut m.matchmaking_casual_ban_last_duration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "matchmaking_casual_low_priority_last_duration",
            |m: &CSOEconGameAccountClient| { &m.matchmaking_casual_low_priority_last_duration },
            |m: &mut CSOEconGameAccountClient| { &mut m.matchmaking_casual_low_priority_last_duration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "phone_identifying",
            |m: &CSOEconGameAccountClient| { &m.phone_identifying },
            |m: &mut CSOEconGameAccountClient| { &mut m.phone_identifying },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "disable_party_quest_progress",
            |m: &CSOEconGameAccountClient| { &m.disable_party_quest_progress },
            |m: &mut CSOEconGameAccountClient| { &mut m.disable_party_quest_progress },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "quest_reward_credits",
            |m: &CSOEconGameAccountClient| { &m.quest_reward_credits },
            |m: &mut CSOEconGameAccountClient| { &mut m.quest_reward_credits },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "matchmaking_last_casual_excessive_reports_auto_ban_time",
            |m: &CSOEconGameAccountClient| { &m.matchmaking_last_casual_excessive_reports_auto_ban_time },
            |m: &mut CSOEconGameAccountClient| { &mut m.matchmaking_last_casual_excessive_reports_auto_ban_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "matchmaking_last_comp_excessive_reports_auto_ban_time",
            |m: &CSOEconGameAccountClient| { &m.matchmaking_last_comp_excessive_reports_auto_ban_time },
            |m: &mut CSOEconGameAccountClient| { &mut m.matchmaking_last_comp_excessive_reports_auto_ban_time },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSOEconGameAccountClient>(
            "CSOEconGameAccountClient",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSOEconGameAccountClient {
    const NAME: &'static str = "CSOEconGameAccountClient";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.additional_backpack_slots = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.trial_account = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.need_to_choose_most_helpful_friend = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.in_coaches_list = ::std::option::Option::Some(is.read_bool()?);
                },
                53 => {
                    self.trade_ban_expiration = ::std::option::Option::Some(is.read_fixed32()?);
                },
                61 => {
                    self.duel_ban_expiration = ::std::option::Option::Some(is.read_fixed32()?);
                },
                64 => {
                    self.preview_item_def = ::std::option::Option::Some(is.read_uint32()?);
                },
                152 => {
                    self.phone_verified = ::std::option::Option::Some(is.read_bool()?);
                },
                160 => {
                    self.skill_rating_6v6 = ::std::option::Option::Some(is.read_uint32()?);
                },
                168 => {
                    self.skill_rating_9v9 = ::std::option::Option::Some(is.read_uint32()?);
                },
                184 => {
                    self.competitive_access = ::std::option::Option::Some(is.read_bool()?);
                },
                144 => {
                    self.matchmaking_ranked_ban_expiration = ::std::option::Option::Some(is.read_uint32()?);
                },
                192 => {
                    self.matchmaking_ranked_low_priority_expiration = ::std::option::Option::Some(is.read_uint32()?);
                },
                200 => {
                    self.matchmaking_ranked_ban_last_duration = ::std::option::Option::Some(is.read_uint32()?);
                },
                208 => {
                    self.matchmaking_ranked_low_priority_last_duration = ::std::option::Option::Some(is.read_uint32()?);
                },
                216 => {
                    self.matchmaking_casual_ban_expiration = ::std::option::Option::Some(is.read_uint32()?);
                },
                224 => {
                    self.matchmaking_casual_low_priority_expiration = ::std::option::Option::Some(is.read_uint32()?);
                },
                232 => {
                    self.matchmaking_casual_ban_last_duration = ::std::option::Option::Some(is.read_uint32()?);
                },
                240 => {
                    self.matchmaking_casual_low_priority_last_duration = ::std::option::Option::Some(is.read_uint32()?);
                },
                248 => {
                    self.phone_identifying = ::std::option::Option::Some(is.read_bool()?);
                },
                256 => {
                    self.disable_party_quest_progress = ::std::option::Option::Some(is.read_bool()?);
                },
                264 => {
                    self.quest_reward_credits = ::std::option::Option::Some(is.read_uint32()?);
                },
                272 => {
                    self.matchmaking_last_casual_excessive_reports_auto_ban_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                280 => {
                    self.matchmaking_last_comp_excessive_reports_auto_ban_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.additional_backpack_slots {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.trial_account {
            my_size += 1 + 1;
        }
        if let Some(v) = self.need_to_choose_most_helpful_friend {
            my_size += 1 + 1;
        }
        if let Some(v) = self.in_coaches_list {
            my_size += 1 + 1;
        }
        if let Some(v) = self.trade_ban_expiration {
            my_size += 1 + 4;
        }
        if let Some(v) = self.duel_ban_expiration {
            my_size += 1 + 4;
        }
        if let Some(v) = self.preview_item_def {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.phone_verified {
            my_size += 2 + 1;
        }
        if let Some(v) = self.skill_rating_6v6 {
            my_size += ::protobuf::rt::uint32_size(20, v);
        }
        if let Some(v) = self.skill_rating_9v9 {
            my_size += ::protobuf::rt::uint32_size(21, v);
        }
        if let Some(v) = self.competitive_access {
            my_size += 2 + 1;
        }
        if let Some(v) = self.matchmaking_ranked_ban_expiration {
            my_size += ::protobuf::rt::uint32_size(18, v);
        }
        if let Some(v) = self.matchmaking_ranked_low_priority_expiration {
            my_size += ::protobuf::rt::uint32_size(24, v);
        }
        if let Some(v) = self.matchmaking_ranked_ban_last_duration {
            my_size += ::protobuf::rt::uint32_size(25, v);
        }
        if let Some(v) = self.matchmaking_ranked_low_priority_last_duration {
            my_size += ::protobuf::rt::uint32_size(26, v);
        }
        if let Some(v) = self.matchmaking_casual_ban_expiration {
            my_size += ::protobuf::rt::uint32_size(27, v);
        }
        if let Some(v) = self.matchmaking_casual_low_priority_expiration {
            my_size += ::protobuf::rt::uint32_size(28, v);
        }
        if let Some(v) = self.matchmaking_casual_ban_last_duration {
            my_size += ::protobuf::rt::uint32_size(29, v);
        }
        if let Some(v) = self.matchmaking_casual_low_priority_last_duration {
            my_size += ::protobuf::rt::uint32_size(30, v);
        }
        if let Some(v) = self.phone_identifying {
            my_size += 2 + 1;
        }
        if let Some(v) = self.disable_party_quest_progress {
            my_size += 2 + 1;
        }
        if let Some(v) = self.quest_reward_credits {
            my_size += ::protobuf::rt::uint32_size(33, v);
        }
        if let Some(v) = self.matchmaking_last_casual_excessive_reports_auto_ban_time {
            my_size += ::protobuf::rt::uint32_size(34, v);
        }
        if let Some(v) = self.matchmaking_last_comp_excessive_reports_auto_ban_time {
            my_size += ::protobuf::rt::uint32_size(35, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.additional_backpack_slots {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.trial_account {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.need_to_choose_most_helpful_friend {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.in_coaches_list {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.trade_ban_expiration {
            os.write_fixed32(6, v)?;
        }
        if let Some(v) = self.duel_ban_expiration {
            os.write_fixed32(7, v)?;
        }
        if let Some(v) = self.preview_item_def {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.phone_verified {
            os.write_bool(19, v)?;
        }
        if let Some(v) = self.skill_rating_6v6 {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.skill_rating_9v9 {
            os.write_uint32(21, v)?;
        }
        if let Some(v) = self.competitive_access {
            os.write_bool(23, v)?;
        }
        if let Some(v) = self.matchmaking_ranked_ban_expiration {
            os.write_uint32(18, v)?;
        }
        if let Some(v) = self.matchmaking_ranked_low_priority_expiration {
            os.write_uint32(24, v)?;
        }
        if let Some(v) = self.matchmaking_ranked_ban_last_duration {
            os.write_uint32(25, v)?;
        }
        if let Some(v) = self.matchmaking_ranked_low_priority_last_duration {
            os.write_uint32(26, v)?;
        }
        if let Some(v) = self.matchmaking_casual_ban_expiration {
            os.write_uint32(27, v)?;
        }
        if let Some(v) = self.matchmaking_casual_low_priority_expiration {
            os.write_uint32(28, v)?;
        }
        if let Some(v) = self.matchmaking_casual_ban_last_duration {
            os.write_uint32(29, v)?;
        }
        if let Some(v) = self.matchmaking_casual_low_priority_last_duration {
            os.write_uint32(30, v)?;
        }
        if let Some(v) = self.phone_identifying {
            os.write_bool(31, v)?;
        }
        if let Some(v) = self.disable_party_quest_progress {
            os.write_bool(32, v)?;
        }
        if let Some(v) = self.quest_reward_credits {
            os.write_uint32(33, v)?;
        }
        if let Some(v) = self.matchmaking_last_casual_excessive_reports_auto_ban_time {
            os.write_uint32(34, v)?;
        }
        if let Some(v) = self.matchmaking_last_comp_excessive_reports_auto_ban_time {
            os.write_uint32(35, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSOEconGameAccountClient {
        CSOEconGameAccountClient::new()
    }

    fn clear(&mut self) {
        self.additional_backpack_slots = ::std::option::Option::None;
        self.trial_account = ::std::option::Option::None;
        self.need_to_choose_most_helpful_friend = ::std::option::Option::None;
        self.in_coaches_list = ::std::option::Option::None;
        self.trade_ban_expiration = ::std::option::Option::None;
        self.duel_ban_expiration = ::std::option::Option::None;
        self.preview_item_def = ::std::option::Option::None;
        self.phone_verified = ::std::option::Option::None;
        self.skill_rating_6v6 = ::std::option::Option::None;
        self.skill_rating_9v9 = ::std::option::Option::None;
        self.competitive_access = ::std::option::Option::None;
        self.matchmaking_ranked_ban_expiration = ::std::option::Option::None;
        self.matchmaking_ranked_low_priority_expiration = ::std::option::Option::None;
        self.matchmaking_ranked_ban_last_duration = ::std::option::Option::None;
        self.matchmaking_ranked_low_priority_last_duration = ::std::option::Option::None;
        self.matchmaking_casual_ban_expiration = ::std::option::Option::None;
        self.matchmaking_casual_low_priority_expiration = ::std::option::Option::None;
        self.matchmaking_casual_ban_last_duration = ::std::option::Option::None;
        self.matchmaking_casual_low_priority_last_duration = ::std::option::Option::None;
        self.phone_identifying = ::std::option::Option::None;
        self.disable_party_quest_progress = ::std::option::Option::None;
        self.quest_reward_credits = ::std::option::Option::None;
        self.matchmaking_last_casual_excessive_reports_auto_ban_time = ::std::option::Option::None;
        self.matchmaking_last_comp_excessive_reports_auto_ban_time = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSOEconGameAccountClient {
        static instance: CSOEconGameAccountClient = CSOEconGameAccountClient {
            additional_backpack_slots: ::std::option::Option::None,
            trial_account: ::std::option::Option::None,
            need_to_choose_most_helpful_friend: ::std::option::Option::None,
            in_coaches_list: ::std::option::Option::None,
            trade_ban_expiration: ::std::option::Option::None,
            duel_ban_expiration: ::std::option::Option::None,
            preview_item_def: ::std::option::Option::None,
            phone_verified: ::std::option::Option::None,
            skill_rating_6v6: ::std::option::Option::None,
            skill_rating_9v9: ::std::option::Option::None,
            competitive_access: ::std::option::Option::None,
            matchmaking_ranked_ban_expiration: ::std::option::Option::None,
            matchmaking_ranked_low_priority_expiration: ::std::option::Option::None,
            matchmaking_ranked_ban_last_duration: ::std::option::Option::None,
            matchmaking_ranked_low_priority_last_duration: ::std::option::Option::None,
            matchmaking_casual_ban_expiration: ::std::option::Option::None,
            matchmaking_casual_low_priority_expiration: ::std::option::Option::None,
            matchmaking_casual_ban_last_duration: ::std::option::Option::None,
            matchmaking_casual_low_priority_last_duration: ::std::option::Option::None,
            phone_identifying: ::std::option::Option::None,
            disable_party_quest_progress: ::std::option::Option::None,
            quest_reward_credits: ::std::option::Option::None,
            matchmaking_last_casual_excessive_reports_auto_ban_time: ::std::option::Option::None,
            matchmaking_last_comp_excessive_reports_auto_ban_time: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSOEconGameAccountClient {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSOEconGameAccountClient").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSOEconGameAccountClient {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOEconGameAccountClient {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CSOItemCriteriaCondition)
pub struct CSOItemCriteriaCondition {
    // message fields
    // @@protoc_insertion_point(field:CSOItemCriteriaCondition.op)
    pub op: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSOItemCriteriaCondition.field)
    pub field: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSOItemCriteriaCondition.required)
    pub required: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSOItemCriteriaCondition.float_value)
    pub float_value: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CSOItemCriteriaCondition.string_value)
    pub string_value: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CSOItemCriteriaCondition.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSOItemCriteriaCondition {
    fn default() -> &'a CSOItemCriteriaCondition {
        <CSOItemCriteriaCondition as ::protobuf::Message>::default_instance()
    }
}

impl CSOItemCriteriaCondition {
    pub fn new() -> CSOItemCriteriaCondition {
        ::std::default::Default::default()
    }

    // optional int32 op = 1;

    pub fn op(&self) -> i32 {
        self.op.unwrap_or(0)
    }

    pub fn clear_op(&mut self) {
        self.op = ::std::option::Option::None;
    }

    pub fn has_op(&self) -> bool {
        self.op.is_some()
    }

    // Param is passed by value, moved
    pub fn set_op(&mut self, v: i32) {
        self.op = ::std::option::Option::Some(v);
    }

    // optional string field = 2;

    pub fn field(&self) -> &str {
        match self.field.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_field(&mut self) {
        self.field = ::std::option::Option::None;
    }

    pub fn has_field(&self) -> bool {
        self.field.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field(&mut self, v: ::std::string::String) {
        self.field = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field(&mut self) -> &mut ::std::string::String {
        if self.field.is_none() {
            self.field = ::std::option::Option::Some(::std::string::String::new());
        }
        self.field.as_mut().unwrap()
    }

    // Take field
    pub fn take_field(&mut self) -> ::std::string::String {
        self.field.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool required = 3;

    pub fn required(&self) -> bool {
        self.required.unwrap_or(false)
    }

    pub fn clear_required(&mut self) {
        self.required = ::std::option::Option::None;
    }

    pub fn has_required(&self) -> bool {
        self.required.is_some()
    }

    // Param is passed by value, moved
    pub fn set_required(&mut self, v: bool) {
        self.required = ::std::option::Option::Some(v);
    }

    // optional float float_value = 4;

    pub fn float_value(&self) -> f32 {
        self.float_value.unwrap_or(0.)
    }

    pub fn clear_float_value(&mut self) {
        self.float_value = ::std::option::Option::None;
    }

    pub fn has_float_value(&self) -> bool {
        self.float_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_float_value(&mut self, v: f32) {
        self.float_value = ::std::option::Option::Some(v);
    }

    // optional string string_value = 5;

    pub fn string_value(&self) -> &str {
        match self.string_value.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_string_value(&mut self) {
        self.string_value = ::std::option::Option::None;
    }

    pub fn has_string_value(&self) -> bool {
        self.string_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_string_value(&mut self, v: ::std::string::String) {
        self.string_value = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_string_value(&mut self) -> &mut ::std::string::String {
        if self.string_value.is_none() {
            self.string_value = ::std::option::Option::Some(::std::string::String::new());
        }
        self.string_value.as_mut().unwrap()
    }

    // Take field
    pub fn take_string_value(&mut self) -> ::std::string::String {
        self.string_value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "op",
            |m: &CSOItemCriteriaCondition| { &m.op },
            |m: &mut CSOItemCriteriaCondition| { &mut m.op },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "field",
            |m: &CSOItemCriteriaCondition| { &m.field },
            |m: &mut CSOItemCriteriaCondition| { &mut m.field },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "required",
            |m: &CSOItemCriteriaCondition| { &m.required },
            |m: &mut CSOItemCriteriaCondition| { &mut m.required },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "float_value",
            |m: &CSOItemCriteriaCondition| { &m.float_value },
            |m: &mut CSOItemCriteriaCondition| { &mut m.float_value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "string_value",
            |m: &CSOItemCriteriaCondition| { &m.string_value },
            |m: &mut CSOItemCriteriaCondition| { &mut m.string_value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSOItemCriteriaCondition>(
            "CSOItemCriteriaCondition",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSOItemCriteriaCondition {
    const NAME: &'static str = "CSOItemCriteriaCondition";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.op = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.field = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.required = ::std::option::Option::Some(is.read_bool()?);
                },
                37 => {
                    self.float_value = ::std::option::Option::Some(is.read_float()?);
                },
                42 => {
                    self.string_value = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.op {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.field.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.required {
            my_size += 1 + 1;
        }
        if let Some(v) = self.float_value {
            my_size += 1 + 4;
        }
        if let Some(v) = self.string_value.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.op {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.field.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.required {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.float_value {
            os.write_float(4, v)?;
        }
        if let Some(v) = self.string_value.as_ref() {
            os.write_string(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSOItemCriteriaCondition {
        CSOItemCriteriaCondition::new()
    }

    fn clear(&mut self) {
        self.op = ::std::option::Option::None;
        self.field = ::std::option::Option::None;
        self.required = ::std::option::Option::None;
        self.float_value = ::std::option::Option::None;
        self.string_value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSOItemCriteriaCondition {
        static instance: CSOItemCriteriaCondition = CSOItemCriteriaCondition {
            op: ::std::option::Option::None,
            field: ::std::option::Option::None,
            required: ::std::option::Option::None,
            float_value: ::std::option::Option::None,
            string_value: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSOItemCriteriaCondition {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSOItemCriteriaCondition").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSOItemCriteriaCondition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOItemCriteriaCondition {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CSOItemCriteria)
pub struct CSOItemCriteria {
    // message fields
    // @@protoc_insertion_point(field:CSOItemCriteria.item_level)
    pub item_level: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOItemCriteria.item_quality)
    pub item_quality: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSOItemCriteria.item_level_set)
    pub item_level_set: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSOItemCriteria.item_quality_set)
    pub item_quality_set: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSOItemCriteria.initial_inventory)
    pub initial_inventory: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOItemCriteria.initial_quantity)
    pub initial_quantity: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOItemCriteria.ignore_enabled_flag)
    pub ignore_enabled_flag: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSOItemCriteria.conditions)
    pub conditions: ::std::vec::Vec<CSOItemCriteriaCondition>,
    // @@protoc_insertion_point(field:CSOItemCriteria.recent_only)
    pub recent_only: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSOItemCriteria.tags)
    pub tags: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSOItemCriteria.equip_regions)
    pub equip_regions: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CSOItemCriteria.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSOItemCriteria {
    fn default() -> &'a CSOItemCriteria {
        <CSOItemCriteria as ::protobuf::Message>::default_instance()
    }
}

impl CSOItemCriteria {
    pub fn new() -> CSOItemCriteria {
        ::std::default::Default::default()
    }

    // optional uint32 item_level = 1;

    pub fn item_level(&self) -> u32 {
        self.item_level.unwrap_or(0)
    }

    pub fn clear_item_level(&mut self) {
        self.item_level = ::std::option::Option::None;
    }

    pub fn has_item_level(&self) -> bool {
        self.item_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_level(&mut self, v: u32) {
        self.item_level = ::std::option::Option::Some(v);
    }

    // optional int32 item_quality = 2;

    pub fn item_quality(&self) -> i32 {
        self.item_quality.unwrap_or(0)
    }

    pub fn clear_item_quality(&mut self) {
        self.item_quality = ::std::option::Option::None;
    }

    pub fn has_item_quality(&self) -> bool {
        self.item_quality.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_quality(&mut self, v: i32) {
        self.item_quality = ::std::option::Option::Some(v);
    }

    // optional bool item_level_set = 3;

    pub fn item_level_set(&self) -> bool {
        self.item_level_set.unwrap_or(false)
    }

    pub fn clear_item_level_set(&mut self) {
        self.item_level_set = ::std::option::Option::None;
    }

    pub fn has_item_level_set(&self) -> bool {
        self.item_level_set.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_level_set(&mut self, v: bool) {
        self.item_level_set = ::std::option::Option::Some(v);
    }

    // optional bool item_quality_set = 4;

    pub fn item_quality_set(&self) -> bool {
        self.item_quality_set.unwrap_or(false)
    }

    pub fn clear_item_quality_set(&mut self) {
        self.item_quality_set = ::std::option::Option::None;
    }

    pub fn has_item_quality_set(&self) -> bool {
        self.item_quality_set.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_quality_set(&mut self, v: bool) {
        self.item_quality_set = ::std::option::Option::Some(v);
    }

    // optional uint32 initial_inventory = 5;

    pub fn initial_inventory(&self) -> u32 {
        self.initial_inventory.unwrap_or(0)
    }

    pub fn clear_initial_inventory(&mut self) {
        self.initial_inventory = ::std::option::Option::None;
    }

    pub fn has_initial_inventory(&self) -> bool {
        self.initial_inventory.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initial_inventory(&mut self, v: u32) {
        self.initial_inventory = ::std::option::Option::Some(v);
    }

    // optional uint32 initial_quantity = 6;

    pub fn initial_quantity(&self) -> u32 {
        self.initial_quantity.unwrap_or(0)
    }

    pub fn clear_initial_quantity(&mut self) {
        self.initial_quantity = ::std::option::Option::None;
    }

    pub fn has_initial_quantity(&self) -> bool {
        self.initial_quantity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initial_quantity(&mut self, v: u32) {
        self.initial_quantity = ::std::option::Option::Some(v);
    }

    // optional bool ignore_enabled_flag = 8;

    pub fn ignore_enabled_flag(&self) -> bool {
        self.ignore_enabled_flag.unwrap_or(false)
    }

    pub fn clear_ignore_enabled_flag(&mut self) {
        self.ignore_enabled_flag = ::std::option::Option::None;
    }

    pub fn has_ignore_enabled_flag(&self) -> bool {
        self.ignore_enabled_flag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ignore_enabled_flag(&mut self, v: bool) {
        self.ignore_enabled_flag = ::std::option::Option::Some(v);
    }

    // optional bool recent_only = 10;

    pub fn recent_only(&self) -> bool {
        self.recent_only.unwrap_or(false)
    }

    pub fn clear_recent_only(&mut self) {
        self.recent_only = ::std::option::Option::None;
    }

    pub fn has_recent_only(&self) -> bool {
        self.recent_only.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recent_only(&mut self, v: bool) {
        self.recent_only = ::std::option::Option::Some(v);
    }

    // optional string tags = 11;

    pub fn tags(&self) -> &str {
        match self.tags.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_tags(&mut self) {
        self.tags = ::std::option::Option::None;
    }

    pub fn has_tags(&self) -> bool {
        self.tags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tags(&mut self, v: ::std::string::String) {
        self.tags = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tags(&mut self) -> &mut ::std::string::String {
        if self.tags.is_none() {
            self.tags = ::std::option::Option::Some(::std::string::String::new());
        }
        self.tags.as_mut().unwrap()
    }

    // Take field
    pub fn take_tags(&mut self) -> ::std::string::String {
        self.tags.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string equip_regions = 12;

    pub fn equip_regions(&self) -> &str {
        match self.equip_regions.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_equip_regions(&mut self) {
        self.equip_regions = ::std::option::Option::None;
    }

    pub fn has_equip_regions(&self) -> bool {
        self.equip_regions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_equip_regions(&mut self, v: ::std::string::String) {
        self.equip_regions = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_equip_regions(&mut self) -> &mut ::std::string::String {
        if self.equip_regions.is_none() {
            self.equip_regions = ::std::option::Option::Some(::std::string::String::new());
        }
        self.equip_regions.as_mut().unwrap()
    }

    // Take field
    pub fn take_equip_regions(&mut self) -> ::std::string::String {
        self.equip_regions.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(11);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_level",
            |m: &CSOItemCriteria| { &m.item_level },
            |m: &mut CSOItemCriteria| { &mut m.item_level },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_quality",
            |m: &CSOItemCriteria| { &m.item_quality },
            |m: &mut CSOItemCriteria| { &mut m.item_quality },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_level_set",
            |m: &CSOItemCriteria| { &m.item_level_set },
            |m: &mut CSOItemCriteria| { &mut m.item_level_set },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_quality_set",
            |m: &CSOItemCriteria| { &m.item_quality_set },
            |m: &mut CSOItemCriteria| { &mut m.item_quality_set },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "initial_inventory",
            |m: &CSOItemCriteria| { &m.initial_inventory },
            |m: &mut CSOItemCriteria| { &mut m.initial_inventory },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "initial_quantity",
            |m: &CSOItemCriteria| { &m.initial_quantity },
            |m: &mut CSOItemCriteria| { &mut m.initial_quantity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ignore_enabled_flag",
            |m: &CSOItemCriteria| { &m.ignore_enabled_flag },
            |m: &mut CSOItemCriteria| { &mut m.ignore_enabled_flag },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "conditions",
            |m: &CSOItemCriteria| { &m.conditions },
            |m: &mut CSOItemCriteria| { &mut m.conditions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "recent_only",
            |m: &CSOItemCriteria| { &m.recent_only },
            |m: &mut CSOItemCriteria| { &mut m.recent_only },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tags",
            |m: &CSOItemCriteria| { &m.tags },
            |m: &mut CSOItemCriteria| { &mut m.tags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "equip_regions",
            |m: &CSOItemCriteria| { &m.equip_regions },
            |m: &mut CSOItemCriteria| { &mut m.equip_regions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSOItemCriteria>(
            "CSOItemCriteria",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSOItemCriteria {
    const NAME: &'static str = "CSOItemCriteria";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_level = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.item_quality = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.item_level_set = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.item_quality_set = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.initial_inventory = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.initial_quantity = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.ignore_enabled_flag = ::std::option::Option::Some(is.read_bool()?);
                },
                74 => {
                    self.conditions.push(is.read_message()?);
                },
                80 => {
                    self.recent_only = ::std::option::Option::Some(is.read_bool()?);
                },
                90 => {
                    self.tags = ::std::option::Option::Some(is.read_string()?);
                },
                98 => {
                    self.equip_regions = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_level {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.item_quality {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.item_level_set {
            my_size += 1 + 1;
        }
        if let Some(v) = self.item_quality_set {
            my_size += 1 + 1;
        }
        if let Some(v) = self.initial_inventory {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.initial_quantity {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.ignore_enabled_flag {
            my_size += 1 + 1;
        }
        for value in &self.conditions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.recent_only {
            my_size += 1 + 1;
        }
        if let Some(v) = self.tags.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(v) = self.equip_regions.as_ref() {
            my_size += ::protobuf::rt::string_size(12, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.item_level {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.item_quality {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.item_level_set {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.item_quality_set {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.initial_inventory {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.initial_quantity {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.ignore_enabled_flag {
            os.write_bool(8, v)?;
        }
        for v in &self.conditions {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        };
        if let Some(v) = self.recent_only {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.tags.as_ref() {
            os.write_string(11, v)?;
        }
        if let Some(v) = self.equip_regions.as_ref() {
            os.write_string(12, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSOItemCriteria {
        CSOItemCriteria::new()
    }

    fn clear(&mut self) {
        self.item_level = ::std::option::Option::None;
        self.item_quality = ::std::option::Option::None;
        self.item_level_set = ::std::option::Option::None;
        self.item_quality_set = ::std::option::Option::None;
        self.initial_inventory = ::std::option::Option::None;
        self.initial_quantity = ::std::option::Option::None;
        self.ignore_enabled_flag = ::std::option::Option::None;
        self.conditions.clear();
        self.recent_only = ::std::option::Option::None;
        self.tags = ::std::option::Option::None;
        self.equip_regions = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSOItemCriteria {
        static instance: CSOItemCriteria = CSOItemCriteria {
            item_level: ::std::option::Option::None,
            item_quality: ::std::option::Option::None,
            item_level_set: ::std::option::Option::None,
            item_quality_set: ::std::option::Option::None,
            initial_inventory: ::std::option::Option::None,
            initial_quantity: ::std::option::Option::None,
            ignore_enabled_flag: ::std::option::Option::None,
            conditions: ::std::vec::Vec::new(),
            recent_only: ::std::option::Option::None,
            tags: ::std::option::Option::None,
            equip_regions: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSOItemCriteria {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSOItemCriteria").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSOItemCriteria {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOItemCriteria {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CSOItemRecipe)
pub struct CSOItemRecipe {
    // message fields
    // @@protoc_insertion_point(field:CSOItemRecipe.def_index)
    pub def_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOItemRecipe.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSOItemRecipe.n_a)
    pub n_a: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSOItemRecipe.desc_inputs)
    pub desc_inputs: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSOItemRecipe.desc_outputs)
    pub desc_outputs: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSOItemRecipe.di_a)
    pub di_a: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSOItemRecipe.di_b)
    pub di_b: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSOItemRecipe.di_c)
    pub di_c: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSOItemRecipe.do_a)
    pub do_a: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSOItemRecipe.do_b)
    pub do_b: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSOItemRecipe.do_c)
    pub do_c: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSOItemRecipe.requires_all_same_class)
    pub requires_all_same_class: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSOItemRecipe.requires_all_same_slot)
    pub requires_all_same_slot: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSOItemRecipe.class_usage_for_output)
    pub class_usage_for_output: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSOItemRecipe.slot_usage_for_output)
    pub slot_usage_for_output: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSOItemRecipe.set_for_output)
    pub set_for_output: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSOItemRecipe.input_items_criteria)
    pub input_items_criteria: ::std::vec::Vec<CSOItemCriteria>,
    // @@protoc_insertion_point(field:CSOItemRecipe.output_items_criteria)
    pub output_items_criteria: ::std::vec::Vec<CSOItemCriteria>,
    // @@protoc_insertion_point(field:CSOItemRecipe.input_item_dupe_counts)
    pub input_item_dupe_counts: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSOItemRecipe.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSOItemRecipe {
    fn default() -> &'a CSOItemRecipe {
        <CSOItemRecipe as ::protobuf::Message>::default_instance()
    }
}

impl CSOItemRecipe {
    pub fn new() -> CSOItemRecipe {
        ::std::default::Default::default()
    }

    // optional uint32 def_index = 1;

    pub fn def_index(&self) -> u32 {
        self.def_index.unwrap_or(0)
    }

    pub fn clear_def_index(&mut self) {
        self.def_index = ::std::option::Option::None;
    }

    pub fn has_def_index(&self) -> bool {
        self.def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_def_index(&mut self, v: u32) {
        self.def_index = ::std::option::Option::Some(v);
    }

    // optional string name = 2;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string n_a = 3;

    pub fn n_a(&self) -> &str {
        match self.n_a.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_n_a(&mut self) {
        self.n_a = ::std::option::Option::None;
    }

    pub fn has_n_a(&self) -> bool {
        self.n_a.is_some()
    }

    // Param is passed by value, moved
    pub fn set_n_a(&mut self, v: ::std::string::String) {
        self.n_a = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_n_a(&mut self) -> &mut ::std::string::String {
        if self.n_a.is_none() {
            self.n_a = ::std::option::Option::Some(::std::string::String::new());
        }
        self.n_a.as_mut().unwrap()
    }

    // Take field
    pub fn take_n_a(&mut self) -> ::std::string::String {
        self.n_a.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string desc_inputs = 4;

    pub fn desc_inputs(&self) -> &str {
        match self.desc_inputs.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_desc_inputs(&mut self) {
        self.desc_inputs = ::std::option::Option::None;
    }

    pub fn has_desc_inputs(&self) -> bool {
        self.desc_inputs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desc_inputs(&mut self, v: ::std::string::String) {
        self.desc_inputs = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_desc_inputs(&mut self) -> &mut ::std::string::String {
        if self.desc_inputs.is_none() {
            self.desc_inputs = ::std::option::Option::Some(::std::string::String::new());
        }
        self.desc_inputs.as_mut().unwrap()
    }

    // Take field
    pub fn take_desc_inputs(&mut self) -> ::std::string::String {
        self.desc_inputs.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string desc_outputs = 5;

    pub fn desc_outputs(&self) -> &str {
        match self.desc_outputs.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_desc_outputs(&mut self) {
        self.desc_outputs = ::std::option::Option::None;
    }

    pub fn has_desc_outputs(&self) -> bool {
        self.desc_outputs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desc_outputs(&mut self, v: ::std::string::String) {
        self.desc_outputs = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_desc_outputs(&mut self) -> &mut ::std::string::String {
        if self.desc_outputs.is_none() {
            self.desc_outputs = ::std::option::Option::Some(::std::string::String::new());
        }
        self.desc_outputs.as_mut().unwrap()
    }

    // Take field
    pub fn take_desc_outputs(&mut self) -> ::std::string::String {
        self.desc_outputs.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string di_a = 6;

    pub fn di_a(&self) -> &str {
        match self.di_a.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_di_a(&mut self) {
        self.di_a = ::std::option::Option::None;
    }

    pub fn has_di_a(&self) -> bool {
        self.di_a.is_some()
    }

    // Param is passed by value, moved
    pub fn set_di_a(&mut self, v: ::std::string::String) {
        self.di_a = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_di_a(&mut self) -> &mut ::std::string::String {
        if self.di_a.is_none() {
            self.di_a = ::std::option::Option::Some(::std::string::String::new());
        }
        self.di_a.as_mut().unwrap()
    }

    // Take field
    pub fn take_di_a(&mut self) -> ::std::string::String {
        self.di_a.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string di_b = 7;

    pub fn di_b(&self) -> &str {
        match self.di_b.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_di_b(&mut self) {
        self.di_b = ::std::option::Option::None;
    }

    pub fn has_di_b(&self) -> bool {
        self.di_b.is_some()
    }

    // Param is passed by value, moved
    pub fn set_di_b(&mut self, v: ::std::string::String) {
        self.di_b = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_di_b(&mut self) -> &mut ::std::string::String {
        if self.di_b.is_none() {
            self.di_b = ::std::option::Option::Some(::std::string::String::new());
        }
        self.di_b.as_mut().unwrap()
    }

    // Take field
    pub fn take_di_b(&mut self) -> ::std::string::String {
        self.di_b.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string di_c = 8;

    pub fn di_c(&self) -> &str {
        match self.di_c.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_di_c(&mut self) {
        self.di_c = ::std::option::Option::None;
    }

    pub fn has_di_c(&self) -> bool {
        self.di_c.is_some()
    }

    // Param is passed by value, moved
    pub fn set_di_c(&mut self, v: ::std::string::String) {
        self.di_c = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_di_c(&mut self) -> &mut ::std::string::String {
        if self.di_c.is_none() {
            self.di_c = ::std::option::Option::Some(::std::string::String::new());
        }
        self.di_c.as_mut().unwrap()
    }

    // Take field
    pub fn take_di_c(&mut self) -> ::std::string::String {
        self.di_c.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string do_a = 9;

    pub fn do_a(&self) -> &str {
        match self.do_a.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_do_a(&mut self) {
        self.do_a = ::std::option::Option::None;
    }

    pub fn has_do_a(&self) -> bool {
        self.do_a.is_some()
    }

    // Param is passed by value, moved
    pub fn set_do_a(&mut self, v: ::std::string::String) {
        self.do_a = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_do_a(&mut self) -> &mut ::std::string::String {
        if self.do_a.is_none() {
            self.do_a = ::std::option::Option::Some(::std::string::String::new());
        }
        self.do_a.as_mut().unwrap()
    }

    // Take field
    pub fn take_do_a(&mut self) -> ::std::string::String {
        self.do_a.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string do_b = 10;

    pub fn do_b(&self) -> &str {
        match self.do_b.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_do_b(&mut self) {
        self.do_b = ::std::option::Option::None;
    }

    pub fn has_do_b(&self) -> bool {
        self.do_b.is_some()
    }

    // Param is passed by value, moved
    pub fn set_do_b(&mut self, v: ::std::string::String) {
        self.do_b = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_do_b(&mut self) -> &mut ::std::string::String {
        if self.do_b.is_none() {
            self.do_b = ::std::option::Option::Some(::std::string::String::new());
        }
        self.do_b.as_mut().unwrap()
    }

    // Take field
    pub fn take_do_b(&mut self) -> ::std::string::String {
        self.do_b.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string do_c = 11;

    pub fn do_c(&self) -> &str {
        match self.do_c.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_do_c(&mut self) {
        self.do_c = ::std::option::Option::None;
    }

    pub fn has_do_c(&self) -> bool {
        self.do_c.is_some()
    }

    // Param is passed by value, moved
    pub fn set_do_c(&mut self, v: ::std::string::String) {
        self.do_c = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_do_c(&mut self) -> &mut ::std::string::String {
        if self.do_c.is_none() {
            self.do_c = ::std::option::Option::Some(::std::string::String::new());
        }
        self.do_c.as_mut().unwrap()
    }

    // Take field
    pub fn take_do_c(&mut self) -> ::std::string::String {
        self.do_c.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool requires_all_same_class = 12;

    pub fn requires_all_same_class(&self) -> bool {
        self.requires_all_same_class.unwrap_or(false)
    }

    pub fn clear_requires_all_same_class(&mut self) {
        self.requires_all_same_class = ::std::option::Option::None;
    }

    pub fn has_requires_all_same_class(&self) -> bool {
        self.requires_all_same_class.is_some()
    }

    // Param is passed by value, moved
    pub fn set_requires_all_same_class(&mut self, v: bool) {
        self.requires_all_same_class = ::std::option::Option::Some(v);
    }

    // optional bool requires_all_same_slot = 13;

    pub fn requires_all_same_slot(&self) -> bool {
        self.requires_all_same_slot.unwrap_or(false)
    }

    pub fn clear_requires_all_same_slot(&mut self) {
        self.requires_all_same_slot = ::std::option::Option::None;
    }

    pub fn has_requires_all_same_slot(&self) -> bool {
        self.requires_all_same_slot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_requires_all_same_slot(&mut self, v: bool) {
        self.requires_all_same_slot = ::std::option::Option::Some(v);
    }

    // optional int32 class_usage_for_output = 14;

    pub fn class_usage_for_output(&self) -> i32 {
        self.class_usage_for_output.unwrap_or(0)
    }

    pub fn clear_class_usage_for_output(&mut self) {
        self.class_usage_for_output = ::std::option::Option::None;
    }

    pub fn has_class_usage_for_output(&self) -> bool {
        self.class_usage_for_output.is_some()
    }

    // Param is passed by value, moved
    pub fn set_class_usage_for_output(&mut self, v: i32) {
        self.class_usage_for_output = ::std::option::Option::Some(v);
    }

    // optional int32 slot_usage_for_output = 15;

    pub fn slot_usage_for_output(&self) -> i32 {
        self.slot_usage_for_output.unwrap_or(0)
    }

    pub fn clear_slot_usage_for_output(&mut self) {
        self.slot_usage_for_output = ::std::option::Option::None;
    }

    pub fn has_slot_usage_for_output(&self) -> bool {
        self.slot_usage_for_output.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slot_usage_for_output(&mut self, v: i32) {
        self.slot_usage_for_output = ::std::option::Option::Some(v);
    }

    // optional int32 set_for_output = 16;

    pub fn set_for_output(&self) -> i32 {
        self.set_for_output.unwrap_or(0)
    }

    pub fn clear_set_for_output(&mut self) {
        self.set_for_output = ::std::option::Option::None;
    }

    pub fn has_set_for_output(&self) -> bool {
        self.set_for_output.is_some()
    }

    // Param is passed by value, moved
    pub fn set_set_for_output(&mut self, v: i32) {
        self.set_for_output = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(19);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "def_index",
            |m: &CSOItemRecipe| { &m.def_index },
            |m: &mut CSOItemRecipe| { &mut m.def_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &CSOItemRecipe| { &m.name },
            |m: &mut CSOItemRecipe| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "n_a",
            |m: &CSOItemRecipe| { &m.n_a },
            |m: &mut CSOItemRecipe| { &mut m.n_a },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "desc_inputs",
            |m: &CSOItemRecipe| { &m.desc_inputs },
            |m: &mut CSOItemRecipe| { &mut m.desc_inputs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "desc_outputs",
            |m: &CSOItemRecipe| { &m.desc_outputs },
            |m: &mut CSOItemRecipe| { &mut m.desc_outputs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "di_a",
            |m: &CSOItemRecipe| { &m.di_a },
            |m: &mut CSOItemRecipe| { &mut m.di_a },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "di_b",
            |m: &CSOItemRecipe| { &m.di_b },
            |m: &mut CSOItemRecipe| { &mut m.di_b },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "di_c",
            |m: &CSOItemRecipe| { &m.di_c },
            |m: &mut CSOItemRecipe| { &mut m.di_c },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "do_a",
            |m: &CSOItemRecipe| { &m.do_a },
            |m: &mut CSOItemRecipe| { &mut m.do_a },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "do_b",
            |m: &CSOItemRecipe| { &m.do_b },
            |m: &mut CSOItemRecipe| { &mut m.do_b },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "do_c",
            |m: &CSOItemRecipe| { &m.do_c },
            |m: &mut CSOItemRecipe| { &mut m.do_c },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "requires_all_same_class",
            |m: &CSOItemRecipe| { &m.requires_all_same_class },
            |m: &mut CSOItemRecipe| { &mut m.requires_all_same_class },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "requires_all_same_slot",
            |m: &CSOItemRecipe| { &m.requires_all_same_slot },
            |m: &mut CSOItemRecipe| { &mut m.requires_all_same_slot },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "class_usage_for_output",
            |m: &CSOItemRecipe| { &m.class_usage_for_output },
            |m: &mut CSOItemRecipe| { &mut m.class_usage_for_output },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "slot_usage_for_output",
            |m: &CSOItemRecipe| { &m.slot_usage_for_output },
            |m: &mut CSOItemRecipe| { &mut m.slot_usage_for_output },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "set_for_output",
            |m: &CSOItemRecipe| { &m.set_for_output },
            |m: &mut CSOItemRecipe| { &mut m.set_for_output },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "input_items_criteria",
            |m: &CSOItemRecipe| { &m.input_items_criteria },
            |m: &mut CSOItemRecipe| { &mut m.input_items_criteria },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "output_items_criteria",
            |m: &CSOItemRecipe| { &m.output_items_criteria },
            |m: &mut CSOItemRecipe| { &mut m.output_items_criteria },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "input_item_dupe_counts",
            |m: &CSOItemRecipe| { &m.input_item_dupe_counts },
            |m: &mut CSOItemRecipe| { &mut m.input_item_dupe_counts },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSOItemRecipe>(
            "CSOItemRecipe",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSOItemRecipe {
    const NAME: &'static str = "CSOItemRecipe";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.def_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.n_a = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.desc_inputs = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.desc_outputs = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.di_a = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    self.di_b = ::std::option::Option::Some(is.read_string()?);
                },
                66 => {
                    self.di_c = ::std::option::Option::Some(is.read_string()?);
                },
                74 => {
                    self.do_a = ::std::option::Option::Some(is.read_string()?);
                },
                82 => {
                    self.do_b = ::std::option::Option::Some(is.read_string()?);
                },
                90 => {
                    self.do_c = ::std::option::Option::Some(is.read_string()?);
                },
                96 => {
                    self.requires_all_same_class = ::std::option::Option::Some(is.read_bool()?);
                },
                104 => {
                    self.requires_all_same_slot = ::std::option::Option::Some(is.read_bool()?);
                },
                112 => {
                    self.class_usage_for_output = ::std::option::Option::Some(is.read_int32()?);
                },
                120 => {
                    self.slot_usage_for_output = ::std::option::Option::Some(is.read_int32()?);
                },
                128 => {
                    self.set_for_output = ::std::option::Option::Some(is.read_int32()?);
                },
                162 => {
                    self.input_items_criteria.push(is.read_message()?);
                },
                170 => {
                    self.output_items_criteria.push(is.read_message()?);
                },
                178 => {
                    is.read_repeated_packed_uint32_into(&mut self.input_item_dupe_counts)?;
                },
                176 => {
                    self.input_item_dupe_counts.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.def_index {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.n_a.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.desc_inputs.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.desc_outputs.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.di_a.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.di_b.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.di_c.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.do_a.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(v) = self.do_b.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(v) = self.do_c.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(v) = self.requires_all_same_class {
            my_size += 1 + 1;
        }
        if let Some(v) = self.requires_all_same_slot {
            my_size += 1 + 1;
        }
        if let Some(v) = self.class_usage_for_output {
            my_size += ::protobuf::rt::int32_size(14, v);
        }
        if let Some(v) = self.slot_usage_for_output {
            my_size += ::protobuf::rt::int32_size(15, v);
        }
        if let Some(v) = self.set_for_output {
            my_size += ::protobuf::rt::int32_size(16, v);
        }
        for value in &self.input_items_criteria {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.output_items_criteria {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.input_item_dupe_counts {
            my_size += ::protobuf::rt::uint32_size(22, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.def_index {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.n_a.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.desc_inputs.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.desc_outputs.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.di_a.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.di_b.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.di_c.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.do_a.as_ref() {
            os.write_string(9, v)?;
        }
        if let Some(v) = self.do_b.as_ref() {
            os.write_string(10, v)?;
        }
        if let Some(v) = self.do_c.as_ref() {
            os.write_string(11, v)?;
        }
        if let Some(v) = self.requires_all_same_class {
            os.write_bool(12, v)?;
        }
        if let Some(v) = self.requires_all_same_slot {
            os.write_bool(13, v)?;
        }
        if let Some(v) = self.class_usage_for_output {
            os.write_int32(14, v)?;
        }
        if let Some(v) = self.slot_usage_for_output {
            os.write_int32(15, v)?;
        }
        if let Some(v) = self.set_for_output {
            os.write_int32(16, v)?;
        }
        for v in &self.input_items_criteria {
            ::protobuf::rt::write_message_field_with_cached_size(20, v, os)?;
        };
        for v in &self.output_items_criteria {
            ::protobuf::rt::write_message_field_with_cached_size(21, v, os)?;
        };
        for v in &self.input_item_dupe_counts {
            os.write_uint32(22, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSOItemRecipe {
        CSOItemRecipe::new()
    }

    fn clear(&mut self) {
        self.def_index = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.n_a = ::std::option::Option::None;
        self.desc_inputs = ::std::option::Option::None;
        self.desc_outputs = ::std::option::Option::None;
        self.di_a = ::std::option::Option::None;
        self.di_b = ::std::option::Option::None;
        self.di_c = ::std::option::Option::None;
        self.do_a = ::std::option::Option::None;
        self.do_b = ::std::option::Option::None;
        self.do_c = ::std::option::Option::None;
        self.requires_all_same_class = ::std::option::Option::None;
        self.requires_all_same_slot = ::std::option::Option::None;
        self.class_usage_for_output = ::std::option::Option::None;
        self.slot_usage_for_output = ::std::option::Option::None;
        self.set_for_output = ::std::option::Option::None;
        self.input_items_criteria.clear();
        self.output_items_criteria.clear();
        self.input_item_dupe_counts.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSOItemRecipe {
        static instance: CSOItemRecipe = CSOItemRecipe {
            def_index: ::std::option::Option::None,
            name: ::std::option::Option::None,
            n_a: ::std::option::Option::None,
            desc_inputs: ::std::option::Option::None,
            desc_outputs: ::std::option::Option::None,
            di_a: ::std::option::Option::None,
            di_b: ::std::option::Option::None,
            di_c: ::std::option::Option::None,
            do_a: ::std::option::Option::None,
            do_b: ::std::option::Option::None,
            do_c: ::std::option::Option::None,
            requires_all_same_class: ::std::option::Option::None,
            requires_all_same_slot: ::std::option::Option::None,
            class_usage_for_output: ::std::option::Option::None,
            slot_usage_for_output: ::std::option::Option::None,
            set_for_output: ::std::option::Option::None,
            input_items_criteria: ::std::vec::Vec::new(),
            output_items_criteria: ::std::vec::Vec::new(),
            input_item_dupe_counts: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSOItemRecipe {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSOItemRecipe").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSOItemRecipe {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOItemRecipe {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgDevNewItemRequest)
pub struct CMsgDevNewItemRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgDevNewItemRequest.receiver)
    pub receiver: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgDevNewItemRequest.criteria)
    pub criteria: ::protobuf::MessageField<CSOItemCriteria>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDevNewItemRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDevNewItemRequest {
    fn default() -> &'a CMsgDevNewItemRequest {
        <CMsgDevNewItemRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDevNewItemRequest {
    pub fn new() -> CMsgDevNewItemRequest {
        ::std::default::Default::default()
    }

    // optional fixed64 receiver = 1;

    pub fn receiver(&self) -> u64 {
        self.receiver.unwrap_or(0)
    }

    pub fn clear_receiver(&mut self) {
        self.receiver = ::std::option::Option::None;
    }

    pub fn has_receiver(&self) -> bool {
        self.receiver.is_some()
    }

    // Param is passed by value, moved
    pub fn set_receiver(&mut self, v: u64) {
        self.receiver = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "receiver",
            |m: &CMsgDevNewItemRequest| { &m.receiver },
            |m: &mut CMsgDevNewItemRequest| { &mut m.receiver },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CSOItemCriteria>(
            "criteria",
            |m: &CMsgDevNewItemRequest| { &m.criteria },
            |m: &mut CMsgDevNewItemRequest| { &mut m.criteria },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgDevNewItemRequest>(
            "CMsgDevNewItemRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgDevNewItemRequest {
    const NAME: &'static str = "CMsgDevNewItemRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.receiver = ::std::option::Option::Some(is.read_fixed64()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.criteria)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.receiver {
            my_size += 1 + 8;
        }
        if let Some(v) = self.criteria.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.receiver {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.criteria.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDevNewItemRequest {
        CMsgDevNewItemRequest::new()
    }

    fn clear(&mut self) {
        self.receiver = ::std::option::Option::None;
        self.criteria.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDevNewItemRequest {
        static instance: CMsgDevNewItemRequest = CMsgDevNewItemRequest {
            receiver: ::std::option::Option::None,
            criteria: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgDevNewItemRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgDevNewItemRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgDevNewItemRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDevNewItemRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgDevDebugRollLootRequest)
pub struct CMsgDevDebugRollLootRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgDevDebugRollLootRequest.receiver)
    pub receiver: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgDevDebugRollLootRequest.loot_list_name)
    pub loot_list_name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDevDebugRollLootRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDevDebugRollLootRequest {
    fn default() -> &'a CMsgDevDebugRollLootRequest {
        <CMsgDevDebugRollLootRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDevDebugRollLootRequest {
    pub fn new() -> CMsgDevDebugRollLootRequest {
        ::std::default::Default::default()
    }

    // optional fixed64 receiver = 1;

    pub fn receiver(&self) -> u64 {
        self.receiver.unwrap_or(0)
    }

    pub fn clear_receiver(&mut self) {
        self.receiver = ::std::option::Option::None;
    }

    pub fn has_receiver(&self) -> bool {
        self.receiver.is_some()
    }

    // Param is passed by value, moved
    pub fn set_receiver(&mut self, v: u64) {
        self.receiver = ::std::option::Option::Some(v);
    }

    // optional string loot_list_name = 2;

    pub fn loot_list_name(&self) -> &str {
        match self.loot_list_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_loot_list_name(&mut self) {
        self.loot_list_name = ::std::option::Option::None;
    }

    pub fn has_loot_list_name(&self) -> bool {
        self.loot_list_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_loot_list_name(&mut self, v: ::std::string::String) {
        self.loot_list_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_loot_list_name(&mut self) -> &mut ::std::string::String {
        if self.loot_list_name.is_none() {
            self.loot_list_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.loot_list_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_loot_list_name(&mut self) -> ::std::string::String {
        self.loot_list_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "receiver",
            |m: &CMsgDevDebugRollLootRequest| { &m.receiver },
            |m: &mut CMsgDevDebugRollLootRequest| { &mut m.receiver },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "loot_list_name",
            |m: &CMsgDevDebugRollLootRequest| { &m.loot_list_name },
            |m: &mut CMsgDevDebugRollLootRequest| { &mut m.loot_list_name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgDevDebugRollLootRequest>(
            "CMsgDevDebugRollLootRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgDevDebugRollLootRequest {
    const NAME: &'static str = "CMsgDevDebugRollLootRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.receiver = ::std::option::Option::Some(is.read_fixed64()?);
                },
                18 => {
                    self.loot_list_name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.receiver {
            my_size += 1 + 8;
        }
        if let Some(v) = self.loot_list_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.receiver {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.loot_list_name.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDevDebugRollLootRequest {
        CMsgDevDebugRollLootRequest::new()
    }

    fn clear(&mut self) {
        self.receiver = ::std::option::Option::None;
        self.loot_list_name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDevDebugRollLootRequest {
        static instance: CMsgDevDebugRollLootRequest = CMsgDevDebugRollLootRequest {
            receiver: ::std::option::Option::None,
            loot_list_name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgDevDebugRollLootRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgDevDebugRollLootRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgDevDebugRollLootRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDevDebugRollLootRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgIncrementKillCountAttribute)
pub struct CMsgIncrementKillCountAttribute {
    // message fields
    // @@protoc_insertion_point(field:CMsgIncrementKillCountAttribute.killer_steam_id)
    pub killer_steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgIncrementKillCountAttribute.victim_steam_id)
    pub victim_steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgIncrementKillCountAttribute.item_id)
    pub item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgIncrementKillCountAttribute.event_type)
    pub event_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgIncrementKillCountAttribute.increment_value)
    pub increment_value: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgIncrementKillCountAttribute.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgIncrementKillCountAttribute {
    fn default() -> &'a CMsgIncrementKillCountAttribute {
        <CMsgIncrementKillCountAttribute as ::protobuf::Message>::default_instance()
    }
}

impl CMsgIncrementKillCountAttribute {
    pub fn new() -> CMsgIncrementKillCountAttribute {
        ::std::default::Default::default()
    }

    // optional uint64 killer_steam_id = 1;

    pub fn killer_steam_id(&self) -> u64 {
        self.killer_steam_id.unwrap_or(0)
    }

    pub fn clear_killer_steam_id(&mut self) {
        self.killer_steam_id = ::std::option::Option::None;
    }

    pub fn has_killer_steam_id(&self) -> bool {
        self.killer_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_killer_steam_id(&mut self, v: u64) {
        self.killer_steam_id = ::std::option::Option::Some(v);
    }

    // optional uint64 victim_steam_id = 2;

    pub fn victim_steam_id(&self) -> u64 {
        self.victim_steam_id.unwrap_or(0)
    }

    pub fn clear_victim_steam_id(&mut self) {
        self.victim_steam_id = ::std::option::Option::None;
    }

    pub fn has_victim_steam_id(&self) -> bool {
        self.victim_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_victim_steam_id(&mut self, v: u64) {
        self.victim_steam_id = ::std::option::Option::Some(v);
    }

    // optional uint64 item_id = 3;

    pub fn item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    // optional uint32 event_type = 4;

    pub fn event_type(&self) -> u32 {
        self.event_type.unwrap_or(0)
    }

    pub fn clear_event_type(&mut self) {
        self.event_type = ::std::option::Option::None;
    }

    pub fn has_event_type(&self) -> bool {
        self.event_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_type(&mut self, v: u32) {
        self.event_type = ::std::option::Option::Some(v);
    }

    // optional uint32 increment_value = 5;

    pub fn increment_value(&self) -> u32 {
        self.increment_value.unwrap_or(0)
    }

    pub fn clear_increment_value(&mut self) {
        self.increment_value = ::std::option::Option::None;
    }

    pub fn has_increment_value(&self) -> bool {
        self.increment_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_increment_value(&mut self, v: u32) {
        self.increment_value = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "killer_steam_id",
            |m: &CMsgIncrementKillCountAttribute| { &m.killer_steam_id },
            |m: &mut CMsgIncrementKillCountAttribute| { &mut m.killer_steam_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "victim_steam_id",
            |m: &CMsgIncrementKillCountAttribute| { &m.victim_steam_id },
            |m: &mut CMsgIncrementKillCountAttribute| { &mut m.victim_steam_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_id",
            |m: &CMsgIncrementKillCountAttribute| { &m.item_id },
            |m: &mut CMsgIncrementKillCountAttribute| { &mut m.item_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_type",
            |m: &CMsgIncrementKillCountAttribute| { &m.event_type },
            |m: &mut CMsgIncrementKillCountAttribute| { &mut m.event_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "increment_value",
            |m: &CMsgIncrementKillCountAttribute| { &m.increment_value },
            |m: &mut CMsgIncrementKillCountAttribute| { &mut m.increment_value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgIncrementKillCountAttribute>(
            "CMsgIncrementKillCountAttribute",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgIncrementKillCountAttribute {
    const NAME: &'static str = "CMsgIncrementKillCountAttribute";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.killer_steam_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.victim_steam_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                32 => {
                    self.event_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.increment_value = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.killer_steam_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.victim_steam_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.event_type {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.increment_value {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.killer_steam_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.victim_steam_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.item_id {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.event_type {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.increment_value {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgIncrementKillCountAttribute {
        CMsgIncrementKillCountAttribute::new()
    }

    fn clear(&mut self) {
        self.killer_steam_id = ::std::option::Option::None;
        self.victim_steam_id = ::std::option::Option::None;
        self.item_id = ::std::option::Option::None;
        self.event_type = ::std::option::Option::None;
        self.increment_value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgIncrementKillCountAttribute {
        static instance: CMsgIncrementKillCountAttribute = CMsgIncrementKillCountAttribute {
            killer_steam_id: ::std::option::Option::None,
            victim_steam_id: ::std::option::Option::None,
            item_id: ::std::option::Option::None,
            event_type: ::std::option::Option::None,
            increment_value: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgIncrementKillCountAttribute {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgIncrementKillCountAttribute").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgIncrementKillCountAttribute {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgIncrementKillCountAttribute {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgIncrementKillCountAttribute_Multiple)
pub struct CMsgIncrementKillCountAttribute_Multiple {
    // message fields
    // @@protoc_insertion_point(field:CMsgIncrementKillCountAttribute_Multiple.msgs)
    pub msgs: ::std::vec::Vec<CMsgIncrementKillCountAttribute>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgIncrementKillCountAttribute_Multiple.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgIncrementKillCountAttribute_Multiple {
    fn default() -> &'a CMsgIncrementKillCountAttribute_Multiple {
        <CMsgIncrementKillCountAttribute_Multiple as ::protobuf::Message>::default_instance()
    }
}

impl CMsgIncrementKillCountAttribute_Multiple {
    pub fn new() -> CMsgIncrementKillCountAttribute_Multiple {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "msgs",
            |m: &CMsgIncrementKillCountAttribute_Multiple| { &m.msgs },
            |m: &mut CMsgIncrementKillCountAttribute_Multiple| { &mut m.msgs },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgIncrementKillCountAttribute_Multiple>(
            "CMsgIncrementKillCountAttribute_Multiple",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgIncrementKillCountAttribute_Multiple {
    const NAME: &'static str = "CMsgIncrementKillCountAttribute_Multiple";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.msgs.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.msgs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.msgs {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgIncrementKillCountAttribute_Multiple {
        CMsgIncrementKillCountAttribute_Multiple::new()
    }

    fn clear(&mut self) {
        self.msgs.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgIncrementKillCountAttribute_Multiple {
        static instance: CMsgIncrementKillCountAttribute_Multiple = CMsgIncrementKillCountAttribute_Multiple {
            msgs: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgIncrementKillCountAttribute_Multiple {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgIncrementKillCountAttribute_Multiple").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgIncrementKillCountAttribute_Multiple {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgIncrementKillCountAttribute_Multiple {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgTrackUniquePlayerPairEvent)
pub struct CMsgTrackUniquePlayerPairEvent {
    // message fields
    // @@protoc_insertion_point(field:CMsgTrackUniquePlayerPairEvent.killer_steam_id)
    pub killer_steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgTrackUniquePlayerPairEvent.victim_steam_id)
    pub victim_steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgTrackUniquePlayerPairEvent.item_id)
    pub item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgTrackUniquePlayerPairEvent.event_type)
    pub event_type: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTrackUniquePlayerPairEvent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTrackUniquePlayerPairEvent {
    fn default() -> &'a CMsgTrackUniquePlayerPairEvent {
        <CMsgTrackUniquePlayerPairEvent as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTrackUniquePlayerPairEvent {
    pub fn new() -> CMsgTrackUniquePlayerPairEvent {
        ::std::default::Default::default()
    }

    // optional uint64 killer_steam_id = 1;

    pub fn killer_steam_id(&self) -> u64 {
        self.killer_steam_id.unwrap_or(0)
    }

    pub fn clear_killer_steam_id(&mut self) {
        self.killer_steam_id = ::std::option::Option::None;
    }

    pub fn has_killer_steam_id(&self) -> bool {
        self.killer_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_killer_steam_id(&mut self, v: u64) {
        self.killer_steam_id = ::std::option::Option::Some(v);
    }

    // optional uint64 victim_steam_id = 2;

    pub fn victim_steam_id(&self) -> u64 {
        self.victim_steam_id.unwrap_or(0)
    }

    pub fn clear_victim_steam_id(&mut self) {
        self.victim_steam_id = ::std::option::Option::None;
    }

    pub fn has_victim_steam_id(&self) -> bool {
        self.victim_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_victim_steam_id(&mut self, v: u64) {
        self.victim_steam_id = ::std::option::Option::Some(v);
    }

    // optional uint64 item_id = 3;

    pub fn item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    // optional uint32 event_type = 4;

    pub fn event_type(&self) -> u32 {
        self.event_type.unwrap_or(0)
    }

    pub fn clear_event_type(&mut self) {
        self.event_type = ::std::option::Option::None;
    }

    pub fn has_event_type(&self) -> bool {
        self.event_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_type(&mut self, v: u32) {
        self.event_type = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "killer_steam_id",
            |m: &CMsgTrackUniquePlayerPairEvent| { &m.killer_steam_id },
            |m: &mut CMsgTrackUniquePlayerPairEvent| { &mut m.killer_steam_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "victim_steam_id",
            |m: &CMsgTrackUniquePlayerPairEvent| { &m.victim_steam_id },
            |m: &mut CMsgTrackUniquePlayerPairEvent| { &mut m.victim_steam_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_id",
            |m: &CMsgTrackUniquePlayerPairEvent| { &m.item_id },
            |m: &mut CMsgTrackUniquePlayerPairEvent| { &mut m.item_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_type",
            |m: &CMsgTrackUniquePlayerPairEvent| { &m.event_type },
            |m: &mut CMsgTrackUniquePlayerPairEvent| { &mut m.event_type },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgTrackUniquePlayerPairEvent>(
            "CMsgTrackUniquePlayerPairEvent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgTrackUniquePlayerPairEvent {
    const NAME: &'static str = "CMsgTrackUniquePlayerPairEvent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.killer_steam_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.victim_steam_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                32 => {
                    self.event_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.killer_steam_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.victim_steam_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.event_type {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.killer_steam_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.victim_steam_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.item_id {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.event_type {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTrackUniquePlayerPairEvent {
        CMsgTrackUniquePlayerPairEvent::new()
    }

    fn clear(&mut self) {
        self.killer_steam_id = ::std::option::Option::None;
        self.victim_steam_id = ::std::option::Option::None;
        self.item_id = ::std::option::Option::None;
        self.event_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTrackUniquePlayerPairEvent {
        static instance: CMsgTrackUniquePlayerPairEvent = CMsgTrackUniquePlayerPairEvent {
            killer_steam_id: ::std::option::Option::None,
            victim_steam_id: ::std::option::Option::None,
            item_id: ::std::option::Option::None,
            event_type: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgTrackUniquePlayerPairEvent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgTrackUniquePlayerPairEvent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgTrackUniquePlayerPairEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTrackUniquePlayerPairEvent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgApplyStrangeCountTransfer)
pub struct CMsgApplyStrangeCountTransfer {
    // message fields
    // @@protoc_insertion_point(field:CMsgApplyStrangeCountTransfer.tool_item_id)
    pub tool_item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgApplyStrangeCountTransfer.item_src_item_id)
    pub item_src_item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgApplyStrangeCountTransfer.item_dest_item_id)
    pub item_dest_item_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgApplyStrangeCountTransfer.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgApplyStrangeCountTransfer {
    fn default() -> &'a CMsgApplyStrangeCountTransfer {
        <CMsgApplyStrangeCountTransfer as ::protobuf::Message>::default_instance()
    }
}

impl CMsgApplyStrangeCountTransfer {
    pub fn new() -> CMsgApplyStrangeCountTransfer {
        ::std::default::Default::default()
    }

    // optional uint64 tool_item_id = 1;

    pub fn tool_item_id(&self) -> u64 {
        self.tool_item_id.unwrap_or(0)
    }

    pub fn clear_tool_item_id(&mut self) {
        self.tool_item_id = ::std::option::Option::None;
    }

    pub fn has_tool_item_id(&self) -> bool {
        self.tool_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tool_item_id(&mut self, v: u64) {
        self.tool_item_id = ::std::option::Option::Some(v);
    }

    // optional uint64 item_src_item_id = 2;

    pub fn item_src_item_id(&self) -> u64 {
        self.item_src_item_id.unwrap_or(0)
    }

    pub fn clear_item_src_item_id(&mut self) {
        self.item_src_item_id = ::std::option::Option::None;
    }

    pub fn has_item_src_item_id(&self) -> bool {
        self.item_src_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_src_item_id(&mut self, v: u64) {
        self.item_src_item_id = ::std::option::Option::Some(v);
    }

    // optional uint64 item_dest_item_id = 3;

    pub fn item_dest_item_id(&self) -> u64 {
        self.item_dest_item_id.unwrap_or(0)
    }

    pub fn clear_item_dest_item_id(&mut self) {
        self.item_dest_item_id = ::std::option::Option::None;
    }

    pub fn has_item_dest_item_id(&self) -> bool {
        self.item_dest_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_dest_item_id(&mut self, v: u64) {
        self.item_dest_item_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tool_item_id",
            |m: &CMsgApplyStrangeCountTransfer| { &m.tool_item_id },
            |m: &mut CMsgApplyStrangeCountTransfer| { &mut m.tool_item_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_src_item_id",
            |m: &CMsgApplyStrangeCountTransfer| { &m.item_src_item_id },
            |m: &mut CMsgApplyStrangeCountTransfer| { &mut m.item_src_item_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_dest_item_id",
            |m: &CMsgApplyStrangeCountTransfer| { &m.item_dest_item_id },
            |m: &mut CMsgApplyStrangeCountTransfer| { &mut m.item_dest_item_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgApplyStrangeCountTransfer>(
            "CMsgApplyStrangeCountTransfer",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgApplyStrangeCountTransfer {
    const NAME: &'static str = "CMsgApplyStrangeCountTransfer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.tool_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.item_src_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.item_dest_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.tool_item_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.item_src_item_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.item_dest_item_id {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.tool_item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.item_src_item_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.item_dest_item_id {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgApplyStrangeCountTransfer {
        CMsgApplyStrangeCountTransfer::new()
    }

    fn clear(&mut self) {
        self.tool_item_id = ::std::option::Option::None;
        self.item_src_item_id = ::std::option::Option::None;
        self.item_dest_item_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgApplyStrangeCountTransfer {
        static instance: CMsgApplyStrangeCountTransfer = CMsgApplyStrangeCountTransfer {
            tool_item_id: ::std::option::Option::None,
            item_src_item_id: ::std::option::Option::None,
            item_dest_item_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgApplyStrangeCountTransfer {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgApplyStrangeCountTransfer").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgApplyStrangeCountTransfer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgApplyStrangeCountTransfer {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgApplyStrangePart)
pub struct CMsgApplyStrangePart {
    // message fields
    // @@protoc_insertion_point(field:CMsgApplyStrangePart.strange_part_item_id)
    pub strange_part_item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgApplyStrangePart.item_item_id)
    pub item_item_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgApplyStrangePart.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgApplyStrangePart {
    fn default() -> &'a CMsgApplyStrangePart {
        <CMsgApplyStrangePart as ::protobuf::Message>::default_instance()
    }
}

impl CMsgApplyStrangePart {
    pub fn new() -> CMsgApplyStrangePart {
        ::std::default::Default::default()
    }

    // optional uint64 strange_part_item_id = 1;

    pub fn strange_part_item_id(&self) -> u64 {
        self.strange_part_item_id.unwrap_or(0)
    }

    pub fn clear_strange_part_item_id(&mut self) {
        self.strange_part_item_id = ::std::option::Option::None;
    }

    pub fn has_strange_part_item_id(&self) -> bool {
        self.strange_part_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_strange_part_item_id(&mut self, v: u64) {
        self.strange_part_item_id = ::std::option::Option::Some(v);
    }

    // optional uint64 item_item_id = 2;

    pub fn item_item_id(&self) -> u64 {
        self.item_item_id.unwrap_or(0)
    }

    pub fn clear_item_item_id(&mut self) {
        self.item_item_id = ::std::option::Option::None;
    }

    pub fn has_item_item_id(&self) -> bool {
        self.item_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_item_id(&mut self, v: u64) {
        self.item_item_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "strange_part_item_id",
            |m: &CMsgApplyStrangePart| { &m.strange_part_item_id },
            |m: &mut CMsgApplyStrangePart| { &mut m.strange_part_item_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_item_id",
            |m: &CMsgApplyStrangePart| { &m.item_item_id },
            |m: &mut CMsgApplyStrangePart| { &mut m.item_item_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgApplyStrangePart>(
            "CMsgApplyStrangePart",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgApplyStrangePart {
    const NAME: &'static str = "CMsgApplyStrangePart";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.strange_part_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.item_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.strange_part_item_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.item_item_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.strange_part_item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.item_item_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgApplyStrangePart {
        CMsgApplyStrangePart::new()
    }

    fn clear(&mut self) {
        self.strange_part_item_id = ::std::option::Option::None;
        self.item_item_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgApplyStrangePart {
        static instance: CMsgApplyStrangePart = CMsgApplyStrangePart {
            strange_part_item_id: ::std::option::Option::None,
            item_item_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgApplyStrangePart {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgApplyStrangePart").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgApplyStrangePart {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgApplyStrangePart {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgApplyStrangeRestriction)
pub struct CMsgApplyStrangeRestriction {
    // message fields
    // @@protoc_insertion_point(field:CMsgApplyStrangeRestriction.strange_part_item_id)
    pub strange_part_item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgApplyStrangeRestriction.item_item_id)
    pub item_item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgApplyStrangeRestriction.strange_attr_index)
    pub strange_attr_index: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgApplyStrangeRestriction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgApplyStrangeRestriction {
    fn default() -> &'a CMsgApplyStrangeRestriction {
        <CMsgApplyStrangeRestriction as ::protobuf::Message>::default_instance()
    }
}

impl CMsgApplyStrangeRestriction {
    pub fn new() -> CMsgApplyStrangeRestriction {
        ::std::default::Default::default()
    }

    // optional uint64 strange_part_item_id = 1;

    pub fn strange_part_item_id(&self) -> u64 {
        self.strange_part_item_id.unwrap_or(0)
    }

    pub fn clear_strange_part_item_id(&mut self) {
        self.strange_part_item_id = ::std::option::Option::None;
    }

    pub fn has_strange_part_item_id(&self) -> bool {
        self.strange_part_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_strange_part_item_id(&mut self, v: u64) {
        self.strange_part_item_id = ::std::option::Option::Some(v);
    }

    // optional uint64 item_item_id = 2;

    pub fn item_item_id(&self) -> u64 {
        self.item_item_id.unwrap_or(0)
    }

    pub fn clear_item_item_id(&mut self) {
        self.item_item_id = ::std::option::Option::None;
    }

    pub fn has_item_item_id(&self) -> bool {
        self.item_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_item_id(&mut self, v: u64) {
        self.item_item_id = ::std::option::Option::Some(v);
    }

    // optional uint32 strange_attr_index = 3;

    pub fn strange_attr_index(&self) -> u32 {
        self.strange_attr_index.unwrap_or(0)
    }

    pub fn clear_strange_attr_index(&mut self) {
        self.strange_attr_index = ::std::option::Option::None;
    }

    pub fn has_strange_attr_index(&self) -> bool {
        self.strange_attr_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_strange_attr_index(&mut self, v: u32) {
        self.strange_attr_index = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "strange_part_item_id",
            |m: &CMsgApplyStrangeRestriction| { &m.strange_part_item_id },
            |m: &mut CMsgApplyStrangeRestriction| { &mut m.strange_part_item_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_item_id",
            |m: &CMsgApplyStrangeRestriction| { &m.item_item_id },
            |m: &mut CMsgApplyStrangeRestriction| { &mut m.item_item_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "strange_attr_index",
            |m: &CMsgApplyStrangeRestriction| { &m.strange_attr_index },
            |m: &mut CMsgApplyStrangeRestriction| { &mut m.strange_attr_index },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgApplyStrangeRestriction>(
            "CMsgApplyStrangeRestriction",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgApplyStrangeRestriction {
    const NAME: &'static str = "CMsgApplyStrangeRestriction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.strange_part_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.item_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.strange_attr_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.strange_part_item_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.item_item_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.strange_attr_index {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.strange_part_item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.item_item_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.strange_attr_index {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgApplyStrangeRestriction {
        CMsgApplyStrangeRestriction::new()
    }

    fn clear(&mut self) {
        self.strange_part_item_id = ::std::option::Option::None;
        self.item_item_id = ::std::option::Option::None;
        self.strange_attr_index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgApplyStrangeRestriction {
        static instance: CMsgApplyStrangeRestriction = CMsgApplyStrangeRestriction {
            strange_part_item_id: ::std::option::Option::None,
            item_item_id: ::std::option::Option::None,
            strange_attr_index: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgApplyStrangeRestriction {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgApplyStrangeRestriction").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgApplyStrangeRestriction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgApplyStrangeRestriction {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgApplyUpgradeCard)
pub struct CMsgApplyUpgradeCard {
    // message fields
    // @@protoc_insertion_point(field:CMsgApplyUpgradeCard.upgrade_card_item_id)
    pub upgrade_card_item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgApplyUpgradeCard.subject_item_id)
    pub subject_item_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgApplyUpgradeCard.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgApplyUpgradeCard {
    fn default() -> &'a CMsgApplyUpgradeCard {
        <CMsgApplyUpgradeCard as ::protobuf::Message>::default_instance()
    }
}

impl CMsgApplyUpgradeCard {
    pub fn new() -> CMsgApplyUpgradeCard {
        ::std::default::Default::default()
    }

    // optional uint64 upgrade_card_item_id = 1;

    pub fn upgrade_card_item_id(&self) -> u64 {
        self.upgrade_card_item_id.unwrap_or(0)
    }

    pub fn clear_upgrade_card_item_id(&mut self) {
        self.upgrade_card_item_id = ::std::option::Option::None;
    }

    pub fn has_upgrade_card_item_id(&self) -> bool {
        self.upgrade_card_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_upgrade_card_item_id(&mut self, v: u64) {
        self.upgrade_card_item_id = ::std::option::Option::Some(v);
    }

    // optional uint64 subject_item_id = 2;

    pub fn subject_item_id(&self) -> u64 {
        self.subject_item_id.unwrap_or(0)
    }

    pub fn clear_subject_item_id(&mut self) {
        self.subject_item_id = ::std::option::Option::None;
    }

    pub fn has_subject_item_id(&self) -> bool {
        self.subject_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subject_item_id(&mut self, v: u64) {
        self.subject_item_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "upgrade_card_item_id",
            |m: &CMsgApplyUpgradeCard| { &m.upgrade_card_item_id },
            |m: &mut CMsgApplyUpgradeCard| { &mut m.upgrade_card_item_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "subject_item_id",
            |m: &CMsgApplyUpgradeCard| { &m.subject_item_id },
            |m: &mut CMsgApplyUpgradeCard| { &mut m.subject_item_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgApplyUpgradeCard>(
            "CMsgApplyUpgradeCard",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgApplyUpgradeCard {
    const NAME: &'static str = "CMsgApplyUpgradeCard";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.upgrade_card_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.subject_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.upgrade_card_item_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.subject_item_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.upgrade_card_item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.subject_item_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgApplyUpgradeCard {
        CMsgApplyUpgradeCard::new()
    }

    fn clear(&mut self) {
        self.upgrade_card_item_id = ::std::option::Option::None;
        self.subject_item_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgApplyUpgradeCard {
        static instance: CMsgApplyUpgradeCard = CMsgApplyUpgradeCard {
            upgrade_card_item_id: ::std::option::Option::None,
            subject_item_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgApplyUpgradeCard {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgApplyUpgradeCard").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgApplyUpgradeCard {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgApplyUpgradeCard {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CSOEconItemAttribute)
pub struct CSOEconItemAttribute {
    // message fields
    // @@protoc_insertion_point(field:CSOEconItemAttribute.def_index)
    pub def_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconItemAttribute.value)
    pub value: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconItemAttribute.value_bytes)
    pub value_bytes: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CSOEconItemAttribute.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSOEconItemAttribute {
    fn default() -> &'a CSOEconItemAttribute {
        <CSOEconItemAttribute as ::protobuf::Message>::default_instance()
    }
}

impl CSOEconItemAttribute {
    pub fn new() -> CSOEconItemAttribute {
        ::std::default::Default::default()
    }

    // optional uint32 def_index = 1;

    pub fn def_index(&self) -> u32 {
        self.def_index.unwrap_or(0)
    }

    pub fn clear_def_index(&mut self) {
        self.def_index = ::std::option::Option::None;
    }

    pub fn has_def_index(&self) -> bool {
        self.def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_def_index(&mut self, v: u32) {
        self.def_index = ::std::option::Option::Some(v);
    }

    // optional uint32 value = 2;

    pub fn value(&self) -> u32 {
        self.value.unwrap_or(0)
    }

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: u32) {
        self.value = ::std::option::Option::Some(v);
    }

    // optional bytes value_bytes = 3;

    pub fn value_bytes(&self) -> &[u8] {
        match self.value_bytes.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_value_bytes(&mut self) {
        self.value_bytes = ::std::option::Option::None;
    }

    pub fn has_value_bytes(&self) -> bool {
        self.value_bytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value_bytes(&mut self, v: ::std::vec::Vec<u8>) {
        self.value_bytes = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value_bytes(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.value_bytes.is_none() {
            self.value_bytes = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.value_bytes.as_mut().unwrap()
    }

    // Take field
    pub fn take_value_bytes(&mut self) -> ::std::vec::Vec<u8> {
        self.value_bytes.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "def_index",
            |m: &CSOEconItemAttribute| { &m.def_index },
            |m: &mut CSOEconItemAttribute| { &mut m.def_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "value",
            |m: &CSOEconItemAttribute| { &m.value },
            |m: &mut CSOEconItemAttribute| { &mut m.value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "value_bytes",
            |m: &CSOEconItemAttribute| { &m.value_bytes },
            |m: &mut CSOEconItemAttribute| { &mut m.value_bytes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSOEconItemAttribute>(
            "CSOEconItemAttribute",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSOEconItemAttribute {
    const NAME: &'static str = "CSOEconItemAttribute";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.def_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.value = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.value_bytes = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.def_index {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.value {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.value_bytes.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.def_index {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.value {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.value_bytes.as_ref() {
            os.write_bytes(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSOEconItemAttribute {
        CSOEconItemAttribute::new()
    }

    fn clear(&mut self) {
        self.def_index = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value_bytes = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSOEconItemAttribute {
        static instance: CSOEconItemAttribute = CSOEconItemAttribute {
            def_index: ::std::option::Option::None,
            value: ::std::option::Option::None,
            value_bytes: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSOEconItemAttribute {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSOEconItemAttribute").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSOEconItemAttribute {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOEconItemAttribute {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CSOEconItemEquipped)
pub struct CSOEconItemEquipped {
    // message fields
    // @@protoc_insertion_point(field:CSOEconItemEquipped.new_class)
    pub new_class: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconItemEquipped.new_slot)
    pub new_slot: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSOEconItemEquipped.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSOEconItemEquipped {
    fn default() -> &'a CSOEconItemEquipped {
        <CSOEconItemEquipped as ::protobuf::Message>::default_instance()
    }
}

impl CSOEconItemEquipped {
    pub fn new() -> CSOEconItemEquipped {
        ::std::default::Default::default()
    }

    // optional uint32 new_class = 1;

    pub fn new_class(&self) -> u32 {
        self.new_class.unwrap_or(0)
    }

    pub fn clear_new_class(&mut self) {
        self.new_class = ::std::option::Option::None;
    }

    pub fn has_new_class(&self) -> bool {
        self.new_class.is_some()
    }

    // Param is passed by value, moved
    pub fn set_new_class(&mut self, v: u32) {
        self.new_class = ::std::option::Option::Some(v);
    }

    // optional uint32 new_slot = 2;

    pub fn new_slot(&self) -> u32 {
        self.new_slot.unwrap_or(0)
    }

    pub fn clear_new_slot(&mut self) {
        self.new_slot = ::std::option::Option::None;
    }

    pub fn has_new_slot(&self) -> bool {
        self.new_slot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_new_slot(&mut self, v: u32) {
        self.new_slot = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "new_class",
            |m: &CSOEconItemEquipped| { &m.new_class },
            |m: &mut CSOEconItemEquipped| { &mut m.new_class },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "new_slot",
            |m: &CSOEconItemEquipped| { &m.new_slot },
            |m: &mut CSOEconItemEquipped| { &mut m.new_slot },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSOEconItemEquipped>(
            "CSOEconItemEquipped",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSOEconItemEquipped {
    const NAME: &'static str = "CSOEconItemEquipped";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.new_class = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.new_slot = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.new_class {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.new_slot {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.new_class {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.new_slot {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSOEconItemEquipped {
        CSOEconItemEquipped::new()
    }

    fn clear(&mut self) {
        self.new_class = ::std::option::Option::None;
        self.new_slot = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSOEconItemEquipped {
        static instance: CSOEconItemEquipped = CSOEconItemEquipped {
            new_class: ::std::option::Option::None,
            new_slot: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSOEconItemEquipped {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSOEconItemEquipped").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSOEconItemEquipped {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOEconItemEquipped {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CSOEconItem)
pub struct CSOEconItem {
    // message fields
    // @@protoc_insertion_point(field:CSOEconItem.id)
    pub id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSOEconItem.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconItem.inventory)
    pub inventory: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconItem.def_index)
    pub def_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconItem.quantity)
    pub quantity: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconItem.level)
    pub level: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconItem.quality)
    pub quality: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconItem.flags)
    pub flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconItem.origin)
    pub origin: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconItem.custom_name)
    pub custom_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSOEconItem.custom_desc)
    pub custom_desc: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSOEconItem.attribute)
    pub attribute: ::std::vec::Vec<CSOEconItemAttribute>,
    // @@protoc_insertion_point(field:CSOEconItem.interior_item)
    pub interior_item: ::protobuf::MessageField<CSOEconItem>,
    // @@protoc_insertion_point(field:CSOEconItem.in_use)
    pub in_use: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSOEconItem.style)
    pub style: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconItem.original_id)
    pub original_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSOEconItem.contains_equipped_state)
    pub contains_equipped_state: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSOEconItem.equipped_state)
    pub equipped_state: ::std::vec::Vec<CSOEconItemEquipped>,
    // @@protoc_insertion_point(field:CSOEconItem.contains_equipped_state_v2)
    pub contains_equipped_state_v2: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CSOEconItem.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSOEconItem {
    fn default() -> &'a CSOEconItem {
        <CSOEconItem as ::protobuf::Message>::default_instance()
    }
}

impl CSOEconItem {
    pub fn new() -> CSOEconItem {
        ::std::default::Default::default()
    }

    // optional uint64 id = 1;

    pub fn id(&self) -> u64 {
        self.id.unwrap_or(0)
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u64) {
        self.id = ::std::option::Option::Some(v);
    }

    // optional uint32 account_id = 2;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 inventory = 3;

    pub fn inventory(&self) -> u32 {
        self.inventory.unwrap_or(0)
    }

    pub fn clear_inventory(&mut self) {
        self.inventory = ::std::option::Option::None;
    }

    pub fn has_inventory(&self) -> bool {
        self.inventory.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inventory(&mut self, v: u32) {
        self.inventory = ::std::option::Option::Some(v);
    }

    // optional uint32 def_index = 4;

    pub fn def_index(&self) -> u32 {
        self.def_index.unwrap_or(0)
    }

    pub fn clear_def_index(&mut self) {
        self.def_index = ::std::option::Option::None;
    }

    pub fn has_def_index(&self) -> bool {
        self.def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_def_index(&mut self, v: u32) {
        self.def_index = ::std::option::Option::Some(v);
    }

    // optional uint32 quantity = 5;

    pub fn quantity(&self) -> u32 {
        self.quantity.unwrap_or(0)
    }

    pub fn clear_quantity(&mut self) {
        self.quantity = ::std::option::Option::None;
    }

    pub fn has_quantity(&self) -> bool {
        self.quantity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quantity(&mut self, v: u32) {
        self.quantity = ::std::option::Option::Some(v);
    }

    // optional uint32 level = 6;

    pub fn level(&self) -> u32 {
        self.level.unwrap_or(0)
    }

    pub fn clear_level(&mut self) {
        self.level = ::std::option::Option::None;
    }

    pub fn has_level(&self) -> bool {
        self.level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_level(&mut self, v: u32) {
        self.level = ::std::option::Option::Some(v);
    }

    // optional uint32 quality = 7;

    pub fn quality(&self) -> u32 {
        self.quality.unwrap_or(0)
    }

    pub fn clear_quality(&mut self) {
        self.quality = ::std::option::Option::None;
    }

    pub fn has_quality(&self) -> bool {
        self.quality.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality(&mut self, v: u32) {
        self.quality = ::std::option::Option::Some(v);
    }

    // optional uint32 flags = 8;

    pub fn flags(&self) -> u32 {
        self.flags.unwrap_or(0u32)
    }

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional uint32 origin = 9;

    pub fn origin(&self) -> u32 {
        self.origin.unwrap_or(0)
    }

    pub fn clear_origin(&mut self) {
        self.origin = ::std::option::Option::None;
    }

    pub fn has_origin(&self) -> bool {
        self.origin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_origin(&mut self, v: u32) {
        self.origin = ::std::option::Option::Some(v);
    }

    // optional string custom_name = 10;

    pub fn custom_name(&self) -> &str {
        match self.custom_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_custom_name(&mut self) {
        self.custom_name = ::std::option::Option::None;
    }

    pub fn has_custom_name(&self) -> bool {
        self.custom_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_name(&mut self, v: ::std::string::String) {
        self.custom_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_custom_name(&mut self) -> &mut ::std::string::String {
        if self.custom_name.is_none() {
            self.custom_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.custom_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_custom_name(&mut self) -> ::std::string::String {
        self.custom_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string custom_desc = 11;

    pub fn custom_desc(&self) -> &str {
        match self.custom_desc.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_custom_desc(&mut self) {
        self.custom_desc = ::std::option::Option::None;
    }

    pub fn has_custom_desc(&self) -> bool {
        self.custom_desc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_desc(&mut self, v: ::std::string::String) {
        self.custom_desc = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_custom_desc(&mut self) -> &mut ::std::string::String {
        if self.custom_desc.is_none() {
            self.custom_desc = ::std::option::Option::Some(::std::string::String::new());
        }
        self.custom_desc.as_mut().unwrap()
    }

    // Take field
    pub fn take_custom_desc(&mut self) -> ::std::string::String {
        self.custom_desc.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool in_use = 14;

    pub fn in_use(&self) -> bool {
        self.in_use.unwrap_or(false)
    }

    pub fn clear_in_use(&mut self) {
        self.in_use = ::std::option::Option::None;
    }

    pub fn has_in_use(&self) -> bool {
        self.in_use.is_some()
    }

    // Param is passed by value, moved
    pub fn set_in_use(&mut self, v: bool) {
        self.in_use = ::std::option::Option::Some(v);
    }

    // optional uint32 style = 15;

    pub fn style(&self) -> u32 {
        self.style.unwrap_or(0u32)
    }

    pub fn clear_style(&mut self) {
        self.style = ::std::option::Option::None;
    }

    pub fn has_style(&self) -> bool {
        self.style.is_some()
    }

    // Param is passed by value, moved
    pub fn set_style(&mut self, v: u32) {
        self.style = ::std::option::Option::Some(v);
    }

    // optional uint64 original_id = 16;

    pub fn original_id(&self) -> u64 {
        self.original_id.unwrap_or(0u64)
    }

    pub fn clear_original_id(&mut self) {
        self.original_id = ::std::option::Option::None;
    }

    pub fn has_original_id(&self) -> bool {
        self.original_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_original_id(&mut self, v: u64) {
        self.original_id = ::std::option::Option::Some(v);
    }

    // optional bool contains_equipped_state = 17;

    pub fn contains_equipped_state(&self) -> bool {
        self.contains_equipped_state.unwrap_or(false)
    }

    pub fn clear_contains_equipped_state(&mut self) {
        self.contains_equipped_state = ::std::option::Option::None;
    }

    pub fn has_contains_equipped_state(&self) -> bool {
        self.contains_equipped_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_contains_equipped_state(&mut self, v: bool) {
        self.contains_equipped_state = ::std::option::Option::Some(v);
    }

    // optional bool contains_equipped_state_v2 = 19;

    pub fn contains_equipped_state_v2(&self) -> bool {
        self.contains_equipped_state_v2.unwrap_or(false)
    }

    pub fn clear_contains_equipped_state_v2(&mut self) {
        self.contains_equipped_state_v2 = ::std::option::Option::None;
    }

    pub fn has_contains_equipped_state_v2(&self) -> bool {
        self.contains_equipped_state_v2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_contains_equipped_state_v2(&mut self, v: bool) {
        self.contains_equipped_state_v2 = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(19);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "id",
            |m: &CSOEconItem| { &m.id },
            |m: &mut CSOEconItem| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CSOEconItem| { &m.account_id },
            |m: &mut CSOEconItem| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "inventory",
            |m: &CSOEconItem| { &m.inventory },
            |m: &mut CSOEconItem| { &mut m.inventory },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "def_index",
            |m: &CSOEconItem| { &m.def_index },
            |m: &mut CSOEconItem| { &mut m.def_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "quantity",
            |m: &CSOEconItem| { &m.quantity },
            |m: &mut CSOEconItem| { &mut m.quantity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "level",
            |m: &CSOEconItem| { &m.level },
            |m: &mut CSOEconItem| { &mut m.level },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "quality",
            |m: &CSOEconItem| { &m.quality },
            |m: &mut CSOEconItem| { &mut m.quality },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "flags",
            |m: &CSOEconItem| { &m.flags },
            |m: &mut CSOEconItem| { &mut m.flags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "origin",
            |m: &CSOEconItem| { &m.origin },
            |m: &mut CSOEconItem| { &mut m.origin },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "custom_name",
            |m: &CSOEconItem| { &m.custom_name },
            |m: &mut CSOEconItem| { &mut m.custom_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "custom_desc",
            |m: &CSOEconItem| { &m.custom_desc },
            |m: &mut CSOEconItem| { &mut m.custom_desc },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "attribute",
            |m: &CSOEconItem| { &m.attribute },
            |m: &mut CSOEconItem| { &mut m.attribute },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CSOEconItem>(
            "interior_item",
            |m: &CSOEconItem| { &m.interior_item },
            |m: &mut CSOEconItem| { &mut m.interior_item },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "in_use",
            |m: &CSOEconItem| { &m.in_use },
            |m: &mut CSOEconItem| { &mut m.in_use },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "style",
            |m: &CSOEconItem| { &m.style },
            |m: &mut CSOEconItem| { &mut m.style },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "original_id",
            |m: &CSOEconItem| { &m.original_id },
            |m: &mut CSOEconItem| { &mut m.original_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "contains_equipped_state",
            |m: &CSOEconItem| { &m.contains_equipped_state },
            |m: &mut CSOEconItem| { &mut m.contains_equipped_state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "equipped_state",
            |m: &CSOEconItem| { &m.equipped_state },
            |m: &mut CSOEconItem| { &mut m.equipped_state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "contains_equipped_state_v2",
            |m: &CSOEconItem| { &m.contains_equipped_state_v2 },
            |m: &mut CSOEconItem| { &mut m.contains_equipped_state_v2 },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSOEconItem>(
            "CSOEconItem",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSOEconItem {
    const NAME: &'static str = "CSOEconItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.inventory = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.def_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.quantity = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.level = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.quality = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.origin = ::std::option::Option::Some(is.read_uint32()?);
                },
                82 => {
                    self.custom_name = ::std::option::Option::Some(is.read_string()?);
                },
                90 => {
                    self.custom_desc = ::std::option::Option::Some(is.read_string()?);
                },
                98 => {
                    self.attribute.push(is.read_message()?);
                },
                106 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.interior_item)?;
                },
                112 => {
                    self.in_use = ::std::option::Option::Some(is.read_bool()?);
                },
                120 => {
                    self.style = ::std::option::Option::Some(is.read_uint32()?);
                },
                128 => {
                    self.original_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                136 => {
                    self.contains_equipped_state = ::std::option::Option::Some(is.read_bool()?);
                },
                146 => {
                    self.equipped_state.push(is.read_message()?);
                },
                152 => {
                    self.contains_equipped_state_v2 = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.inventory {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.def_index {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.quantity {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.level {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.quality {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.origin {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.custom_name.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(v) = self.custom_desc.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        for value in &self.attribute {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.interior_item.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.in_use {
            my_size += 1 + 1;
        }
        if let Some(v) = self.style {
            my_size += ::protobuf::rt::uint32_size(15, v);
        }
        if let Some(v) = self.original_id {
            my_size += ::protobuf::rt::uint64_size(16, v);
        }
        if let Some(v) = self.contains_equipped_state {
            my_size += 2 + 1;
        }
        for value in &self.equipped_state {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.contains_equipped_state_v2 {
            my_size += 2 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.account_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.inventory {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.def_index {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.quantity {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.level {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.quality {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.flags {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.origin {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.custom_name.as_ref() {
            os.write_string(10, v)?;
        }
        if let Some(v) = self.custom_desc.as_ref() {
            os.write_string(11, v)?;
        }
        for v in &self.attribute {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        };
        if let Some(v) = self.interior_item.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        }
        if let Some(v) = self.in_use {
            os.write_bool(14, v)?;
        }
        if let Some(v) = self.style {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.original_id {
            os.write_uint64(16, v)?;
        }
        if let Some(v) = self.contains_equipped_state {
            os.write_bool(17, v)?;
        }
        for v in &self.equipped_state {
            ::protobuf::rt::write_message_field_with_cached_size(18, v, os)?;
        };
        if let Some(v) = self.contains_equipped_state_v2 {
            os.write_bool(19, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSOEconItem {
        CSOEconItem::new()
    }

    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.account_id = ::std::option::Option::None;
        self.inventory = ::std::option::Option::None;
        self.def_index = ::std::option::Option::None;
        self.quantity = ::std::option::Option::None;
        self.level = ::std::option::Option::None;
        self.quality = ::std::option::Option::None;
        self.flags = ::std::option::Option::None;
        self.origin = ::std::option::Option::None;
        self.custom_name = ::std::option::Option::None;
        self.custom_desc = ::std::option::Option::None;
        self.attribute.clear();
        self.interior_item.clear();
        self.in_use = ::std::option::Option::None;
        self.style = ::std::option::Option::None;
        self.original_id = ::std::option::Option::None;
        self.contains_equipped_state = ::std::option::Option::None;
        self.equipped_state.clear();
        self.contains_equipped_state_v2 = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSOEconItem {
        static instance: CSOEconItem = CSOEconItem {
            id: ::std::option::Option::None,
            account_id: ::std::option::Option::None,
            inventory: ::std::option::Option::None,
            def_index: ::std::option::Option::None,
            quantity: ::std::option::Option::None,
            level: ::std::option::Option::None,
            quality: ::std::option::Option::None,
            flags: ::std::option::Option::None,
            origin: ::std::option::Option::None,
            custom_name: ::std::option::Option::None,
            custom_desc: ::std::option::Option::None,
            attribute: ::std::vec::Vec::new(),
            interior_item: ::protobuf::MessageField::none(),
            in_use: ::std::option::Option::None,
            style: ::std::option::Option::None,
            original_id: ::std::option::Option::None,
            contains_equipped_state: ::std::option::Option::None,
            equipped_state: ::std::vec::Vec::new(),
            contains_equipped_state_v2: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSOEconItem {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSOEconItem").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSOEconItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOEconItem {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgAdjustItemEquippedState)
pub struct CMsgAdjustItemEquippedState {
    // message fields
    // @@protoc_insertion_point(field:CMsgAdjustItemEquippedState.item_id)
    pub item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgAdjustItemEquippedState.new_class)
    pub new_class: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgAdjustItemEquippedState.new_slot)
    pub new_slot: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgAdjustItemEquippedState.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgAdjustItemEquippedState {
    fn default() -> &'a CMsgAdjustItemEquippedState {
        <CMsgAdjustItemEquippedState as ::protobuf::Message>::default_instance()
    }
}

impl CMsgAdjustItemEquippedState {
    pub fn new() -> CMsgAdjustItemEquippedState {
        ::std::default::Default::default()
    }

    // optional uint64 item_id = 1;

    pub fn item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    // optional uint32 new_class = 2;

    pub fn new_class(&self) -> u32 {
        self.new_class.unwrap_or(0)
    }

    pub fn clear_new_class(&mut self) {
        self.new_class = ::std::option::Option::None;
    }

    pub fn has_new_class(&self) -> bool {
        self.new_class.is_some()
    }

    // Param is passed by value, moved
    pub fn set_new_class(&mut self, v: u32) {
        self.new_class = ::std::option::Option::Some(v);
    }

    // optional uint32 new_slot = 3;

    pub fn new_slot(&self) -> u32 {
        self.new_slot.unwrap_or(0)
    }

    pub fn clear_new_slot(&mut self) {
        self.new_slot = ::std::option::Option::None;
    }

    pub fn has_new_slot(&self) -> bool {
        self.new_slot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_new_slot(&mut self, v: u32) {
        self.new_slot = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_id",
            |m: &CMsgAdjustItemEquippedState| { &m.item_id },
            |m: &mut CMsgAdjustItemEquippedState| { &mut m.item_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "new_class",
            |m: &CMsgAdjustItemEquippedState| { &m.new_class },
            |m: &mut CMsgAdjustItemEquippedState| { &mut m.new_class },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "new_slot",
            |m: &CMsgAdjustItemEquippedState| { &m.new_slot },
            |m: &mut CMsgAdjustItemEquippedState| { &mut m.new_slot },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgAdjustItemEquippedState>(
            "CMsgAdjustItemEquippedState",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgAdjustItemEquippedState {
    const NAME: &'static str = "CMsgAdjustItemEquippedState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.new_class = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.new_slot = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.new_class {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.new_slot {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.new_class {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.new_slot {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgAdjustItemEquippedState {
        CMsgAdjustItemEquippedState::new()
    }

    fn clear(&mut self) {
        self.item_id = ::std::option::Option::None;
        self.new_class = ::std::option::Option::None;
        self.new_slot = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgAdjustItemEquippedState {
        static instance: CMsgAdjustItemEquippedState = CMsgAdjustItemEquippedState {
            item_id: ::std::option::Option::None,
            new_class: ::std::option::Option::None,
            new_slot: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgAdjustItemEquippedState {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgAdjustItemEquippedState").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgAdjustItemEquippedState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgAdjustItemEquippedState {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgSortItems)
pub struct CMsgSortItems {
    // message fields
    // @@protoc_insertion_point(field:CMsgSortItems.sort_type)
    pub sort_type: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSortItems.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSortItems {
    fn default() -> &'a CMsgSortItems {
        <CMsgSortItems as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSortItems {
    pub fn new() -> CMsgSortItems {
        ::std::default::Default::default()
    }

    // optional uint32 sort_type = 1;

    pub fn sort_type(&self) -> u32 {
        self.sort_type.unwrap_or(0)
    }

    pub fn clear_sort_type(&mut self) {
        self.sort_type = ::std::option::Option::None;
    }

    pub fn has_sort_type(&self) -> bool {
        self.sort_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sort_type(&mut self, v: u32) {
        self.sort_type = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sort_type",
            |m: &CMsgSortItems| { &m.sort_type },
            |m: &mut CMsgSortItems| { &mut m.sort_type },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSortItems>(
            "CMsgSortItems",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSortItems {
    const NAME: &'static str = "CMsgSortItems";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.sort_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.sort_type {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.sort_type {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSortItems {
        CMsgSortItems::new()
    }

    fn clear(&mut self) {
        self.sort_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSortItems {
        static instance: CMsgSortItems = CMsgSortItems {
            sort_type: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSortItems {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSortItems").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSortItems {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSortItems {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CSOEconClaimCode)
pub struct CSOEconClaimCode {
    // message fields
    // @@protoc_insertion_point(field:CSOEconClaimCode.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconClaimCode.code_type)
    pub code_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconClaimCode.time_acquired)
    pub time_acquired: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconClaimCode.code)
    pub code: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CSOEconClaimCode.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSOEconClaimCode {
    fn default() -> &'a CSOEconClaimCode {
        <CSOEconClaimCode as ::protobuf::Message>::default_instance()
    }
}

impl CSOEconClaimCode {
    pub fn new() -> CSOEconClaimCode {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 code_type = 2;

    pub fn code_type(&self) -> u32 {
        self.code_type.unwrap_or(0)
    }

    pub fn clear_code_type(&mut self) {
        self.code_type = ::std::option::Option::None;
    }

    pub fn has_code_type(&self) -> bool {
        self.code_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_code_type(&mut self, v: u32) {
        self.code_type = ::std::option::Option::Some(v);
    }

    // optional uint32 time_acquired = 3;

    pub fn time_acquired(&self) -> u32 {
        self.time_acquired.unwrap_or(0)
    }

    pub fn clear_time_acquired(&mut self) {
        self.time_acquired = ::std::option::Option::None;
    }

    pub fn has_time_acquired(&self) -> bool {
        self.time_acquired.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_acquired(&mut self, v: u32) {
        self.time_acquired = ::std::option::Option::Some(v);
    }

    // optional string code = 4;

    pub fn code(&self) -> &str {
        match self.code.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_code(&mut self) {
        self.code = ::std::option::Option::None;
    }

    pub fn has_code(&self) -> bool {
        self.code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_code(&mut self, v: ::std::string::String) {
        self.code = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_code(&mut self) -> &mut ::std::string::String {
        if self.code.is_none() {
            self.code = ::std::option::Option::Some(::std::string::String::new());
        }
        self.code.as_mut().unwrap()
    }

    // Take field
    pub fn take_code(&mut self) -> ::std::string::String {
        self.code.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CSOEconClaimCode| { &m.account_id },
            |m: &mut CSOEconClaimCode| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "code_type",
            |m: &CSOEconClaimCode| { &m.code_type },
            |m: &mut CSOEconClaimCode| { &mut m.code_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "time_acquired",
            |m: &CSOEconClaimCode| { &m.time_acquired },
            |m: &mut CSOEconClaimCode| { &mut m.time_acquired },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "code",
            |m: &CSOEconClaimCode| { &m.code },
            |m: &mut CSOEconClaimCode| { &mut m.code },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSOEconClaimCode>(
            "CSOEconClaimCode",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSOEconClaimCode {
    const NAME: &'static str = "CSOEconClaimCode";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.code_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.time_acquired = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.code = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.code_type {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.time_acquired {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.code.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.code_type {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.time_acquired {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.code.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSOEconClaimCode {
        CSOEconClaimCode::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.code_type = ::std::option::Option::None;
        self.time_acquired = ::std::option::Option::None;
        self.code = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSOEconClaimCode {
        static instance: CSOEconClaimCode = CSOEconClaimCode {
            account_id: ::std::option::Option::None,
            code_type: ::std::option::Option::None,
            time_acquired: ::std::option::Option::None,
            code: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSOEconClaimCode {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSOEconClaimCode").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSOEconClaimCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOEconClaimCode {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgStoreGetUserData)
pub struct CMsgStoreGetUserData {
    // message fields
    // @@protoc_insertion_point(field:CMsgStoreGetUserData.price_sheet_version)
    pub price_sheet_version: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgStoreGetUserData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgStoreGetUserData {
    fn default() -> &'a CMsgStoreGetUserData {
        <CMsgStoreGetUserData as ::protobuf::Message>::default_instance()
    }
}

impl CMsgStoreGetUserData {
    pub fn new() -> CMsgStoreGetUserData {
        ::std::default::Default::default()
    }

    // optional fixed32 price_sheet_version = 1;

    pub fn price_sheet_version(&self) -> u32 {
        self.price_sheet_version.unwrap_or(0)
    }

    pub fn clear_price_sheet_version(&mut self) {
        self.price_sheet_version = ::std::option::Option::None;
    }

    pub fn has_price_sheet_version(&self) -> bool {
        self.price_sheet_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_price_sheet_version(&mut self, v: u32) {
        self.price_sheet_version = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "price_sheet_version",
            |m: &CMsgStoreGetUserData| { &m.price_sheet_version },
            |m: &mut CMsgStoreGetUserData| { &mut m.price_sheet_version },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgStoreGetUserData>(
            "CMsgStoreGetUserData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgStoreGetUserData {
    const NAME: &'static str = "CMsgStoreGetUserData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.price_sheet_version = ::std::option::Option::Some(is.read_fixed32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.price_sheet_version {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.price_sheet_version {
            os.write_fixed32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgStoreGetUserData {
        CMsgStoreGetUserData::new()
    }

    fn clear(&mut self) {
        self.price_sheet_version = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgStoreGetUserData {
        static instance: CMsgStoreGetUserData = CMsgStoreGetUserData {
            price_sheet_version: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgStoreGetUserData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgStoreGetUserData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgStoreGetUserData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgStoreGetUserData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgStoreGetUserDataResponse)
pub struct CMsgStoreGetUserDataResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgStoreGetUserDataResponse.result)
    pub result: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgStoreGetUserDataResponse.currency)
    pub currency: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgStoreGetUserDataResponse.country)
    pub country: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgStoreGetUserDataResponse.price_sheet_version)
    pub price_sheet_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgStoreGetUserDataResponse.experiment_data)
    pub experiment_data: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgStoreGetUserDataResponse.featured_item_idx)
    pub featured_item_idx: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgStoreGetUserDataResponse.show_hat_descriptions)
    pub show_hat_descriptions: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgStoreGetUserDataResponse.price_sheet)
    pub price_sheet: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgStoreGetUserDataResponse.default_item_sort)
    pub default_item_sort: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgStoreGetUserDataResponse.popular_items)
    pub popular_items: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgStoreGetUserDataResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgStoreGetUserDataResponse {
    fn default() -> &'a CMsgStoreGetUserDataResponse {
        <CMsgStoreGetUserDataResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgStoreGetUserDataResponse {
    pub fn new() -> CMsgStoreGetUserDataResponse {
        ::std::default::Default::default()
    }

    // optional int32 result = 1;

    pub fn result(&self) -> i32 {
        self.result.unwrap_or(0)
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: i32) {
        self.result = ::std::option::Option::Some(v);
    }

    // optional int32 currency = 2;

    pub fn currency(&self) -> i32 {
        self.currency.unwrap_or(0)
    }

    pub fn clear_currency(&mut self) {
        self.currency = ::std::option::Option::None;
    }

    pub fn has_currency(&self) -> bool {
        self.currency.is_some()
    }

    // Param is passed by value, moved
    pub fn set_currency(&mut self, v: i32) {
        self.currency = ::std::option::Option::Some(v);
    }

    // optional string country = 3;

    pub fn country(&self) -> &str {
        match self.country.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_country(&mut self) {
        self.country = ::std::option::Option::None;
    }

    pub fn has_country(&self) -> bool {
        self.country.is_some()
    }

    // Param is passed by value, moved
    pub fn set_country(&mut self, v: ::std::string::String) {
        self.country = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_country(&mut self) -> &mut ::std::string::String {
        if self.country.is_none() {
            self.country = ::std::option::Option::Some(::std::string::String::new());
        }
        self.country.as_mut().unwrap()
    }

    // Take field
    pub fn take_country(&mut self) -> ::std::string::String {
        self.country.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional fixed32 price_sheet_version = 4;

    pub fn price_sheet_version(&self) -> u32 {
        self.price_sheet_version.unwrap_or(0)
    }

    pub fn clear_price_sheet_version(&mut self) {
        self.price_sheet_version = ::std::option::Option::None;
    }

    pub fn has_price_sheet_version(&self) -> bool {
        self.price_sheet_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_price_sheet_version(&mut self, v: u32) {
        self.price_sheet_version = ::std::option::Option::Some(v);
    }

    // optional uint64 experiment_data = 5;

    pub fn experiment_data(&self) -> u64 {
        self.experiment_data.unwrap_or(0u64)
    }

    pub fn clear_experiment_data(&mut self) {
        self.experiment_data = ::std::option::Option::None;
    }

    pub fn has_experiment_data(&self) -> bool {
        self.experiment_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_experiment_data(&mut self, v: u64) {
        self.experiment_data = ::std::option::Option::Some(v);
    }

    // optional int32 featured_item_idx = 6;

    pub fn featured_item_idx(&self) -> i32 {
        self.featured_item_idx.unwrap_or(0)
    }

    pub fn clear_featured_item_idx(&mut self) {
        self.featured_item_idx = ::std::option::Option::None;
    }

    pub fn has_featured_item_idx(&self) -> bool {
        self.featured_item_idx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_featured_item_idx(&mut self, v: i32) {
        self.featured_item_idx = ::std::option::Option::Some(v);
    }

    // optional bool show_hat_descriptions = 7;

    pub fn show_hat_descriptions(&self) -> bool {
        self.show_hat_descriptions.unwrap_or(true)
    }

    pub fn clear_show_hat_descriptions(&mut self) {
        self.show_hat_descriptions = ::std::option::Option::None;
    }

    pub fn has_show_hat_descriptions(&self) -> bool {
        self.show_hat_descriptions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_show_hat_descriptions(&mut self, v: bool) {
        self.show_hat_descriptions = ::std::option::Option::Some(v);
    }

    // optional bytes price_sheet = 8;

    pub fn price_sheet(&self) -> &[u8] {
        match self.price_sheet.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_price_sheet(&mut self) {
        self.price_sheet = ::std::option::Option::None;
    }

    pub fn has_price_sheet(&self) -> bool {
        self.price_sheet.is_some()
    }

    // Param is passed by value, moved
    pub fn set_price_sheet(&mut self, v: ::std::vec::Vec<u8>) {
        self.price_sheet = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_price_sheet(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.price_sheet.is_none() {
            self.price_sheet = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.price_sheet.as_mut().unwrap()
    }

    // Take field
    pub fn take_price_sheet(&mut self) -> ::std::vec::Vec<u8> {
        self.price_sheet.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional int32 default_item_sort = 9;

    pub fn default_item_sort(&self) -> i32 {
        self.default_item_sort.unwrap_or(0i32)
    }

    pub fn clear_default_item_sort(&mut self) {
        self.default_item_sort = ::std::option::Option::None;
    }

    pub fn has_default_item_sort(&self) -> bool {
        self.default_item_sort.is_some()
    }

    // Param is passed by value, moved
    pub fn set_default_item_sort(&mut self, v: i32) {
        self.default_item_sort = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &CMsgStoreGetUserDataResponse| { &m.result },
            |m: &mut CMsgStoreGetUserDataResponse| { &mut m.result },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "currency",
            |m: &CMsgStoreGetUserDataResponse| { &m.currency },
            |m: &mut CMsgStoreGetUserDataResponse| { &mut m.currency },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "country",
            |m: &CMsgStoreGetUserDataResponse| { &m.country },
            |m: &mut CMsgStoreGetUserDataResponse| { &mut m.country },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "price_sheet_version",
            |m: &CMsgStoreGetUserDataResponse| { &m.price_sheet_version },
            |m: &mut CMsgStoreGetUserDataResponse| { &mut m.price_sheet_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "experiment_data",
            |m: &CMsgStoreGetUserDataResponse| { &m.experiment_data },
            |m: &mut CMsgStoreGetUserDataResponse| { &mut m.experiment_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "featured_item_idx",
            |m: &CMsgStoreGetUserDataResponse| { &m.featured_item_idx },
            |m: &mut CMsgStoreGetUserDataResponse| { &mut m.featured_item_idx },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "show_hat_descriptions",
            |m: &CMsgStoreGetUserDataResponse| { &m.show_hat_descriptions },
            |m: &mut CMsgStoreGetUserDataResponse| { &mut m.show_hat_descriptions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "price_sheet",
            |m: &CMsgStoreGetUserDataResponse| { &m.price_sheet },
            |m: &mut CMsgStoreGetUserDataResponse| { &mut m.price_sheet },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "default_item_sort",
            |m: &CMsgStoreGetUserDataResponse| { &m.default_item_sort },
            |m: &mut CMsgStoreGetUserDataResponse| { &mut m.default_item_sort },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "popular_items",
            |m: &CMsgStoreGetUserDataResponse| { &m.popular_items },
            |m: &mut CMsgStoreGetUserDataResponse| { &mut m.popular_items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgStoreGetUserDataResponse>(
            "CMsgStoreGetUserDataResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgStoreGetUserDataResponse {
    const NAME: &'static str = "CMsgStoreGetUserDataResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.currency = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    self.country = ::std::option::Option::Some(is.read_string()?);
                },
                37 => {
                    self.price_sheet_version = ::std::option::Option::Some(is.read_fixed32()?);
                },
                40 => {
                    self.experiment_data = ::std::option::Option::Some(is.read_uint64()?);
                },
                48 => {
                    self.featured_item_idx = ::std::option::Option::Some(is.read_int32()?);
                },
                56 => {
                    self.show_hat_descriptions = ::std::option::Option::Some(is.read_bool()?);
                },
                66 => {
                    self.price_sheet = ::std::option::Option::Some(is.read_bytes()?);
                },
                72 => {
                    self.default_item_sort = ::std::option::Option::Some(is.read_int32()?);
                },
                82 => {
                    is.read_repeated_packed_uint32_into(&mut self.popular_items)?;
                },
                80 => {
                    self.popular_items.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.currency {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.country.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.price_sheet_version {
            my_size += 1 + 4;
        }
        if let Some(v) = self.experiment_data {
            my_size += ::protobuf::rt::uint64_size(5, v);
        }
        if let Some(v) = self.featured_item_idx {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.show_hat_descriptions {
            my_size += 1 + 1;
        }
        if let Some(v) = self.price_sheet.as_ref() {
            my_size += ::protobuf::rt::bytes_size(8, &v);
        }
        if let Some(v) = self.default_item_sort {
            my_size += ::protobuf::rt::int32_size(9, v);
        }
        for value in &self.popular_items {
            my_size += ::protobuf::rt::uint32_size(10, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.currency {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.country.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.price_sheet_version {
            os.write_fixed32(4, v)?;
        }
        if let Some(v) = self.experiment_data {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.featured_item_idx {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.show_hat_descriptions {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.price_sheet.as_ref() {
            os.write_bytes(8, v)?;
        }
        if let Some(v) = self.default_item_sort {
            os.write_int32(9, v)?;
        }
        for v in &self.popular_items {
            os.write_uint32(10, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgStoreGetUserDataResponse {
        CMsgStoreGetUserDataResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.currency = ::std::option::Option::None;
        self.country = ::std::option::Option::None;
        self.price_sheet_version = ::std::option::Option::None;
        self.experiment_data = ::std::option::Option::None;
        self.featured_item_idx = ::std::option::Option::None;
        self.show_hat_descriptions = ::std::option::Option::None;
        self.price_sheet = ::std::option::Option::None;
        self.default_item_sort = ::std::option::Option::None;
        self.popular_items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgStoreGetUserDataResponse {
        static instance: CMsgStoreGetUserDataResponse = CMsgStoreGetUserDataResponse {
            result: ::std::option::Option::None,
            currency: ::std::option::Option::None,
            country: ::std::option::Option::None,
            price_sheet_version: ::std::option::Option::None,
            experiment_data: ::std::option::Option::None,
            featured_item_idx: ::std::option::Option::None,
            show_hat_descriptions: ::std::option::Option::None,
            price_sheet: ::std::option::Option::None,
            default_item_sort: ::std::option::Option::None,
            popular_items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgStoreGetUserDataResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgStoreGetUserDataResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgStoreGetUserDataResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgStoreGetUserDataResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgUpdateItemSchema)
pub struct CMsgUpdateItemSchema {
    // message fields
    // @@protoc_insertion_point(field:CMsgUpdateItemSchema.items_game)
    pub items_game: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgUpdateItemSchema.item_schema_version)
    pub item_schema_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgUpdateItemSchema.items_game_url)
    pub items_game_url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgUpdateItemSchema.signature)
    pub signature: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgUpdateItemSchema.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgUpdateItemSchema {
    fn default() -> &'a CMsgUpdateItemSchema {
        <CMsgUpdateItemSchema as ::protobuf::Message>::default_instance()
    }
}

impl CMsgUpdateItemSchema {
    pub fn new() -> CMsgUpdateItemSchema {
        ::std::default::Default::default()
    }

    // optional bytes items_game = 1;

    pub fn items_game(&self) -> &[u8] {
        match self.items_game.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_items_game(&mut self) {
        self.items_game = ::std::option::Option::None;
    }

    pub fn has_items_game(&self) -> bool {
        self.items_game.is_some()
    }

    // Param is passed by value, moved
    pub fn set_items_game(&mut self, v: ::std::vec::Vec<u8>) {
        self.items_game = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_items_game(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.items_game.is_none() {
            self.items_game = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.items_game.as_mut().unwrap()
    }

    // Take field
    pub fn take_items_game(&mut self) -> ::std::vec::Vec<u8> {
        self.items_game.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional fixed32 item_schema_version = 2;

    pub fn item_schema_version(&self) -> u32 {
        self.item_schema_version.unwrap_or(0)
    }

    pub fn clear_item_schema_version(&mut self) {
        self.item_schema_version = ::std::option::Option::None;
    }

    pub fn has_item_schema_version(&self) -> bool {
        self.item_schema_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_schema_version(&mut self, v: u32) {
        self.item_schema_version = ::std::option::Option::Some(v);
    }

    // optional string items_game_url = 3;

    pub fn items_game_url(&self) -> &str {
        match self.items_game_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_items_game_url(&mut self) {
        self.items_game_url = ::std::option::Option::None;
    }

    pub fn has_items_game_url(&self) -> bool {
        self.items_game_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_items_game_url(&mut self, v: ::std::string::String) {
        self.items_game_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_items_game_url(&mut self) -> &mut ::std::string::String {
        if self.items_game_url.is_none() {
            self.items_game_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.items_game_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_items_game_url(&mut self) -> ::std::string::String {
        self.items_game_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes signature = 4;

    pub fn signature(&self) -> &[u8] {
        match self.signature.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_signature(&mut self) {
        self.signature = ::std::option::Option::None;
    }

    pub fn has_signature(&self) -> bool {
        self.signature.is_some()
    }

    // Param is passed by value, moved
    pub fn set_signature(&mut self, v: ::std::vec::Vec<u8>) {
        self.signature = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signature(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.signature.is_none() {
            self.signature = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.signature.as_mut().unwrap()
    }

    // Take field
    pub fn take_signature(&mut self) -> ::std::vec::Vec<u8> {
        self.signature.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "items_game",
            |m: &CMsgUpdateItemSchema| { &m.items_game },
            |m: &mut CMsgUpdateItemSchema| { &mut m.items_game },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_schema_version",
            |m: &CMsgUpdateItemSchema| { &m.item_schema_version },
            |m: &mut CMsgUpdateItemSchema| { &mut m.item_schema_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "items_game_url",
            |m: &CMsgUpdateItemSchema| { &m.items_game_url },
            |m: &mut CMsgUpdateItemSchema| { &mut m.items_game_url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "signature",
            |m: &CMsgUpdateItemSchema| { &m.signature },
            |m: &mut CMsgUpdateItemSchema| { &mut m.signature },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgUpdateItemSchema>(
            "CMsgUpdateItemSchema",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgUpdateItemSchema {
    const NAME: &'static str = "CMsgUpdateItemSchema";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.items_game = ::std::option::Option::Some(is.read_bytes()?);
                },
                21 => {
                    self.item_schema_version = ::std::option::Option::Some(is.read_fixed32()?);
                },
                26 => {
                    self.items_game_url = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.signature = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.items_game.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.item_schema_version {
            my_size += 1 + 4;
        }
        if let Some(v) = self.items_game_url.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.signature.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.items_game.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.item_schema_version {
            os.write_fixed32(2, v)?;
        }
        if let Some(v) = self.items_game_url.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.signature.as_ref() {
            os.write_bytes(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgUpdateItemSchema {
        CMsgUpdateItemSchema::new()
    }

    fn clear(&mut self) {
        self.items_game = ::std::option::Option::None;
        self.item_schema_version = ::std::option::Option::None;
        self.items_game_url = ::std::option::Option::None;
        self.signature = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgUpdateItemSchema {
        static instance: CMsgUpdateItemSchema = CMsgUpdateItemSchema {
            items_game: ::std::option::Option::None,
            item_schema_version: ::std::option::Option::None,
            items_game_url: ::std::option::Option::None,
            signature: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgUpdateItemSchema {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgUpdateItemSchema").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgUpdateItemSchema {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgUpdateItemSchema {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCError)
pub struct CMsgGCError {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCError.error_text)
    pub error_text: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCError.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCError {
    fn default() -> &'a CMsgGCError {
        <CMsgGCError as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCError {
    pub fn new() -> CMsgGCError {
        ::std::default::Default::default()
    }

    // optional string error_text = 1;

    pub fn error_text(&self) -> &str {
        match self.error_text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_error_text(&mut self) {
        self.error_text = ::std::option::Option::None;
    }

    pub fn has_error_text(&self) -> bool {
        self.error_text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error_text(&mut self, v: ::std::string::String) {
        self.error_text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error_text(&mut self) -> &mut ::std::string::String {
        if self.error_text.is_none() {
            self.error_text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.error_text.as_mut().unwrap()
    }

    // Take field
    pub fn take_error_text(&mut self) -> ::std::string::String {
        self.error_text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "error_text",
            |m: &CMsgGCError| { &m.error_text },
            |m: &mut CMsgGCError| { &mut m.error_text },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCError>(
            "CMsgGCError",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCError {
    const NAME: &'static str = "CMsgGCError";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.error_text = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.error_text.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.error_text.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCError {
        CMsgGCError::new()
    }

    fn clear(&mut self) {
        self.error_text = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCError {
        static instance: CMsgGCError = CMsgGCError {
            error_text: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCError {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCError").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCError {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgRequestInventoryRefresh)
pub struct CMsgRequestInventoryRefresh {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgRequestInventoryRefresh.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRequestInventoryRefresh {
    fn default() -> &'a CMsgRequestInventoryRefresh {
        <CMsgRequestInventoryRefresh as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRequestInventoryRefresh {
    pub fn new() -> CMsgRequestInventoryRefresh {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgRequestInventoryRefresh>(
            "CMsgRequestInventoryRefresh",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgRequestInventoryRefresh {
    const NAME: &'static str = "CMsgRequestInventoryRefresh";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRequestInventoryRefresh {
        CMsgRequestInventoryRefresh::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRequestInventoryRefresh {
        static instance: CMsgRequestInventoryRefresh = CMsgRequestInventoryRefresh {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgRequestInventoryRefresh {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgRequestInventoryRefresh").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgRequestInventoryRefresh {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgRequestInventoryRefresh {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgConVarValue)
pub struct CMsgConVarValue {
    // message fields
    // @@protoc_insertion_point(field:CMsgConVarValue.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgConVarValue.value)
    pub value: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgConVarValue.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgConVarValue {
    fn default() -> &'a CMsgConVarValue {
        <CMsgConVarValue as ::protobuf::Message>::default_instance()
    }
}

impl CMsgConVarValue {
    pub fn new() -> CMsgConVarValue {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string value = 2;

    pub fn value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value = ::std::option::Option::Some(::std::string::String::new());
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &CMsgConVarValue| { &m.name },
            |m: &mut CMsgConVarValue| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "value",
            |m: &CMsgConVarValue| { &m.value },
            |m: &mut CMsgConVarValue| { &mut m.value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgConVarValue>(
            "CMsgConVarValue",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgConVarValue {
    const NAME: &'static str = "CMsgConVarValue";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.value = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.value.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgConVarValue {
        CMsgConVarValue::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgConVarValue {
        static instance: CMsgConVarValue = CMsgConVarValue {
            name: ::std::option::Option::None,
            value: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgConVarValue {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgConVarValue").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgConVarValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgConVarValue {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgReplicateConVars)
pub struct CMsgReplicateConVars {
    // message fields
    // @@protoc_insertion_point(field:CMsgReplicateConVars.convars)
    pub convars: ::std::vec::Vec<CMsgConVarValue>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgReplicateConVars.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgReplicateConVars {
    fn default() -> &'a CMsgReplicateConVars {
        <CMsgReplicateConVars as ::protobuf::Message>::default_instance()
    }
}

impl CMsgReplicateConVars {
    pub fn new() -> CMsgReplicateConVars {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "convars",
            |m: &CMsgReplicateConVars| { &m.convars },
            |m: &mut CMsgReplicateConVars| { &mut m.convars },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgReplicateConVars>(
            "CMsgReplicateConVars",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgReplicateConVars {
    const NAME: &'static str = "CMsgReplicateConVars";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.convars.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.convars {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.convars {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgReplicateConVars {
        CMsgReplicateConVars::new()
    }

    fn clear(&mut self) {
        self.convars.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgReplicateConVars {
        static instance: CMsgReplicateConVars = CMsgReplicateConVars {
            convars: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgReplicateConVars {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgReplicateConVars").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgReplicateConVars {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgReplicateConVars {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgUseItem)
pub struct CMsgUseItem {
    // message fields
    // @@protoc_insertion_point(field:CMsgUseItem.item_id)
    pub item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgUseItem.target_steam_id)
    pub target_steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgUseItem.gift__potential_targets)
    pub gift__potential_targets: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgUseItem.duel__class_lock)
    pub duel__class_lock: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgUseItem.initiator_steam_id)
    pub initiator_steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgUseItem.itempack__ack_immediately)
    pub itempack__ack_immediately: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgUseItem.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgUseItem {
    fn default() -> &'a CMsgUseItem {
        <CMsgUseItem as ::protobuf::Message>::default_instance()
    }
}

impl CMsgUseItem {
    pub fn new() -> CMsgUseItem {
        ::std::default::Default::default()
    }

    // optional uint64 item_id = 1;

    pub fn item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 target_steam_id = 2;

    pub fn target_steam_id(&self) -> u64 {
        self.target_steam_id.unwrap_or(0)
    }

    pub fn clear_target_steam_id(&mut self) {
        self.target_steam_id = ::std::option::Option::None;
    }

    pub fn has_target_steam_id(&self) -> bool {
        self.target_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_steam_id(&mut self, v: u64) {
        self.target_steam_id = ::std::option::Option::Some(v);
    }

    // optional uint32 duel__class_lock = 4;

    pub fn duel__class_lock(&self) -> u32 {
        self.duel__class_lock.unwrap_or(0)
    }

    pub fn clear_duel__class_lock(&mut self) {
        self.duel__class_lock = ::std::option::Option::None;
    }

    pub fn has_duel__class_lock(&self) -> bool {
        self.duel__class_lock.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duel__class_lock(&mut self, v: u32) {
        self.duel__class_lock = ::std::option::Option::Some(v);
    }

    // optional fixed64 initiator_steam_id = 5;

    pub fn initiator_steam_id(&self) -> u64 {
        self.initiator_steam_id.unwrap_or(0)
    }

    pub fn clear_initiator_steam_id(&mut self) {
        self.initiator_steam_id = ::std::option::Option::None;
    }

    pub fn has_initiator_steam_id(&self) -> bool {
        self.initiator_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initiator_steam_id(&mut self, v: u64) {
        self.initiator_steam_id = ::std::option::Option::Some(v);
    }

    // optional bool itempack__ack_immediately = 6;

    pub fn itempack__ack_immediately(&self) -> bool {
        self.itempack__ack_immediately.unwrap_or(false)
    }

    pub fn clear_itempack__ack_immediately(&mut self) {
        self.itempack__ack_immediately = ::std::option::Option::None;
    }

    pub fn has_itempack__ack_immediately(&self) -> bool {
        self.itempack__ack_immediately.is_some()
    }

    // Param is passed by value, moved
    pub fn set_itempack__ack_immediately(&mut self, v: bool) {
        self.itempack__ack_immediately = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_id",
            |m: &CMsgUseItem| { &m.item_id },
            |m: &mut CMsgUseItem| { &mut m.item_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "target_steam_id",
            |m: &CMsgUseItem| { &m.target_steam_id },
            |m: &mut CMsgUseItem| { &mut m.target_steam_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "gift__potential_targets",
            |m: &CMsgUseItem| { &m.gift__potential_targets },
            |m: &mut CMsgUseItem| { &mut m.gift__potential_targets },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "duel__class_lock",
            |m: &CMsgUseItem| { &m.duel__class_lock },
            |m: &mut CMsgUseItem| { &mut m.duel__class_lock },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "initiator_steam_id",
            |m: &CMsgUseItem| { &m.initiator_steam_id },
            |m: &mut CMsgUseItem| { &mut m.initiator_steam_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "itempack__ack_immediately",
            |m: &CMsgUseItem| { &m.itempack__ack_immediately },
            |m: &mut CMsgUseItem| { &mut m.itempack__ack_immediately },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgUseItem>(
            "CMsgUseItem",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgUseItem {
    const NAME: &'static str = "CMsgUseItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                17 => {
                    self.target_steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                26 => {
                    is.read_repeated_packed_uint32_into(&mut self.gift__potential_targets)?;
                },
                24 => {
                    self.gift__potential_targets.push(is.read_uint32()?);
                },
                32 => {
                    self.duel__class_lock = ::std::option::Option::Some(is.read_uint32()?);
                },
                41 => {
                    self.initiator_steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                48 => {
                    self.itempack__ack_immediately = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.target_steam_id {
            my_size += 1 + 8;
        }
        for value in &self.gift__potential_targets {
            my_size += ::protobuf::rt::uint32_size(3, *value);
        };
        if let Some(v) = self.duel__class_lock {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.initiator_steam_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.itempack__ack_immediately {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.target_steam_id {
            os.write_fixed64(2, v)?;
        }
        for v in &self.gift__potential_targets {
            os.write_uint32(3, *v)?;
        };
        if let Some(v) = self.duel__class_lock {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.initiator_steam_id {
            os.write_fixed64(5, v)?;
        }
        if let Some(v) = self.itempack__ack_immediately {
            os.write_bool(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgUseItem {
        CMsgUseItem::new()
    }

    fn clear(&mut self) {
        self.item_id = ::std::option::Option::None;
        self.target_steam_id = ::std::option::Option::None;
        self.gift__potential_targets.clear();
        self.duel__class_lock = ::std::option::Option::None;
        self.initiator_steam_id = ::std::option::Option::None;
        self.itempack__ack_immediately = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgUseItem {
        static instance: CMsgUseItem = CMsgUseItem {
            item_id: ::std::option::Option::None,
            target_steam_id: ::std::option::Option::None,
            gift__potential_targets: ::std::vec::Vec::new(),
            duel__class_lock: ::std::option::Option::None,
            initiator_steam_id: ::std::option::Option::None,
            itempack__ack_immediately: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgUseItem {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgUseItem").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgUseItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgUseItem {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgReplayUploadedToYouTube)
pub struct CMsgReplayUploadedToYouTube {
    // message fields
    // @@protoc_insertion_point(field:CMsgReplayUploadedToYouTube.youtube_url)
    pub youtube_url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgReplayUploadedToYouTube.youtube_account_name)
    pub youtube_account_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgReplayUploadedToYouTube.session_id)
    pub session_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgReplayUploadedToYouTube.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgReplayUploadedToYouTube {
    fn default() -> &'a CMsgReplayUploadedToYouTube {
        <CMsgReplayUploadedToYouTube as ::protobuf::Message>::default_instance()
    }
}

impl CMsgReplayUploadedToYouTube {
    pub fn new() -> CMsgReplayUploadedToYouTube {
        ::std::default::Default::default()
    }

    // optional string youtube_url = 1;

    pub fn youtube_url(&self) -> &str {
        match self.youtube_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_youtube_url(&mut self) {
        self.youtube_url = ::std::option::Option::None;
    }

    pub fn has_youtube_url(&self) -> bool {
        self.youtube_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_youtube_url(&mut self, v: ::std::string::String) {
        self.youtube_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_youtube_url(&mut self) -> &mut ::std::string::String {
        if self.youtube_url.is_none() {
            self.youtube_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.youtube_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_youtube_url(&mut self) -> ::std::string::String {
        self.youtube_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string youtube_account_name = 2;

    pub fn youtube_account_name(&self) -> &str {
        match self.youtube_account_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_youtube_account_name(&mut self) {
        self.youtube_account_name = ::std::option::Option::None;
    }

    pub fn has_youtube_account_name(&self) -> bool {
        self.youtube_account_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_youtube_account_name(&mut self, v: ::std::string::String) {
        self.youtube_account_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_youtube_account_name(&mut self) -> &mut ::std::string::String {
        if self.youtube_account_name.is_none() {
            self.youtube_account_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.youtube_account_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_youtube_account_name(&mut self) -> ::std::string::String {
        self.youtube_account_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 session_id = 3;

    pub fn session_id(&self) -> u64 {
        self.session_id.unwrap_or(0)
    }

    pub fn clear_session_id(&mut self) {
        self.session_id = ::std::option::Option::None;
    }

    pub fn has_session_id(&self) -> bool {
        self.session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_session_id(&mut self, v: u64) {
        self.session_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "youtube_url",
            |m: &CMsgReplayUploadedToYouTube| { &m.youtube_url },
            |m: &mut CMsgReplayUploadedToYouTube| { &mut m.youtube_url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "youtube_account_name",
            |m: &CMsgReplayUploadedToYouTube| { &m.youtube_account_name },
            |m: &mut CMsgReplayUploadedToYouTube| { &mut m.youtube_account_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "session_id",
            |m: &CMsgReplayUploadedToYouTube| { &m.session_id },
            |m: &mut CMsgReplayUploadedToYouTube| { &mut m.session_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgReplayUploadedToYouTube>(
            "CMsgReplayUploadedToYouTube",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgReplayUploadedToYouTube {
    const NAME: &'static str = "CMsgReplayUploadedToYouTube";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.youtube_url = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.youtube_account_name = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.session_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.youtube_url.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.youtube_account_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.session_id {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.youtube_url.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.youtube_account_name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.session_id {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgReplayUploadedToYouTube {
        CMsgReplayUploadedToYouTube::new()
    }

    fn clear(&mut self) {
        self.youtube_url = ::std::option::Option::None;
        self.youtube_account_name = ::std::option::Option::None;
        self.session_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgReplayUploadedToYouTube {
        static instance: CMsgReplayUploadedToYouTube = CMsgReplayUploadedToYouTube {
            youtube_url: ::std::option::Option::None,
            youtube_account_name: ::std::option::Option::None,
            session_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgReplayUploadedToYouTube {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgReplayUploadedToYouTube").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgReplayUploadedToYouTube {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgReplayUploadedToYouTube {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgConsumableExhausted)
pub struct CMsgConsumableExhausted {
    // message fields
    // @@protoc_insertion_point(field:CMsgConsumableExhausted.item_def_id)
    pub item_def_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgConsumableExhausted.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgConsumableExhausted {
    fn default() -> &'a CMsgConsumableExhausted {
        <CMsgConsumableExhausted as ::protobuf::Message>::default_instance()
    }
}

impl CMsgConsumableExhausted {
    pub fn new() -> CMsgConsumableExhausted {
        ::std::default::Default::default()
    }

    // optional int32 item_def_id = 1;

    pub fn item_def_id(&self) -> i32 {
        self.item_def_id.unwrap_or(0)
    }

    pub fn clear_item_def_id(&mut self) {
        self.item_def_id = ::std::option::Option::None;
    }

    pub fn has_item_def_id(&self) -> bool {
        self.item_def_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_def_id(&mut self, v: i32) {
        self.item_def_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_def_id",
            |m: &CMsgConsumableExhausted| { &m.item_def_id },
            |m: &mut CMsgConsumableExhausted| { &mut m.item_def_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgConsumableExhausted>(
            "CMsgConsumableExhausted",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgConsumableExhausted {
    const NAME: &'static str = "CMsgConsumableExhausted";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_def_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_def_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.item_def_id {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgConsumableExhausted {
        CMsgConsumableExhausted::new()
    }

    fn clear(&mut self) {
        self.item_def_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgConsumableExhausted {
        static instance: CMsgConsumableExhausted = CMsgConsumableExhausted {
            item_def_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgConsumableExhausted {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgConsumableExhausted").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgConsumableExhausted {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgConsumableExhausted {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgItemAcknowledged)
pub struct CMsgItemAcknowledged {
    // message fields
    // @@protoc_insertion_point(field:CMsgItemAcknowledged.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgItemAcknowledged.inventory)
    pub inventory: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgItemAcknowledged.def_index)
    pub def_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgItemAcknowledged.quality)
    pub quality: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgItemAcknowledged.rarity)
    pub rarity: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgItemAcknowledged.origin)
    pub origin: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgItemAcknowledged.is_strange)
    pub is_strange: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgItemAcknowledged.is_unusual)
    pub is_unusual: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgItemAcknowledged.wear)
    pub wear: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgItemAcknowledged.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgItemAcknowledged {
    fn default() -> &'a CMsgItemAcknowledged {
        <CMsgItemAcknowledged as ::protobuf::Message>::default_instance()
    }
}

impl CMsgItemAcknowledged {
    pub fn new() -> CMsgItemAcknowledged {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 inventory = 2;

    pub fn inventory(&self) -> u32 {
        self.inventory.unwrap_or(0)
    }

    pub fn clear_inventory(&mut self) {
        self.inventory = ::std::option::Option::None;
    }

    pub fn has_inventory(&self) -> bool {
        self.inventory.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inventory(&mut self, v: u32) {
        self.inventory = ::std::option::Option::Some(v);
    }

    // optional uint32 def_index = 3;

    pub fn def_index(&self) -> u32 {
        self.def_index.unwrap_or(0)
    }

    pub fn clear_def_index(&mut self) {
        self.def_index = ::std::option::Option::None;
    }

    pub fn has_def_index(&self) -> bool {
        self.def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_def_index(&mut self, v: u32) {
        self.def_index = ::std::option::Option::Some(v);
    }

    // optional uint32 quality = 4;

    pub fn quality(&self) -> u32 {
        self.quality.unwrap_or(0)
    }

    pub fn clear_quality(&mut self) {
        self.quality = ::std::option::Option::None;
    }

    pub fn has_quality(&self) -> bool {
        self.quality.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality(&mut self, v: u32) {
        self.quality = ::std::option::Option::Some(v);
    }

    // optional uint32 rarity = 5;

    pub fn rarity(&self) -> u32 {
        self.rarity.unwrap_or(0)
    }

    pub fn clear_rarity(&mut self) {
        self.rarity = ::std::option::Option::None;
    }

    pub fn has_rarity(&self) -> bool {
        self.rarity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rarity(&mut self, v: u32) {
        self.rarity = ::std::option::Option::Some(v);
    }

    // optional uint32 origin = 6;

    pub fn origin(&self) -> u32 {
        self.origin.unwrap_or(0)
    }

    pub fn clear_origin(&mut self) {
        self.origin = ::std::option::Option::None;
    }

    pub fn has_origin(&self) -> bool {
        self.origin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_origin(&mut self, v: u32) {
        self.origin = ::std::option::Option::Some(v);
    }

    // optional uint32 is_strange = 7;

    pub fn is_strange(&self) -> u32 {
        self.is_strange.unwrap_or(0)
    }

    pub fn clear_is_strange(&mut self) {
        self.is_strange = ::std::option::Option::None;
    }

    pub fn has_is_strange(&self) -> bool {
        self.is_strange.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_strange(&mut self, v: u32) {
        self.is_strange = ::std::option::Option::Some(v);
    }

    // optional uint32 is_unusual = 8;

    pub fn is_unusual(&self) -> u32 {
        self.is_unusual.unwrap_or(0)
    }

    pub fn clear_is_unusual(&mut self) {
        self.is_unusual = ::std::option::Option::None;
    }

    pub fn has_is_unusual(&self) -> bool {
        self.is_unusual.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_unusual(&mut self, v: u32) {
        self.is_unusual = ::std::option::Option::Some(v);
    }

    // optional float wear = 9;

    pub fn wear(&self) -> f32 {
        self.wear.unwrap_or(0.)
    }

    pub fn clear_wear(&mut self) {
        self.wear = ::std::option::Option::None;
    }

    pub fn has_wear(&self) -> bool {
        self.wear.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wear(&mut self, v: f32) {
        self.wear = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CMsgItemAcknowledged| { &m.account_id },
            |m: &mut CMsgItemAcknowledged| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "inventory",
            |m: &CMsgItemAcknowledged| { &m.inventory },
            |m: &mut CMsgItemAcknowledged| { &mut m.inventory },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "def_index",
            |m: &CMsgItemAcknowledged| { &m.def_index },
            |m: &mut CMsgItemAcknowledged| { &mut m.def_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "quality",
            |m: &CMsgItemAcknowledged| { &m.quality },
            |m: &mut CMsgItemAcknowledged| { &mut m.quality },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rarity",
            |m: &CMsgItemAcknowledged| { &m.rarity },
            |m: &mut CMsgItemAcknowledged| { &mut m.rarity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "origin",
            |m: &CMsgItemAcknowledged| { &m.origin },
            |m: &mut CMsgItemAcknowledged| { &mut m.origin },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_strange",
            |m: &CMsgItemAcknowledged| { &m.is_strange },
            |m: &mut CMsgItemAcknowledged| { &mut m.is_strange },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_unusual",
            |m: &CMsgItemAcknowledged| { &m.is_unusual },
            |m: &mut CMsgItemAcknowledged| { &mut m.is_unusual },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "wear",
            |m: &CMsgItemAcknowledged| { &m.wear },
            |m: &mut CMsgItemAcknowledged| { &mut m.wear },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgItemAcknowledged>(
            "CMsgItemAcknowledged",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgItemAcknowledged {
    const NAME: &'static str = "CMsgItemAcknowledged";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.inventory = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.def_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.quality = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.rarity = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.origin = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.is_strange = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.is_unusual = ::std::option::Option::Some(is.read_uint32()?);
                },
                77 => {
                    self.wear = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.inventory {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.def_index {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.quality {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.rarity {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.origin {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.is_strange {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.is_unusual {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.wear {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.inventory {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.def_index {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.quality {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.rarity {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.origin {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.is_strange {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.is_unusual {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.wear {
            os.write_float(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgItemAcknowledged {
        CMsgItemAcknowledged::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.inventory = ::std::option::Option::None;
        self.def_index = ::std::option::Option::None;
        self.quality = ::std::option::Option::None;
        self.rarity = ::std::option::Option::None;
        self.origin = ::std::option::Option::None;
        self.is_strange = ::std::option::Option::None;
        self.is_unusual = ::std::option::Option::None;
        self.wear = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgItemAcknowledged {
        static instance: CMsgItemAcknowledged = CMsgItemAcknowledged {
            account_id: ::std::option::Option::None,
            inventory: ::std::option::Option::None,
            def_index: ::std::option::Option::None,
            quality: ::std::option::Option::None,
            rarity: ::std::option::Option::None,
            origin: ::std::option::Option::None,
            is_strange: ::std::option::Option::None,
            is_unusual: ::std::option::Option::None,
            wear: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgItemAcknowledged {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgItemAcknowledged").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgItemAcknowledged {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgItemAcknowledged {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgSetPresetItemPosition)
pub struct CMsgSetPresetItemPosition {
    // message fields
    // @@protoc_insertion_point(field:CMsgSetPresetItemPosition.class_id)
    pub class_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSetPresetItemPosition.preset_id)
    pub preset_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSetPresetItemPosition.slot_id)
    pub slot_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSetPresetItemPosition.item_id)
    pub item_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSetPresetItemPosition.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSetPresetItemPosition {
    fn default() -> &'a CMsgSetPresetItemPosition {
        <CMsgSetPresetItemPosition as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSetPresetItemPosition {
    pub fn new() -> CMsgSetPresetItemPosition {
        ::std::default::Default::default()
    }

    // optional uint32 class_id = 1;

    pub fn class_id(&self) -> u32 {
        self.class_id.unwrap_or(0)
    }

    pub fn clear_class_id(&mut self) {
        self.class_id = ::std::option::Option::None;
    }

    pub fn has_class_id(&self) -> bool {
        self.class_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_class_id(&mut self, v: u32) {
        self.class_id = ::std::option::Option::Some(v);
    }

    // optional uint32 preset_id = 2;

    pub fn preset_id(&self) -> u32 {
        self.preset_id.unwrap_or(0)
    }

    pub fn clear_preset_id(&mut self) {
        self.preset_id = ::std::option::Option::None;
    }

    pub fn has_preset_id(&self) -> bool {
        self.preset_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preset_id(&mut self, v: u32) {
        self.preset_id = ::std::option::Option::Some(v);
    }

    // optional uint32 slot_id = 3;

    pub fn slot_id(&self) -> u32 {
        self.slot_id.unwrap_or(0)
    }

    pub fn clear_slot_id(&mut self) {
        self.slot_id = ::std::option::Option::None;
    }

    pub fn has_slot_id(&self) -> bool {
        self.slot_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slot_id(&mut self, v: u32) {
        self.slot_id = ::std::option::Option::Some(v);
    }

    // optional uint64 item_id = 4;

    pub fn item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "class_id",
            |m: &CMsgSetPresetItemPosition| { &m.class_id },
            |m: &mut CMsgSetPresetItemPosition| { &mut m.class_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "preset_id",
            |m: &CMsgSetPresetItemPosition| { &m.preset_id },
            |m: &mut CMsgSetPresetItemPosition| { &mut m.preset_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "slot_id",
            |m: &CMsgSetPresetItemPosition| { &m.slot_id },
            |m: &mut CMsgSetPresetItemPosition| { &mut m.slot_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_id",
            |m: &CMsgSetPresetItemPosition| { &m.item_id },
            |m: &mut CMsgSetPresetItemPosition| { &mut m.item_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSetPresetItemPosition>(
            "CMsgSetPresetItemPosition",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSetPresetItemPosition {
    const NAME: &'static str = "CMsgSetPresetItemPosition";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.class_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.preset_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.slot_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.class_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.preset_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.slot_id {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::uint64_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.class_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.preset_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.slot_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.item_id {
            os.write_uint64(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSetPresetItemPosition {
        CMsgSetPresetItemPosition::new()
    }

    fn clear(&mut self) {
        self.class_id = ::std::option::Option::None;
        self.preset_id = ::std::option::Option::None;
        self.slot_id = ::std::option::Option::None;
        self.item_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSetPresetItemPosition {
        static instance: CMsgSetPresetItemPosition = CMsgSetPresetItemPosition {
            class_id: ::std::option::Option::None,
            preset_id: ::std::option::Option::None,
            slot_id: ::std::option::Option::None,
            item_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSetPresetItemPosition {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSetPresetItemPosition").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSetPresetItemPosition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSetPresetItemPosition {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgSetItemPositions)
pub struct CMsgSetItemPositions {
    // message fields
    // @@protoc_insertion_point(field:CMsgSetItemPositions.item_positions)
    pub item_positions: ::std::vec::Vec<cmsg_set_item_positions::ItemPosition>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSetItemPositions.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSetItemPositions {
    fn default() -> &'a CMsgSetItemPositions {
        <CMsgSetItemPositions as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSetItemPositions {
    pub fn new() -> CMsgSetItemPositions {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "item_positions",
            |m: &CMsgSetItemPositions| { &m.item_positions },
            |m: &mut CMsgSetItemPositions| { &mut m.item_positions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSetItemPositions>(
            "CMsgSetItemPositions",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSetItemPositions {
    const NAME: &'static str = "CMsgSetItemPositions";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.item_positions.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.item_positions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.item_positions {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSetItemPositions {
        CMsgSetItemPositions::new()
    }

    fn clear(&mut self) {
        self.item_positions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSetItemPositions {
        static instance: CMsgSetItemPositions = CMsgSetItemPositions {
            item_positions: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSetItemPositions {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSetItemPositions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSetItemPositions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSetItemPositions {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgSetItemPositions`
pub mod cmsg_set_item_positions {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:CMsgSetItemPositions.ItemPosition)
    pub struct ItemPosition {
        // message fields
        // @@protoc_insertion_point(field:CMsgSetItemPositions.ItemPosition.item_id)
        pub item_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgSetItemPositions.ItemPosition.position)
        pub position: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgSetItemPositions.ItemPosition.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ItemPosition {
        fn default() -> &'a ItemPosition {
            <ItemPosition as ::protobuf::Message>::default_instance()
        }
    }

    impl ItemPosition {
        pub fn new() -> ItemPosition {
            ::std::default::Default::default()
        }

        // optional uint64 item_id = 1;

        pub fn item_id(&self) -> u64 {
            self.item_id.unwrap_or(0)
        }

        pub fn clear_item_id(&mut self) {
            self.item_id = ::std::option::Option::None;
        }

        pub fn has_item_id(&self) -> bool {
            self.item_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_item_id(&mut self, v: u64) {
            self.item_id = ::std::option::Option::Some(v);
        }

        // optional uint32 position = 2;

        pub fn position(&self) -> u32 {
            self.position.unwrap_or(0)
        }

        pub fn clear_position(&mut self) {
            self.position = ::std::option::Option::None;
        }

        pub fn has_position(&self) -> bool {
            self.position.is_some()
        }

        // Param is passed by value, moved
        pub fn set_position(&mut self, v: u32) {
            self.position = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "item_id",
                |m: &ItemPosition| { &m.item_id },
                |m: &mut ItemPosition| { &mut m.item_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "position",
                |m: &ItemPosition| { &m.position },
                |m: &mut ItemPosition| { &mut m.position },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ItemPosition>(
                "CMsgSetItemPositions.ItemPosition",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ItemPosition {
        const NAME: &'static str = "ItemPosition";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    16 => {
                        self.position = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.item_id {
                my_size += ::protobuf::rt::uint64_size(1, v);
            }
            if let Some(v) = self.position {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.item_id {
                os.write_uint64(1, v)?;
            }
            if let Some(v) = self.position {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ItemPosition {
            ItemPosition::new()
        }

        fn clear(&mut self) {
            self.item_id = ::std::option::Option::None;
            self.position = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ItemPosition {
            static instance: ItemPosition = ItemPosition {
                item_id: ::std::option::Option::None,
                position: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for ItemPosition {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgSetItemPositions.ItemPosition").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ItemPosition {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ItemPosition {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CSOEconItemPresetInstance)
pub struct CSOEconItemPresetInstance {
    // message fields
    // @@protoc_insertion_point(field:CSOEconItemPresetInstance.class_id)
    pub class_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconItemPresetInstance.preset_id)
    pub preset_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconItemPresetInstance.slot_id)
    pub slot_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconItemPresetInstance.item_id)
    pub item_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CSOEconItemPresetInstance.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSOEconItemPresetInstance {
    fn default() -> &'a CSOEconItemPresetInstance {
        <CSOEconItemPresetInstance as ::protobuf::Message>::default_instance()
    }
}

impl CSOEconItemPresetInstance {
    pub fn new() -> CSOEconItemPresetInstance {
        ::std::default::Default::default()
    }

    // optional uint32 class_id = 2;

    pub fn class_id(&self) -> u32 {
        self.class_id.unwrap_or(0)
    }

    pub fn clear_class_id(&mut self) {
        self.class_id = ::std::option::Option::None;
    }

    pub fn has_class_id(&self) -> bool {
        self.class_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_class_id(&mut self, v: u32) {
        self.class_id = ::std::option::Option::Some(v);
    }

    // optional uint32 preset_id = 3;

    pub fn preset_id(&self) -> u32 {
        self.preset_id.unwrap_or(0)
    }

    pub fn clear_preset_id(&mut self) {
        self.preset_id = ::std::option::Option::None;
    }

    pub fn has_preset_id(&self) -> bool {
        self.preset_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preset_id(&mut self, v: u32) {
        self.preset_id = ::std::option::Option::Some(v);
    }

    // optional uint32 slot_id = 4;

    pub fn slot_id(&self) -> u32 {
        self.slot_id.unwrap_or(0)
    }

    pub fn clear_slot_id(&mut self) {
        self.slot_id = ::std::option::Option::None;
    }

    pub fn has_slot_id(&self) -> bool {
        self.slot_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slot_id(&mut self, v: u32) {
        self.slot_id = ::std::option::Option::Some(v);
    }

    // optional uint64 item_id = 5;

    pub fn item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "class_id",
            |m: &CSOEconItemPresetInstance| { &m.class_id },
            |m: &mut CSOEconItemPresetInstance| { &mut m.class_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "preset_id",
            |m: &CSOEconItemPresetInstance| { &m.preset_id },
            |m: &mut CSOEconItemPresetInstance| { &mut m.preset_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "slot_id",
            |m: &CSOEconItemPresetInstance| { &m.slot_id },
            |m: &mut CSOEconItemPresetInstance| { &mut m.slot_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_id",
            |m: &CSOEconItemPresetInstance| { &m.item_id },
            |m: &mut CSOEconItemPresetInstance| { &mut m.item_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSOEconItemPresetInstance>(
            "CSOEconItemPresetInstance",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSOEconItemPresetInstance {
    const NAME: &'static str = "CSOEconItemPresetInstance";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                16 => {
                    self.class_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.preset_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.slot_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.class_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.preset_id {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.slot_id {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::uint64_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.class_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.preset_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.slot_id {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.item_id {
            os.write_uint64(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSOEconItemPresetInstance {
        CSOEconItemPresetInstance::new()
    }

    fn clear(&mut self) {
        self.class_id = ::std::option::Option::None;
        self.preset_id = ::std::option::Option::None;
        self.slot_id = ::std::option::Option::None;
        self.item_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSOEconItemPresetInstance {
        static instance: CSOEconItemPresetInstance = CSOEconItemPresetInstance {
            class_id: ::std::option::Option::None,
            preset_id: ::std::option::Option::None,
            slot_id: ::std::option::Option::None,
            item_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSOEconItemPresetInstance {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSOEconItemPresetInstance").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSOEconItemPresetInstance {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOEconItemPresetInstance {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgSelectPresetForClass)
pub struct CMsgSelectPresetForClass {
    // message fields
    // @@protoc_insertion_point(field:CMsgSelectPresetForClass.class_id)
    pub class_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSelectPresetForClass.preset_id)
    pub preset_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSelectPresetForClass.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSelectPresetForClass {
    fn default() -> &'a CMsgSelectPresetForClass {
        <CMsgSelectPresetForClass as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSelectPresetForClass {
    pub fn new() -> CMsgSelectPresetForClass {
        ::std::default::Default::default()
    }

    // optional uint32 class_id = 1;

    pub fn class_id(&self) -> u32 {
        self.class_id.unwrap_or(0)
    }

    pub fn clear_class_id(&mut self) {
        self.class_id = ::std::option::Option::None;
    }

    pub fn has_class_id(&self) -> bool {
        self.class_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_class_id(&mut self, v: u32) {
        self.class_id = ::std::option::Option::Some(v);
    }

    // optional uint32 preset_id = 2;

    pub fn preset_id(&self) -> u32 {
        self.preset_id.unwrap_or(0)
    }

    pub fn clear_preset_id(&mut self) {
        self.preset_id = ::std::option::Option::None;
    }

    pub fn has_preset_id(&self) -> bool {
        self.preset_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preset_id(&mut self, v: u32) {
        self.preset_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "class_id",
            |m: &CMsgSelectPresetForClass| { &m.class_id },
            |m: &mut CMsgSelectPresetForClass| { &mut m.class_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "preset_id",
            |m: &CMsgSelectPresetForClass| { &m.preset_id },
            |m: &mut CMsgSelectPresetForClass| { &mut m.preset_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSelectPresetForClass>(
            "CMsgSelectPresetForClass",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSelectPresetForClass {
    const NAME: &'static str = "CMsgSelectPresetForClass";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.class_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.preset_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.class_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.preset_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.class_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.preset_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSelectPresetForClass {
        CMsgSelectPresetForClass::new()
    }

    fn clear(&mut self) {
        self.class_id = ::std::option::Option::None;
        self.preset_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSelectPresetForClass {
        static instance: CMsgSelectPresetForClass = CMsgSelectPresetForClass {
            class_id: ::std::option::Option::None,
            preset_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSelectPresetForClass {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSelectPresetForClass").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSelectPresetForClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSelectPresetForClass {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CSOClassPresetClientData)
pub struct CSOClassPresetClientData {
    // message fields
    // @@protoc_insertion_point(field:CSOClassPresetClientData.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOClassPresetClientData.class_id)
    pub class_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOClassPresetClientData.active_preset_id)
    pub active_preset_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSOClassPresetClientData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSOClassPresetClientData {
    fn default() -> &'a CSOClassPresetClientData {
        <CSOClassPresetClientData as ::protobuf::Message>::default_instance()
    }
}

impl CSOClassPresetClientData {
    pub fn new() -> CSOClassPresetClientData {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 class_id = 2;

    pub fn class_id(&self) -> u32 {
        self.class_id.unwrap_or(0)
    }

    pub fn clear_class_id(&mut self) {
        self.class_id = ::std::option::Option::None;
    }

    pub fn has_class_id(&self) -> bool {
        self.class_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_class_id(&mut self, v: u32) {
        self.class_id = ::std::option::Option::Some(v);
    }

    // optional uint32 active_preset_id = 3;

    pub fn active_preset_id(&self) -> u32 {
        self.active_preset_id.unwrap_or(0)
    }

    pub fn clear_active_preset_id(&mut self) {
        self.active_preset_id = ::std::option::Option::None;
    }

    pub fn has_active_preset_id(&self) -> bool {
        self.active_preset_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_active_preset_id(&mut self, v: u32) {
        self.active_preset_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CSOClassPresetClientData| { &m.account_id },
            |m: &mut CSOClassPresetClientData| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "class_id",
            |m: &CSOClassPresetClientData| { &m.class_id },
            |m: &mut CSOClassPresetClientData| { &mut m.class_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "active_preset_id",
            |m: &CSOClassPresetClientData| { &m.active_preset_id },
            |m: &mut CSOClassPresetClientData| { &mut m.active_preset_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSOClassPresetClientData>(
            "CSOClassPresetClientData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSOClassPresetClientData {
    const NAME: &'static str = "CSOClassPresetClientData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.class_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.active_preset_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.class_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.active_preset_id {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.class_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.active_preset_id {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSOClassPresetClientData {
        CSOClassPresetClientData::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.class_id = ::std::option::Option::None;
        self.active_preset_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSOClassPresetClientData {
        static instance: CSOClassPresetClientData = CSOClassPresetClientData {
            account_id: ::std::option::Option::None,
            class_id: ::std::option::Option::None,
            active_preset_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSOClassPresetClientData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSOClassPresetClientData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSOClassPresetClientData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOClassPresetClientData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCReportAbuse)
pub struct CMsgGCReportAbuse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCReportAbuse.target_steam_id)
    pub target_steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCReportAbuse.description)
    pub description: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGCReportAbuse.gid)
    pub gid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCReportAbuse.abuse_type)
    pub abuse_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCReportAbuse.content_type)
    pub content_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCReportAbuse.target_game_server_ip)
    pub target_game_server_ip: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCReportAbuse.target_game_server_port)
    pub target_game_server_port: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCReportAbuse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCReportAbuse {
    fn default() -> &'a CMsgGCReportAbuse {
        <CMsgGCReportAbuse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCReportAbuse {
    pub fn new() -> CMsgGCReportAbuse {
        ::std::default::Default::default()
    }

    // optional fixed64 target_steam_id = 1;

    pub fn target_steam_id(&self) -> u64 {
        self.target_steam_id.unwrap_or(0)
    }

    pub fn clear_target_steam_id(&mut self) {
        self.target_steam_id = ::std::option::Option::None;
    }

    pub fn has_target_steam_id(&self) -> bool {
        self.target_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_steam_id(&mut self, v: u64) {
        self.target_steam_id = ::std::option::Option::Some(v);
    }

    // optional string description = 4;

    pub fn description(&self) -> &str {
        match self.description.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_description(&mut self) {
        self.description = ::std::option::Option::None;
    }

    pub fn has_description(&self) -> bool {
        self.description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        if self.description.is_none() {
            self.description = ::std::option::Option::Some(::std::string::String::new());
        }
        self.description.as_mut().unwrap()
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        self.description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 gid = 5;

    pub fn gid(&self) -> u64 {
        self.gid.unwrap_or(0)
    }

    pub fn clear_gid(&mut self) {
        self.gid = ::std::option::Option::None;
    }

    pub fn has_gid(&self) -> bool {
        self.gid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gid(&mut self, v: u64) {
        self.gid = ::std::option::Option::Some(v);
    }

    // optional uint32 abuse_type = 2;

    pub fn abuse_type(&self) -> u32 {
        self.abuse_type.unwrap_or(0)
    }

    pub fn clear_abuse_type(&mut self) {
        self.abuse_type = ::std::option::Option::None;
    }

    pub fn has_abuse_type(&self) -> bool {
        self.abuse_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_abuse_type(&mut self, v: u32) {
        self.abuse_type = ::std::option::Option::Some(v);
    }

    // optional uint32 content_type = 3;

    pub fn content_type(&self) -> u32 {
        self.content_type.unwrap_or(0)
    }

    pub fn clear_content_type(&mut self) {
        self.content_type = ::std::option::Option::None;
    }

    pub fn has_content_type(&self) -> bool {
        self.content_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_content_type(&mut self, v: u32) {
        self.content_type = ::std::option::Option::Some(v);
    }

    // optional fixed32 target_game_server_ip = 6;

    pub fn target_game_server_ip(&self) -> u32 {
        self.target_game_server_ip.unwrap_or(0)
    }

    pub fn clear_target_game_server_ip(&mut self) {
        self.target_game_server_ip = ::std::option::Option::None;
    }

    pub fn has_target_game_server_ip(&self) -> bool {
        self.target_game_server_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_game_server_ip(&mut self, v: u32) {
        self.target_game_server_ip = ::std::option::Option::Some(v);
    }

    // optional uint32 target_game_server_port = 7;

    pub fn target_game_server_port(&self) -> u32 {
        self.target_game_server_port.unwrap_or(0)
    }

    pub fn clear_target_game_server_port(&mut self) {
        self.target_game_server_port = ::std::option::Option::None;
    }

    pub fn has_target_game_server_port(&self) -> bool {
        self.target_game_server_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_game_server_port(&mut self, v: u32) {
        self.target_game_server_port = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "target_steam_id",
            |m: &CMsgGCReportAbuse| { &m.target_steam_id },
            |m: &mut CMsgGCReportAbuse| { &mut m.target_steam_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "description",
            |m: &CMsgGCReportAbuse| { &m.description },
            |m: &mut CMsgGCReportAbuse| { &mut m.description },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gid",
            |m: &CMsgGCReportAbuse| { &m.gid },
            |m: &mut CMsgGCReportAbuse| { &mut m.gid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "abuse_type",
            |m: &CMsgGCReportAbuse| { &m.abuse_type },
            |m: &mut CMsgGCReportAbuse| { &mut m.abuse_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "content_type",
            |m: &CMsgGCReportAbuse| { &m.content_type },
            |m: &mut CMsgGCReportAbuse| { &mut m.content_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "target_game_server_ip",
            |m: &CMsgGCReportAbuse| { &m.target_game_server_ip },
            |m: &mut CMsgGCReportAbuse| { &mut m.target_game_server_ip },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "target_game_server_port",
            |m: &CMsgGCReportAbuse| { &m.target_game_server_port },
            |m: &mut CMsgGCReportAbuse| { &mut m.target_game_server_port },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCReportAbuse>(
            "CMsgGCReportAbuse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCReportAbuse {
    const NAME: &'static str = "CMsgGCReportAbuse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.target_steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                34 => {
                    self.description = ::std::option::Option::Some(is.read_string()?);
                },
                40 => {
                    self.gid = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.abuse_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.content_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                53 => {
                    self.target_game_server_ip = ::std::option::Option::Some(is.read_fixed32()?);
                },
                56 => {
                    self.target_game_server_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.target_steam_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.description.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.gid {
            my_size += ::protobuf::rt::uint64_size(5, v);
        }
        if let Some(v) = self.abuse_type {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.content_type {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.target_game_server_ip {
            my_size += 1 + 4;
        }
        if let Some(v) = self.target_game_server_port {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.target_steam_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.description.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.gid {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.abuse_type {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.content_type {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.target_game_server_ip {
            os.write_fixed32(6, v)?;
        }
        if let Some(v) = self.target_game_server_port {
            os.write_uint32(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCReportAbuse {
        CMsgGCReportAbuse::new()
    }

    fn clear(&mut self) {
        self.target_steam_id = ::std::option::Option::None;
        self.description = ::std::option::Option::None;
        self.gid = ::std::option::Option::None;
        self.abuse_type = ::std::option::Option::None;
        self.content_type = ::std::option::Option::None;
        self.target_game_server_ip = ::std::option::Option::None;
        self.target_game_server_port = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCReportAbuse {
        static instance: CMsgGCReportAbuse = CMsgGCReportAbuse {
            target_steam_id: ::std::option::Option::None,
            description: ::std::option::Option::None,
            gid: ::std::option::Option::None,
            abuse_type: ::std::option::Option::None,
            content_type: ::std::option::Option::None,
            target_game_server_ip: ::std::option::Option::None,
            target_game_server_port: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCReportAbuse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCReportAbuse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCReportAbuse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCReportAbuse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCReportAbuseResponse)
pub struct CMsgGCReportAbuseResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCReportAbuseResponse.target_steam_id)
    pub target_steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCReportAbuseResponse.result)
    pub result: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCReportAbuseResponse.error_message)
    pub error_message: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCReportAbuseResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCReportAbuseResponse {
    fn default() -> &'a CMsgGCReportAbuseResponse {
        <CMsgGCReportAbuseResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCReportAbuseResponse {
    pub fn new() -> CMsgGCReportAbuseResponse {
        ::std::default::Default::default()
    }

    // optional fixed64 target_steam_id = 1;

    pub fn target_steam_id(&self) -> u64 {
        self.target_steam_id.unwrap_or(0)
    }

    pub fn clear_target_steam_id(&mut self) {
        self.target_steam_id = ::std::option::Option::None;
    }

    pub fn has_target_steam_id(&self) -> bool {
        self.target_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_steam_id(&mut self, v: u64) {
        self.target_steam_id = ::std::option::Option::Some(v);
    }

    // optional uint32 result = 2;

    pub fn result(&self) -> u32 {
        self.result.unwrap_or(0)
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: u32) {
        self.result = ::std::option::Option::Some(v);
    }

    // optional string error_message = 3;

    pub fn error_message(&self) -> &str {
        match self.error_message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_error_message(&mut self) {
        self.error_message = ::std::option::Option::None;
    }

    pub fn has_error_message(&self) -> bool {
        self.error_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error_message(&mut self, v: ::std::string::String) {
        self.error_message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error_message(&mut self) -> &mut ::std::string::String {
        if self.error_message.is_none() {
            self.error_message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.error_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_error_message(&mut self) -> ::std::string::String {
        self.error_message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "target_steam_id",
            |m: &CMsgGCReportAbuseResponse| { &m.target_steam_id },
            |m: &mut CMsgGCReportAbuseResponse| { &mut m.target_steam_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &CMsgGCReportAbuseResponse| { &m.result },
            |m: &mut CMsgGCReportAbuseResponse| { &mut m.result },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "error_message",
            |m: &CMsgGCReportAbuseResponse| { &m.error_message },
            |m: &mut CMsgGCReportAbuseResponse| { &mut m.error_message },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCReportAbuseResponse>(
            "CMsgGCReportAbuseResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCReportAbuseResponse {
    const NAME: &'static str = "CMsgGCReportAbuseResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.target_steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.result = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.error_message = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.target_steam_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.error_message.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.target_steam_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.result {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.error_message.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCReportAbuseResponse {
        CMsgGCReportAbuseResponse::new()
    }

    fn clear(&mut self) {
        self.target_steam_id = ::std::option::Option::None;
        self.result = ::std::option::Option::None;
        self.error_message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCReportAbuseResponse {
        static instance: CMsgGCReportAbuseResponse = CMsgGCReportAbuseResponse {
            target_steam_id: ::std::option::Option::None,
            result: ::std::option::Option::None,
            error_message: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCReportAbuseResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCReportAbuseResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCReportAbuseResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCReportAbuseResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCNameItemNotification)
pub struct CMsgGCNameItemNotification {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCNameItemNotification.player_steamid)
    pub player_steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCNameItemNotification.item_def_index)
    pub item_def_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCNameItemNotification.item_name_custom)
    pub item_name_custom: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCNameItemNotification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCNameItemNotification {
    fn default() -> &'a CMsgGCNameItemNotification {
        <CMsgGCNameItemNotification as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCNameItemNotification {
    pub fn new() -> CMsgGCNameItemNotification {
        ::std::default::Default::default()
    }

    // optional fixed64 player_steamid = 1;

    pub fn player_steamid(&self) -> u64 {
        self.player_steamid.unwrap_or(0)
    }

    pub fn clear_player_steamid(&mut self) {
        self.player_steamid = ::std::option::Option::None;
    }

    pub fn has_player_steamid(&self) -> bool {
        self.player_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_steamid(&mut self, v: u64) {
        self.player_steamid = ::std::option::Option::Some(v);
    }

    // optional uint32 item_def_index = 2;

    pub fn item_def_index(&self) -> u32 {
        self.item_def_index.unwrap_or(0)
    }

    pub fn clear_item_def_index(&mut self) {
        self.item_def_index = ::std::option::Option::None;
    }

    pub fn has_item_def_index(&self) -> bool {
        self.item_def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_def_index(&mut self, v: u32) {
        self.item_def_index = ::std::option::Option::Some(v);
    }

    // optional string item_name_custom = 3;

    pub fn item_name_custom(&self) -> &str {
        match self.item_name_custom.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_item_name_custom(&mut self) {
        self.item_name_custom = ::std::option::Option::None;
    }

    pub fn has_item_name_custom(&self) -> bool {
        self.item_name_custom.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_name_custom(&mut self, v: ::std::string::String) {
        self.item_name_custom = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_item_name_custom(&mut self) -> &mut ::std::string::String {
        if self.item_name_custom.is_none() {
            self.item_name_custom = ::std::option::Option::Some(::std::string::String::new());
        }
        self.item_name_custom.as_mut().unwrap()
    }

    // Take field
    pub fn take_item_name_custom(&mut self) -> ::std::string::String {
        self.item_name_custom.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_steamid",
            |m: &CMsgGCNameItemNotification| { &m.player_steamid },
            |m: &mut CMsgGCNameItemNotification| { &mut m.player_steamid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_def_index",
            |m: &CMsgGCNameItemNotification| { &m.item_def_index },
            |m: &mut CMsgGCNameItemNotification| { &mut m.item_def_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_name_custom",
            |m: &CMsgGCNameItemNotification| { &m.item_name_custom },
            |m: &mut CMsgGCNameItemNotification| { &mut m.item_name_custom },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCNameItemNotification>(
            "CMsgGCNameItemNotification",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCNameItemNotification {
    const NAME: &'static str = "CMsgGCNameItemNotification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.player_steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.item_def_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.item_name_custom = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.item_def_index {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.item_name_custom.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.player_steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.item_def_index {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.item_name_custom.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCNameItemNotification {
        CMsgGCNameItemNotification::new()
    }

    fn clear(&mut self) {
        self.player_steamid = ::std::option::Option::None;
        self.item_def_index = ::std::option::Option::None;
        self.item_name_custom = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCNameItemNotification {
        static instance: CMsgGCNameItemNotification = CMsgGCNameItemNotification {
            player_steamid: ::std::option::Option::None,
            item_def_index: ::std::option::Option::None,
            item_name_custom: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCNameItemNotification {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCNameItemNotification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCNameItemNotification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCNameItemNotification {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCClientDisplayNotification)
pub struct CMsgGCClientDisplayNotification {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCClientDisplayNotification.notification_title_localization_key)
    pub notification_title_localization_key: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGCClientDisplayNotification.notification_body_localization_key)
    pub notification_body_localization_key: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGCClientDisplayNotification.body_substring_keys)
    pub body_substring_keys: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGCClientDisplayNotification.body_substring_values)
    pub body_substring_values: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCClientDisplayNotification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCClientDisplayNotification {
    fn default() -> &'a CMsgGCClientDisplayNotification {
        <CMsgGCClientDisplayNotification as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCClientDisplayNotification {
    pub fn new() -> CMsgGCClientDisplayNotification {
        ::std::default::Default::default()
    }

    // optional string notification_title_localization_key = 1;

    pub fn notification_title_localization_key(&self) -> &str {
        match self.notification_title_localization_key.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_notification_title_localization_key(&mut self) {
        self.notification_title_localization_key = ::std::option::Option::None;
    }

    pub fn has_notification_title_localization_key(&self) -> bool {
        self.notification_title_localization_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_notification_title_localization_key(&mut self, v: ::std::string::String) {
        self.notification_title_localization_key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_notification_title_localization_key(&mut self) -> &mut ::std::string::String {
        if self.notification_title_localization_key.is_none() {
            self.notification_title_localization_key = ::std::option::Option::Some(::std::string::String::new());
        }
        self.notification_title_localization_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_notification_title_localization_key(&mut self) -> ::std::string::String {
        self.notification_title_localization_key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string notification_body_localization_key = 2;

    pub fn notification_body_localization_key(&self) -> &str {
        match self.notification_body_localization_key.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_notification_body_localization_key(&mut self) {
        self.notification_body_localization_key = ::std::option::Option::None;
    }

    pub fn has_notification_body_localization_key(&self) -> bool {
        self.notification_body_localization_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_notification_body_localization_key(&mut self, v: ::std::string::String) {
        self.notification_body_localization_key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_notification_body_localization_key(&mut self) -> &mut ::std::string::String {
        if self.notification_body_localization_key.is_none() {
            self.notification_body_localization_key = ::std::option::Option::Some(::std::string::String::new());
        }
        self.notification_body_localization_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_notification_body_localization_key(&mut self) -> ::std::string::String {
        self.notification_body_localization_key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "notification_title_localization_key",
            |m: &CMsgGCClientDisplayNotification| { &m.notification_title_localization_key },
            |m: &mut CMsgGCClientDisplayNotification| { &mut m.notification_title_localization_key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "notification_body_localization_key",
            |m: &CMsgGCClientDisplayNotification| { &m.notification_body_localization_key },
            |m: &mut CMsgGCClientDisplayNotification| { &mut m.notification_body_localization_key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "body_substring_keys",
            |m: &CMsgGCClientDisplayNotification| { &m.body_substring_keys },
            |m: &mut CMsgGCClientDisplayNotification| { &mut m.body_substring_keys },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "body_substring_values",
            |m: &CMsgGCClientDisplayNotification| { &m.body_substring_values },
            |m: &mut CMsgGCClientDisplayNotification| { &mut m.body_substring_values },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCClientDisplayNotification>(
            "CMsgGCClientDisplayNotification",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCClientDisplayNotification {
    const NAME: &'static str = "CMsgGCClientDisplayNotification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.notification_title_localization_key = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.notification_body_localization_key = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.body_substring_keys.push(is.read_string()?);
                },
                34 => {
                    self.body_substring_values.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.notification_title_localization_key.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.notification_body_localization_key.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.body_substring_keys {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.body_substring_values {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.notification_title_localization_key.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.notification_body_localization_key.as_ref() {
            os.write_string(2, v)?;
        }
        for v in &self.body_substring_keys {
            os.write_string(3, &v)?;
        };
        for v in &self.body_substring_values {
            os.write_string(4, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCClientDisplayNotification {
        CMsgGCClientDisplayNotification::new()
    }

    fn clear(&mut self) {
        self.notification_title_localization_key = ::std::option::Option::None;
        self.notification_body_localization_key = ::std::option::Option::None;
        self.body_substring_keys.clear();
        self.body_substring_values.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCClientDisplayNotification {
        static instance: CMsgGCClientDisplayNotification = CMsgGCClientDisplayNotification {
            notification_title_localization_key: ::std::option::Option::None,
            notification_body_localization_key: ::std::option::Option::None,
            body_substring_keys: ::std::vec::Vec::new(),
            body_substring_values: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCClientDisplayNotification {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCClientDisplayNotification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCClientDisplayNotification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCClientDisplayNotification {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCShowItemsPickedUp)
pub struct CMsgGCShowItemsPickedUp {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCShowItemsPickedUp.player_steamid)
    pub player_steamid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCShowItemsPickedUp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCShowItemsPickedUp {
    fn default() -> &'a CMsgGCShowItemsPickedUp {
        <CMsgGCShowItemsPickedUp as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCShowItemsPickedUp {
    pub fn new() -> CMsgGCShowItemsPickedUp {
        ::std::default::Default::default()
    }

    // optional fixed64 player_steamid = 1;

    pub fn player_steamid(&self) -> u64 {
        self.player_steamid.unwrap_or(0)
    }

    pub fn clear_player_steamid(&mut self) {
        self.player_steamid = ::std::option::Option::None;
    }

    pub fn has_player_steamid(&self) -> bool {
        self.player_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_steamid(&mut self, v: u64) {
        self.player_steamid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_steamid",
            |m: &CMsgGCShowItemsPickedUp| { &m.player_steamid },
            |m: &mut CMsgGCShowItemsPickedUp| { &mut m.player_steamid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCShowItemsPickedUp>(
            "CMsgGCShowItemsPickedUp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCShowItemsPickedUp {
    const NAME: &'static str = "CMsgGCShowItemsPickedUp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.player_steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_steamid {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.player_steamid {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCShowItemsPickedUp {
        CMsgGCShowItemsPickedUp::new()
    }

    fn clear(&mut self) {
        self.player_steamid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCShowItemsPickedUp {
        static instance: CMsgGCShowItemsPickedUp = CMsgGCShowItemsPickedUp {
            player_steamid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCShowItemsPickedUp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCShowItemsPickedUp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCShowItemsPickedUp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCShowItemsPickedUp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgUpdatePeriodicEvent)
pub struct CMsgUpdatePeriodicEvent {
    // message fields
    // @@protoc_insertion_point(field:CMsgUpdatePeriodicEvent.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgUpdatePeriodicEvent.event_type)
    pub event_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgUpdatePeriodicEvent.amount)
    pub amount: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgUpdatePeriodicEvent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgUpdatePeriodicEvent {
    fn default() -> &'a CMsgUpdatePeriodicEvent {
        <CMsgUpdatePeriodicEvent as ::protobuf::Message>::default_instance()
    }
}

impl CMsgUpdatePeriodicEvent {
    pub fn new() -> CMsgUpdatePeriodicEvent {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 event_type = 2;

    pub fn event_type(&self) -> u32 {
        self.event_type.unwrap_or(0)
    }

    pub fn clear_event_type(&mut self) {
        self.event_type = ::std::option::Option::None;
    }

    pub fn has_event_type(&self) -> bool {
        self.event_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_type(&mut self, v: u32) {
        self.event_type = ::std::option::Option::Some(v);
    }

    // optional uint32 amount = 3;

    pub fn amount(&self) -> u32 {
        self.amount.unwrap_or(0)
    }

    pub fn clear_amount(&mut self) {
        self.amount = ::std::option::Option::None;
    }

    pub fn has_amount(&self) -> bool {
        self.amount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: u32) {
        self.amount = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CMsgUpdatePeriodicEvent| { &m.account_id },
            |m: &mut CMsgUpdatePeriodicEvent| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_type",
            |m: &CMsgUpdatePeriodicEvent| { &m.event_type },
            |m: &mut CMsgUpdatePeriodicEvent| { &mut m.event_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "amount",
            |m: &CMsgUpdatePeriodicEvent| { &m.amount },
            |m: &mut CMsgUpdatePeriodicEvent| { &mut m.amount },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgUpdatePeriodicEvent>(
            "CMsgUpdatePeriodicEvent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgUpdatePeriodicEvent {
    const NAME: &'static str = "CMsgUpdatePeriodicEvent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.event_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.amount = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.event_type {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.amount {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.event_type {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.amount {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgUpdatePeriodicEvent {
        CMsgUpdatePeriodicEvent::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.event_type = ::std::option::Option::None;
        self.amount = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgUpdatePeriodicEvent {
        static instance: CMsgUpdatePeriodicEvent = CMsgUpdatePeriodicEvent {
            account_id: ::std::option::Option::None,
            event_type: ::std::option::Option::None,
            amount: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgUpdatePeriodicEvent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgUpdatePeriodicEvent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgUpdatePeriodicEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgUpdatePeriodicEvent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCIncrementKillCountResponse)
pub struct CMsgGCIncrementKillCountResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCIncrementKillCountResponse.killer_account_id)
    pub killer_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCIncrementKillCountResponse.num_kills)
    pub num_kills: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCIncrementKillCountResponse.item_def)
    pub item_def: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCIncrementKillCountResponse.level_type)
    pub level_type: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCIncrementKillCountResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCIncrementKillCountResponse {
    fn default() -> &'a CMsgGCIncrementKillCountResponse {
        <CMsgGCIncrementKillCountResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCIncrementKillCountResponse {
    pub fn new() -> CMsgGCIncrementKillCountResponse {
        ::std::default::Default::default()
    }

    // optional uint32 killer_account_id = 1;

    pub fn killer_account_id(&self) -> u32 {
        self.killer_account_id.unwrap_or(0)
    }

    pub fn clear_killer_account_id(&mut self) {
        self.killer_account_id = ::std::option::Option::None;
    }

    pub fn has_killer_account_id(&self) -> bool {
        self.killer_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_killer_account_id(&mut self, v: u32) {
        self.killer_account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 num_kills = 2;

    pub fn num_kills(&self) -> u32 {
        self.num_kills.unwrap_or(0)
    }

    pub fn clear_num_kills(&mut self) {
        self.num_kills = ::std::option::Option::None;
    }

    pub fn has_num_kills(&self) -> bool {
        self.num_kills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_kills(&mut self, v: u32) {
        self.num_kills = ::std::option::Option::Some(v);
    }

    // optional uint32 item_def = 3;

    pub fn item_def(&self) -> u32 {
        self.item_def.unwrap_or(0)
    }

    pub fn clear_item_def(&mut self) {
        self.item_def = ::std::option::Option::None;
    }

    pub fn has_item_def(&self) -> bool {
        self.item_def.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_def(&mut self, v: u32) {
        self.item_def = ::std::option::Option::Some(v);
    }

    // optional uint32 level_type = 4;

    pub fn level_type(&self) -> u32 {
        self.level_type.unwrap_or(0)
    }

    pub fn clear_level_type(&mut self) {
        self.level_type = ::std::option::Option::None;
    }

    pub fn has_level_type(&self) -> bool {
        self.level_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_level_type(&mut self, v: u32) {
        self.level_type = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "killer_account_id",
            |m: &CMsgGCIncrementKillCountResponse| { &m.killer_account_id },
            |m: &mut CMsgGCIncrementKillCountResponse| { &mut m.killer_account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "num_kills",
            |m: &CMsgGCIncrementKillCountResponse| { &m.num_kills },
            |m: &mut CMsgGCIncrementKillCountResponse| { &mut m.num_kills },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_def",
            |m: &CMsgGCIncrementKillCountResponse| { &m.item_def },
            |m: &mut CMsgGCIncrementKillCountResponse| { &mut m.item_def },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "level_type",
            |m: &CMsgGCIncrementKillCountResponse| { &m.level_type },
            |m: &mut CMsgGCIncrementKillCountResponse| { &mut m.level_type },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCIncrementKillCountResponse>(
            "CMsgGCIncrementKillCountResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCIncrementKillCountResponse {
    const NAME: &'static str = "CMsgGCIncrementKillCountResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.killer_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.num_kills = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.item_def = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.level_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.killer_account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.num_kills {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.item_def {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.level_type {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.killer_account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.num_kills {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.item_def {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.level_type {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCIncrementKillCountResponse {
        CMsgGCIncrementKillCountResponse::new()
    }

    fn clear(&mut self) {
        self.killer_account_id = ::std::option::Option::None;
        self.num_kills = ::std::option::Option::None;
        self.item_def = ::std::option::Option::None;
        self.level_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCIncrementKillCountResponse {
        static instance: CMsgGCIncrementKillCountResponse = CMsgGCIncrementKillCountResponse {
            killer_account_id: ::std::option::Option::None,
            num_kills: ::std::option::Option::None,
            item_def: ::std::option::Option::None,
            level_type: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCIncrementKillCountResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCIncrementKillCountResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCIncrementKillCountResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCIncrementKillCountResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCRemoveStrangePart)
pub struct CMsgGCRemoveStrangePart {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCRemoveStrangePart.item_id)
    pub item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCRemoveStrangePart.strange_part_score_type)
    pub strange_part_score_type: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCRemoveStrangePart.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCRemoveStrangePart {
    fn default() -> &'a CMsgGCRemoveStrangePart {
        <CMsgGCRemoveStrangePart as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCRemoveStrangePart {
    pub fn new() -> CMsgGCRemoveStrangePart {
        ::std::default::Default::default()
    }

    // optional uint64 item_id = 1;

    pub fn item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    // optional uint32 strange_part_score_type = 2;

    pub fn strange_part_score_type(&self) -> u32 {
        self.strange_part_score_type.unwrap_or(0)
    }

    pub fn clear_strange_part_score_type(&mut self) {
        self.strange_part_score_type = ::std::option::Option::None;
    }

    pub fn has_strange_part_score_type(&self) -> bool {
        self.strange_part_score_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_strange_part_score_type(&mut self, v: u32) {
        self.strange_part_score_type = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_id",
            |m: &CMsgGCRemoveStrangePart| { &m.item_id },
            |m: &mut CMsgGCRemoveStrangePart| { &mut m.item_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "strange_part_score_type",
            |m: &CMsgGCRemoveStrangePart| { &m.strange_part_score_type },
            |m: &mut CMsgGCRemoveStrangePart| { &mut m.strange_part_score_type },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCRemoveStrangePart>(
            "CMsgGCRemoveStrangePart",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCRemoveStrangePart {
    const NAME: &'static str = "CMsgGCRemoveStrangePart";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.strange_part_score_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.strange_part_score_type {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.strange_part_score_type {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCRemoveStrangePart {
        CMsgGCRemoveStrangePart::new()
    }

    fn clear(&mut self) {
        self.item_id = ::std::option::Option::None;
        self.strange_part_score_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCRemoveStrangePart {
        static instance: CMsgGCRemoveStrangePart = CMsgGCRemoveStrangePart {
            item_id: ::std::option::Option::None,
            strange_part_score_type: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCRemoveStrangePart {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCRemoveStrangePart").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCRemoveStrangePart {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCRemoveStrangePart {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCRemoveUpgradeCard)
pub struct CMsgGCRemoveUpgradeCard {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCRemoveUpgradeCard.item_id)
    pub item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCRemoveUpgradeCard.attribute_index)
    pub attribute_index: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCRemoveUpgradeCard.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCRemoveUpgradeCard {
    fn default() -> &'a CMsgGCRemoveUpgradeCard {
        <CMsgGCRemoveUpgradeCard as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCRemoveUpgradeCard {
    pub fn new() -> CMsgGCRemoveUpgradeCard {
        ::std::default::Default::default()
    }

    // optional uint64 item_id = 1;

    pub fn item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    // optional uint32 attribute_index = 2;

    pub fn attribute_index(&self) -> u32 {
        self.attribute_index.unwrap_or(0)
    }

    pub fn clear_attribute_index(&mut self) {
        self.attribute_index = ::std::option::Option::None;
    }

    pub fn has_attribute_index(&self) -> bool {
        self.attribute_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attribute_index(&mut self, v: u32) {
        self.attribute_index = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_id",
            |m: &CMsgGCRemoveUpgradeCard| { &m.item_id },
            |m: &mut CMsgGCRemoveUpgradeCard| { &mut m.item_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "attribute_index",
            |m: &CMsgGCRemoveUpgradeCard| { &m.attribute_index },
            |m: &mut CMsgGCRemoveUpgradeCard| { &mut m.attribute_index },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCRemoveUpgradeCard>(
            "CMsgGCRemoveUpgradeCard",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCRemoveUpgradeCard {
    const NAME: &'static str = "CMsgGCRemoveUpgradeCard";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.attribute_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.attribute_index {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.attribute_index {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCRemoveUpgradeCard {
        CMsgGCRemoveUpgradeCard::new()
    }

    fn clear(&mut self) {
        self.item_id = ::std::option::Option::None;
        self.attribute_index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCRemoveUpgradeCard {
        static instance: CMsgGCRemoveUpgradeCard = CMsgGCRemoveUpgradeCard {
            item_id: ::std::option::Option::None,
            attribute_index: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCRemoveUpgradeCard {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCRemoveUpgradeCard").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCRemoveUpgradeCard {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCRemoveUpgradeCard {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCRemoveCustomizationAttributeSimple)
pub struct CMsgGCRemoveCustomizationAttributeSimple {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCRemoveCustomizationAttributeSimple.item_id)
    pub item_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCRemoveCustomizationAttributeSimple.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCRemoveCustomizationAttributeSimple {
    fn default() -> &'a CMsgGCRemoveCustomizationAttributeSimple {
        <CMsgGCRemoveCustomizationAttributeSimple as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCRemoveCustomizationAttributeSimple {
    pub fn new() -> CMsgGCRemoveCustomizationAttributeSimple {
        ::std::default::Default::default()
    }

    // optional uint64 item_id = 1;

    pub fn item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_id",
            |m: &CMsgGCRemoveCustomizationAttributeSimple| { &m.item_id },
            |m: &mut CMsgGCRemoveCustomizationAttributeSimple| { &mut m.item_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCRemoveCustomizationAttributeSimple>(
            "CMsgGCRemoveCustomizationAttributeSimple",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCRemoveCustomizationAttributeSimple {
    const NAME: &'static str = "CMsgGCRemoveCustomizationAttributeSimple";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.item_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCRemoveCustomizationAttributeSimple {
        CMsgGCRemoveCustomizationAttributeSimple::new()
    }

    fn clear(&mut self) {
        self.item_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCRemoveCustomizationAttributeSimple {
        static instance: CMsgGCRemoveCustomizationAttributeSimple = CMsgGCRemoveCustomizationAttributeSimple {
            item_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCRemoveCustomizationAttributeSimple {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCRemoveCustomizationAttributeSimple").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCRemoveCustomizationAttributeSimple {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCRemoveCustomizationAttributeSimple {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCResetStrangeScores)
pub struct CMsgGCResetStrangeScores {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCResetStrangeScores.item_id)
    pub item_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCResetStrangeScores.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCResetStrangeScores {
    fn default() -> &'a CMsgGCResetStrangeScores {
        <CMsgGCResetStrangeScores as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCResetStrangeScores {
    pub fn new() -> CMsgGCResetStrangeScores {
        ::std::default::Default::default()
    }

    // optional uint64 item_id = 1;

    pub fn item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_id",
            |m: &CMsgGCResetStrangeScores| { &m.item_id },
            |m: &mut CMsgGCResetStrangeScores| { &mut m.item_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCResetStrangeScores>(
            "CMsgGCResetStrangeScores",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCResetStrangeScores {
    const NAME: &'static str = "CMsgGCResetStrangeScores";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.item_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCResetStrangeScores {
        CMsgGCResetStrangeScores::new()
    }

    fn clear(&mut self) {
        self.item_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCResetStrangeScores {
        static instance: CMsgGCResetStrangeScores = CMsgGCResetStrangeScores {
            item_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCResetStrangeScores {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCResetStrangeScores").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCResetStrangeScores {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCResetStrangeScores {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCItemPreviewItemBoughtNotification)
pub struct CMsgGCItemPreviewItemBoughtNotification {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCItemPreviewItemBoughtNotification.item_def_index)
    pub item_def_index: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCItemPreviewItemBoughtNotification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCItemPreviewItemBoughtNotification {
    fn default() -> &'a CMsgGCItemPreviewItemBoughtNotification {
        <CMsgGCItemPreviewItemBoughtNotification as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCItemPreviewItemBoughtNotification {
    pub fn new() -> CMsgGCItemPreviewItemBoughtNotification {
        ::std::default::Default::default()
    }

    // optional uint32 item_def_index = 1;

    pub fn item_def_index(&self) -> u32 {
        self.item_def_index.unwrap_or(0)
    }

    pub fn clear_item_def_index(&mut self) {
        self.item_def_index = ::std::option::Option::None;
    }

    pub fn has_item_def_index(&self) -> bool {
        self.item_def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_def_index(&mut self, v: u32) {
        self.item_def_index = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_def_index",
            |m: &CMsgGCItemPreviewItemBoughtNotification| { &m.item_def_index },
            |m: &mut CMsgGCItemPreviewItemBoughtNotification| { &mut m.item_def_index },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCItemPreviewItemBoughtNotification>(
            "CMsgGCItemPreviewItemBoughtNotification",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCItemPreviewItemBoughtNotification {
    const NAME: &'static str = "CMsgGCItemPreviewItemBoughtNotification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_def_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_def_index {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.item_def_index {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCItemPreviewItemBoughtNotification {
        CMsgGCItemPreviewItemBoughtNotification::new()
    }

    fn clear(&mut self) {
        self.item_def_index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCItemPreviewItemBoughtNotification {
        static instance: CMsgGCItemPreviewItemBoughtNotification = CMsgGCItemPreviewItemBoughtNotification {
            item_def_index: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCItemPreviewItemBoughtNotification {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCItemPreviewItemBoughtNotification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCItemPreviewItemBoughtNotification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCItemPreviewItemBoughtNotification {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCStorePurchaseCancel)
pub struct CMsgGCStorePurchaseCancel {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCStorePurchaseCancel.txn_id)
    pub txn_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCStorePurchaseCancel.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCStorePurchaseCancel {
    fn default() -> &'a CMsgGCStorePurchaseCancel {
        <CMsgGCStorePurchaseCancel as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCStorePurchaseCancel {
    pub fn new() -> CMsgGCStorePurchaseCancel {
        ::std::default::Default::default()
    }

    // optional uint64 txn_id = 1;

    pub fn txn_id(&self) -> u64 {
        self.txn_id.unwrap_or(0)
    }

    pub fn clear_txn_id(&mut self) {
        self.txn_id = ::std::option::Option::None;
    }

    pub fn has_txn_id(&self) -> bool {
        self.txn_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txn_id(&mut self, v: u64) {
        self.txn_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "txn_id",
            |m: &CMsgGCStorePurchaseCancel| { &m.txn_id },
            |m: &mut CMsgGCStorePurchaseCancel| { &mut m.txn_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCStorePurchaseCancel>(
            "CMsgGCStorePurchaseCancel",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCStorePurchaseCancel {
    const NAME: &'static str = "CMsgGCStorePurchaseCancel";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.txn_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.txn_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.txn_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCStorePurchaseCancel {
        CMsgGCStorePurchaseCancel::new()
    }

    fn clear(&mut self) {
        self.txn_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCStorePurchaseCancel {
        static instance: CMsgGCStorePurchaseCancel = CMsgGCStorePurchaseCancel {
            txn_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCStorePurchaseCancel {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCStorePurchaseCancel").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCStorePurchaseCancel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCStorePurchaseCancel {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCStorePurchaseCancelResponse)
pub struct CMsgGCStorePurchaseCancelResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCStorePurchaseCancelResponse.result)
    pub result: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCStorePurchaseCancelResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCStorePurchaseCancelResponse {
    fn default() -> &'a CMsgGCStorePurchaseCancelResponse {
        <CMsgGCStorePurchaseCancelResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCStorePurchaseCancelResponse {
    pub fn new() -> CMsgGCStorePurchaseCancelResponse {
        ::std::default::Default::default()
    }

    // optional uint32 result = 1;

    pub fn result(&self) -> u32 {
        self.result.unwrap_or(0)
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: u32) {
        self.result = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &CMsgGCStorePurchaseCancelResponse| { &m.result },
            |m: &mut CMsgGCStorePurchaseCancelResponse| { &mut m.result },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCStorePurchaseCancelResponse>(
            "CMsgGCStorePurchaseCancelResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCStorePurchaseCancelResponse {
    const NAME: &'static str = "CMsgGCStorePurchaseCancelResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCStorePurchaseCancelResponse {
        CMsgGCStorePurchaseCancelResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCStorePurchaseCancelResponse {
        static instance: CMsgGCStorePurchaseCancelResponse = CMsgGCStorePurchaseCancelResponse {
            result: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCStorePurchaseCancelResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCStorePurchaseCancelResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCStorePurchaseCancelResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCStorePurchaseCancelResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCStorePurchaseFinalize)
pub struct CMsgGCStorePurchaseFinalize {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCStorePurchaseFinalize.txn_id)
    pub txn_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCStorePurchaseFinalize.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCStorePurchaseFinalize {
    fn default() -> &'a CMsgGCStorePurchaseFinalize {
        <CMsgGCStorePurchaseFinalize as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCStorePurchaseFinalize {
    pub fn new() -> CMsgGCStorePurchaseFinalize {
        ::std::default::Default::default()
    }

    // optional uint64 txn_id = 1;

    pub fn txn_id(&self) -> u64 {
        self.txn_id.unwrap_or(0)
    }

    pub fn clear_txn_id(&mut self) {
        self.txn_id = ::std::option::Option::None;
    }

    pub fn has_txn_id(&self) -> bool {
        self.txn_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txn_id(&mut self, v: u64) {
        self.txn_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "txn_id",
            |m: &CMsgGCStorePurchaseFinalize| { &m.txn_id },
            |m: &mut CMsgGCStorePurchaseFinalize| { &mut m.txn_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCStorePurchaseFinalize>(
            "CMsgGCStorePurchaseFinalize",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCStorePurchaseFinalize {
    const NAME: &'static str = "CMsgGCStorePurchaseFinalize";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.txn_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.txn_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.txn_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCStorePurchaseFinalize {
        CMsgGCStorePurchaseFinalize::new()
    }

    fn clear(&mut self) {
        self.txn_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCStorePurchaseFinalize {
        static instance: CMsgGCStorePurchaseFinalize = CMsgGCStorePurchaseFinalize {
            txn_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCStorePurchaseFinalize {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCStorePurchaseFinalize").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCStorePurchaseFinalize {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCStorePurchaseFinalize {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCStorePurchaseFinalizeResponse)
pub struct CMsgGCStorePurchaseFinalizeResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCStorePurchaseFinalizeResponse.result)
    pub result: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCStorePurchaseFinalizeResponse.item_ids)
    pub item_ids: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCStorePurchaseFinalizeResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCStorePurchaseFinalizeResponse {
    fn default() -> &'a CMsgGCStorePurchaseFinalizeResponse {
        <CMsgGCStorePurchaseFinalizeResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCStorePurchaseFinalizeResponse {
    pub fn new() -> CMsgGCStorePurchaseFinalizeResponse {
        ::std::default::Default::default()
    }

    // optional uint32 result = 1;

    pub fn result(&self) -> u32 {
        self.result.unwrap_or(0)
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: u32) {
        self.result = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &CMsgGCStorePurchaseFinalizeResponse| { &m.result },
            |m: &mut CMsgGCStorePurchaseFinalizeResponse| { &mut m.result },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "item_ids",
            |m: &CMsgGCStorePurchaseFinalizeResponse| { &m.item_ids },
            |m: &mut CMsgGCStorePurchaseFinalizeResponse| { &mut m.item_ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCStorePurchaseFinalizeResponse>(
            "CMsgGCStorePurchaseFinalizeResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCStorePurchaseFinalizeResponse {
    const NAME: &'static str = "CMsgGCStorePurchaseFinalizeResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    is.read_repeated_packed_uint64_into(&mut self.item_ids)?;
                },
                16 => {
                    self.item_ids.push(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.item_ids {
            my_size += ::protobuf::rt::uint64_size(2, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_uint32(1, v)?;
        }
        for v in &self.item_ids {
            os.write_uint64(2, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCStorePurchaseFinalizeResponse {
        CMsgGCStorePurchaseFinalizeResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.item_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCStorePurchaseFinalizeResponse {
        static instance: CMsgGCStorePurchaseFinalizeResponse = CMsgGCStorePurchaseFinalizeResponse {
            result: ::std::option::Option::None,
            item_ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCStorePurchaseFinalizeResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCStorePurchaseFinalizeResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCStorePurchaseFinalizeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCStorePurchaseFinalizeResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCBannedWordListRequest)
pub struct CMsgGCBannedWordListRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCBannedWordListRequest.ban_list_group_id)
    pub ban_list_group_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCBannedWordListRequest.word_id)
    pub word_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCBannedWordListRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCBannedWordListRequest {
    fn default() -> &'a CMsgGCBannedWordListRequest {
        <CMsgGCBannedWordListRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCBannedWordListRequest {
    pub fn new() -> CMsgGCBannedWordListRequest {
        ::std::default::Default::default()
    }

    // optional uint32 ban_list_group_id = 1;

    pub fn ban_list_group_id(&self) -> u32 {
        self.ban_list_group_id.unwrap_or(0)
    }

    pub fn clear_ban_list_group_id(&mut self) {
        self.ban_list_group_id = ::std::option::Option::None;
    }

    pub fn has_ban_list_group_id(&self) -> bool {
        self.ban_list_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ban_list_group_id(&mut self, v: u32) {
        self.ban_list_group_id = ::std::option::Option::Some(v);
    }

    // optional uint32 word_id = 2;

    pub fn word_id(&self) -> u32 {
        self.word_id.unwrap_or(0)
    }

    pub fn clear_word_id(&mut self) {
        self.word_id = ::std::option::Option::None;
    }

    pub fn has_word_id(&self) -> bool {
        self.word_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_word_id(&mut self, v: u32) {
        self.word_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ban_list_group_id",
            |m: &CMsgGCBannedWordListRequest| { &m.ban_list_group_id },
            |m: &mut CMsgGCBannedWordListRequest| { &mut m.ban_list_group_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "word_id",
            |m: &CMsgGCBannedWordListRequest| { &m.word_id },
            |m: &mut CMsgGCBannedWordListRequest| { &mut m.word_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCBannedWordListRequest>(
            "CMsgGCBannedWordListRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCBannedWordListRequest {
    const NAME: &'static str = "CMsgGCBannedWordListRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ban_list_group_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.word_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ban_list_group_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.word_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.ban_list_group_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.word_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCBannedWordListRequest {
        CMsgGCBannedWordListRequest::new()
    }

    fn clear(&mut self) {
        self.ban_list_group_id = ::std::option::Option::None;
        self.word_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCBannedWordListRequest {
        static instance: CMsgGCBannedWordListRequest = CMsgGCBannedWordListRequest {
            ban_list_group_id: ::std::option::Option::None,
            word_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCBannedWordListRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCBannedWordListRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCBannedWordListRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCBannedWordListRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCGiftedItems)
pub struct CMsgGCGiftedItems {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCGiftedItems.gifter_steam_id)
    pub gifter_steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCGiftedItems.was_random_person)
    pub was_random_person: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgGCGiftedItems.recipient_account_ids)
    pub recipient_account_ids: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCGiftedItems.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCGiftedItems {
    fn default() -> &'a CMsgGCGiftedItems {
        <CMsgGCGiftedItems as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCGiftedItems {
    pub fn new() -> CMsgGCGiftedItems {
        ::std::default::Default::default()
    }

    // optional uint64 gifter_steam_id = 1;

    pub fn gifter_steam_id(&self) -> u64 {
        self.gifter_steam_id.unwrap_or(0)
    }

    pub fn clear_gifter_steam_id(&mut self) {
        self.gifter_steam_id = ::std::option::Option::None;
    }

    pub fn has_gifter_steam_id(&self) -> bool {
        self.gifter_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gifter_steam_id(&mut self, v: u64) {
        self.gifter_steam_id = ::std::option::Option::Some(v);
    }

    // optional bool was_random_person = 2;

    pub fn was_random_person(&self) -> bool {
        self.was_random_person.unwrap_or(false)
    }

    pub fn clear_was_random_person(&mut self) {
        self.was_random_person = ::std::option::Option::None;
    }

    pub fn has_was_random_person(&self) -> bool {
        self.was_random_person.is_some()
    }

    // Param is passed by value, moved
    pub fn set_was_random_person(&mut self, v: bool) {
        self.was_random_person = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gifter_steam_id",
            |m: &CMsgGCGiftedItems| { &m.gifter_steam_id },
            |m: &mut CMsgGCGiftedItems| { &mut m.gifter_steam_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "was_random_person",
            |m: &CMsgGCGiftedItems| { &m.was_random_person },
            |m: &mut CMsgGCGiftedItems| { &mut m.was_random_person },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "recipient_account_ids",
            |m: &CMsgGCGiftedItems| { &m.recipient_account_ids },
            |m: &mut CMsgGCGiftedItems| { &mut m.recipient_account_ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCGiftedItems>(
            "CMsgGCGiftedItems",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCGiftedItems {
    const NAME: &'static str = "CMsgGCGiftedItems";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.gifter_steam_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.was_random_person = ::std::option::Option::Some(is.read_bool()?);
                },
                26 => {
                    is.read_repeated_packed_uint32_into(&mut self.recipient_account_ids)?;
                },
                24 => {
                    self.recipient_account_ids.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.gifter_steam_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.was_random_person {
            my_size += 1 + 1;
        }
        for value in &self.recipient_account_ids {
            my_size += ::protobuf::rt::uint32_size(3, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.gifter_steam_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.was_random_person {
            os.write_bool(2, v)?;
        }
        for v in &self.recipient_account_ids {
            os.write_uint32(3, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCGiftedItems {
        CMsgGCGiftedItems::new()
    }

    fn clear(&mut self) {
        self.gifter_steam_id = ::std::option::Option::None;
        self.was_random_person = ::std::option::Option::None;
        self.recipient_account_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCGiftedItems {
        static instance: CMsgGCGiftedItems = CMsgGCGiftedItems {
            gifter_steam_id: ::std::option::Option::None,
            was_random_person: ::std::option::Option::None,
            recipient_account_ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCGiftedItems {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCGiftedItems").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCGiftedItems {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCGiftedItems {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCCollectItem)
pub struct CMsgGCCollectItem {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCollectItem.collection_item_id)
    pub collection_item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCCollectItem.subject_item_id)
    pub subject_item_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCollectItem.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCollectItem {
    fn default() -> &'a CMsgGCCollectItem {
        <CMsgGCCollectItem as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCollectItem {
    pub fn new() -> CMsgGCCollectItem {
        ::std::default::Default::default()
    }

    // optional uint64 collection_item_id = 1;

    pub fn collection_item_id(&self) -> u64 {
        self.collection_item_id.unwrap_or(0)
    }

    pub fn clear_collection_item_id(&mut self) {
        self.collection_item_id = ::std::option::Option::None;
    }

    pub fn has_collection_item_id(&self) -> bool {
        self.collection_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_collection_item_id(&mut self, v: u64) {
        self.collection_item_id = ::std::option::Option::Some(v);
    }

    // optional uint64 subject_item_id = 2;

    pub fn subject_item_id(&self) -> u64 {
        self.subject_item_id.unwrap_or(0)
    }

    pub fn clear_subject_item_id(&mut self) {
        self.subject_item_id = ::std::option::Option::None;
    }

    pub fn has_subject_item_id(&self) -> bool {
        self.subject_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subject_item_id(&mut self, v: u64) {
        self.subject_item_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "collection_item_id",
            |m: &CMsgGCCollectItem| { &m.collection_item_id },
            |m: &mut CMsgGCCollectItem| { &mut m.collection_item_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "subject_item_id",
            |m: &CMsgGCCollectItem| { &m.subject_item_id },
            |m: &mut CMsgGCCollectItem| { &mut m.subject_item_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCollectItem>(
            "CMsgGCCollectItem",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCollectItem {
    const NAME: &'static str = "CMsgGCCollectItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.collection_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.subject_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.collection_item_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.subject_item_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.collection_item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.subject_item_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCollectItem {
        CMsgGCCollectItem::new()
    }

    fn clear(&mut self) {
        self.collection_item_id = ::std::option::Option::None;
        self.subject_item_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCollectItem {
        static instance: CMsgGCCollectItem = CMsgGCCollectItem {
            collection_item_id: ::std::option::Option::None,
            subject_item_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCollectItem {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCollectItem").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCollectItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCollectItem {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCClientMarketDataRequest)
pub struct CMsgGCClientMarketDataRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCClientMarketDataRequest.user_currency)
    pub user_currency: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCClientMarketDataRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCClientMarketDataRequest {
    fn default() -> &'a CMsgGCClientMarketDataRequest {
        <CMsgGCClientMarketDataRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCClientMarketDataRequest {
    pub fn new() -> CMsgGCClientMarketDataRequest {
        ::std::default::Default::default()
    }

    // optional uint32 user_currency = 1;

    pub fn user_currency(&self) -> u32 {
        self.user_currency.unwrap_or(0)
    }

    pub fn clear_user_currency(&mut self) {
        self.user_currency = ::std::option::Option::None;
    }

    pub fn has_user_currency(&self) -> bool {
        self.user_currency.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_currency(&mut self, v: u32) {
        self.user_currency = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "user_currency",
            |m: &CMsgGCClientMarketDataRequest| { &m.user_currency },
            |m: &mut CMsgGCClientMarketDataRequest| { &mut m.user_currency },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCClientMarketDataRequest>(
            "CMsgGCClientMarketDataRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCClientMarketDataRequest {
    const NAME: &'static str = "CMsgGCClientMarketDataRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.user_currency = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_currency {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.user_currency {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCClientMarketDataRequest {
        CMsgGCClientMarketDataRequest::new()
    }

    fn clear(&mut self) {
        self.user_currency = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCClientMarketDataRequest {
        static instance: CMsgGCClientMarketDataRequest = CMsgGCClientMarketDataRequest {
            user_currency: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCClientMarketDataRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCClientMarketDataRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCClientMarketDataRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCClientMarketDataRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCClientMarketDataEntry)
pub struct CMsgGCClientMarketDataEntry {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCClientMarketDataEntry.item_def_index)
    pub item_def_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCClientMarketDataEntry.item_quality)
    pub item_quality: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCClientMarketDataEntry.item_sell_listings)
    pub item_sell_listings: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCClientMarketDataEntry.price_in_local_currency)
    pub price_in_local_currency: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCClientMarketDataEntry.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCClientMarketDataEntry {
    fn default() -> &'a CMsgGCClientMarketDataEntry {
        <CMsgGCClientMarketDataEntry as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCClientMarketDataEntry {
    pub fn new() -> CMsgGCClientMarketDataEntry {
        ::std::default::Default::default()
    }

    // optional uint32 item_def_index = 1;

    pub fn item_def_index(&self) -> u32 {
        self.item_def_index.unwrap_or(0)
    }

    pub fn clear_item_def_index(&mut self) {
        self.item_def_index = ::std::option::Option::None;
    }

    pub fn has_item_def_index(&self) -> bool {
        self.item_def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_def_index(&mut self, v: u32) {
        self.item_def_index = ::std::option::Option::Some(v);
    }

    // optional uint32 item_quality = 2;

    pub fn item_quality(&self) -> u32 {
        self.item_quality.unwrap_or(0)
    }

    pub fn clear_item_quality(&mut self) {
        self.item_quality = ::std::option::Option::None;
    }

    pub fn has_item_quality(&self) -> bool {
        self.item_quality.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_quality(&mut self, v: u32) {
        self.item_quality = ::std::option::Option::Some(v);
    }

    // optional uint32 item_sell_listings = 3;

    pub fn item_sell_listings(&self) -> u32 {
        self.item_sell_listings.unwrap_or(0)
    }

    pub fn clear_item_sell_listings(&mut self) {
        self.item_sell_listings = ::std::option::Option::None;
    }

    pub fn has_item_sell_listings(&self) -> bool {
        self.item_sell_listings.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_sell_listings(&mut self, v: u32) {
        self.item_sell_listings = ::std::option::Option::Some(v);
    }

    // optional uint32 price_in_local_currency = 4;

    pub fn price_in_local_currency(&self) -> u32 {
        self.price_in_local_currency.unwrap_or(0)
    }

    pub fn clear_price_in_local_currency(&mut self) {
        self.price_in_local_currency = ::std::option::Option::None;
    }

    pub fn has_price_in_local_currency(&self) -> bool {
        self.price_in_local_currency.is_some()
    }

    // Param is passed by value, moved
    pub fn set_price_in_local_currency(&mut self, v: u32) {
        self.price_in_local_currency = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_def_index",
            |m: &CMsgGCClientMarketDataEntry| { &m.item_def_index },
            |m: &mut CMsgGCClientMarketDataEntry| { &mut m.item_def_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_quality",
            |m: &CMsgGCClientMarketDataEntry| { &m.item_quality },
            |m: &mut CMsgGCClientMarketDataEntry| { &mut m.item_quality },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_sell_listings",
            |m: &CMsgGCClientMarketDataEntry| { &m.item_sell_listings },
            |m: &mut CMsgGCClientMarketDataEntry| { &mut m.item_sell_listings },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "price_in_local_currency",
            |m: &CMsgGCClientMarketDataEntry| { &m.price_in_local_currency },
            |m: &mut CMsgGCClientMarketDataEntry| { &mut m.price_in_local_currency },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCClientMarketDataEntry>(
            "CMsgGCClientMarketDataEntry",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCClientMarketDataEntry {
    const NAME: &'static str = "CMsgGCClientMarketDataEntry";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_def_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.item_quality = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.item_sell_listings = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.price_in_local_currency = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_def_index {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.item_quality {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.item_sell_listings {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.price_in_local_currency {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.item_def_index {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.item_quality {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.item_sell_listings {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.price_in_local_currency {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCClientMarketDataEntry {
        CMsgGCClientMarketDataEntry::new()
    }

    fn clear(&mut self) {
        self.item_def_index = ::std::option::Option::None;
        self.item_quality = ::std::option::Option::None;
        self.item_sell_listings = ::std::option::Option::None;
        self.price_in_local_currency = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCClientMarketDataEntry {
        static instance: CMsgGCClientMarketDataEntry = CMsgGCClientMarketDataEntry {
            item_def_index: ::std::option::Option::None,
            item_quality: ::std::option::Option::None,
            item_sell_listings: ::std::option::Option::None,
            price_in_local_currency: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCClientMarketDataEntry {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCClientMarketDataEntry").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCClientMarketDataEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCClientMarketDataEntry {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCClientMarketData)
pub struct CMsgGCClientMarketData {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCClientMarketData.entries)
    pub entries: ::std::vec::Vec<CMsgGCClientMarketDataEntry>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCClientMarketData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCClientMarketData {
    fn default() -> &'a CMsgGCClientMarketData {
        <CMsgGCClientMarketData as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCClientMarketData {
    pub fn new() -> CMsgGCClientMarketData {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "entries",
            |m: &CMsgGCClientMarketData| { &m.entries },
            |m: &mut CMsgGCClientMarketData| { &mut m.entries },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCClientMarketData>(
            "CMsgGCClientMarketData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCClientMarketData {
    const NAME: &'static str = "CMsgGCClientMarketData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.entries.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.entries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.entries {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCClientMarketData {
        CMsgGCClientMarketData::new()
    }

    fn clear(&mut self) {
        self.entries.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCClientMarketData {
        static instance: CMsgGCClientMarketData = CMsgGCClientMarketData {
            entries: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCClientMarketData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCClientMarketData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCClientMarketData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCClientMarketData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgApplyToolToItem)
pub struct CMsgApplyToolToItem {
    // message fields
    // @@protoc_insertion_point(field:CMsgApplyToolToItem.tool_item_id)
    pub tool_item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgApplyToolToItem.subject_item_id)
    pub subject_item_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgApplyToolToItem.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgApplyToolToItem {
    fn default() -> &'a CMsgApplyToolToItem {
        <CMsgApplyToolToItem as ::protobuf::Message>::default_instance()
    }
}

impl CMsgApplyToolToItem {
    pub fn new() -> CMsgApplyToolToItem {
        ::std::default::Default::default()
    }

    // optional uint64 tool_item_id = 1;

    pub fn tool_item_id(&self) -> u64 {
        self.tool_item_id.unwrap_or(0)
    }

    pub fn clear_tool_item_id(&mut self) {
        self.tool_item_id = ::std::option::Option::None;
    }

    pub fn has_tool_item_id(&self) -> bool {
        self.tool_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tool_item_id(&mut self, v: u64) {
        self.tool_item_id = ::std::option::Option::Some(v);
    }

    // optional uint64 subject_item_id = 2;

    pub fn subject_item_id(&self) -> u64 {
        self.subject_item_id.unwrap_or(0)
    }

    pub fn clear_subject_item_id(&mut self) {
        self.subject_item_id = ::std::option::Option::None;
    }

    pub fn has_subject_item_id(&self) -> bool {
        self.subject_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subject_item_id(&mut self, v: u64) {
        self.subject_item_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tool_item_id",
            |m: &CMsgApplyToolToItem| { &m.tool_item_id },
            |m: &mut CMsgApplyToolToItem| { &mut m.tool_item_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "subject_item_id",
            |m: &CMsgApplyToolToItem| { &m.subject_item_id },
            |m: &mut CMsgApplyToolToItem| { &mut m.subject_item_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgApplyToolToItem>(
            "CMsgApplyToolToItem",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgApplyToolToItem {
    const NAME: &'static str = "CMsgApplyToolToItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.tool_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.subject_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.tool_item_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.subject_item_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.tool_item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.subject_item_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgApplyToolToItem {
        CMsgApplyToolToItem::new()
    }

    fn clear(&mut self) {
        self.tool_item_id = ::std::option::Option::None;
        self.subject_item_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgApplyToolToItem {
        static instance: CMsgApplyToolToItem = CMsgApplyToolToItem {
            tool_item_id: ::std::option::Option::None,
            subject_item_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgApplyToolToItem {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgApplyToolToItem").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgApplyToolToItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgApplyToolToItem {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgApplyToolToBaseItem)
pub struct CMsgApplyToolToBaseItem {
    // message fields
    // @@protoc_insertion_point(field:CMsgApplyToolToBaseItem.tool_item_id)
    pub tool_item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgApplyToolToBaseItem.baseitem_def_index)
    pub baseitem_def_index: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgApplyToolToBaseItem.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgApplyToolToBaseItem {
    fn default() -> &'a CMsgApplyToolToBaseItem {
        <CMsgApplyToolToBaseItem as ::protobuf::Message>::default_instance()
    }
}

impl CMsgApplyToolToBaseItem {
    pub fn new() -> CMsgApplyToolToBaseItem {
        ::std::default::Default::default()
    }

    // optional uint64 tool_item_id = 1;

    pub fn tool_item_id(&self) -> u64 {
        self.tool_item_id.unwrap_or(0)
    }

    pub fn clear_tool_item_id(&mut self) {
        self.tool_item_id = ::std::option::Option::None;
    }

    pub fn has_tool_item_id(&self) -> bool {
        self.tool_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tool_item_id(&mut self, v: u64) {
        self.tool_item_id = ::std::option::Option::Some(v);
    }

    // optional uint32 baseitem_def_index = 2;

    pub fn baseitem_def_index(&self) -> u32 {
        self.baseitem_def_index.unwrap_or(0)
    }

    pub fn clear_baseitem_def_index(&mut self) {
        self.baseitem_def_index = ::std::option::Option::None;
    }

    pub fn has_baseitem_def_index(&self) -> bool {
        self.baseitem_def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_baseitem_def_index(&mut self, v: u32) {
        self.baseitem_def_index = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tool_item_id",
            |m: &CMsgApplyToolToBaseItem| { &m.tool_item_id },
            |m: &mut CMsgApplyToolToBaseItem| { &mut m.tool_item_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "baseitem_def_index",
            |m: &CMsgApplyToolToBaseItem| { &m.baseitem_def_index },
            |m: &mut CMsgApplyToolToBaseItem| { &mut m.baseitem_def_index },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgApplyToolToBaseItem>(
            "CMsgApplyToolToBaseItem",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgApplyToolToBaseItem {
    const NAME: &'static str = "CMsgApplyToolToBaseItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.tool_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.baseitem_def_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.tool_item_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.baseitem_def_index {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.tool_item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.baseitem_def_index {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgApplyToolToBaseItem {
        CMsgApplyToolToBaseItem::new()
    }

    fn clear(&mut self) {
        self.tool_item_id = ::std::option::Option::None;
        self.baseitem_def_index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgApplyToolToBaseItem {
        static instance: CMsgApplyToolToBaseItem = CMsgApplyToolToBaseItem {
            tool_item_id: ::std::option::Option::None,
            baseitem_def_index: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgApplyToolToBaseItem {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgApplyToolToBaseItem").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgApplyToolToBaseItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgApplyToolToBaseItem {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgRecipeComponent)
pub struct CMsgRecipeComponent {
    // message fields
    // @@protoc_insertion_point(field:CMsgRecipeComponent.subject_item_id)
    pub subject_item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgRecipeComponent.attribute_index)
    pub attribute_index: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgRecipeComponent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRecipeComponent {
    fn default() -> &'a CMsgRecipeComponent {
        <CMsgRecipeComponent as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRecipeComponent {
    pub fn new() -> CMsgRecipeComponent {
        ::std::default::Default::default()
    }

    // optional uint64 subject_item_id = 1;

    pub fn subject_item_id(&self) -> u64 {
        self.subject_item_id.unwrap_or(0)
    }

    pub fn clear_subject_item_id(&mut self) {
        self.subject_item_id = ::std::option::Option::None;
    }

    pub fn has_subject_item_id(&self) -> bool {
        self.subject_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subject_item_id(&mut self, v: u64) {
        self.subject_item_id = ::std::option::Option::Some(v);
    }

    // optional uint64 attribute_index = 2;

    pub fn attribute_index(&self) -> u64 {
        self.attribute_index.unwrap_or(0)
    }

    pub fn clear_attribute_index(&mut self) {
        self.attribute_index = ::std::option::Option::None;
    }

    pub fn has_attribute_index(&self) -> bool {
        self.attribute_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attribute_index(&mut self, v: u64) {
        self.attribute_index = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "subject_item_id",
            |m: &CMsgRecipeComponent| { &m.subject_item_id },
            |m: &mut CMsgRecipeComponent| { &mut m.subject_item_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "attribute_index",
            |m: &CMsgRecipeComponent| { &m.attribute_index },
            |m: &mut CMsgRecipeComponent| { &mut m.attribute_index },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgRecipeComponent>(
            "CMsgRecipeComponent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgRecipeComponent {
    const NAME: &'static str = "CMsgRecipeComponent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.subject_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.attribute_index = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.subject_item_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.attribute_index {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.subject_item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.attribute_index {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRecipeComponent {
        CMsgRecipeComponent::new()
    }

    fn clear(&mut self) {
        self.subject_item_id = ::std::option::Option::None;
        self.attribute_index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRecipeComponent {
        static instance: CMsgRecipeComponent = CMsgRecipeComponent {
            subject_item_id: ::std::option::Option::None,
            attribute_index: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgRecipeComponent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgRecipeComponent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgRecipeComponent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgRecipeComponent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgFulfillDynamicRecipeComponent)
pub struct CMsgFulfillDynamicRecipeComponent {
    // message fields
    // @@protoc_insertion_point(field:CMsgFulfillDynamicRecipeComponent.tool_item_id)
    pub tool_item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgFulfillDynamicRecipeComponent.consumption_components)
    pub consumption_components: ::std::vec::Vec<CMsgRecipeComponent>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgFulfillDynamicRecipeComponent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgFulfillDynamicRecipeComponent {
    fn default() -> &'a CMsgFulfillDynamicRecipeComponent {
        <CMsgFulfillDynamicRecipeComponent as ::protobuf::Message>::default_instance()
    }
}

impl CMsgFulfillDynamicRecipeComponent {
    pub fn new() -> CMsgFulfillDynamicRecipeComponent {
        ::std::default::Default::default()
    }

    // optional uint64 tool_item_id = 1;

    pub fn tool_item_id(&self) -> u64 {
        self.tool_item_id.unwrap_or(0)
    }

    pub fn clear_tool_item_id(&mut self) {
        self.tool_item_id = ::std::option::Option::None;
    }

    pub fn has_tool_item_id(&self) -> bool {
        self.tool_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tool_item_id(&mut self, v: u64) {
        self.tool_item_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tool_item_id",
            |m: &CMsgFulfillDynamicRecipeComponent| { &m.tool_item_id },
            |m: &mut CMsgFulfillDynamicRecipeComponent| { &mut m.tool_item_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "consumption_components",
            |m: &CMsgFulfillDynamicRecipeComponent| { &m.consumption_components },
            |m: &mut CMsgFulfillDynamicRecipeComponent| { &mut m.consumption_components },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgFulfillDynamicRecipeComponent>(
            "CMsgFulfillDynamicRecipeComponent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgFulfillDynamicRecipeComponent {
    const NAME: &'static str = "CMsgFulfillDynamicRecipeComponent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.tool_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    self.consumption_components.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.tool_item_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        for value in &self.consumption_components {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.tool_item_id {
            os.write_uint64(1, v)?;
        }
        for v in &self.consumption_components {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgFulfillDynamicRecipeComponent {
        CMsgFulfillDynamicRecipeComponent::new()
    }

    fn clear(&mut self) {
        self.tool_item_id = ::std::option::Option::None;
        self.consumption_components.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgFulfillDynamicRecipeComponent {
        static instance: CMsgFulfillDynamicRecipeComponent = CMsgFulfillDynamicRecipeComponent {
            tool_item_id: ::std::option::Option::None,
            consumption_components: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgFulfillDynamicRecipeComponent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgFulfillDynamicRecipeComponent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgFulfillDynamicRecipeComponent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgFulfillDynamicRecipeComponent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgSetItemEffectVerticalOffset)
pub struct CMsgSetItemEffectVerticalOffset {
    // message fields
    // @@protoc_insertion_point(field:CMsgSetItemEffectVerticalOffset.item_id)
    pub item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSetItemEffectVerticalOffset.offset)
    pub offset: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSetItemEffectVerticalOffset.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSetItemEffectVerticalOffset {
    fn default() -> &'a CMsgSetItemEffectVerticalOffset {
        <CMsgSetItemEffectVerticalOffset as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSetItemEffectVerticalOffset {
    pub fn new() -> CMsgSetItemEffectVerticalOffset {
        ::std::default::Default::default()
    }

    // optional uint64 item_id = 1;

    pub fn item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    // optional float offset = 2;

    pub fn offset(&self) -> f32 {
        self.offset.unwrap_or(0.)
    }

    pub fn clear_offset(&mut self) {
        self.offset = ::std::option::Option::None;
    }

    pub fn has_offset(&self) -> bool {
        self.offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: f32) {
        self.offset = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_id",
            |m: &CMsgSetItemEffectVerticalOffset| { &m.item_id },
            |m: &mut CMsgSetItemEffectVerticalOffset| { &mut m.item_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "offset",
            |m: &CMsgSetItemEffectVerticalOffset| { &m.offset },
            |m: &mut CMsgSetItemEffectVerticalOffset| { &mut m.offset },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSetItemEffectVerticalOffset>(
            "CMsgSetItemEffectVerticalOffset",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSetItemEffectVerticalOffset {
    const NAME: &'static str = "CMsgSetItemEffectVerticalOffset";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                21 => {
                    self.offset = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.offset {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.offset {
            os.write_float(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSetItemEffectVerticalOffset {
        CMsgSetItemEffectVerticalOffset::new()
    }

    fn clear(&mut self) {
        self.item_id = ::std::option::Option::None;
        self.offset = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSetItemEffectVerticalOffset {
        static instance: CMsgSetItemEffectVerticalOffset = CMsgSetItemEffectVerticalOffset {
            item_id: ::std::option::Option::None,
            offset: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSetItemEffectVerticalOffset {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSetItemEffectVerticalOffset").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSetItemEffectVerticalOffset {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSetItemEffectVerticalOffset {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgSetHatEffectUseHeadOrigin)
pub struct CMsgSetHatEffectUseHeadOrigin {
    // message fields
    // @@protoc_insertion_point(field:CMsgSetHatEffectUseHeadOrigin.item_id)
    pub item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSetHatEffectUseHeadOrigin.use_head)
    pub use_head: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSetHatEffectUseHeadOrigin.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSetHatEffectUseHeadOrigin {
    fn default() -> &'a CMsgSetHatEffectUseHeadOrigin {
        <CMsgSetHatEffectUseHeadOrigin as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSetHatEffectUseHeadOrigin {
    pub fn new() -> CMsgSetHatEffectUseHeadOrigin {
        ::std::default::Default::default()
    }

    // optional uint64 item_id = 1;

    pub fn item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    // optional bool use_head = 2;

    pub fn use_head(&self) -> bool {
        self.use_head.unwrap_or(false)
    }

    pub fn clear_use_head(&mut self) {
        self.use_head = ::std::option::Option::None;
    }

    pub fn has_use_head(&self) -> bool {
        self.use_head.is_some()
    }

    // Param is passed by value, moved
    pub fn set_use_head(&mut self, v: bool) {
        self.use_head = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_id",
            |m: &CMsgSetHatEffectUseHeadOrigin| { &m.item_id },
            |m: &mut CMsgSetHatEffectUseHeadOrigin| { &mut m.item_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "use_head",
            |m: &CMsgSetHatEffectUseHeadOrigin| { &m.use_head },
            |m: &mut CMsgSetHatEffectUseHeadOrigin| { &mut m.use_head },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSetHatEffectUseHeadOrigin>(
            "CMsgSetHatEffectUseHeadOrigin",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSetHatEffectUseHeadOrigin {
    const NAME: &'static str = "CMsgSetHatEffectUseHeadOrigin";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.use_head = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.use_head {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.use_head {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSetHatEffectUseHeadOrigin {
        CMsgSetHatEffectUseHeadOrigin::new()
    }

    fn clear(&mut self) {
        self.item_id = ::std::option::Option::None;
        self.use_head = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSetHatEffectUseHeadOrigin {
        static instance: CMsgSetHatEffectUseHeadOrigin = CMsgSetHatEffectUseHeadOrigin {
            item_id: ::std::option::Option::None,
            use_head: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSetHatEffectUseHeadOrigin {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSetHatEffectUseHeadOrigin").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSetHatEffectUseHeadOrigin {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSetHatEffectUseHeadOrigin {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgDeliverGiftResponseGiver)
pub struct CMsgDeliverGiftResponseGiver {
    // message fields
    // @@protoc_insertion_point(field:CMsgDeliverGiftResponseGiver.response_code)
    pub response_code: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDeliverGiftResponseGiver.receiver_account_name)
    pub receiver_account_name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDeliverGiftResponseGiver.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDeliverGiftResponseGiver {
    fn default() -> &'a CMsgDeliverGiftResponseGiver {
        <CMsgDeliverGiftResponseGiver as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDeliverGiftResponseGiver {
    pub fn new() -> CMsgDeliverGiftResponseGiver {
        ::std::default::Default::default()
    }

    // optional uint32 response_code = 1;

    pub fn response_code(&self) -> u32 {
        self.response_code.unwrap_or(0)
    }

    pub fn clear_response_code(&mut self) {
        self.response_code = ::std::option::Option::None;
    }

    pub fn has_response_code(&self) -> bool {
        self.response_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response_code(&mut self, v: u32) {
        self.response_code = ::std::option::Option::Some(v);
    }

    // optional string receiver_account_name = 2;

    pub fn receiver_account_name(&self) -> &str {
        match self.receiver_account_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_receiver_account_name(&mut self) {
        self.receiver_account_name = ::std::option::Option::None;
    }

    pub fn has_receiver_account_name(&self) -> bool {
        self.receiver_account_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_receiver_account_name(&mut self, v: ::std::string::String) {
        self.receiver_account_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_receiver_account_name(&mut self) -> &mut ::std::string::String {
        if self.receiver_account_name.is_none() {
            self.receiver_account_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.receiver_account_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_receiver_account_name(&mut self) -> ::std::string::String {
        self.receiver_account_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "response_code",
            |m: &CMsgDeliverGiftResponseGiver| { &m.response_code },
            |m: &mut CMsgDeliverGiftResponseGiver| { &mut m.response_code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "receiver_account_name",
            |m: &CMsgDeliverGiftResponseGiver| { &m.receiver_account_name },
            |m: &mut CMsgDeliverGiftResponseGiver| { &mut m.receiver_account_name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgDeliverGiftResponseGiver>(
            "CMsgDeliverGiftResponseGiver",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgDeliverGiftResponseGiver {
    const NAME: &'static str = "CMsgDeliverGiftResponseGiver";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.response_code = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.receiver_account_name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.response_code {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.receiver_account_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.response_code {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.receiver_account_name.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDeliverGiftResponseGiver {
        CMsgDeliverGiftResponseGiver::new()
    }

    fn clear(&mut self) {
        self.response_code = ::std::option::Option::None;
        self.receiver_account_name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDeliverGiftResponseGiver {
        static instance: CMsgDeliverGiftResponseGiver = CMsgDeliverGiftResponseGiver {
            response_code: ::std::option::Option::None,
            receiver_account_name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgDeliverGiftResponseGiver {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgDeliverGiftResponseGiver").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgDeliverGiftResponseGiver {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDeliverGiftResponseGiver {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CSOEconGameAccountForGameServers)
pub struct CSOEconGameAccountForGameServers {
    // message fields
    // @@protoc_insertion_point(field:CSOEconGameAccountForGameServers.disable_party_quest_progress)
    pub disable_party_quest_progress: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CSOEconGameAccountForGameServers.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSOEconGameAccountForGameServers {
    fn default() -> &'a CSOEconGameAccountForGameServers {
        <CSOEconGameAccountForGameServers as ::protobuf::Message>::default_instance()
    }
}

impl CSOEconGameAccountForGameServers {
    pub fn new() -> CSOEconGameAccountForGameServers {
        ::std::default::Default::default()
    }

    // optional bool disable_party_quest_progress = 6;

    pub fn disable_party_quest_progress(&self) -> bool {
        self.disable_party_quest_progress.unwrap_or(false)
    }

    pub fn clear_disable_party_quest_progress(&mut self) {
        self.disable_party_quest_progress = ::std::option::Option::None;
    }

    pub fn has_disable_party_quest_progress(&self) -> bool {
        self.disable_party_quest_progress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_disable_party_quest_progress(&mut self, v: bool) {
        self.disable_party_quest_progress = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "disable_party_quest_progress",
            |m: &CSOEconGameAccountForGameServers| { &m.disable_party_quest_progress },
            |m: &mut CSOEconGameAccountForGameServers| { &mut m.disable_party_quest_progress },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSOEconGameAccountForGameServers>(
            "CSOEconGameAccountForGameServers",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSOEconGameAccountForGameServers {
    const NAME: &'static str = "CSOEconGameAccountForGameServers";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                48 => {
                    self.disable_party_quest_progress = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.disable_party_quest_progress {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.disable_party_quest_progress {
            os.write_bool(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSOEconGameAccountForGameServers {
        CSOEconGameAccountForGameServers::new()
    }

    fn clear(&mut self) {
        self.disable_party_quest_progress = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSOEconGameAccountForGameServers {
        static instance: CSOEconGameAccountForGameServers = CSOEconGameAccountForGameServers {
            disable_party_quest_progress: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSOEconGameAccountForGameServers {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSOEconGameAccountForGameServers").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSOEconGameAccountForGameServers {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOEconGameAccountForGameServers {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CWorkshop_PopulateItemDescriptions_Request)
pub struct CWorkshop_PopulateItemDescriptions_Request {
    // message fields
    // @@protoc_insertion_point(field:CWorkshop_PopulateItemDescriptions_Request.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CWorkshop_PopulateItemDescriptions_Request.languages)
    pub languages: ::std::vec::Vec<cworkshop_populate_item_descriptions_request::ItemDescriptionsLanguageBlock>,
    // special fields
    // @@protoc_insertion_point(special_field:CWorkshop_PopulateItemDescriptions_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CWorkshop_PopulateItemDescriptions_Request {
    fn default() -> &'a CWorkshop_PopulateItemDescriptions_Request {
        <CWorkshop_PopulateItemDescriptions_Request as ::protobuf::Message>::default_instance()
    }
}

impl CWorkshop_PopulateItemDescriptions_Request {
    pub fn new() -> CWorkshop_PopulateItemDescriptions_Request {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "appid",
            |m: &CWorkshop_PopulateItemDescriptions_Request| { &m.appid },
            |m: &mut CWorkshop_PopulateItemDescriptions_Request| { &mut m.appid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "languages",
            |m: &CWorkshop_PopulateItemDescriptions_Request| { &m.languages },
            |m: &mut CWorkshop_PopulateItemDescriptions_Request| { &mut m.languages },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CWorkshop_PopulateItemDescriptions_Request>(
            "CWorkshop_PopulateItemDescriptions_Request",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CWorkshop_PopulateItemDescriptions_Request {
    const NAME: &'static str = "CWorkshop_PopulateItemDescriptions_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.languages.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.languages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        for v in &self.languages {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CWorkshop_PopulateItemDescriptions_Request {
        CWorkshop_PopulateItemDescriptions_Request::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.languages.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CWorkshop_PopulateItemDescriptions_Request {
        static instance: CWorkshop_PopulateItemDescriptions_Request = CWorkshop_PopulateItemDescriptions_Request {
            appid: ::std::option::Option::None,
            languages: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CWorkshop_PopulateItemDescriptions_Request {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CWorkshop_PopulateItemDescriptions_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CWorkshop_PopulateItemDescriptions_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CWorkshop_PopulateItemDescriptions_Request {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CWorkshop_PopulateItemDescriptions_Request`
pub mod cworkshop_populate_item_descriptions_request {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:CWorkshop_PopulateItemDescriptions_Request.SingleItemDescription)
    pub struct SingleItemDescription {
        // message fields
        // @@protoc_insertion_point(field:CWorkshop_PopulateItemDescriptions_Request.SingleItemDescription.gameitemid)
        pub gameitemid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CWorkshop_PopulateItemDescriptions_Request.SingleItemDescription.item_description)
        pub item_description: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CWorkshop_PopulateItemDescriptions_Request.SingleItemDescription.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SingleItemDescription {
        fn default() -> &'a SingleItemDescription {
            <SingleItemDescription as ::protobuf::Message>::default_instance()
        }
    }

    impl SingleItemDescription {
        pub fn new() -> SingleItemDescription {
            ::std::default::Default::default()
        }

        // optional uint32 gameitemid = 1;

        pub fn gameitemid(&self) -> u32 {
            self.gameitemid.unwrap_or(0)
        }

        pub fn clear_gameitemid(&mut self) {
            self.gameitemid = ::std::option::Option::None;
        }

        pub fn has_gameitemid(&self) -> bool {
            self.gameitemid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_gameitemid(&mut self, v: u32) {
            self.gameitemid = ::std::option::Option::Some(v);
        }

        // optional string item_description = 2;

        pub fn item_description(&self) -> &str {
            match self.item_description.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_item_description(&mut self) {
            self.item_description = ::std::option::Option::None;
        }

        pub fn has_item_description(&self) -> bool {
            self.item_description.is_some()
        }

        // Param is passed by value, moved
        pub fn set_item_description(&mut self, v: ::std::string::String) {
            self.item_description = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_item_description(&mut self) -> &mut ::std::string::String {
            if self.item_description.is_none() {
                self.item_description = ::std::option::Option::Some(::std::string::String::new());
            }
            self.item_description.as_mut().unwrap()
        }

        // Take field
        pub fn take_item_description(&mut self) -> ::std::string::String {
            self.item_description.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "gameitemid",
                |m: &SingleItemDescription| { &m.gameitemid },
                |m: &mut SingleItemDescription| { &mut m.gameitemid },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "item_description",
                |m: &SingleItemDescription| { &m.item_description },
                |m: &mut SingleItemDescription| { &mut m.item_description },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleItemDescription>(
                "CWorkshop_PopulateItemDescriptions_Request.SingleItemDescription",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for SingleItemDescription {
        const NAME: &'static str = "SingleItemDescription";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.gameitemid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.item_description = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.gameitemid {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.item_description.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.gameitemid {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.item_description.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SingleItemDescription {
            SingleItemDescription::new()
        }

        fn clear(&mut self) {
            self.gameitemid = ::std::option::Option::None;
            self.item_description = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SingleItemDescription {
            static instance: SingleItemDescription = SingleItemDescription {
                gameitemid: ::std::option::Option::None,
                item_description: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for SingleItemDescription {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CWorkshop_PopulateItemDescriptions_Request.SingleItemDescription").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for SingleItemDescription {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for SingleItemDescription {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:CWorkshop_PopulateItemDescriptions_Request.ItemDescriptionsLanguageBlock)
    pub struct ItemDescriptionsLanguageBlock {
        // message fields
        // @@protoc_insertion_point(field:CWorkshop_PopulateItemDescriptions_Request.ItemDescriptionsLanguageBlock.language)
        pub language: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CWorkshop_PopulateItemDescriptions_Request.ItemDescriptionsLanguageBlock.descriptions)
        pub descriptions: ::std::vec::Vec<SingleItemDescription>,
        // special fields
        // @@protoc_insertion_point(special_field:CWorkshop_PopulateItemDescriptions_Request.ItemDescriptionsLanguageBlock.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ItemDescriptionsLanguageBlock {
        fn default() -> &'a ItemDescriptionsLanguageBlock {
            <ItemDescriptionsLanguageBlock as ::protobuf::Message>::default_instance()
        }
    }

    impl ItemDescriptionsLanguageBlock {
        pub fn new() -> ItemDescriptionsLanguageBlock {
            ::std::default::Default::default()
        }

        // optional string language = 1;

        pub fn language(&self) -> &str {
            match self.language.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_language(&mut self) {
            self.language = ::std::option::Option::None;
        }

        pub fn has_language(&self) -> bool {
            self.language.is_some()
        }

        // Param is passed by value, moved
        pub fn set_language(&mut self, v: ::std::string::String) {
            self.language = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_language(&mut self) -> &mut ::std::string::String {
            if self.language.is_none() {
                self.language = ::std::option::Option::Some(::std::string::String::new());
            }
            self.language.as_mut().unwrap()
        }

        // Take field
        pub fn take_language(&mut self) -> ::std::string::String {
            self.language.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "language",
                |m: &ItemDescriptionsLanguageBlock| { &m.language },
                |m: &mut ItemDescriptionsLanguageBlock| { &mut m.language },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "descriptions",
                |m: &ItemDescriptionsLanguageBlock| { &m.descriptions },
                |m: &mut ItemDescriptionsLanguageBlock| { &mut m.descriptions },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ItemDescriptionsLanguageBlock>(
                "CWorkshop_PopulateItemDescriptions_Request.ItemDescriptionsLanguageBlock",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ItemDescriptionsLanguageBlock {
        const NAME: &'static str = "ItemDescriptionsLanguageBlock";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.language = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.descriptions.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.language.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            for value in &self.descriptions {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.language.as_ref() {
                os.write_string(1, v)?;
            }
            for v in &self.descriptions {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ItemDescriptionsLanguageBlock {
            ItemDescriptionsLanguageBlock::new()
        }

        fn clear(&mut self) {
            self.language = ::std::option::Option::None;
            self.descriptions.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ItemDescriptionsLanguageBlock {
            static instance: ItemDescriptionsLanguageBlock = ItemDescriptionsLanguageBlock {
                language: ::std::option::Option::None,
                descriptions: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for ItemDescriptionsLanguageBlock {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CWorkshop_PopulateItemDescriptions_Request.ItemDescriptionsLanguageBlock").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ItemDescriptionsLanguageBlock {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ItemDescriptionsLanguageBlock {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CWorkshop_GetContributors_Request)
pub struct CWorkshop_GetContributors_Request {
    // message fields
    // @@protoc_insertion_point(field:CWorkshop_GetContributors_Request.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CWorkshop_GetContributors_Request.gameitemid)
    pub gameitemid: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CWorkshop_GetContributors_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CWorkshop_GetContributors_Request {
    fn default() -> &'a CWorkshop_GetContributors_Request {
        <CWorkshop_GetContributors_Request as ::protobuf::Message>::default_instance()
    }
}

impl CWorkshop_GetContributors_Request {
    pub fn new() -> CWorkshop_GetContributors_Request {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional uint32 gameitemid = 2;

    pub fn gameitemid(&self) -> u32 {
        self.gameitemid.unwrap_or(0)
    }

    pub fn clear_gameitemid(&mut self) {
        self.gameitemid = ::std::option::Option::None;
    }

    pub fn has_gameitemid(&self) -> bool {
        self.gameitemid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gameitemid(&mut self, v: u32) {
        self.gameitemid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "appid",
            |m: &CWorkshop_GetContributors_Request| { &m.appid },
            |m: &mut CWorkshop_GetContributors_Request| { &mut m.appid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gameitemid",
            |m: &CWorkshop_GetContributors_Request| { &m.gameitemid },
            |m: &mut CWorkshop_GetContributors_Request| { &mut m.gameitemid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CWorkshop_GetContributors_Request>(
            "CWorkshop_GetContributors_Request",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CWorkshop_GetContributors_Request {
    const NAME: &'static str = "CWorkshop_GetContributors_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.gameitemid = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.gameitemid {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.gameitemid {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CWorkshop_GetContributors_Request {
        CWorkshop_GetContributors_Request::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.gameitemid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CWorkshop_GetContributors_Request {
        static instance: CWorkshop_GetContributors_Request = CWorkshop_GetContributors_Request {
            appid: ::std::option::Option::None,
            gameitemid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CWorkshop_GetContributors_Request {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CWorkshop_GetContributors_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CWorkshop_GetContributors_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CWorkshop_GetContributors_Request {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CWorkshop_GetContributors_Response)
pub struct CWorkshop_GetContributors_Response {
    // message fields
    // @@protoc_insertion_point(field:CWorkshop_GetContributors_Response.contributors)
    pub contributors: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CWorkshop_GetContributors_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CWorkshop_GetContributors_Response {
    fn default() -> &'a CWorkshop_GetContributors_Response {
        <CWorkshop_GetContributors_Response as ::protobuf::Message>::default_instance()
    }
}

impl CWorkshop_GetContributors_Response {
    pub fn new() -> CWorkshop_GetContributors_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "contributors",
            |m: &CWorkshop_GetContributors_Response| { &m.contributors },
            |m: &mut CWorkshop_GetContributors_Response| { &mut m.contributors },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CWorkshop_GetContributors_Response>(
            "CWorkshop_GetContributors_Response",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CWorkshop_GetContributors_Response {
    const NAME: &'static str = "CWorkshop_GetContributors_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_fixed64_into(&mut self.contributors)?;
                },
                9 => {
                    self.contributors.push(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += 9 * self.contributors.len() as u64;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.contributors {
            os.write_fixed64(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CWorkshop_GetContributors_Response {
        CWorkshop_GetContributors_Response::new()
    }

    fn clear(&mut self) {
        self.contributors.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CWorkshop_GetContributors_Response {
        static instance: CWorkshop_GetContributors_Response = CWorkshop_GetContributors_Response {
            contributors: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CWorkshop_GetContributors_Response {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CWorkshop_GetContributors_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CWorkshop_GetContributors_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CWorkshop_GetContributors_Response {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CWorkshop_SetItemPaymentRules_Request)
pub struct CWorkshop_SetItemPaymentRules_Request {
    // message fields
    // @@protoc_insertion_point(field:CWorkshop_SetItemPaymentRules_Request.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CWorkshop_SetItemPaymentRules_Request.gameitemid)
    pub gameitemid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CWorkshop_SetItemPaymentRules_Request.associated_workshop_files)
    pub associated_workshop_files: ::std::vec::Vec<cworkshop_set_item_payment_rules_request::WorkshopItemPaymentRule>,
    // @@protoc_insertion_point(field:CWorkshop_SetItemPaymentRules_Request.partner_accounts)
    pub partner_accounts: ::std::vec::Vec<cworkshop_set_item_payment_rules_request::PartnerItemPaymentRule>,
    // special fields
    // @@protoc_insertion_point(special_field:CWorkshop_SetItemPaymentRules_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CWorkshop_SetItemPaymentRules_Request {
    fn default() -> &'a CWorkshop_SetItemPaymentRules_Request {
        <CWorkshop_SetItemPaymentRules_Request as ::protobuf::Message>::default_instance()
    }
}

impl CWorkshop_SetItemPaymentRules_Request {
    pub fn new() -> CWorkshop_SetItemPaymentRules_Request {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional uint32 gameitemid = 2;

    pub fn gameitemid(&self) -> u32 {
        self.gameitemid.unwrap_or(0)
    }

    pub fn clear_gameitemid(&mut self) {
        self.gameitemid = ::std::option::Option::None;
    }

    pub fn has_gameitemid(&self) -> bool {
        self.gameitemid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gameitemid(&mut self, v: u32) {
        self.gameitemid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "appid",
            |m: &CWorkshop_SetItemPaymentRules_Request| { &m.appid },
            |m: &mut CWorkshop_SetItemPaymentRules_Request| { &mut m.appid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gameitemid",
            |m: &CWorkshop_SetItemPaymentRules_Request| { &m.gameitemid },
            |m: &mut CWorkshop_SetItemPaymentRules_Request| { &mut m.gameitemid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "associated_workshop_files",
            |m: &CWorkshop_SetItemPaymentRules_Request| { &m.associated_workshop_files },
            |m: &mut CWorkshop_SetItemPaymentRules_Request| { &mut m.associated_workshop_files },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "partner_accounts",
            |m: &CWorkshop_SetItemPaymentRules_Request| { &m.partner_accounts },
            |m: &mut CWorkshop_SetItemPaymentRules_Request| { &mut m.partner_accounts },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CWorkshop_SetItemPaymentRules_Request>(
            "CWorkshop_SetItemPaymentRules_Request",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CWorkshop_SetItemPaymentRules_Request {
    const NAME: &'static str = "CWorkshop_SetItemPaymentRules_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.gameitemid = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.associated_workshop_files.push(is.read_message()?);
                },
                34 => {
                    self.partner_accounts.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.gameitemid {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        for value in &self.associated_workshop_files {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.partner_accounts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.gameitemid {
            os.write_uint32(2, v)?;
        }
        for v in &self.associated_workshop_files {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.partner_accounts {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CWorkshop_SetItemPaymentRules_Request {
        CWorkshop_SetItemPaymentRules_Request::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.gameitemid = ::std::option::Option::None;
        self.associated_workshop_files.clear();
        self.partner_accounts.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CWorkshop_SetItemPaymentRules_Request {
        static instance: CWorkshop_SetItemPaymentRules_Request = CWorkshop_SetItemPaymentRules_Request {
            appid: ::std::option::Option::None,
            gameitemid: ::std::option::Option::None,
            associated_workshop_files: ::std::vec::Vec::new(),
            partner_accounts: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CWorkshop_SetItemPaymentRules_Request {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CWorkshop_SetItemPaymentRules_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CWorkshop_SetItemPaymentRules_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CWorkshop_SetItemPaymentRules_Request {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CWorkshop_SetItemPaymentRules_Request`
pub mod cworkshop_set_item_payment_rules_request {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:CWorkshop_SetItemPaymentRules_Request.WorkshopItemPaymentRule)
    pub struct WorkshopItemPaymentRule {
        // message fields
        // @@protoc_insertion_point(field:CWorkshop_SetItemPaymentRules_Request.WorkshopItemPaymentRule.workshop_file_id)
        pub workshop_file_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CWorkshop_SetItemPaymentRules_Request.WorkshopItemPaymentRule.revenue_percentage)
        pub revenue_percentage: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CWorkshop_SetItemPaymentRules_Request.WorkshopItemPaymentRule.rule_description)
        pub rule_description: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CWorkshop_SetItemPaymentRules_Request.WorkshopItemPaymentRule.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a WorkshopItemPaymentRule {
        fn default() -> &'a WorkshopItemPaymentRule {
            <WorkshopItemPaymentRule as ::protobuf::Message>::default_instance()
        }
    }

    impl WorkshopItemPaymentRule {
        pub fn new() -> WorkshopItemPaymentRule {
            ::std::default::Default::default()
        }

        // optional uint64 workshop_file_id = 1;

        pub fn workshop_file_id(&self) -> u64 {
            self.workshop_file_id.unwrap_or(0)
        }

        pub fn clear_workshop_file_id(&mut self) {
            self.workshop_file_id = ::std::option::Option::None;
        }

        pub fn has_workshop_file_id(&self) -> bool {
            self.workshop_file_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_workshop_file_id(&mut self, v: u64) {
            self.workshop_file_id = ::std::option::Option::Some(v);
        }

        // optional float revenue_percentage = 2;

        pub fn revenue_percentage(&self) -> f32 {
            self.revenue_percentage.unwrap_or(0.)
        }

        pub fn clear_revenue_percentage(&mut self) {
            self.revenue_percentage = ::std::option::Option::None;
        }

        pub fn has_revenue_percentage(&self) -> bool {
            self.revenue_percentage.is_some()
        }

        // Param is passed by value, moved
        pub fn set_revenue_percentage(&mut self, v: f32) {
            self.revenue_percentage = ::std::option::Option::Some(v);
        }

        // optional string rule_description = 3;

        pub fn rule_description(&self) -> &str {
            match self.rule_description.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_rule_description(&mut self) {
            self.rule_description = ::std::option::Option::None;
        }

        pub fn has_rule_description(&self) -> bool {
            self.rule_description.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rule_description(&mut self, v: ::std::string::String) {
            self.rule_description = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_rule_description(&mut self) -> &mut ::std::string::String {
            if self.rule_description.is_none() {
                self.rule_description = ::std::option::Option::Some(::std::string::String::new());
            }
            self.rule_description.as_mut().unwrap()
        }

        // Take field
        pub fn take_rule_description(&mut self) -> ::std::string::String {
            self.rule_description.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "workshop_file_id",
                |m: &WorkshopItemPaymentRule| { &m.workshop_file_id },
                |m: &mut WorkshopItemPaymentRule| { &mut m.workshop_file_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "revenue_percentage",
                |m: &WorkshopItemPaymentRule| { &m.revenue_percentage },
                |m: &mut WorkshopItemPaymentRule| { &mut m.revenue_percentage },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "rule_description",
                |m: &WorkshopItemPaymentRule| { &m.rule_description },
                |m: &mut WorkshopItemPaymentRule| { &mut m.rule_description },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WorkshopItemPaymentRule>(
                "CWorkshop_SetItemPaymentRules_Request.WorkshopItemPaymentRule",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for WorkshopItemPaymentRule {
        const NAME: &'static str = "WorkshopItemPaymentRule";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.workshop_file_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    21 => {
                        self.revenue_percentage = ::std::option::Option::Some(is.read_float()?);
                    },
                    26 => {
                        self.rule_description = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.workshop_file_id {
                my_size += ::protobuf::rt::uint64_size(1, v);
            }
            if let Some(v) = self.revenue_percentage {
                my_size += 1 + 4;
            }
            if let Some(v) = self.rule_description.as_ref() {
                my_size += ::protobuf::rt::string_size(3, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.workshop_file_id {
                os.write_uint64(1, v)?;
            }
            if let Some(v) = self.revenue_percentage {
                os.write_float(2, v)?;
            }
            if let Some(v) = self.rule_description.as_ref() {
                os.write_string(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> WorkshopItemPaymentRule {
            WorkshopItemPaymentRule::new()
        }

        fn clear(&mut self) {
            self.workshop_file_id = ::std::option::Option::None;
            self.revenue_percentage = ::std::option::Option::None;
            self.rule_description = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static WorkshopItemPaymentRule {
            static instance: WorkshopItemPaymentRule = WorkshopItemPaymentRule {
                workshop_file_id: ::std::option::Option::None,
                revenue_percentage: ::std::option::Option::None,
                rule_description: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for WorkshopItemPaymentRule {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CWorkshop_SetItemPaymentRules_Request.WorkshopItemPaymentRule").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for WorkshopItemPaymentRule {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for WorkshopItemPaymentRule {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:CWorkshop_SetItemPaymentRules_Request.PartnerItemPaymentRule)
    pub struct PartnerItemPaymentRule {
        // message fields
        // @@protoc_insertion_point(field:CWorkshop_SetItemPaymentRules_Request.PartnerItemPaymentRule.account_id)
        pub account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CWorkshop_SetItemPaymentRules_Request.PartnerItemPaymentRule.revenue_percentage)
        pub revenue_percentage: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CWorkshop_SetItemPaymentRules_Request.PartnerItemPaymentRule.rule_description)
        pub rule_description: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CWorkshop_SetItemPaymentRules_Request.PartnerItemPaymentRule.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PartnerItemPaymentRule {
        fn default() -> &'a PartnerItemPaymentRule {
            <PartnerItemPaymentRule as ::protobuf::Message>::default_instance()
        }
    }

    impl PartnerItemPaymentRule {
        pub fn new() -> PartnerItemPaymentRule {
            ::std::default::Default::default()
        }

        // optional uint32 account_id = 1;

        pub fn account_id(&self) -> u32 {
            self.account_id.unwrap_or(0)
        }

        pub fn clear_account_id(&mut self) {
            self.account_id = ::std::option::Option::None;
        }

        pub fn has_account_id(&self) -> bool {
            self.account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_account_id(&mut self, v: u32) {
            self.account_id = ::std::option::Option::Some(v);
        }

        // optional float revenue_percentage = 2;

        pub fn revenue_percentage(&self) -> f32 {
            self.revenue_percentage.unwrap_or(0.)
        }

        pub fn clear_revenue_percentage(&mut self) {
            self.revenue_percentage = ::std::option::Option::None;
        }

        pub fn has_revenue_percentage(&self) -> bool {
            self.revenue_percentage.is_some()
        }

        // Param is passed by value, moved
        pub fn set_revenue_percentage(&mut self, v: f32) {
            self.revenue_percentage = ::std::option::Option::Some(v);
        }

        // optional string rule_description = 3;

        pub fn rule_description(&self) -> &str {
            match self.rule_description.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_rule_description(&mut self) {
            self.rule_description = ::std::option::Option::None;
        }

        pub fn has_rule_description(&self) -> bool {
            self.rule_description.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rule_description(&mut self, v: ::std::string::String) {
            self.rule_description = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_rule_description(&mut self) -> &mut ::std::string::String {
            if self.rule_description.is_none() {
                self.rule_description = ::std::option::Option::Some(::std::string::String::new());
            }
            self.rule_description.as_mut().unwrap()
        }

        // Take field
        pub fn take_rule_description(&mut self) -> ::std::string::String {
            self.rule_description.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "account_id",
                |m: &PartnerItemPaymentRule| { &m.account_id },
                |m: &mut PartnerItemPaymentRule| { &mut m.account_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "revenue_percentage",
                |m: &PartnerItemPaymentRule| { &m.revenue_percentage },
                |m: &mut PartnerItemPaymentRule| { &mut m.revenue_percentage },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "rule_description",
                |m: &PartnerItemPaymentRule| { &m.rule_description },
                |m: &mut PartnerItemPaymentRule| { &mut m.rule_description },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PartnerItemPaymentRule>(
                "CWorkshop_SetItemPaymentRules_Request.PartnerItemPaymentRule",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for PartnerItemPaymentRule {
        const NAME: &'static str = "PartnerItemPaymentRule";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    21 => {
                        self.revenue_percentage = ::std::option::Option::Some(is.read_float()?);
                    },
                    26 => {
                        self.rule_description = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.account_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.revenue_percentage {
                my_size += 1 + 4;
            }
            if let Some(v) = self.rule_description.as_ref() {
                my_size += ::protobuf::rt::string_size(3, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.account_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.revenue_percentage {
                os.write_float(2, v)?;
            }
            if let Some(v) = self.rule_description.as_ref() {
                os.write_string(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PartnerItemPaymentRule {
            PartnerItemPaymentRule::new()
        }

        fn clear(&mut self) {
            self.account_id = ::std::option::Option::None;
            self.revenue_percentage = ::std::option::Option::None;
            self.rule_description = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PartnerItemPaymentRule {
            static instance: PartnerItemPaymentRule = PartnerItemPaymentRule {
                account_id: ::std::option::Option::None,
                revenue_percentage: ::std::option::Option::None,
                rule_description: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for PartnerItemPaymentRule {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CWorkshop_SetItemPaymentRules_Request.PartnerItemPaymentRule").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for PartnerItemPaymentRule {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for PartnerItemPaymentRule {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CWorkshop_SetItemPaymentRules_Response)
pub struct CWorkshop_SetItemPaymentRules_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CWorkshop_SetItemPaymentRules_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CWorkshop_SetItemPaymentRules_Response {
    fn default() -> &'a CWorkshop_SetItemPaymentRules_Response {
        <CWorkshop_SetItemPaymentRules_Response as ::protobuf::Message>::default_instance()
    }
}

impl CWorkshop_SetItemPaymentRules_Response {
    pub fn new() -> CWorkshop_SetItemPaymentRules_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CWorkshop_SetItemPaymentRules_Response>(
            "CWorkshop_SetItemPaymentRules_Response",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CWorkshop_SetItemPaymentRules_Response {
    const NAME: &'static str = "CWorkshop_SetItemPaymentRules_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CWorkshop_SetItemPaymentRules_Response {
        CWorkshop_SetItemPaymentRules_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CWorkshop_SetItemPaymentRules_Response {
        static instance: CWorkshop_SetItemPaymentRules_Response = CWorkshop_SetItemPaymentRules_Response {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CWorkshop_SetItemPaymentRules_Response {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CWorkshop_SetItemPaymentRules_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CWorkshop_SetItemPaymentRules_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CWorkshop_SetItemPaymentRules_Response {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EGCBaseMsg)
pub enum EGCBaseMsg {
    // @@protoc_insertion_point(enum_value:EGCBaseMsg.k_EMsgGCSystemMessage)
    k_EMsgGCSystemMessage = 4001,
    // @@protoc_insertion_point(enum_value:EGCBaseMsg.k_EMsgGCReplicateConVars)
    k_EMsgGCReplicateConVars = 4002,
    // @@protoc_insertion_point(enum_value:EGCBaseMsg.k_EMsgGCConVarUpdated)
    k_EMsgGCConVarUpdated = 4003,
    // @@protoc_insertion_point(enum_value:EGCBaseMsg.k_EMsgGCServerAvailable)
    k_EMsgGCServerAvailable = 4506,
    // @@protoc_insertion_point(enum_value:EGCBaseMsg.k_EMsgGCClientConnectToServer)
    k_EMsgGCClientConnectToServer = 4507,
    // @@protoc_insertion_point(enum_value:EGCBaseMsg.k_EMsgGCGameServerInfo)
    k_EMsgGCGameServerInfo = 4508,
    // @@protoc_insertion_point(enum_value:EGCBaseMsg.k_EMsgGCError)
    k_EMsgGCError = 4509,
    // @@protoc_insertion_point(enum_value:EGCBaseMsg.k_EMsgGCReplay_UploadedToYouTube)
    k_EMsgGCReplay_UploadedToYouTube = 4510,
    // @@protoc_insertion_point(enum_value:EGCBaseMsg.k_EMsgGCLANServerAvailable)
    k_EMsgGCLANServerAvailable = 4511,
}

impl ::protobuf::Enum for EGCBaseMsg {
    const NAME: &'static str = "EGCBaseMsg";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EGCBaseMsg> {
        match value {
            4001 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCSystemMessage),
            4002 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCReplicateConVars),
            4003 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCConVarUpdated),
            4506 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCServerAvailable),
            4507 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCClientConnectToServer),
            4508 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCGameServerInfo),
            4509 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCError),
            4510 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCReplay_UploadedToYouTube),
            4511 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCLANServerAvailable),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EGCBaseMsg] = &[
        EGCBaseMsg::k_EMsgGCSystemMessage,
        EGCBaseMsg::k_EMsgGCReplicateConVars,
        EGCBaseMsg::k_EMsgGCConVarUpdated,
        EGCBaseMsg::k_EMsgGCServerAvailable,
        EGCBaseMsg::k_EMsgGCClientConnectToServer,
        EGCBaseMsg::k_EMsgGCGameServerInfo,
        EGCBaseMsg::k_EMsgGCError,
        EGCBaseMsg::k_EMsgGCReplay_UploadedToYouTube,
        EGCBaseMsg::k_EMsgGCLANServerAvailable,
    ];
}

impl ::protobuf::EnumFull for EGCBaseMsg {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EGCBaseMsg").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            EGCBaseMsg::k_EMsgGCSystemMessage => 0,
            EGCBaseMsg::k_EMsgGCReplicateConVars => 1,
            EGCBaseMsg::k_EMsgGCConVarUpdated => 2,
            EGCBaseMsg::k_EMsgGCServerAvailable => 3,
            EGCBaseMsg::k_EMsgGCClientConnectToServer => 4,
            EGCBaseMsg::k_EMsgGCGameServerInfo => 5,
            EGCBaseMsg::k_EMsgGCError => 6,
            EGCBaseMsg::k_EMsgGCReplay_UploadedToYouTube => 7,
            EGCBaseMsg::k_EMsgGCLANServerAvailable => 8,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EGCBaseMsg {
    fn default() -> Self {
        EGCBaseMsg::k_EMsgGCSystemMessage
    }
}

impl EGCBaseMsg {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EGCBaseMsg>("EGCBaseMsg")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EGCBaseProtoObjectTypes)
pub enum EGCBaseProtoObjectTypes {
    // @@protoc_insertion_point(enum_value:EGCBaseProtoObjectTypes.k_EProtoObjectPartyInvite)
    k_EProtoObjectPartyInvite = 1001,
    // @@protoc_insertion_point(enum_value:EGCBaseProtoObjectTypes.k_EProtoObjectLobbyInvite)
    k_EProtoObjectLobbyInvite = 1002,
}

impl ::protobuf::Enum for EGCBaseProtoObjectTypes {
    const NAME: &'static str = "EGCBaseProtoObjectTypes";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EGCBaseProtoObjectTypes> {
        match value {
            1001 => ::std::option::Option::Some(EGCBaseProtoObjectTypes::k_EProtoObjectPartyInvite),
            1002 => ::std::option::Option::Some(EGCBaseProtoObjectTypes::k_EProtoObjectLobbyInvite),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EGCBaseProtoObjectTypes] = &[
        EGCBaseProtoObjectTypes::k_EProtoObjectPartyInvite,
        EGCBaseProtoObjectTypes::k_EProtoObjectLobbyInvite,
    ];
}

impl ::protobuf::EnumFull for EGCBaseProtoObjectTypes {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EGCBaseProtoObjectTypes").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            EGCBaseProtoObjectTypes::k_EProtoObjectPartyInvite => 0,
            EGCBaseProtoObjectTypes::k_EProtoObjectLobbyInvite => 1,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EGCBaseProtoObjectTypes {
    fn default() -> Self {
        EGCBaseProtoObjectTypes::k_EProtoObjectPartyInvite
    }
}

impl EGCBaseProtoObjectTypes {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EGCBaseProtoObjectTypes>("EGCBaseProtoObjectTypes")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:GCGoodbyeReason)
pub enum GCGoodbyeReason {
    // @@protoc_insertion_point(enum_value:GCGoodbyeReason.GCGoodbyeReason_GC_GOING_DOWN)
    GCGoodbyeReason_GC_GOING_DOWN = 1,
    // @@protoc_insertion_point(enum_value:GCGoodbyeReason.GCGoodbyeReason_NO_SESSION)
    GCGoodbyeReason_NO_SESSION = 2,
}

impl ::protobuf::Enum for GCGoodbyeReason {
    const NAME: &'static str = "GCGoodbyeReason";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<GCGoodbyeReason> {
        match value {
            1 => ::std::option::Option::Some(GCGoodbyeReason::GCGoodbyeReason_GC_GOING_DOWN),
            2 => ::std::option::Option::Some(GCGoodbyeReason::GCGoodbyeReason_NO_SESSION),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [GCGoodbyeReason] = &[
        GCGoodbyeReason::GCGoodbyeReason_GC_GOING_DOWN,
        GCGoodbyeReason::GCGoodbyeReason_NO_SESSION,
    ];
}

impl ::protobuf::EnumFull for GCGoodbyeReason {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("GCGoodbyeReason").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            GCGoodbyeReason::GCGoodbyeReason_GC_GOING_DOWN => 0,
            GCGoodbyeReason::GCGoodbyeReason_NO_SESSION => 1,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for GCGoodbyeReason {
    fn default() -> Self {
        GCGoodbyeReason::GCGoodbyeReason_GC_GOING_DOWN
    }
}

impl GCGoodbyeReason {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<GCGoodbyeReason>("GCGoodbyeReason")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x15base_gcmessages.proto\x1a\x13steammessages.proto\"\xb5\x01\n\x1dCG\
    CStorePurchaseInit_LineItem\x12\x1e\n\x0bitem_def_id\x18\x01\x20\x01(\rR\
    \titemDefId\x12\x1a\n\x08quantity\x18\x02\x20\x01(\rR\x08quantity\x123\n\
    \x16cost_in_local_currency\x18\x03\x20\x01(\rR\x13costInLocalCurrency\
    \x12#\n\rpurchase_type\x18\x04\x20\x01(\rR\x0cpurchaseType\"\xaa\x01\n\
    \x17CMsgGCStorePurchaseInit\x12\x18\n\x07country\x18\x01\x20\x01(\tR\x07\
    country\x12\x1a\n\x08language\x18\x02\x20\x01(\x05R\x08language\x12\x1a\
    \n\x08currency\x18\x03\x20\x01(\x05R\x08currency\x12=\n\nline_items\x18\
    \x04\x20\x03(\x0b2\x1e.CGCStorePurchaseInit_LineItemR\tlineItems\"P\n\
    \x1fCMsgGCStorePurchaseInitResponse\x12\x16\n\x06result\x18\x01\x20\x01(\
    \x05R\x06result\x12\x15\n\x06txn_id\x18\x02\x20\x01(\x04R\x05txnId\"/\n\
    \x13CMsgSystemBroadcast\x12\x18\n\x07message\x18\x01\x20\x01(\tR\x07mess\
    age\"+\n\x0fCMsgClientHello\x12\x18\n\x07version\x18\x01\x20\x01(\rR\x07\
    version\"+\n\x0fCMsgServerHello\x12\x18\n\x07version\x18\x01\x20\x01(\rR\
    \x07version\"t\n\x11CMsgClientWelcome\x12\x18\n\x07version\x18\x01\x20\
    \x01(\rR\x07version\x12\x1b\n\tgame_data\x18\x02\x20\x01(\x0cR\x08gameDa\
    ta\x12(\n\x10txn_country_code\x18\x03\x20\x01(\tR\x0etxnCountryCode\"j\n\
    \x11CMsgServerWelcome\x12.\n\x13min_allowed_version\x18\x01\x20\x01(\rR\
    \x11minAllowedVersion\x12%\n\x0eactive_version\x18\x02\x20\x01(\rR\racti\
    veVersion\"\\\n\x11CMsgClientGoodbye\x12G\n\x06reason\x18\x01\x20\x01(\
    \x0e2\x10.GCGoodbyeReason:\x1dGCGoodbyeReason_GC_GOING_DOWNR\x06reason\"\
    \\\n\x11CMsgServerGoodbye\x12G\n\x06reason\x18\x01\x20\x01(\x0e2\x10.GCG\
    oodbyeReason:\x1dGCGoodbyeReason_GC_GOING_DOWNR\x06reason\"\x15\n\x13CMs\
    gServerAvailable\"3\n\x16CMsgLANServerAvailable\x12\x19\n\x08lobby_id\
    \x18\x01\x20\x01(\x06R\x07lobbyId\"\xff\x0c\n\x18CSOEconGameAccountClien\
    t\x12=\n\x19additional_backpack_slots\x18\x01\x20\x01(\r:\x010R\x17addit\
    ionalBackpackSlots\x12*\n\rtrial_account\x18\x02\x20\x01(\x08:\x05falseR\
    \x0ctrialAccount\x12I\n\"need_to_choose_most_helpful_friend\x18\x04\x20\
    \x01(\x08R\x1dneedToChooseMostHelpfulFriend\x12&\n\x0fin_coaches_list\
    \x18\x05\x20\x01(\x08R\rinCoachesList\x120\n\x14trade_ban_expiration\x18\
    \x06\x20\x01(\x07R\x12tradeBanExpiration\x12.\n\x13duel_ban_expiration\
    \x18\x07\x20\x01(\x07R\x11duelBanExpiration\x12+\n\x10preview_item_def\
    \x18\x08\x20\x01(\r:\x010R\x0epreviewItemDef\x12,\n\x0ephone_verified\
    \x18\x13\x20\x01(\x08:\x05falseR\rphoneVerified\x12(\n\x10skill_rating_6\
    v6\x18\x14\x20\x01(\rR\x0eskillRating6v6\x12(\n\x10skill_rating_9v9\x18\
    \x15\x20\x01(\rR\x0eskillRating9v9\x124\n\x12competitive_access\x18\x17\
    \x20\x01(\x08:\x05falseR\x11competitiveAccess\x12I\n!matchmaking_ranked_\
    ban_expiration\x18\x12\x20\x01(\rR\x1ematchmakingRankedBanExpiration\x12\
    Z\n*matchmaking_ranked_low_priority_expiration\x18\x18\x20\x01(\rR&match\
    makingRankedLowPriorityExpiration\x12N\n$matchmaking_ranked_ban_last_dur\
    ation\x18\x19\x20\x01(\rR\x20matchmakingRankedBanLastDuration\x12_\n-mat\
    chmaking_ranked_low_priority_last_duration\x18\x1a\x20\x01(\rR(matchmaki\
    ngRankedLowPriorityLastDuration\x12I\n!matchmaking_casual_ban_expiration\
    \x18\x1b\x20\x01(\rR\x1ematchmakingCasualBanExpiration\x12Z\n*matchmakin\
    g_casual_low_priority_expiration\x18\x1c\x20\x01(\rR&matchmakingCasualLo\
    wPriorityExpiration\x12N\n$matchmaking_casual_ban_last_duration\x18\x1d\
    \x20\x01(\rR\x20matchmakingCasualBanLastDuration\x12_\n-matchmaking_casu\
    al_low_priority_last_duration\x18\x1e\x20\x01(\rR(matchmakingCasualLowPr\
    iorityLastDuration\x122\n\x11phone_identifying\x18\x1f\x20\x01(\x08:\x05\
    falseR\x10phoneIdentifying\x12F\n\x1cdisable_party_quest_progress\x18\
    \x20\x20\x01(\x08:\x05falseR\x19disablePartyQuestProgress\x120\n\x14ques\
    t_reward_credits\x18!\x20\x01(\rR\x12questRewardCredits\x12q\n7matchmaki\
    ng_last_casual_excessive_reports_auto_ban_time\x18\"\x20\x01(\rR0matchma\
    kingLastCasualExcessiveReportsAutoBanTime\x12m\n5matchmaking_last_comp_e\
    xcessive_reports_auto_ban_time\x18#\x20\x01(\rR.matchmakingLastCompExces\
    siveReportsAutoBanTime\"\xa0\x01\n\x18CSOItemCriteriaCondition\x12\x0e\n\
    \x02op\x18\x01\x20\x01(\x05R\x02op\x12\x14\n\x05field\x18\x02\x20\x01(\t\
    R\x05field\x12\x1a\n\x08required\x18\x03\x20\x01(\x08R\x08required\x12\
    \x1f\n\x0bfloat_value\x18\x04\x20\x01(\x02R\nfloatValue\x12!\n\x0cstring\
    _value\x18\x05\x20\x01(\tR\x0bstringValue\"\xc0\x03\n\x0fCSOItemCriteria\
    \x12\x1d\n\nitem_level\x18\x01\x20\x01(\rR\titemLevel\x12!\n\x0citem_qua\
    lity\x18\x02\x20\x01(\x05R\x0bitemQuality\x12$\n\x0eitem_level_set\x18\
    \x03\x20\x01(\x08R\x0citemLevelSet\x12(\n\x10item_quality_set\x18\x04\
    \x20\x01(\x08R\x0eitemQualitySet\x12+\n\x11initial_inventory\x18\x05\x20\
    \x01(\rR\x10initialInventory\x12)\n\x10initial_quantity\x18\x06\x20\x01(\
    \rR\x0finitialQuantity\x12.\n\x13ignore_enabled_flag\x18\x08\x20\x01(\
    \x08R\x11ignoreEnabledFlag\x129\n\nconditions\x18\t\x20\x03(\x0b2\x19.CS\
    OItemCriteriaConditionR\nconditions\x12\x1f\n\x0brecent_only\x18\n\x20\
    \x01(\x08R\nrecentOnly\x12\x12\n\x04tags\x18\x0b\x20\x01(\tR\x04tags\x12\
    #\n\requip_regions\x18\x0c\x20\x01(\tR\x0cequipRegions\"\xc0\x05\n\rCSOI\
    temRecipe\x12\x1b\n\tdef_index\x18\x01\x20\x01(\rR\x08defIndex\x12\x12\n\
    \x04name\x18\x02\x20\x01(\tR\x04name\x12\x0f\n\x03n_a\x18\x03\x20\x01(\t\
    R\x02nA\x12\x1f\n\x0bdesc_inputs\x18\x04\x20\x01(\tR\ndescInputs\x12!\n\
    \x0cdesc_outputs\x18\x05\x20\x01(\tR\x0bdescOutputs\x12\x11\n\x04di_a\
    \x18\x06\x20\x01(\tR\x03diA\x12\x11\n\x04di_b\x18\x07\x20\x01(\tR\x03diB\
    \x12\x11\n\x04di_c\x18\x08\x20\x01(\tR\x03diC\x12\x11\n\x04do_a\x18\t\
    \x20\x01(\tR\x03doA\x12\x11\n\x04do_b\x18\n\x20\x01(\tR\x03doB\x12\x11\n\
    \x04do_c\x18\x0b\x20\x01(\tR\x03doC\x125\n\x17requires_all_same_class\
    \x18\x0c\x20\x01(\x08R\x14requiresAllSameClass\x123\n\x16requires_all_sa\
    me_slot\x18\r\x20\x01(\x08R\x13requiresAllSameSlot\x123\n\x16class_usage\
    _for_output\x18\x0e\x20\x01(\x05R\x13classUsageForOutput\x121\n\x15slot_\
    usage_for_output\x18\x0f\x20\x01(\x05R\x12slotUsageForOutput\x12$\n\x0es\
    et_for_output\x18\x10\x20\x01(\x05R\x0csetForOutput\x12B\n\x14input_item\
    s_criteria\x18\x14\x20\x03(\x0b2\x10.CSOItemCriteriaR\x12inputItemsCrite\
    ria\x12D\n\x15output_items_criteria\x18\x15\x20\x03(\x0b2\x10.CSOItemCri\
    teriaR\x13outputItemsCriteria\x123\n\x16input_item_dupe_counts\x18\x16\
    \x20\x03(\rR\x13inputItemDupeCounts\"a\n\x15CMsgDevNewItemRequest\x12\
    \x1a\n\x08receiver\x18\x01\x20\x01(\x06R\x08receiver\x12,\n\x08criteria\
    \x18\x02\x20\x01(\x0b2\x10.CSOItemCriteriaR\x08criteria\"_\n\x1bCMsgDevD\
    ebugRollLootRequest\x12\x1a\n\x08receiver\x18\x01\x20\x01(\x06R\x08recei\
    ver\x12$\n\x0eloot_list_name\x18\x02\x20\x01(\tR\x0clootListName\"\xd2\
    \x01\n\x1fCMsgIncrementKillCountAttribute\x12&\n\x0fkiller_steam_id\x18\
    \x01\x20\x01(\x04R\rkillerSteamId\x12&\n\x0fvictim_steam_id\x18\x02\x20\
    \x01(\x04R\rvictimSteamId\x12\x17\n\x07item_id\x18\x03\x20\x01(\x04R\x06\
    itemId\x12\x1d\n\nevent_type\x18\x04\x20\x01(\rR\teventType\x12'\n\x0fin\
    crement_value\x18\x05\x20\x01(\rR\x0eincrementValue\"`\n(CMsgIncrementKi\
    llCountAttribute_Multiple\x124\n\x04msgs\x18\x01\x20\x03(\x0b2\x20.CMsgI\
    ncrementKillCountAttributeR\x04msgs\"\xa8\x01\n\x1eCMsgTrackUniquePlayer\
    PairEvent\x12&\n\x0fkiller_steam_id\x18\x01\x20\x01(\x04R\rkillerSteamId\
    \x12&\n\x0fvictim_steam_id\x18\x02\x20\x01(\x04R\rvictimSteamId\x12\x17\
    \n\x07item_id\x18\x03\x20\x01(\x04R\x06itemId\x12\x1d\n\nevent_type\x18\
    \x04\x20\x01(\rR\teventType\"\x95\x01\n\x1dCMsgApplyStrangeCountTransfer\
    \x12\x20\n\x0ctool_item_id\x18\x01\x20\x01(\x04R\ntoolItemId\x12'\n\x10i\
    tem_src_item_id\x18\x02\x20\x01(\x04R\ritemSrcItemId\x12)\n\x11item_dest\
    _item_id\x18\x03\x20\x01(\x04R\x0eitemDestItemId\"i\n\x14CMsgApplyStrang\
    ePart\x12/\n\x14strange_part_item_id\x18\x01\x20\x01(\x04R\x11strangePar\
    tItemId\x12\x20\n\x0citem_item_id\x18\x02\x20\x01(\x04R\nitemItemId\"\
    \x9e\x01\n\x1bCMsgApplyStrangeRestriction\x12/\n\x14strange_part_item_id\
    \x18\x01\x20\x01(\x04R\x11strangePartItemId\x12\x20\n\x0citem_item_id\
    \x18\x02\x20\x01(\x04R\nitemItemId\x12,\n\x12strange_attr_index\x18\x03\
    \x20\x01(\rR\x10strangeAttrIndex\"o\n\x14CMsgApplyUpgradeCard\x12/\n\x14\
    upgrade_card_item_id\x18\x01\x20\x01(\x04R\x11upgradeCardItemId\x12&\n\
    \x0fsubject_item_id\x18\x02\x20\x01(\x04R\rsubjectItemId\"j\n\x14CSOEcon\
    ItemAttribute\x12\x1b\n\tdef_index\x18\x01\x20\x01(\rR\x08defIndex\x12\
    \x14\n\x05value\x18\x02\x20\x01(\rR\x05value\x12\x1f\n\x0bvalue_bytes\
    \x18\x03\x20\x01(\x0cR\nvalueBytes\"M\n\x13CSOEconItemEquipped\x12\x1b\n\
    \tnew_class\x18\x01\x20\x01(\rR\x08newClass\x12\x19\n\x08new_slot\x18\
    \x02\x20\x01(\rR\x07newSlot\"\xab\x05\n\x0bCSOEconItem\x12\x0e\n\x02id\
    \x18\x01\x20\x01(\x04R\x02id\x12\x1d\n\naccount_id\x18\x02\x20\x01(\rR\t\
    accountId\x12\x1c\n\tinventory\x18\x03\x20\x01(\rR\tinventory\x12\x1b\n\
    \tdef_index\x18\x04\x20\x01(\rR\x08defIndex\x12\x1a\n\x08quantity\x18\
    \x05\x20\x01(\rR\x08quantity\x12\x14\n\x05level\x18\x06\x20\x01(\rR\x05l\
    evel\x12\x18\n\x07quality\x18\x07\x20\x01(\rR\x07quality\x12\x17\n\x05fl\
    ags\x18\x08\x20\x01(\r:\x010R\x05flags\x12\x16\n\x06origin\x18\t\x20\x01\
    (\rR\x06origin\x12\x1f\n\x0bcustom_name\x18\n\x20\x01(\tR\ncustomName\
    \x12\x1f\n\x0bcustom_desc\x18\x0b\x20\x01(\tR\ncustomDesc\x123\n\tattrib\
    ute\x18\x0c\x20\x03(\x0b2\x15.CSOEconItemAttributeR\tattribute\x121\n\ri\
    nterior_item\x18\r\x20\x01(\x0b2\x0c.CSOEconItemR\x0cinteriorItem\x12\
    \x1c\n\x06in_use\x18\x0e\x20\x01(\x08:\x05falseR\x05inUse\x12\x17\n\x05s\
    tyle\x18\x0f\x20\x01(\r:\x010R\x05style\x12\"\n\x0boriginal_id\x18\x10\
    \x20\x01(\x04:\x010R\noriginalId\x126\n\x17contains_equipped_state\x18\
    \x11\x20\x01(\x08R\x15containsEquippedState\x12;\n\x0eequipped_state\x18\
    \x12\x20\x03(\x0b2\x14.CSOEconItemEquippedR\requippedState\x12;\n\x1acon\
    tains_equipped_state_v2\x18\x13\x20\x01(\x08R\x17containsEquippedStateV2\
    \"n\n\x1bCMsgAdjustItemEquippedState\x12\x17\n\x07item_id\x18\x01\x20\
    \x01(\x04R\x06itemId\x12\x1b\n\tnew_class\x18\x02\x20\x01(\rR\x08newClas\
    s\x12\x19\n\x08new_slot\x18\x03\x20\x01(\rR\x07newSlot\",\n\rCMsgSortIte\
    ms\x12\x1b\n\tsort_type\x18\x01\x20\x01(\rR\x08sortType\"\x87\x01\n\x10C\
    SOEconClaimCode\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\x12\
    \x1b\n\tcode_type\x18\x02\x20\x01(\rR\x08codeType\x12#\n\rtime_acquired\
    \x18\x03\x20\x01(\rR\x0ctimeAcquired\x12\x12\n\x04code\x18\x04\x20\x01(\
    \tR\x04code\"F\n\x14CMsgStoreGetUserData\x12.\n\x13price_sheet_version\
    \x18\x01\x20\x01(\x07R\x11priceSheetVersion\"\xa3\x03\n\x1cCMsgStoreGetU\
    serDataResponse\x12\x16\n\x06result\x18\x01\x20\x01(\x05R\x06result\x12\
    \x1a\n\x08currency\x18\x02\x20\x01(\x05R\x08currency\x12\x18\n\x07countr\
    y\x18\x03\x20\x01(\tR\x07country\x12.\n\x13price_sheet_version\x18\x04\
    \x20\x01(\x07R\x11priceSheetVersion\x12*\n\x0fexperiment_data\x18\x05\
    \x20\x01(\x04:\x010R\x0eexperimentData\x12*\n\x11featured_item_idx\x18\
    \x06\x20\x01(\x05R\x0ffeaturedItemIdx\x128\n\x15show_hat_descriptions\
    \x18\x07\x20\x01(\x08:\x04trueR\x13showHatDescriptions\x12\x1f\n\x0bpric\
    e_sheet\x18\x08\x20\x01(\x0cR\npriceSheet\x12-\n\x11default_item_sort\
    \x18\t\x20\x01(\x05:\x010R\x0fdefaultItemSort\x12#\n\rpopular_items\x18\
    \n\x20\x03(\rR\x0cpopularItems\"\xa9\x01\n\x14CMsgUpdateItemSchema\x12\
    \x1d\n\nitems_game\x18\x01\x20\x01(\x0cR\titemsGame\x12.\n\x13item_schem\
    a_version\x18\x02\x20\x01(\x07R\x11itemSchemaVersion\x12$\n\x0eitems_gam\
    e_url\x18\x03\x20\x01(\tR\x0citemsGameUrl\x12\x1c\n\tsignature\x18\x04\
    \x20\x01(\x0cR\tsignature\",\n\x0bCMsgGCError\x12\x1d\n\nerror_text\x18\
    \x01\x20\x01(\tR\terrorText\"\x1d\n\x1bCMsgRequestInventoryRefresh\";\n\
    \x0fCMsgConVarValue\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\
    \x14\n\x05value\x18\x02\x20\x01(\tR\x05value\"B\n\x14CMsgReplicateConVar\
    s\x12*\n\x07convars\x18\x01\x20\x03(\x0b2\x10.CMsgConVarValueR\x07convar\
    s\"\x97\x02\n\x0bCMsgUseItem\x12\x17\n\x07item_id\x18\x01\x20\x01(\x04R\
    \x06itemId\x12&\n\x0ftarget_steam_id\x18\x02\x20\x01(\x06R\rtargetSteamI\
    d\x125\n\x17gift__potential_targets\x18\x03\x20\x03(\rR\x14giftPotential\
    Targets\x12'\n\x10duel__class_lock\x18\x04\x20\x01(\rR\rduelClassLock\
    \x12,\n\x12initiator_steam_id\x18\x05\x20\x01(\x06R\x10initiatorSteamId\
    \x129\n\x19itempack__ack_immediately\x18\x06\x20\x01(\x08R\x16itempackAc\
    kImmediately\"\x8f\x01\n\x1bCMsgReplayUploadedToYouTube\x12\x1f\n\x0byou\
    tube_url\x18\x01\x20\x01(\tR\nyoutubeUrl\x120\n\x14youtube_account_name\
    \x18\x02\x20\x01(\tR\x12youtubeAccountName\x12\x1d\n\nsession_id\x18\x03\
    \x20\x01(\x04R\tsessionId\"9\n\x17CMsgConsumableExhausted\x12\x1e\n\x0bi\
    tem_def_id\x18\x01\x20\x01(\x05R\titemDefId\"\x8c\x02\n\x14CMsgItemAckno\
    wledged\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\x12\x1c\n\t\
    inventory\x18\x02\x20\x01(\rR\tinventory\x12\x1b\n\tdef_index\x18\x03\
    \x20\x01(\rR\x08defIndex\x12\x18\n\x07quality\x18\x04\x20\x01(\rR\x07qua\
    lity\x12\x16\n\x06rarity\x18\x05\x20\x01(\rR\x06rarity\x12\x16\n\x06orig\
    in\x18\x06\x20\x01(\rR\x06origin\x12\x1d\n\nis_strange\x18\x07\x20\x01(\
    \rR\tisStrange\x12\x1d\n\nis_unusual\x18\x08\x20\x01(\rR\tisUnusual\x12\
    \x12\n\x04wear\x18\t\x20\x01(\x02R\x04wear\"\x85\x01\n\x19CMsgSetPresetI\
    temPosition\x12\x19\n\x08class_id\x18\x01\x20\x01(\rR\x07classId\x12\x1b\
    \n\tpreset_id\x18\x02\x20\x01(\rR\x08presetId\x12\x17\n\x07slot_id\x18\
    \x03\x20\x01(\rR\x06slotId\x12\x17\n\x07item_id\x18\x04\x20\x01(\x04R\
    \x06itemId\"\xa6\x01\n\x14CMsgSetItemPositions\x12I\n\x0eitem_positions\
    \x18\x01\x20\x03(\x0b2\".CMsgSetItemPositions.ItemPositionR\ritemPositio\
    ns\x1aC\n\x0cItemPosition\x12\x17\n\x07item_id\x18\x01\x20\x01(\x04R\x06\
    itemId\x12\x1a\n\x08position\x18\x02\x20\x01(\rR\x08position\"\x97\x01\n\
    \x19CSOEconItemPresetInstance\x12\x1f\n\x08class_id\x18\x02\x20\x01(\rR\
    \x07classIdB\x04\x80\xa6\x1d\x01\x12!\n\tpreset_id\x18\x03\x20\x01(\rR\
    \x08presetIdB\x04\x80\xa6\x1d\x01\x12\x1d\n\x07slot_id\x18\x04\x20\x01(\
    \rR\x06slotIdB\x04\x80\xa6\x1d\x01\x12\x17\n\x07item_id\x18\x05\x20\x01(\
    \x04R\x06itemId\"R\n\x18CMsgSelectPresetForClass\x12\x19\n\x08class_id\
    \x18\x01\x20\x01(\rR\x07classId\x12\x1b\n\tpreset_id\x18\x02\x20\x01(\rR\
    \x08presetId\"~\n\x18CSOClassPresetClientData\x12\x1d\n\naccount_id\x18\
    \x01\x20\x01(\rR\taccountId\x12\x19\n\x08class_id\x18\x02\x20\x01(\rR\
    \x07classId\x12(\n\x10active_preset_id\x18\x03\x20\x01(\rR\x0eactivePres\
    etId\"\x9b\x02\n\x11CMsgGCReportAbuse\x12&\n\x0ftarget_steam_id\x18\x01\
    \x20\x01(\x06R\rtargetSteamId\x12\x20\n\x0bdescription\x18\x04\x20\x01(\
    \tR\x0bdescription\x12\x10\n\x03gid\x18\x05\x20\x01(\x04R\x03gid\x12\x1d\
    \n\nabuse_type\x18\x02\x20\x01(\rR\tabuseType\x12!\n\x0ccontent_type\x18\
    \x03\x20\x01(\rR\x0bcontentType\x121\n\x15target_game_server_ip\x18\x06\
    \x20\x01(\x07R\x12targetGameServerIp\x125\n\x17target_game_server_port\
    \x18\x07\x20\x01(\rR\x14targetGameServerPort\"\x80\x01\n\x19CMsgGCReport\
    AbuseResponse\x12&\n\x0ftarget_steam_id\x18\x01\x20\x01(\x06R\rtargetSte\
    amId\x12\x16\n\x06result\x18\x02\x20\x01(\rR\x06result\x12#\n\rerror_mes\
    sage\x18\x03\x20\x01(\tR\x0cerrorMessage\"\x93\x01\n\x1aCMsgGCNameItemNo\
    tification\x12%\n\x0eplayer_steamid\x18\x01\x20\x01(\x06R\rplayerSteamid\
    \x12$\n\x0eitem_def_index\x18\x02\x20\x01(\rR\x0citemDefIndex\x12(\n\x10\
    item_name_custom\x18\x03\x20\x01(\tR\x0eitemNameCustom\"\xa1\x02\n\x1fCM\
    sgGCClientDisplayNotification\x12M\n#notification_title_localization_key\
    \x18\x01\x20\x01(\tR\x20notificationTitleLocalizationKey\x12K\n\"notific\
    ation_body_localization_key\x18\x02\x20\x01(\tR\x1fnotificationBodyLocal\
    izationKey\x12.\n\x13body_substring_keys\x18\x03\x20\x03(\tR\x11bodySubs\
    tringKeys\x122\n\x15body_substring_values\x18\x04\x20\x03(\tR\x13bodySub\
    stringValues\"@\n\x17CMsgGCShowItemsPickedUp\x12%\n\x0eplayer_steamid\
    \x18\x01\x20\x01(\x06R\rplayerSteamid\"o\n\x17CMsgUpdatePeriodicEvent\
    \x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\x12\x1d\n\nevent_t\
    ype\x18\x02\x20\x01(\rR\teventType\x12\x16\n\x06amount\x18\x03\x20\x01(\
    \rR\x06amount\"\xab\x01\n\x20CMsgGCIncrementKillCountResponse\x120\n\x11\
    killer_account_id\x18\x01\x20\x01(\rR\x0fkillerAccountIdB\x04\x80\xa6\
    \x1d\x01\x12\x1b\n\tnum_kills\x18\x02\x20\x01(\rR\x08numKills\x12\x19\n\
    \x08item_def\x18\x03\x20\x01(\rR\x07itemDef\x12\x1d\n\nlevel_type\x18\
    \x04\x20\x01(\rR\tlevelType\"i\n\x17CMsgGCRemoveStrangePart\x12\x17\n\
    \x07item_id\x18\x01\x20\x01(\x04R\x06itemId\x125\n\x17strange_part_score\
    _type\x18\x02\x20\x01(\rR\x14strangePartScoreType\"[\n\x17CMsgGCRemoveUp\
    gradeCard\x12\x17\n\x07item_id\x18\x01\x20\x01(\x04R\x06itemId\x12'\n\
    \x0fattribute_index\x18\x02\x20\x01(\rR\x0eattributeIndex\"C\n(CMsgGCRem\
    oveCustomizationAttributeSimple\x12\x17\n\x07item_id\x18\x01\x20\x01(\
    \x04R\x06itemId\"3\n\x18CMsgGCResetStrangeScores\x12\x17\n\x07item_id\
    \x18\x01\x20\x01(\x04R\x06itemId\"O\n'CMsgGCItemPreviewItemBoughtNotific\
    ation\x12$\n\x0eitem_def_index\x18\x01\x20\x01(\rR\x0citemDefIndex\"2\n\
    \x19CMsgGCStorePurchaseCancel\x12\x15\n\x06txn_id\x18\x01\x20\x01(\x04R\
    \x05txnId\";\n!CMsgGCStorePurchaseCancelResponse\x12\x16\n\x06result\x18\
    \x01\x20\x01(\rR\x06result\"4\n\x1bCMsgGCStorePurchaseFinalize\x12\x15\n\
    \x06txn_id\x18\x01\x20\x01(\x04R\x05txnId\"X\n#CMsgGCStorePurchaseFinali\
    zeResponse\x12\x16\n\x06result\x18\x01\x20\x01(\rR\x06result\x12\x19\n\
    \x08item_ids\x18\x02\x20\x03(\x04R\x07itemIds\"a\n\x1bCMsgGCBannedWordLi\
    stRequest\x12)\n\x11ban_list_group_id\x18\x01\x20\x01(\rR\x0ebanListGrou\
    pId\x12\x17\n\x07word_id\x18\x02\x20\x01(\rR\x06wordId\"\x9b\x01\n\x11CM\
    sgGCGiftedItems\x12&\n\x0fgifter_steam_id\x18\x01\x20\x01(\x04R\rgifterS\
    teamId\x12*\n\x11was_random_person\x18\x02\x20\x01(\x08R\x0fwasRandomPer\
    son\x122\n\x15recipient_account_ids\x18\x03\x20\x03(\rR\x13recipientAcco\
    untIds\"i\n\x11CMsgGCCollectItem\x12,\n\x12collection_item_id\x18\x01\
    \x20\x01(\x04R\x10collectionItemId\x12&\n\x0fsubject_item_id\x18\x02\x20\
    \x01(\x04R\rsubjectItemId\"D\n\x1dCMsgGCClientMarketDataRequest\x12#\n\r\
    user_currency\x18\x01\x20\x01(\rR\x0cuserCurrency\"\xcb\x01\n\x1bCMsgGCC\
    lientMarketDataEntry\x12$\n\x0eitem_def_index\x18\x01\x20\x01(\rR\x0cite\
    mDefIndex\x12!\n\x0citem_quality\x18\x02\x20\x01(\rR\x0bitemQuality\x12,\
    \n\x12item_sell_listings\x18\x03\x20\x01(\rR\x10itemSellListings\x125\n\
    \x17price_in_local_currency\x18\x04\x20\x01(\rR\x14priceInLocalCurrency\
    \"P\n\x16CMsgGCClientMarketData\x126\n\x07entries\x18\x01\x20\x03(\x0b2\
    \x1c.CMsgGCClientMarketDataEntryR\x07entries\"_\n\x13CMsgApplyToolToItem\
    \x12\x20\n\x0ctool_item_id\x18\x01\x20\x01(\x04R\ntoolItemId\x12&\n\x0fs\
    ubject_item_id\x18\x02\x20\x01(\x04R\rsubjectItemId\"i\n\x17CMsgApplyToo\
    lToBaseItem\x12\x20\n\x0ctool_item_id\x18\x01\x20\x01(\x04R\ntoolItemId\
    \x12,\n\x12baseitem_def_index\x18\x02\x20\x01(\rR\x10baseitemDefIndex\"f\
    \n\x13CMsgRecipeComponent\x12&\n\x0fsubject_item_id\x18\x01\x20\x01(\x04\
    R\rsubjectItemId\x12'\n\x0fattribute_index\x18\x02\x20\x01(\x04R\x0eattr\
    ibuteIndex\"\x92\x01\n!CMsgFulfillDynamicRecipeComponent\x12\x20\n\x0cto\
    ol_item_id\x18\x01\x20\x01(\x04R\ntoolItemId\x12K\n\x16consumption_compo\
    nents\x18\x02\x20\x03(\x0b2\x14.CMsgRecipeComponentR\x15consumptionCompo\
    nents\"R\n\x1fCMsgSetItemEffectVerticalOffset\x12\x17\n\x07item_id\x18\
    \x01\x20\x01(\x04R\x06itemId\x12\x16\n\x06offset\x18\x02\x20\x01(\x02R\
    \x06offset\"S\n\x1dCMsgSetHatEffectUseHeadOrigin\x12\x17\n\x07item_id\
    \x18\x01\x20\x01(\x04R\x06itemId\x12\x19\n\x08use_head\x18\x02\x20\x01(\
    \x08R\x07useHead\"w\n\x1cCMsgDeliverGiftResponseGiver\x12#\n\rresponse_c\
    ode\x18\x01\x20\x01(\rR\x0cresponseCode\x122\n\x15receiver_account_name\
    \x18\x02\x20\x01(\tR\x13receiverAccountName\"j\n\x20CSOEconGameAccountFo\
    rGameServers\x12F\n\x1cdisable_party_quest_progress\x18\x06\x20\x01(\x08\
    :\x05falseR\x19disablePartyQuestProgress\"\xb4\x03\n*CWorkshop_PopulateI\
    temDescriptions_Request\x12\x14\n\x05appid\x18\x01\x20\x01(\rR\x05appid\
    \x12g\n\tlanguages\x18\x02\x20\x03(\x0b2I.CWorkshop_PopulateItemDescript\
    ions_Request.ItemDescriptionsLanguageBlockR\tlanguages\x1ab\n\x15SingleI\
    temDescription\x12\x1e\n\ngameitemid\x18\x01\x20\x01(\rR\ngameitemid\x12\
    )\n\x10item_description\x18\x02\x20\x01(\tR\x0fitemDescription\x1a\xa2\
    \x01\n\x1dItemDescriptionsLanguageBlock\x12\x1a\n\x08language\x18\x01\
    \x20\x01(\tR\x08language\x12e\n\x0cdescriptions\x18\x02\x20\x03(\x0b2A.C\
    Workshop_PopulateItemDescriptions_Request.SingleItemDescriptionR\x0cdesc\
    riptions\"Y\n!CWorkshop_GetContributors_Request\x12\x14\n\x05appid\x18\
    \x01\x20\x01(\rR\x05appid\x12\x1e\n\ngameitemid\x18\x02\x20\x01(\rR\ngam\
    eitemid\"H\n\"CWorkshop_GetContributors_Response\x12\"\n\x0ccontributors\
    \x18\x01\x20\x03(\x06R\x0ccontributors\"\xf7\x04\n%CWorkshop_SetItemPaym\
    entRules_Request\x12\x14\n\x05appid\x18\x01\x20\x01(\rR\x05appid\x12\x1e\
    \n\ngameitemid\x18\x02\x20\x01(\rR\ngameitemid\x12z\n\x19associated_work\
    shop_files\x18\x03\x20\x03(\x0b2>.CWorkshop_SetItemPaymentRules_Request.\
    WorkshopItemPaymentRuleR\x17associatedWorkshopFiles\x12h\n\x10partner_ac\
    counts\x18\x04\x20\x03(\x0b2=.CWorkshop_SetItemPaymentRules_Request.Part\
    nerItemPaymentRuleR\x0fpartnerAccounts\x1a\x9d\x01\n\x17WorkshopItemPaym\
    entRule\x12(\n\x10workshop_file_id\x18\x01\x20\x01(\x04R\x0eworkshopFile\
    Id\x12-\n\x12revenue_percentage\x18\x02\x20\x01(\x02R\x11revenuePercenta\
    ge\x12)\n\x10rule_description\x18\x03\x20\x01(\tR\x0fruleDescription\x1a\
    \x91\x01\n\x16PartnerItemPaymentRule\x12\x1d\n\naccount_id\x18\x01\x20\
    \x01(\rR\taccountId\x12-\n\x12revenue_percentage\x18\x02\x20\x01(\x02R\
    \x11revenuePercentage\x12)\n\x10rule_description\x18\x03\x20\x01(\tR\x0f\
    ruleDescription\"(\n&CWorkshop_SetItemPaymentRules_Response*\x9e\x02\n\n\
    EGCBaseMsg\x12\x1a\n\x15k_EMsgGCSystemMessage\x10\xa1\x1f\x12\x1d\n\x18k\
    _EMsgGCReplicateConVars\x10\xa2\x1f\x12\x1a\n\x15k_EMsgGCConVarUpdated\
    \x10\xa3\x1f\x12\x1c\n\x17k_EMsgGCServerAvailable\x10\x9a#\x12\"\n\x1dk_\
    EMsgGCClientConnectToServer\x10\x9b#\x12\x1b\n\x16k_EMsgGCGameServerInfo\
    \x10\x9c#\x12\x12\n\rk_EMsgGCError\x10\x9d#\x12%\n\x20k_EMsgGCReplay_Upl\
    oadedToYouTube\x10\x9e#\x12\x1f\n\x1ak_EMsgGCLANServerAvailable\x10\x9f#\
    *Y\n\x17EGCBaseProtoObjectTypes\x12\x1e\n\x19k_EProtoObjectPartyInvite\
    \x10\xe9\x07\x12\x1e\n\x19k_EProtoObjectLobbyInvite\x10\xea\x07*T\n\x0fG\
    CGoodbyeReason\x12!\n\x1dGCGoodbyeReason_GC_GOING_DOWN\x10\x01\x12\x1e\n\
    \x1aGCGoodbyeReason_NO_SESSION\x10\x02B\x05H\x01\x80\x01\0J\xaa\xb9\x01\
    \n\x07\x12\x05\0\0\xb0\x04\x01\n\t\n\x02\x03\0\x12\x03\0\x07\x1c\n\x08\n\
    \x01\x08\x12\x03\x02\0\x1c\n\t\n\x02\x08\t\x12\x03\x02\0\x1c\n\x08\n\x01\
    \x08\x12\x03\x03\0#\n\t\n\x02\x08\x10\x12\x03\x03\0#\n\n\n\x02\x05\0\x12\
    \x04\x05\0\x0f\x01\n\n\n\x03\x05\0\x01\x12\x03\x05\x05\x0f\n\x0b\n\x04\
    \x05\0\x02\0\x12\x03\x06\x08%\n\x0c\n\x05\x05\0\x02\0\x01\x12\x03\x06\
    \x08\x1d\n\x0c\n\x05\x05\0\x02\0\x02\x12\x03\x06\x20$\n\x0b\n\x04\x05\0\
    \x02\x01\x12\x03\x07\x08(\n\x0c\n\x05\x05\0\x02\x01\x01\x12\x03\x07\x08\
    \x20\n\x0c\n\x05\x05\0\x02\x01\x02\x12\x03\x07#'\n\x0b\n\x04\x05\0\x02\
    \x02\x12\x03\x08\x08%\n\x0c\n\x05\x05\0\x02\x02\x01\x12\x03\x08\x08\x1d\
    \n\x0c\n\x05\x05\0\x02\x02\x02\x12\x03\x08\x20$\n\x0b\n\x04\x05\0\x02\
    \x03\x12\x03\t\x08'\n\x0c\n\x05\x05\0\x02\x03\x01\x12\x03\t\x08\x1f\n\
    \x0c\n\x05\x05\0\x02\x03\x02\x12\x03\t\"&\n\x0b\n\x04\x05\0\x02\x04\x12\
    \x03\n\x08-\n\x0c\n\x05\x05\0\x02\x04\x01\x12\x03\n\x08%\n\x0c\n\x05\x05\
    \0\x02\x04\x02\x12\x03\n(,\n\x0b\n\x04\x05\0\x02\x05\x12\x03\x0b\x08&\n\
    \x0c\n\x05\x05\0\x02\x05\x01\x12\x03\x0b\x08\x1e\n\x0c\n\x05\x05\0\x02\
    \x05\x02\x12\x03\x0b!%\n\x0b\n\x04\x05\0\x02\x06\x12\x03\x0c\x08\x1d\n\
    \x0c\n\x05\x05\0\x02\x06\x01\x12\x03\x0c\x08\x15\n\x0c\n\x05\x05\0\x02\
    \x06\x02\x12\x03\x0c\x18\x1c\n\x0b\n\x04\x05\0\x02\x07\x12\x03\r\x080\n\
    \x0c\n\x05\x05\0\x02\x07\x01\x12\x03\r\x08(\n\x0c\n\x05\x05\0\x02\x07\
    \x02\x12\x03\r+/\n\x0b\n\x04\x05\0\x02\x08\x12\x03\x0e\x08*\n\x0c\n\x05\
    \x05\0\x02\x08\x01\x12\x03\x0e\x08\"\n\x0c\n\x05\x05\0\x02\x08\x02\x12\
    \x03\x0e%)\n\n\n\x02\x05\x01\x12\x04\x11\0\x14\x01\n\n\n\x03\x05\x01\x01\
    \x12\x03\x11\x05\x1c\n\x0b\n\x04\x05\x01\x02\0\x12\x03\x12\x08)\n\x0c\n\
    \x05\x05\x01\x02\0\x01\x12\x03\x12\x08!\n\x0c\n\x05\x05\x01\x02\0\x02\
    \x12\x03\x12$(\n\x0b\n\x04\x05\x01\x02\x01\x12\x03\x13\x08)\n\x0c\n\x05\
    \x05\x01\x02\x01\x01\x12\x03\x13\x08!\n\x0c\n\x05\x05\x01\x02\x01\x02\
    \x12\x03\x13$(\n\n\n\x02\x05\x02\x12\x04\x16\0\x19\x01\n\n\n\x03\x05\x02\
    \x01\x12\x03\x16\x05\x14\n\x0b\n\x04\x05\x02\x02\0\x12\x03\x17\x08*\n\
    \x0c\n\x05\x05\x02\x02\0\x01\x12\x03\x17\x08%\n\x0c\n\x05\x05\x02\x02\0\
    \x02\x12\x03\x17()\n\x0b\n\x04\x05\x02\x02\x01\x12\x03\x18\x08'\n\x0c\n\
    \x05\x05\x02\x02\x01\x01\x12\x03\x18\x08\"\n\x0c\n\x05\x05\x02\x02\x01\
    \x02\x12\x03\x18%&\n\n\n\x02\x04\0\x12\x04\x1b\0\x20\x01\n\n\n\x03\x04\0\
    \x01\x12\x03\x1b\x08%\n\x0b\n\x04\x04\0\x02\0\x12\x03\x1c\x08(\n\x0c\n\
    \x05\x04\0\x02\0\x04\x12\x03\x1c\x08\x10\n\x0c\n\x05\x04\0\x02\0\x05\x12\
    \x03\x1c\x11\x17\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03\x1c\x18#\n\x0c\n\
    \x05\x04\0\x02\0\x03\x12\x03\x1c&'\n\x0b\n\x04\x04\0\x02\x01\x12\x03\x1d\
    \x08%\n\x0c\n\x05\x04\0\x02\x01\x04\x12\x03\x1d\x08\x10\n\x0c\n\x05\x04\
    \0\x02\x01\x05\x12\x03\x1d\x11\x17\n\x0c\n\x05\x04\0\x02\x01\x01\x12\x03\
    \x1d\x18\x20\n\x0c\n\x05\x04\0\x02\x01\x03\x12\x03\x1d#$\n\x0b\n\x04\x04\
    \0\x02\x02\x12\x03\x1e\x083\n\x0c\n\x05\x04\0\x02\x02\x04\x12\x03\x1e\
    \x08\x10\n\x0c\n\x05\x04\0\x02\x02\x05\x12\x03\x1e\x11\x17\n\x0c\n\x05\
    \x04\0\x02\x02\x01\x12\x03\x1e\x18.\n\x0c\n\x05\x04\0\x02\x02\x03\x12\
    \x03\x1e12\n\x0b\n\x04\x04\0\x02\x03\x12\x03\x1f\x08*\n\x0c\n\x05\x04\0\
    \x02\x03\x04\x12\x03\x1f\x08\x10\n\x0c\n\x05\x04\0\x02\x03\x05\x12\x03\
    \x1f\x11\x17\n\x0c\n\x05\x04\0\x02\x03\x01\x12\x03\x1f\x18%\n\x0c\n\x05\
    \x04\0\x02\x03\x03\x12\x03\x1f()\n\n\n\x02\x04\x01\x12\x04\"\0'\x01\n\n\
    \n\x03\x04\x01\x01\x12\x03\"\x08\x1f\n\x0b\n\x04\x04\x01\x02\0\x12\x03#\
    \x08$\n\x0c\n\x05\x04\x01\x02\0\x04\x12\x03#\x08\x10\n\x0c\n\x05\x04\x01\
    \x02\0\x05\x12\x03#\x11\x17\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03#\x18\
    \x1f\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03#\"#\n\x0b\n\x04\x04\x01\x02\
    \x01\x12\x03$\x08$\n\x0c\n\x05\x04\x01\x02\x01\x04\x12\x03$\x08\x10\n\
    \x0c\n\x05\x04\x01\x02\x01\x05\x12\x03$\x11\x16\n\x0c\n\x05\x04\x01\x02\
    \x01\x01\x12\x03$\x17\x1f\n\x0c\n\x05\x04\x01\x02\x01\x03\x12\x03$\"#\n\
    \x0b\n\x04\x04\x01\x02\x02\x12\x03%\x08$\n\x0c\n\x05\x04\x01\x02\x02\x04\
    \x12\x03%\x08\x10\n\x0c\n\x05\x04\x01\x02\x02\x05\x12\x03%\x11\x16\n\x0c\
    \n\x05\x04\x01\x02\x02\x01\x12\x03%\x17\x1f\n\x0c\n\x05\x04\x01\x02\x02\
    \x03\x12\x03%\"#\n\x0b\n\x04\x04\x01\x02\x03\x12\x03&\x08?\n\x0c\n\x05\
    \x04\x01\x02\x03\x04\x12\x03&\x08\x10\n\x0c\n\x05\x04\x01\x02\x03\x06\
    \x12\x03&\x11/\n\x0c\n\x05\x04\x01\x02\x03\x01\x12\x03&0:\n\x0c\n\x05\
    \x04\x01\x02\x03\x03\x12\x03&=>\n\n\n\x02\x04\x02\x12\x04)\0,\x01\n\n\n\
    \x03\x04\x02\x01\x12\x03)\x08'\n\x0b\n\x04\x04\x02\x02\0\x12\x03*\x08\"\
    \n\x0c\n\x05\x04\x02\x02\0\x04\x12\x03*\x08\x10\n\x0c\n\x05\x04\x02\x02\
    \0\x05\x12\x03*\x11\x16\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x03*\x17\x1d\n\
    \x0c\n\x05\x04\x02\x02\0\x03\x12\x03*\x20!\n\x0b\n\x04\x04\x02\x02\x01\
    \x12\x03+\x08#\n\x0c\n\x05\x04\x02\x02\x01\x04\x12\x03+\x08\x10\n\x0c\n\
    \x05\x04\x02\x02\x01\x05\x12\x03+\x11\x17\n\x0c\n\x05\x04\x02\x02\x01\
    \x01\x12\x03+\x18\x1e\n\x0c\n\x05\x04\x02\x02\x01\x03\x12\x03+!\"\n\n\n\
    \x02\x04\x03\x12\x04.\00\x01\n\n\n\x03\x04\x03\x01\x12\x03.\x08\x1b\n\
    \x0b\n\x04\x04\x03\x02\0\x12\x03/\x08$\n\x0c\n\x05\x04\x03\x02\0\x04\x12\
    \x03/\x08\x10\n\x0c\n\x05\x04\x03\x02\0\x05\x12\x03/\x11\x17\n\x0c\n\x05\
    \x04\x03\x02\0\x01\x12\x03/\x18\x1f\n\x0c\n\x05\x04\x03\x02\0\x03\x12\
    \x03/\"#\n\n\n\x02\x04\x04\x12\x042\04\x01\n\n\n\x03\x04\x04\x01\x12\x03\
    2\x08\x17\n\x0b\n\x04\x04\x04\x02\0\x12\x033\x08$\n\x0c\n\x05\x04\x04\
    \x02\0\x04\x12\x033\x08\x10\n\x0c\n\x05\x04\x04\x02\0\x05\x12\x033\x11\
    \x17\n\x0c\n\x05\x04\x04\x02\0\x01\x12\x033\x18\x1f\n\x0c\n\x05\x04\x04\
    \x02\0\x03\x12\x033\"#\n\n\n\x02\x04\x05\x12\x046\08\x01\n\n\n\x03\x04\
    \x05\x01\x12\x036\x08\x17\n\x0b\n\x04\x04\x05\x02\0\x12\x037\x08$\n\x0c\
    \n\x05\x04\x05\x02\0\x04\x12\x037\x08\x10\n\x0c\n\x05\x04\x05\x02\0\x05\
    \x12\x037\x11\x17\n\x0c\n\x05\x04\x05\x02\0\x01\x12\x037\x18\x1f\n\x0c\n\
    \x05\x04\x05\x02\0\x03\x12\x037\"#\n\n\n\x02\x04\x06\x12\x04:\0>\x01\n\n\
    \n\x03\x04\x06\x01\x12\x03:\x08\x19\n\x0b\n\x04\x04\x06\x02\0\x12\x03;\
    \x08$\n\x0c\n\x05\x04\x06\x02\0\x04\x12\x03;\x08\x10\n\x0c\n\x05\x04\x06\
    \x02\0\x05\x12\x03;\x11\x17\n\x0c\n\x05\x04\x06\x02\0\x01\x12\x03;\x18\
    \x1f\n\x0c\n\x05\x04\x06\x02\0\x03\x12\x03;\"#\n\x0b\n\x04\x04\x06\x02\
    \x01\x12\x03<\x08%\n\x0c\n\x05\x04\x06\x02\x01\x04\x12\x03<\x08\x10\n\
    \x0c\n\x05\x04\x06\x02\x01\x05\x12\x03<\x11\x16\n\x0c\n\x05\x04\x06\x02\
    \x01\x01\x12\x03<\x17\x20\n\x0c\n\x05\x04\x06\x02\x01\x03\x12\x03<#$\n\
    \x0b\n\x04\x04\x06\x02\x02\x12\x03=\x08-\n\x0c\n\x05\x04\x06\x02\x02\x04\
    \x12\x03=\x08\x10\n\x0c\n\x05\x04\x06\x02\x02\x05\x12\x03=\x11\x17\n\x0c\
    \n\x05\x04\x06\x02\x02\x01\x12\x03=\x18(\n\x0c\n\x05\x04\x06\x02\x02\x03\
    \x12\x03=+,\n\n\n\x02\x04\x07\x12\x04@\0C\x01\n\n\n\x03\x04\x07\x01\x12\
    \x03@\x08\x19\n\x0b\n\x04\x04\x07\x02\0\x12\x03A\x080\n\x0c\n\x05\x04\
    \x07\x02\0\x04\x12\x03A\x08\x10\n\x0c\n\x05\x04\x07\x02\0\x05\x12\x03A\
    \x11\x17\n\x0c\n\x05\x04\x07\x02\0\x01\x12\x03A\x18+\n\x0c\n\x05\x04\x07\
    \x02\0\x03\x12\x03A./\n\x0b\n\x04\x04\x07\x02\x01\x12\x03B\x08+\n\x0c\n\
    \x05\x04\x07\x02\x01\x04\x12\x03B\x08\x10\n\x0c\n\x05\x04\x07\x02\x01\
    \x05\x12\x03B\x11\x17\n\x0c\n\x05\x04\x07\x02\x01\x01\x12\x03B\x18&\n\
    \x0c\n\x05\x04\x07\x02\x01\x03\x12\x03B)*\n\n\n\x02\x04\x08\x12\x04E\0G\
    \x01\n\n\n\x03\x04\x08\x01\x12\x03E\x08\x19\n\x0b\n\x04\x04\x08\x02\0\
    \x12\x03F\x08W\n\x0c\n\x05\x04\x08\x02\0\x04\x12\x03F\x08\x10\n\x0c\n\
    \x05\x04\x08\x02\0\x06\x12\x03F\x11!\n\x0c\n\x05\x04\x08\x02\0\x01\x12\
    \x03F\"(\n\x0c\n\x05\x04\x08\x02\0\x03\x12\x03F+,\n\x0c\n\x05\x04\x08\
    \x02\0\x08\x12\x03F-V\n\x0c\n\x05\x04\x08\x02\0\x07\x12\x03F8U\n\n\n\x02\
    \x04\t\x12\x04I\0K\x01\n\n\n\x03\x04\t\x01\x12\x03I\x08\x19\n\x0b\n\x04\
    \x04\t\x02\0\x12\x03J\x08W\n\x0c\n\x05\x04\t\x02\0\x04\x12\x03J\x08\x10\
    \n\x0c\n\x05\x04\t\x02\0\x06\x12\x03J\x11!\n\x0c\n\x05\x04\t\x02\0\x01\
    \x12\x03J\"(\n\x0c\n\x05\x04\t\x02\0\x03\x12\x03J+,\n\x0c\n\x05\x04\t\
    \x02\0\x08\x12\x03J-V\n\x0c\n\x05\x04\t\x02\0\x07\x12\x03J8U\n\n\n\x02\
    \x04\n\x12\x04M\0N\x01\n\n\n\x03\x04\n\x01\x12\x03M\x08\x1b\n\n\n\x02\
    \x04\x0b\x12\x04P\0R\x01\n\n\n\x03\x04\x0b\x01\x12\x03P\x08\x1e\n\x0b\n\
    \x04\x04\x0b\x02\0\x12\x03Q\x08&\n\x0c\n\x05\x04\x0b\x02\0\x04\x12\x03Q\
    \x08\x10\n\x0c\n\x05\x04\x0b\x02\0\x05\x12\x03Q\x11\x18\n\x0c\n\x05\x04\
    \x0b\x02\0\x01\x12\x03Q\x19!\n\x0c\n\x05\x04\x0b\x02\0\x03\x12\x03Q$%\n\
    \n\n\x02\x04\x0c\x12\x04T\0m\x01\n\n\n\x03\x04\x0c\x01\x12\x03T\x08\x20\
    \n\x0b\n\x04\x04\x0c\x02\0\x12\x03U\x08D\n\x0c\n\x05\x04\x0c\x02\0\x04\
    \x12\x03U\x08\x10\n\x0c\n\x05\x04\x0c\x02\0\x05\x12\x03U\x11\x17\n\x0c\n\
    \x05\x04\x0c\x02\0\x01\x12\x03U\x181\n\x0c\n\x05\x04\x0c\x02\0\x03\x12\
    \x03U45\n\x0c\n\x05\x04\x0c\x02\0\x08\x12\x03U6C\n\x0c\n\x05\x04\x0c\x02\
    \0\x07\x12\x03UAB\n\x0b\n\x04\x04\x0c\x02\x01\x12\x03V\x08:\n\x0c\n\x05\
    \x04\x0c\x02\x01\x04\x12\x03V\x08\x10\n\x0c\n\x05\x04\x0c\x02\x01\x05\
    \x12\x03V\x11\x15\n\x0c\n\x05\x04\x0c\x02\x01\x01\x12\x03V\x16#\n\x0c\n\
    \x05\x04\x0c\x02\x01\x03\x12\x03V&'\n\x0c\n\x05\x04\x0c\x02\x01\x08\x12\
    \x03V(9\n\x0c\n\x05\x04\x0c\x02\x01\x07\x12\x03V38\n\x0b\n\x04\x04\x0c\
    \x02\x02\x12\x03W\x08=\n\x0c\n\x05\x04\x0c\x02\x02\x04\x12\x03W\x08\x10\
    \n\x0c\n\x05\x04\x0c\x02\x02\x05\x12\x03W\x11\x15\n\x0c\n\x05\x04\x0c\
    \x02\x02\x01\x12\x03W\x168\n\x0c\n\x05\x04\x0c\x02\x02\x03\x12\x03W;<\n\
    \x0b\n\x04\x04\x0c\x02\x03\x12\x03X\x08*\n\x0c\n\x05\x04\x0c\x02\x03\x04\
    \x12\x03X\x08\x10\n\x0c\n\x05\x04\x0c\x02\x03\x05\x12\x03X\x11\x15\n\x0c\
    \n\x05\x04\x0c\x02\x03\x01\x12\x03X\x16%\n\x0c\n\x05\x04\x0c\x02\x03\x03\
    \x12\x03X()\n\x0b\n\x04\x04\x0c\x02\x04\x12\x03Y\x082\n\x0c\n\x05\x04\
    \x0c\x02\x04\x04\x12\x03Y\x08\x10\n\x0c\n\x05\x04\x0c\x02\x04\x05\x12\
    \x03Y\x11\x18\n\x0c\n\x05\x04\x0c\x02\x04\x01\x12\x03Y\x19-\n\x0c\n\x05\
    \x04\x0c\x02\x04\x03\x12\x03Y01\n\x0b\n\x04\x04\x0c\x02\x05\x12\x03Z\x08\
    1\n\x0c\n\x05\x04\x0c\x02\x05\x04\x12\x03Z\x08\x10\n\x0c\n\x05\x04\x0c\
    \x02\x05\x05\x12\x03Z\x11\x18\n\x0c\n\x05\x04\x0c\x02\x05\x01\x12\x03Z\
    \x19,\n\x0c\n\x05\x04\x0c\x02\x05\x03\x12\x03Z/0\n\x0b\n\x04\x04\x0c\x02\
    \x06\x12\x03[\x08;\n\x0c\n\x05\x04\x0c\x02\x06\x04\x12\x03[\x08\x10\n\
    \x0c\n\x05\x04\x0c\x02\x06\x05\x12\x03[\x11\x17\n\x0c\n\x05\x04\x0c\x02\
    \x06\x01\x12\x03[\x18(\n\x0c\n\x05\x04\x0c\x02\x06\x03\x12\x03[+,\n\x0c\
    \n\x05\x04\x0c\x02\x06\x08\x12\x03[-:\n\x0c\n\x05\x04\x0c\x02\x06\x07\
    \x12\x03[89\n\x0b\n\x04\x04\x0c\x02\x07\x12\x03\\\x08<\n\x0c\n\x05\x04\
    \x0c\x02\x07\x04\x12\x03\\\x08\x10\n\x0c\n\x05\x04\x0c\x02\x07\x05\x12\
    \x03\\\x11\x15\n\x0c\n\x05\x04\x0c\x02\x07\x01\x12\x03\\\x16$\n\x0c\n\
    \x05\x04\x0c\x02\x07\x03\x12\x03\\')\n\x0c\n\x05\x04\x0c\x02\x07\x08\x12\
    \x03\\*;\n\x0c\n\x05\x04\x0c\x02\x07\x07\x12\x03\\5:\n\x0b\n\x04\x04\x0c\
    \x02\x08\x12\x03]\x08.\n\x0c\n\x05\x04\x0c\x02\x08\x04\x12\x03]\x08\x10\
    \n\x0c\n\x05\x04\x0c\x02\x08\x05\x12\x03]\x11\x17\n\x0c\n\x05\x04\x0c\
    \x02\x08\x01\x12\x03]\x18(\n\x0c\n\x05\x04\x0c\x02\x08\x03\x12\x03]+-\n\
    \x0b\n\x04\x04\x0c\x02\t\x12\x03^\x08.\n\x0c\n\x05\x04\x0c\x02\t\x04\x12\
    \x03^\x08\x10\n\x0c\n\x05\x04\x0c\x02\t\x05\x12\x03^\x11\x17\n\x0c\n\x05\
    \x04\x0c\x02\t\x01\x12\x03^\x18(\n\x0c\n\x05\x04\x0c\x02\t\x03\x12\x03^+\
    -\n\x0b\n\x04\x04\x0c\x02\n\x12\x03_\x08@\n\x0c\n\x05\x04\x0c\x02\n\x04\
    \x12\x03_\x08\x10\n\x0c\n\x05\x04\x0c\x02\n\x05\x12\x03_\x11\x15\n\x0c\n\
    \x05\x04\x0c\x02\n\x01\x12\x03_\x16(\n\x0c\n\x05\x04\x0c\x02\n\x03\x12\
    \x03_+-\n\x0c\n\x05\x04\x0c\x02\n\x08\x12\x03_.?\n\x0c\n\x05\x04\x0c\x02\
    \n\x07\x12\x03_9>\n\x0b\n\x04\x04\x0c\x02\x0b\x12\x03`\x08?\n\x0c\n\x05\
    \x04\x0c\x02\x0b\x04\x12\x03`\x08\x10\n\x0c\n\x05\x04\x0c\x02\x0b\x05\
    \x12\x03`\x11\x17\n\x0c\n\x05\x04\x0c\x02\x0b\x01\x12\x03`\x189\n\x0c\n\
    \x05\x04\x0c\x02\x0b\x03\x12\x03`<>\n\x0b\n\x04\x04\x0c\x02\x0c\x12\x03a\
    \x08H\n\x0c\n\x05\x04\x0c\x02\x0c\x04\x12\x03a\x08\x10\n\x0c\n\x05\x04\
    \x0c\x02\x0c\x05\x12\x03a\x11\x17\n\x0c\n\x05\x04\x0c\x02\x0c\x01\x12\
    \x03a\x18B\n\x0c\n\x05\x04\x0c\x02\x0c\x03\x12\x03aEG\n\x0b\n\x04\x04\
    \x0c\x02\r\x12\x03b\x08B\n\x0c\n\x05\x04\x0c\x02\r\x04\x12\x03b\x08\x10\
    \n\x0c\n\x05\x04\x0c\x02\r\x05\x12\x03b\x11\x17\n\x0c\n\x05\x04\x0c\x02\
    \r\x01\x12\x03b\x18<\n\x0c\n\x05\x04\x0c\x02\r\x03\x12\x03b?A\n\x0b\n\
    \x04\x04\x0c\x02\x0e\x12\x03c\x08K\n\x0c\n\x05\x04\x0c\x02\x0e\x04\x12\
    \x03c\x08\x10\n\x0c\n\x05\x04\x0c\x02\x0e\x05\x12\x03c\x11\x17\n\x0c\n\
    \x05\x04\x0c\x02\x0e\x01\x12\x03c\x18E\n\x0c\n\x05\x04\x0c\x02\x0e\x03\
    \x12\x03cHJ\n\x0b\n\x04\x04\x0c\x02\x0f\x12\x03d\x08?\n\x0c\n\x05\x04\
    \x0c\x02\x0f\x04\x12\x03d\x08\x10\n\x0c\n\x05\x04\x0c\x02\x0f\x05\x12\
    \x03d\x11\x17\n\x0c\n\x05\x04\x0c\x02\x0f\x01\x12\x03d\x189\n\x0c\n\x05\
    \x04\x0c\x02\x0f\x03\x12\x03d<>\n\x0b\n\x04\x04\x0c\x02\x10\x12\x03e\x08\
    H\n\x0c\n\x05\x04\x0c\x02\x10\x04\x12\x03e\x08\x10\n\x0c\n\x05\x04\x0c\
    \x02\x10\x05\x12\x03e\x11\x17\n\x0c\n\x05\x04\x0c\x02\x10\x01\x12\x03e\
    \x18B\n\x0c\n\x05\x04\x0c\x02\x10\x03\x12\x03eEG\n\x0b\n\x04\x04\x0c\x02\
    \x11\x12\x03f\x08B\n\x0c\n\x05\x04\x0c\x02\x11\x04\x12\x03f\x08\x10\n\
    \x0c\n\x05\x04\x0c\x02\x11\x05\x12\x03f\x11\x17\n\x0c\n\x05\x04\x0c\x02\
    \x11\x01\x12\x03f\x18<\n\x0c\n\x05\x04\x0c\x02\x11\x03\x12\x03f?A\n\x0b\
    \n\x04\x04\x0c\x02\x12\x12\x03g\x08K\n\x0c\n\x05\x04\x0c\x02\x12\x04\x12\
    \x03g\x08\x10\n\x0c\n\x05\x04\x0c\x02\x12\x05\x12\x03g\x11\x17\n\x0c\n\
    \x05\x04\x0c\x02\x12\x01\x12\x03g\x18E\n\x0c\n\x05\x04\x0c\x02\x12\x03\
    \x12\x03gHJ\n\x0b\n\x04\x04\x0c\x02\x13\x12\x03h\x08?\n\x0c\n\x05\x04\
    \x0c\x02\x13\x04\x12\x03h\x08\x10\n\x0c\n\x05\x04\x0c\x02\x13\x05\x12\
    \x03h\x11\x15\n\x0c\n\x05\x04\x0c\x02\x13\x01\x12\x03h\x16'\n\x0c\n\x05\
    \x04\x0c\x02\x13\x03\x12\x03h*,\n\x0c\n\x05\x04\x0c\x02\x13\x08\x12\x03h\
    ->\n\x0c\n\x05\x04\x0c\x02\x13\x07\x12\x03h8=\n\x0b\n\x04\x04\x0c\x02\
    \x14\x12\x03i\x08J\n\x0c\n\x05\x04\x0c\x02\x14\x04\x12\x03i\x08\x10\n\
    \x0c\n\x05\x04\x0c\x02\x14\x05\x12\x03i\x11\x15\n\x0c\n\x05\x04\x0c\x02\
    \x14\x01\x12\x03i\x162\n\x0c\n\x05\x04\x0c\x02\x14\x03\x12\x03i57\n\x0c\
    \n\x05\x04\x0c\x02\x14\x08\x12\x03i8I\n\x0c\n\x05\x04\x0c\x02\x14\x07\
    \x12\x03iCH\n\x0b\n\x04\x04\x0c\x02\x15\x12\x03j\x082\n\x0c\n\x05\x04\
    \x0c\x02\x15\x04\x12\x03j\x08\x10\n\x0c\n\x05\x04\x0c\x02\x15\x05\x12\
    \x03j\x11\x17\n\x0c\n\x05\x04\x0c\x02\x15\x01\x12\x03j\x18,\n\x0c\n\x05\
    \x04\x0c\x02\x15\x03\x12\x03j/1\n\x0b\n\x04\x04\x0c\x02\x16\x12\x03k\x08\
    U\n\x0c\n\x05\x04\x0c\x02\x16\x04\x12\x03k\x08\x10\n\x0c\n\x05\x04\x0c\
    \x02\x16\x05\x12\x03k\x11\x17\n\x0c\n\x05\x04\x0c\x02\x16\x01\x12\x03k\
    \x18O\n\x0c\n\x05\x04\x0c\x02\x16\x03\x12\x03kRT\n\x0b\n\x04\x04\x0c\x02\
    \x17\x12\x03l\x08S\n\x0c\n\x05\x04\x0c\x02\x17\x04\x12\x03l\x08\x10\n\
    \x0c\n\x05\x04\x0c\x02\x17\x05\x12\x03l\x11\x17\n\x0c\n\x05\x04\x0c\x02\
    \x17\x01\x12\x03l\x18M\n\x0c\n\x05\x04\x0c\x02\x17\x03\x12\x03lPR\n\n\n\
    \x02\x04\r\x12\x04o\0u\x01\n\n\n\x03\x04\r\x01\x12\x03o\x08\x20\n\x0b\n\
    \x04\x04\r\x02\0\x12\x03p\x08\x1e\n\x0c\n\x05\x04\r\x02\0\x04\x12\x03p\
    \x08\x10\n\x0c\n\x05\x04\r\x02\0\x05\x12\x03p\x11\x16\n\x0c\n\x05\x04\r\
    \x02\0\x01\x12\x03p\x17\x19\n\x0c\n\x05\x04\r\x02\0\x03\x12\x03p\x1c\x1d\
    \n\x0b\n\x04\x04\r\x02\x01\x12\x03q\x08\"\n\x0c\n\x05\x04\r\x02\x01\x04\
    \x12\x03q\x08\x10\n\x0c\n\x05\x04\r\x02\x01\x05\x12\x03q\x11\x17\n\x0c\n\
    \x05\x04\r\x02\x01\x01\x12\x03q\x18\x1d\n\x0c\n\x05\x04\r\x02\x01\x03\
    \x12\x03q\x20!\n\x0b\n\x04\x04\r\x02\x02\x12\x03r\x08#\n\x0c\n\x05\x04\r\
    \x02\x02\x04\x12\x03r\x08\x10\n\x0c\n\x05\x04\r\x02\x02\x05\x12\x03r\x11\
    \x15\n\x0c\n\x05\x04\r\x02\x02\x01\x12\x03r\x16\x1e\n\x0c\n\x05\x04\r\
    \x02\x02\x03\x12\x03r!\"\n\x0b\n\x04\x04\r\x02\x03\x12\x03s\x08'\n\x0c\n\
    \x05\x04\r\x02\x03\x04\x12\x03s\x08\x10\n\x0c\n\x05\x04\r\x02\x03\x05\
    \x12\x03s\x11\x16\n\x0c\n\x05\x04\r\x02\x03\x01\x12\x03s\x17\"\n\x0c\n\
    \x05\x04\r\x02\x03\x03\x12\x03s%&\n\x0b\n\x04\x04\r\x02\x04\x12\x03t\x08\
    )\n\x0c\n\x05\x04\r\x02\x04\x04\x12\x03t\x08\x10\n\x0c\n\x05\x04\r\x02\
    \x04\x05\x12\x03t\x11\x17\n\x0c\n\x05\x04\r\x02\x04\x01\x12\x03t\x18$\n\
    \x0c\n\x05\x04\r\x02\x04\x03\x12\x03t'(\n\x0b\n\x02\x04\x0e\x12\x05w\0\
    \x83\x01\x01\n\n\n\x03\x04\x0e\x01\x12\x03w\x08\x17\n\x0b\n\x04\x04\x0e\
    \x02\0\x12\x03x\x08'\n\x0c\n\x05\x04\x0e\x02\0\x04\x12\x03x\x08\x10\n\
    \x0c\n\x05\x04\x0e\x02\0\x05\x12\x03x\x11\x17\n\x0c\n\x05\x04\x0e\x02\0\
    \x01\x12\x03x\x18\"\n\x0c\n\x05\x04\x0e\x02\0\x03\x12\x03x%&\n\x0b\n\x04\
    \x04\x0e\x02\x01\x12\x03y\x08(\n\x0c\n\x05\x04\x0e\x02\x01\x04\x12\x03y\
    \x08\x10\n\x0c\n\x05\x04\x0e\x02\x01\x05\x12\x03y\x11\x16\n\x0c\n\x05\
    \x04\x0e\x02\x01\x01\x12\x03y\x17#\n\x0c\n\x05\x04\x0e\x02\x01\x03\x12\
    \x03y&'\n\x0b\n\x04\x04\x0e\x02\x02\x12\x03z\x08)\n\x0c\n\x05\x04\x0e\
    \x02\x02\x04\x12\x03z\x08\x10\n\x0c\n\x05\x04\x0e\x02\x02\x05\x12\x03z\
    \x11\x15\n\x0c\n\x05\x04\x0e\x02\x02\x01\x12\x03z\x16$\n\x0c\n\x05\x04\
    \x0e\x02\x02\x03\x12\x03z'(\n\x0b\n\x04\x04\x0e\x02\x03\x12\x03{\x08+\n\
    \x0c\n\x05\x04\x0e\x02\x03\x04\x12\x03{\x08\x10\n\x0c\n\x05\x04\x0e\x02\
    \x03\x05\x12\x03{\x11\x15\n\x0c\n\x05\x04\x0e\x02\x03\x01\x12\x03{\x16&\
    \n\x0c\n\x05\x04\x0e\x02\x03\x03\x12\x03{)*\n\x0b\n\x04\x04\x0e\x02\x04\
    \x12\x03|\x08.\n\x0c\n\x05\x04\x0e\x02\x04\x04\x12\x03|\x08\x10\n\x0c\n\
    \x05\x04\x0e\x02\x04\x05\x12\x03|\x11\x17\n\x0c\n\x05\x04\x0e\x02\x04\
    \x01\x12\x03|\x18)\n\x0c\n\x05\x04\x0e\x02\x04\x03\x12\x03|,-\n\x0b\n\
    \x04\x04\x0e\x02\x05\x12\x03}\x08-\n\x0c\n\x05\x04\x0e\x02\x05\x04\x12\
    \x03}\x08\x10\n\x0c\n\x05\x04\x0e\x02\x05\x05\x12\x03}\x11\x17\n\x0c\n\
    \x05\x04\x0e\x02\x05\x01\x12\x03}\x18(\n\x0c\n\x05\x04\x0e\x02\x05\x03\
    \x12\x03}+,\n\x0b\n\x04\x04\x0e\x02\x06\x12\x03~\x08.\n\x0c\n\x05\x04\
    \x0e\x02\x06\x04\x12\x03~\x08\x10\n\x0c\n\x05\x04\x0e\x02\x06\x05\x12\
    \x03~\x11\x15\n\x0c\n\x05\x04\x0e\x02\x06\x01\x12\x03~\x16)\n\x0c\n\x05\
    \x04\x0e\x02\x06\x03\x12\x03~,-\n\x0b\n\x04\x04\x0e\x02\x07\x12\x03\x7f\
    \x08:\n\x0c\n\x05\x04\x0e\x02\x07\x04\x12\x03\x7f\x08\x10\n\x0c\n\x05\
    \x04\x0e\x02\x07\x06\x12\x03\x7f\x11*\n\x0c\n\x05\x04\x0e\x02\x07\x01\
    \x12\x03\x7f+5\n\x0c\n\x05\x04\x0e\x02\x07\x03\x12\x03\x7f89\n\x0c\n\x04\
    \x04\x0e\x02\x08\x12\x04\x80\x01\x08'\n\r\n\x05\x04\x0e\x02\x08\x04\x12\
    \x04\x80\x01\x08\x10\n\r\n\x05\x04\x0e\x02\x08\x05\x12\x04\x80\x01\x11\
    \x15\n\r\n\x05\x04\x0e\x02\x08\x01\x12\x04\x80\x01\x16!\n\r\n\x05\x04\
    \x0e\x02\x08\x03\x12\x04\x80\x01$&\n\x0c\n\x04\x04\x0e\x02\t\x12\x04\x81\
    \x01\x08\"\n\r\n\x05\x04\x0e\x02\t\x04\x12\x04\x81\x01\x08\x10\n\r\n\x05\
    \x04\x0e\x02\t\x05\x12\x04\x81\x01\x11\x17\n\r\n\x05\x04\x0e\x02\t\x01\
    \x12\x04\x81\x01\x18\x1c\n\r\n\x05\x04\x0e\x02\t\x03\x12\x04\x81\x01\x1f\
    !\n\x0c\n\x04\x04\x0e\x02\n\x12\x04\x82\x01\x08+\n\r\n\x05\x04\x0e\x02\n\
    \x04\x12\x04\x82\x01\x08\x10\n\r\n\x05\x04\x0e\x02\n\x05\x12\x04\x82\x01\
    \x11\x17\n\r\n\x05\x04\x0e\x02\n\x01\x12\x04\x82\x01\x18%\n\r\n\x05\x04\
    \x0e\x02\n\x03\x12\x04\x82\x01(*\n\x0c\n\x02\x04\x0f\x12\x06\x85\x01\0\
    \x99\x01\x01\n\x0b\n\x03\x04\x0f\x01\x12\x04\x85\x01\x08\x15\n\x0c\n\x04\
    \x04\x0f\x02\0\x12\x04\x86\x01\x08&\n\r\n\x05\x04\x0f\x02\0\x04\x12\x04\
    \x86\x01\x08\x10\n\r\n\x05\x04\x0f\x02\0\x05\x12\x04\x86\x01\x11\x17\n\r\
    \n\x05\x04\x0f\x02\0\x01\x12\x04\x86\x01\x18!\n\r\n\x05\x04\x0f\x02\0\
    \x03\x12\x04\x86\x01$%\n\x0c\n\x04\x04\x0f\x02\x01\x12\x04\x87\x01\x08!\
    \n\r\n\x05\x04\x0f\x02\x01\x04\x12\x04\x87\x01\x08\x10\n\r\n\x05\x04\x0f\
    \x02\x01\x05\x12\x04\x87\x01\x11\x17\n\r\n\x05\x04\x0f\x02\x01\x01\x12\
    \x04\x87\x01\x18\x1c\n\r\n\x05\x04\x0f\x02\x01\x03\x12\x04\x87\x01\x1f\
    \x20\n\x0c\n\x04\x04\x0f\x02\x02\x12\x04\x88\x01\x08\x20\n\r\n\x05\x04\
    \x0f\x02\x02\x04\x12\x04\x88\x01\x08\x10\n\r\n\x05\x04\x0f\x02\x02\x05\
    \x12\x04\x88\x01\x11\x17\n\r\n\x05\x04\x0f\x02\x02\x01\x12\x04\x88\x01\
    \x18\x1b\n\r\n\x05\x04\x0f\x02\x02\x03\x12\x04\x88\x01\x1e\x1f\n\x0c\n\
    \x04\x04\x0f\x02\x03\x12\x04\x89\x01\x08(\n\r\n\x05\x04\x0f\x02\x03\x04\
    \x12\x04\x89\x01\x08\x10\n\r\n\x05\x04\x0f\x02\x03\x05\x12\x04\x89\x01\
    \x11\x17\n\r\n\x05\x04\x0f\x02\x03\x01\x12\x04\x89\x01\x18#\n\r\n\x05\
    \x04\x0f\x02\x03\x03\x12\x04\x89\x01&'\n\x0c\n\x04\x04\x0f\x02\x04\x12\
    \x04\x8a\x01\x08)\n\r\n\x05\x04\x0f\x02\x04\x04\x12\x04\x8a\x01\x08\x10\
    \n\r\n\x05\x04\x0f\x02\x04\x05\x12\x04\x8a\x01\x11\x17\n\r\n\x05\x04\x0f\
    \x02\x04\x01\x12\x04\x8a\x01\x18$\n\r\n\x05\x04\x0f\x02\x04\x03\x12\x04\
    \x8a\x01'(\n\x0c\n\x04\x04\x0f\x02\x05\x12\x04\x8b\x01\x08!\n\r\n\x05\
    \x04\x0f\x02\x05\x04\x12\x04\x8b\x01\x08\x10\n\r\n\x05\x04\x0f\x02\x05\
    \x05\x12\x04\x8b\x01\x11\x17\n\r\n\x05\x04\x0f\x02\x05\x01\x12\x04\x8b\
    \x01\x18\x1c\n\r\n\x05\x04\x0f\x02\x05\x03\x12\x04\x8b\x01\x1f\x20\n\x0c\
    \n\x04\x04\x0f\x02\x06\x12\x04\x8c\x01\x08!\n\r\n\x05\x04\x0f\x02\x06\
    \x04\x12\x04\x8c\x01\x08\x10\n\r\n\x05\x04\x0f\x02\x06\x05\x12\x04\x8c\
    \x01\x11\x17\n\r\n\x05\x04\x0f\x02\x06\x01\x12\x04\x8c\x01\x18\x1c\n\r\n\
    \x05\x04\x0f\x02\x06\x03\x12\x04\x8c\x01\x1f\x20\n\x0c\n\x04\x04\x0f\x02\
    \x07\x12\x04\x8d\x01\x08!\n\r\n\x05\x04\x0f\x02\x07\x04\x12\x04\x8d\x01\
    \x08\x10\n\r\n\x05\x04\x0f\x02\x07\x05\x12\x04\x8d\x01\x11\x17\n\r\n\x05\
    \x04\x0f\x02\x07\x01\x12\x04\x8d\x01\x18\x1c\n\r\n\x05\x04\x0f\x02\x07\
    \x03\x12\x04\x8d\x01\x1f\x20\n\x0c\n\x04\x04\x0f\x02\x08\x12\x04\x8e\x01\
    \x08!\n\r\n\x05\x04\x0f\x02\x08\x04\x12\x04\x8e\x01\x08\x10\n\r\n\x05\
    \x04\x0f\x02\x08\x05\x12\x04\x8e\x01\x11\x17\n\r\n\x05\x04\x0f\x02\x08\
    \x01\x12\x04\x8e\x01\x18\x1c\n\r\n\x05\x04\x0f\x02\x08\x03\x12\x04\x8e\
    \x01\x1f\x20\n\x0c\n\x04\x04\x0f\x02\t\x12\x04\x8f\x01\x08\"\n\r\n\x05\
    \x04\x0f\x02\t\x04\x12\x04\x8f\x01\x08\x10\n\r\n\x05\x04\x0f\x02\t\x05\
    \x12\x04\x8f\x01\x11\x17\n\r\n\x05\x04\x0f\x02\t\x01\x12\x04\x8f\x01\x18\
    \x1c\n\r\n\x05\x04\x0f\x02\t\x03\x12\x04\x8f\x01\x1f!\n\x0c\n\x04\x04\
    \x0f\x02\n\x12\x04\x90\x01\x08\"\n\r\n\x05\x04\x0f\x02\n\x04\x12\x04\x90\
    \x01\x08\x10\n\r\n\x05\x04\x0f\x02\n\x05\x12\x04\x90\x01\x11\x17\n\r\n\
    \x05\x04\x0f\x02\n\x01\x12\x04\x90\x01\x18\x1c\n\r\n\x05\x04\x0f\x02\n\
    \x03\x12\x04\x90\x01\x1f!\n\x0c\n\x04\x04\x0f\x02\x0b\x12\x04\x91\x01\
    \x083\n\r\n\x05\x04\x0f\x02\x0b\x04\x12\x04\x91\x01\x08\x10\n\r\n\x05\
    \x04\x0f\x02\x0b\x05\x12\x04\x91\x01\x11\x15\n\r\n\x05\x04\x0f\x02\x0b\
    \x01\x12\x04\x91\x01\x16-\n\r\n\x05\x04\x0f\x02\x0b\x03\x12\x04\x91\x010\
    2\n\x0c\n\x04\x04\x0f\x02\x0c\x12\x04\x92\x01\x082\n\r\n\x05\x04\x0f\x02\
    \x0c\x04\x12\x04\x92\x01\x08\x10\n\r\n\x05\x04\x0f\x02\x0c\x05\x12\x04\
    \x92\x01\x11\x15\n\r\n\x05\x04\x0f\x02\x0c\x01\x12\x04\x92\x01\x16,\n\r\
    \n\x05\x04\x0f\x02\x0c\x03\x12\x04\x92\x01/1\n\x0c\n\x04\x04\x0f\x02\r\
    \x12\x04\x93\x01\x083\n\r\n\x05\x04\x0f\x02\r\x04\x12\x04\x93\x01\x08\
    \x10\n\r\n\x05\x04\x0f\x02\r\x05\x12\x04\x93\x01\x11\x16\n\r\n\x05\x04\
    \x0f\x02\r\x01\x12\x04\x93\x01\x17-\n\r\n\x05\x04\x0f\x02\r\x03\x12\x04\
    \x93\x0102\n\x0c\n\x04\x04\x0f\x02\x0e\x12\x04\x94\x01\x082\n\r\n\x05\
    \x04\x0f\x02\x0e\x04\x12\x04\x94\x01\x08\x10\n\r\n\x05\x04\x0f\x02\x0e\
    \x05\x12\x04\x94\x01\x11\x16\n\r\n\x05\x04\x0f\x02\x0e\x01\x12\x04\x94\
    \x01\x17,\n\r\n\x05\x04\x0f\x02\x0e\x03\x12\x04\x94\x01/1\n\x0c\n\x04\
    \x04\x0f\x02\x0f\x12\x04\x95\x01\x08+\n\r\n\x05\x04\x0f\x02\x0f\x04\x12\
    \x04\x95\x01\x08\x10\n\r\n\x05\x04\x0f\x02\x0f\x05\x12\x04\x95\x01\x11\
    \x16\n\r\n\x05\x04\x0f\x02\x0f\x01\x12\x04\x95\x01\x17%\n\r\n\x05\x04\
    \x0f\x02\x0f\x03\x12\x04\x95\x01(*\n\x0c\n\x04\x04\x0f\x02\x10\x12\x04\
    \x96\x01\x08<\n\r\n\x05\x04\x0f\x02\x10\x04\x12\x04\x96\x01\x08\x10\n\r\
    \n\x05\x04\x0f\x02\x10\x06\x12\x04\x96\x01\x11!\n\r\n\x05\x04\x0f\x02\
    \x10\x01\x12\x04\x96\x01\"6\n\r\n\x05\x04\x0f\x02\x10\x03\x12\x04\x96\
    \x019;\n\x0c\n\x04\x04\x0f\x02\x11\x12\x04\x97\x01\x08=\n\r\n\x05\x04\
    \x0f\x02\x11\x04\x12\x04\x97\x01\x08\x10\n\r\n\x05\x04\x0f\x02\x11\x06\
    \x12\x04\x97\x01\x11!\n\r\n\x05\x04\x0f\x02\x11\x01\x12\x04\x97\x01\"7\n\
    \r\n\x05\x04\x0f\x02\x11\x03\x12\x04\x97\x01:<\n\x0c\n\x04\x04\x0f\x02\
    \x12\x12\x04\x98\x01\x084\n\r\n\x05\x04\x0f\x02\x12\x04\x12\x04\x98\x01\
    \x08\x10\n\r\n\x05\x04\x0f\x02\x12\x05\x12\x04\x98\x01\x11\x17\n\r\n\x05\
    \x04\x0f\x02\x12\x01\x12\x04\x98\x01\x18.\n\r\n\x05\x04\x0f\x02\x12\x03\
    \x12\x04\x98\x0113\n\x0c\n\x02\x04\x10\x12\x06\x9b\x01\0\x9e\x01\x01\n\
    \x0b\n\x03\x04\x10\x01\x12\x04\x9b\x01\x08\x1d\n\x0c\n\x04\x04\x10\x02\0\
    \x12\x04\x9c\x01\x08&\n\r\n\x05\x04\x10\x02\0\x04\x12\x04\x9c\x01\x08\
    \x10\n\r\n\x05\x04\x10\x02\0\x05\x12\x04\x9c\x01\x11\x18\n\r\n\x05\x04\
    \x10\x02\0\x01\x12\x04\x9c\x01\x19!\n\r\n\x05\x04\x10\x02\0\x03\x12\x04\
    \x9c\x01$%\n\x0c\n\x04\x04\x10\x02\x01\x12\x04\x9d\x01\x08/\n\r\n\x05\
    \x04\x10\x02\x01\x04\x12\x04\x9d\x01\x08\x10\n\r\n\x05\x04\x10\x02\x01\
    \x06\x12\x04\x9d\x01\x11!\n\r\n\x05\x04\x10\x02\x01\x01\x12\x04\x9d\x01\
    \"*\n\r\n\x05\x04\x10\x02\x01\x03\x12\x04\x9d\x01-.\n\x0c\n\x02\x04\x11\
    \x12\x06\xa0\x01\0\xa3\x01\x01\n\x0b\n\x03\x04\x11\x01\x12\x04\xa0\x01\
    \x08#\n\x0c\n\x04\x04\x11\x02\0\x12\x04\xa1\x01\x08&\n\r\n\x05\x04\x11\
    \x02\0\x04\x12\x04\xa1\x01\x08\x10\n\r\n\x05\x04\x11\x02\0\x05\x12\x04\
    \xa1\x01\x11\x18\n\r\n\x05\x04\x11\x02\0\x01\x12\x04\xa1\x01\x19!\n\r\n\
    \x05\x04\x11\x02\0\x03\x12\x04\xa1\x01$%\n\x0c\n\x04\x04\x11\x02\x01\x12\
    \x04\xa2\x01\x08+\n\r\n\x05\x04\x11\x02\x01\x04\x12\x04\xa2\x01\x08\x10\
    \n\r\n\x05\x04\x11\x02\x01\x05\x12\x04\xa2\x01\x11\x17\n\r\n\x05\x04\x11\
    \x02\x01\x01\x12\x04\xa2\x01\x18&\n\r\n\x05\x04\x11\x02\x01\x03\x12\x04\
    \xa2\x01)*\n\x0c\n\x02\x04\x12\x12\x06\xa5\x01\0\xab\x01\x01\n\x0b\n\x03\
    \x04\x12\x01\x12\x04\xa5\x01\x08'\n\x0c\n\x04\x04\x12\x02\0\x12\x04\xa6\
    \x01\x08,\n\r\n\x05\x04\x12\x02\0\x04\x12\x04\xa6\x01\x08\x10\n\r\n\x05\
    \x04\x12\x02\0\x05\x12\x04\xa6\x01\x11\x17\n\r\n\x05\x04\x12\x02\0\x01\
    \x12\x04\xa6\x01\x18'\n\r\n\x05\x04\x12\x02\0\x03\x12\x04\xa6\x01*+\n\
    \x0c\n\x04\x04\x12\x02\x01\x12\x04\xa7\x01\x08,\n\r\n\x05\x04\x12\x02\
    \x01\x04\x12\x04\xa7\x01\x08\x10\n\r\n\x05\x04\x12\x02\x01\x05\x12\x04\
    \xa7\x01\x11\x17\n\r\n\x05\x04\x12\x02\x01\x01\x12\x04\xa7\x01\x18'\n\r\
    \n\x05\x04\x12\x02\x01\x03\x12\x04\xa7\x01*+\n\x0c\n\x04\x04\x12\x02\x02\
    \x12\x04\xa8\x01\x08$\n\r\n\x05\x04\x12\x02\x02\x04\x12\x04\xa8\x01\x08\
    \x10\n\r\n\x05\x04\x12\x02\x02\x05\x12\x04\xa8\x01\x11\x17\n\r\n\x05\x04\
    \x12\x02\x02\x01\x12\x04\xa8\x01\x18\x1f\n\r\n\x05\x04\x12\x02\x02\x03\
    \x12\x04\xa8\x01\"#\n\x0c\n\x04\x04\x12\x02\x03\x12\x04\xa9\x01\x08'\n\r\
    \n\x05\x04\x12\x02\x03\x04\x12\x04\xa9\x01\x08\x10\n\r\n\x05\x04\x12\x02\
    \x03\x05\x12\x04\xa9\x01\x11\x17\n\r\n\x05\x04\x12\x02\x03\x01\x12\x04\
    \xa9\x01\x18\"\n\r\n\x05\x04\x12\x02\x03\x03\x12\x04\xa9\x01%&\n\x0c\n\
    \x04\x04\x12\x02\x04\x12\x04\xaa\x01\x08,\n\r\n\x05\x04\x12\x02\x04\x04\
    \x12\x04\xaa\x01\x08\x10\n\r\n\x05\x04\x12\x02\x04\x05\x12\x04\xaa\x01\
    \x11\x17\n\r\n\x05\x04\x12\x02\x04\x01\x12\x04\xaa\x01\x18'\n\r\n\x05\
    \x04\x12\x02\x04\x03\x12\x04\xaa\x01*+\n\x0c\n\x02\x04\x13\x12\x06\xad\
    \x01\0\xaf\x01\x01\n\x0b\n\x03\x04\x13\x01\x12\x04\xad\x01\x080\n\x0c\n\
    \x04\x04\x13\x02\0\x12\x04\xae\x01\x08;\n\r\n\x05\x04\x13\x02\0\x04\x12\
    \x04\xae\x01\x08\x10\n\r\n\x05\x04\x13\x02\0\x06\x12\x04\xae\x01\x111\n\
    \r\n\x05\x04\x13\x02\0\x01\x12\x04\xae\x0126\n\r\n\x05\x04\x13\x02\0\x03\
    \x12\x04\xae\x019:\n\x0c\n\x02\x04\x14\x12\x06\xb1\x01\0\xb6\x01\x01\n\
    \x0b\n\x03\x04\x14\x01\x12\x04\xb1\x01\x08&\n\x0c\n\x04\x04\x14\x02\0\
    \x12\x04\xb2\x01\x08,\n\r\n\x05\x04\x14\x02\0\x04\x12\x04\xb2\x01\x08\
    \x10\n\r\n\x05\x04\x14\x02\0\x05\x12\x04\xb2\x01\x11\x17\n\r\n\x05\x04\
    \x14\x02\0\x01\x12\x04\xb2\x01\x18'\n\r\n\x05\x04\x14\x02\0\x03\x12\x04\
    \xb2\x01*+\n\x0c\n\x04\x04\x14\x02\x01\x12\x04\xb3\x01\x08,\n\r\n\x05\
    \x04\x14\x02\x01\x04\x12\x04\xb3\x01\x08\x10\n\r\n\x05\x04\x14\x02\x01\
    \x05\x12\x04\xb3\x01\x11\x17\n\r\n\x05\x04\x14\x02\x01\x01\x12\x04\xb3\
    \x01\x18'\n\r\n\x05\x04\x14\x02\x01\x03\x12\x04\xb3\x01*+\n\x0c\n\x04\
    \x04\x14\x02\x02\x12\x04\xb4\x01\x08$\n\r\n\x05\x04\x14\x02\x02\x04\x12\
    \x04\xb4\x01\x08\x10\n\r\n\x05\x04\x14\x02\x02\x05\x12\x04\xb4\x01\x11\
    \x17\n\r\n\x05\x04\x14\x02\x02\x01\x12\x04\xb4\x01\x18\x1f\n\r\n\x05\x04\
    \x14\x02\x02\x03\x12\x04\xb4\x01\"#\n\x0c\n\x04\x04\x14\x02\x03\x12\x04\
    \xb5\x01\x08'\n\r\n\x05\x04\x14\x02\x03\x04\x12\x04\xb5\x01\x08\x10\n\r\
    \n\x05\x04\x14\x02\x03\x05\x12\x04\xb5\x01\x11\x17\n\r\n\x05\x04\x14\x02\
    \x03\x01\x12\x04\xb5\x01\x18\"\n\r\n\x05\x04\x14\x02\x03\x03\x12\x04\xb5\
    \x01%&\n\x0c\n\x02\x04\x15\x12\x06\xb8\x01\0\xbc\x01\x01\n\x0b\n\x03\x04\
    \x15\x01\x12\x04\xb8\x01\x08%\n\x0c\n\x04\x04\x15\x02\0\x12\x04\xb9\x01\
    \x08)\n\r\n\x05\x04\x15\x02\0\x04\x12\x04\xb9\x01\x08\x10\n\r\n\x05\x04\
    \x15\x02\0\x05\x12\x04\xb9\x01\x11\x17\n\r\n\x05\x04\x15\x02\0\x01\x12\
    \x04\xb9\x01\x18$\n\r\n\x05\x04\x15\x02\0\x03\x12\x04\xb9\x01'(\n\x0c\n\
    \x04\x04\x15\x02\x01\x12\x04\xba\x01\x08-\n\r\n\x05\x04\x15\x02\x01\x04\
    \x12\x04\xba\x01\x08\x10\n\r\n\x05\x04\x15\x02\x01\x05\x12\x04\xba\x01\
    \x11\x17\n\r\n\x05\x04\x15\x02\x01\x01\x12\x04\xba\x01\x18(\n\r\n\x05\
    \x04\x15\x02\x01\x03\x12\x04\xba\x01+,\n\x0c\n\x04\x04\x15\x02\x02\x12\
    \x04\xbb\x01\x08.\n\r\n\x05\x04\x15\x02\x02\x04\x12\x04\xbb\x01\x08\x10\
    \n\r\n\x05\x04\x15\x02\x02\x05\x12\x04\xbb\x01\x11\x17\n\r\n\x05\x04\x15\
    \x02\x02\x01\x12\x04\xbb\x01\x18)\n\r\n\x05\x04\x15\x02\x02\x03\x12\x04\
    \xbb\x01,-\n\x0c\n\x02\x04\x16\x12\x06\xbe\x01\0\xc1\x01\x01\n\x0b\n\x03\
    \x04\x16\x01\x12\x04\xbe\x01\x08\x1c\n\x0c\n\x04\x04\x16\x02\0\x12\x04\
    \xbf\x01\x081\n\r\n\x05\x04\x16\x02\0\x04\x12\x04\xbf\x01\x08\x10\n\r\n\
    \x05\x04\x16\x02\0\x05\x12\x04\xbf\x01\x11\x17\n\r\n\x05\x04\x16\x02\0\
    \x01\x12\x04\xbf\x01\x18,\n\r\n\x05\x04\x16\x02\0\x03\x12\x04\xbf\x01/0\
    \n\x0c\n\x04\x04\x16\x02\x01\x12\x04\xc0\x01\x08)\n\r\n\x05\x04\x16\x02\
    \x01\x04\x12\x04\xc0\x01\x08\x10\n\r\n\x05\x04\x16\x02\x01\x05\x12\x04\
    \xc0\x01\x11\x17\n\r\n\x05\x04\x16\x02\x01\x01\x12\x04\xc0\x01\x18$\n\r\
    \n\x05\x04\x16\x02\x01\x03\x12\x04\xc0\x01'(\n\x0c\n\x02\x04\x17\x12\x06\
    \xc3\x01\0\xc7\x01\x01\n\x0b\n\x03\x04\x17\x01\x12\x04\xc3\x01\x08#\n\
    \x0c\n\x04\x04\x17\x02\0\x12\x04\xc4\x01\x081\n\r\n\x05\x04\x17\x02\0\
    \x04\x12\x04\xc4\x01\x08\x10\n\r\n\x05\x04\x17\x02\0\x05\x12\x04\xc4\x01\
    \x11\x17\n\r\n\x05\x04\x17\x02\0\x01\x12\x04\xc4\x01\x18,\n\r\n\x05\x04\
    \x17\x02\0\x03\x12\x04\xc4\x01/0\n\x0c\n\x04\x04\x17\x02\x01\x12\x04\xc5\
    \x01\x08)\n\r\n\x05\x04\x17\x02\x01\x04\x12\x04\xc5\x01\x08\x10\n\r\n\
    \x05\x04\x17\x02\x01\x05\x12\x04\xc5\x01\x11\x17\n\r\n\x05\x04\x17\x02\
    \x01\x01\x12\x04\xc5\x01\x18$\n\r\n\x05\x04\x17\x02\x01\x03\x12\x04\xc5\
    \x01'(\n\x0c\n\x04\x04\x17\x02\x02\x12\x04\xc6\x01\x08/\n\r\n\x05\x04\
    \x17\x02\x02\x04\x12\x04\xc6\x01\x08\x10\n\r\n\x05\x04\x17\x02\x02\x05\
    \x12\x04\xc6\x01\x11\x17\n\r\n\x05\x04\x17\x02\x02\x01\x12\x04\xc6\x01\
    \x18*\n\r\n\x05\x04\x17\x02\x02\x03\x12\x04\xc6\x01-.\n\x0c\n\x02\x04\
    \x18\x12\x06\xc9\x01\0\xcc\x01\x01\n\x0b\n\x03\x04\x18\x01\x12\x04\xc9\
    \x01\x08\x1c\n\x0c\n\x04\x04\x18\x02\0\x12\x04\xca\x01\x081\n\r\n\x05\
    \x04\x18\x02\0\x04\x12\x04\xca\x01\x08\x10\n\r\n\x05\x04\x18\x02\0\x05\
    \x12\x04\xca\x01\x11\x17\n\r\n\x05\x04\x18\x02\0\x01\x12\x04\xca\x01\x18\
    ,\n\r\n\x05\x04\x18\x02\0\x03\x12\x04\xca\x01/0\n\x0c\n\x04\x04\x18\x02\
    \x01\x12\x04\xcb\x01\x08,\n\r\n\x05\x04\x18\x02\x01\x04\x12\x04\xcb\x01\
    \x08\x10\n\r\n\x05\x04\x18\x02\x01\x05\x12\x04\xcb\x01\x11\x17\n\r\n\x05\
    \x04\x18\x02\x01\x01\x12\x04\xcb\x01\x18'\n\r\n\x05\x04\x18\x02\x01\x03\
    \x12\x04\xcb\x01*+\n\x0c\n\x02\x04\x19\x12\x06\xce\x01\0\xd2\x01\x01\n\
    \x0b\n\x03\x04\x19\x01\x12\x04\xce\x01\x08\x1c\n\x0c\n\x04\x04\x19\x02\0\
    \x12\x04\xcf\x01\x08&\n\r\n\x05\x04\x19\x02\0\x04\x12\x04\xcf\x01\x08\
    \x10\n\r\n\x05\x04\x19\x02\0\x05\x12\x04\xcf\x01\x11\x17\n\r\n\x05\x04\
    \x19\x02\0\x01\x12\x04\xcf\x01\x18!\n\r\n\x05\x04\x19\x02\0\x03\x12\x04\
    \xcf\x01$%\n\x0c\n\x04\x04\x19\x02\x01\x12\x04\xd0\x01\x08\"\n\r\n\x05\
    \x04\x19\x02\x01\x04\x12\x04\xd0\x01\x08\x10\n\r\n\x05\x04\x19\x02\x01\
    \x05\x12\x04\xd0\x01\x11\x17\n\r\n\x05\x04\x19\x02\x01\x01\x12\x04\xd0\
    \x01\x18\x1d\n\r\n\x05\x04\x19\x02\x01\x03\x12\x04\xd0\x01\x20!\n\x0c\n\
    \x04\x04\x19\x02\x02\x12\x04\xd1\x01\x08'\n\r\n\x05\x04\x19\x02\x02\x04\
    \x12\x04\xd1\x01\x08\x10\n\r\n\x05\x04\x19\x02\x02\x05\x12\x04\xd1\x01\
    \x11\x16\n\r\n\x05\x04\x19\x02\x02\x01\x12\x04\xd1\x01\x17\"\n\r\n\x05\
    \x04\x19\x02\x02\x03\x12\x04\xd1\x01%&\n\x0c\n\x02\x04\x1a\x12\x06\xd4\
    \x01\0\xd7\x01\x01\n\x0b\n\x03\x04\x1a\x01\x12\x04\xd4\x01\x08\x1b\n\x0c\
    \n\x04\x04\x1a\x02\0\x12\x04\xd5\x01\x08&\n\r\n\x05\x04\x1a\x02\0\x04\
    \x12\x04\xd5\x01\x08\x10\n\r\n\x05\x04\x1a\x02\0\x05\x12\x04\xd5\x01\x11\
    \x17\n\r\n\x05\x04\x1a\x02\0\x01\x12\x04\xd5\x01\x18!\n\r\n\x05\x04\x1a\
    \x02\0\x03\x12\x04\xd5\x01$%\n\x0c\n\x04\x04\x1a\x02\x01\x12\x04\xd6\x01\
    \x08%\n\r\n\x05\x04\x1a\x02\x01\x04\x12\x04\xd6\x01\x08\x10\n\r\n\x05\
    \x04\x1a\x02\x01\x05\x12\x04\xd6\x01\x11\x17\n\r\n\x05\x04\x1a\x02\x01\
    \x01\x12\x04\xd6\x01\x18\x20\n\r\n\x05\x04\x1a\x02\x01\x03\x12\x04\xd6\
    \x01#$\n\x0c\n\x02\x04\x1b\x12\x06\xd9\x01\0\xed\x01\x01\n\x0b\n\x03\x04\
    \x1b\x01\x12\x04\xd9\x01\x08\x13\n\x0c\n\x04\x04\x1b\x02\0\x12\x04\xda\
    \x01\x08\x1f\n\r\n\x05\x04\x1b\x02\0\x04\x12\x04\xda\x01\x08\x10\n\r\n\
    \x05\x04\x1b\x02\0\x05\x12\x04\xda\x01\x11\x17\n\r\n\x05\x04\x1b\x02\0\
    \x01\x12\x04\xda\x01\x18\x1a\n\r\n\x05\x04\x1b\x02\0\x03\x12\x04\xda\x01\
    \x1d\x1e\n\x0c\n\x04\x04\x1b\x02\x01\x12\x04\xdb\x01\x08'\n\r\n\x05\x04\
    \x1b\x02\x01\x04\x12\x04\xdb\x01\x08\x10\n\r\n\x05\x04\x1b\x02\x01\x05\
    \x12\x04\xdb\x01\x11\x17\n\r\n\x05\x04\x1b\x02\x01\x01\x12\x04\xdb\x01\
    \x18\"\n\r\n\x05\x04\x1b\x02\x01\x03\x12\x04\xdb\x01%&\n\x0c\n\x04\x04\
    \x1b\x02\x02\x12\x04\xdc\x01\x08&\n\r\n\x05\x04\x1b\x02\x02\x04\x12\x04\
    \xdc\x01\x08\x10\n\r\n\x05\x04\x1b\x02\x02\x05\x12\x04\xdc\x01\x11\x17\n\
    \r\n\x05\x04\x1b\x02\x02\x01\x12\x04\xdc\x01\x18!\n\r\n\x05\x04\x1b\x02\
    \x02\x03\x12\x04\xdc\x01$%\n\x0c\n\x04\x04\x1b\x02\x03\x12\x04\xdd\x01\
    \x08&\n\r\n\x05\x04\x1b\x02\x03\x04\x12\x04\xdd\x01\x08\x10\n\r\n\x05\
    \x04\x1b\x02\x03\x05\x12\x04\xdd\x01\x11\x17\n\r\n\x05\x04\x1b\x02\x03\
    \x01\x12\x04\xdd\x01\x18!\n\r\n\x05\x04\x1b\x02\x03\x03\x12\x04\xdd\x01$\
    %\n\x0c\n\x04\x04\x1b\x02\x04\x12\x04\xde\x01\x08%\n\r\n\x05\x04\x1b\x02\
    \x04\x04\x12\x04\xde\x01\x08\x10\n\r\n\x05\x04\x1b\x02\x04\x05\x12\x04\
    \xde\x01\x11\x17\n\r\n\x05\x04\x1b\x02\x04\x01\x12\x04\xde\x01\x18\x20\n\
    \r\n\x05\x04\x1b\x02\x04\x03\x12\x04\xde\x01#$\n\x0c\n\x04\x04\x1b\x02\
    \x05\x12\x04\xdf\x01\x08\"\n\r\n\x05\x04\x1b\x02\x05\x04\x12\x04\xdf\x01\
    \x08\x10\n\r\n\x05\x04\x1b\x02\x05\x05\x12\x04\xdf\x01\x11\x17\n\r\n\x05\
    \x04\x1b\x02\x05\x01\x12\x04\xdf\x01\x18\x1d\n\r\n\x05\x04\x1b\x02\x05\
    \x03\x12\x04\xdf\x01\x20!\n\x0c\n\x04\x04\x1b\x02\x06\x12\x04\xe0\x01\
    \x08$\n\r\n\x05\x04\x1b\x02\x06\x04\x12\x04\xe0\x01\x08\x10\n\r\n\x05\
    \x04\x1b\x02\x06\x05\x12\x04\xe0\x01\x11\x17\n\r\n\x05\x04\x1b\x02\x06\
    \x01\x12\x04\xe0\x01\x18\x1f\n\r\n\x05\x04\x1b\x02\x06\x03\x12\x04\xe0\
    \x01\"#\n\x0c\n\x04\x04\x1b\x02\x07\x12\x04\xe1\x01\x080\n\r\n\x05\x04\
    \x1b\x02\x07\x04\x12\x04\xe1\x01\x08\x10\n\r\n\x05\x04\x1b\x02\x07\x05\
    \x12\x04\xe1\x01\x11\x17\n\r\n\x05\x04\x1b\x02\x07\x01\x12\x04\xe1\x01\
    \x18\x1d\n\r\n\x05\x04\x1b\x02\x07\x03\x12\x04\xe1\x01\x20!\n\r\n\x05\
    \x04\x1b\x02\x07\x08\x12\x04\xe1\x01\"/\n\r\n\x05\x04\x1b\x02\x07\x07\
    \x12\x04\xe1\x01-.\n\x0c\n\x04\x04\x1b\x02\x08\x12\x04\xe2\x01\x08#\n\r\
    \n\x05\x04\x1b\x02\x08\x04\x12\x04\xe2\x01\x08\x10\n\r\n\x05\x04\x1b\x02\
    \x08\x05\x12\x04\xe2\x01\x11\x17\n\r\n\x05\x04\x1b\x02\x08\x01\x12\x04\
    \xe2\x01\x18\x1e\n\r\n\x05\x04\x1b\x02\x08\x03\x12\x04\xe2\x01!\"\n\x0c\
    \n\x04\x04\x1b\x02\t\x12\x04\xe3\x01\x08)\n\r\n\x05\x04\x1b\x02\t\x04\
    \x12\x04\xe3\x01\x08\x10\n\r\n\x05\x04\x1b\x02\t\x05\x12\x04\xe3\x01\x11\
    \x17\n\r\n\x05\x04\x1b\x02\t\x01\x12\x04\xe3\x01\x18#\n\r\n\x05\x04\x1b\
    \x02\t\x03\x12\x04\xe3\x01&(\n\x0c\n\x04\x04\x1b\x02\n\x12\x04\xe4\x01\
    \x08)\n\r\n\x05\x04\x1b\x02\n\x04\x12\x04\xe4\x01\x08\x10\n\r\n\x05\x04\
    \x1b\x02\n\x05\x12\x04\xe4\x01\x11\x17\n\r\n\x05\x04\x1b\x02\n\x01\x12\
    \x04\xe4\x01\x18#\n\r\n\x05\x04\x1b\x02\n\x03\x12\x04\xe4\x01&(\n\x0c\n\
    \x04\x04\x1b\x02\x0b\x12\x04\xe5\x01\x086\n\r\n\x05\x04\x1b\x02\x0b\x04\
    \x12\x04\xe5\x01\x08\x10\n\r\n\x05\x04\x1b\x02\x0b\x06\x12\x04\xe5\x01\
    \x11&\n\r\n\x05\x04\x1b\x02\x0b\x01\x12\x04\xe5\x01'0\n\r\n\x05\x04\x1b\
    \x02\x0b\x03\x12\x04\xe5\x0135\n\x0c\n\x04\x04\x1b\x02\x0c\x12\x04\xe6\
    \x01\x081\n\r\n\x05\x04\x1b\x02\x0c\x04\x12\x04\xe6\x01\x08\x10\n\r\n\
    \x05\x04\x1b\x02\x0c\x06\x12\x04\xe6\x01\x11\x1d\n\r\n\x05\x04\x1b\x02\
    \x0c\x01\x12\x04\xe6\x01\x1e+\n\r\n\x05\x04\x1b\x02\x0c\x03\x12\x04\xe6\
    \x01.0\n\x0c\n\x04\x04\x1b\x02\r\x12\x04\xe7\x01\x084\n\r\n\x05\x04\x1b\
    \x02\r\x04\x12\x04\xe7\x01\x08\x10\n\r\n\x05\x04\x1b\x02\r\x05\x12\x04\
    \xe7\x01\x11\x15\n\r\n\x05\x04\x1b\x02\r\x01\x12\x04\xe7\x01\x16\x1c\n\r\
    \n\x05\x04\x1b\x02\r\x03\x12\x04\xe7\x01\x1f!\n\r\n\x05\x04\x1b\x02\r\
    \x08\x12\x04\xe7\x01\"3\n\r\n\x05\x04\x1b\x02\r\x07\x12\x04\xe7\x01-2\n\
    \x0c\n\x04\x04\x1b\x02\x0e\x12\x04\xe8\x01\x081\n\r\n\x05\x04\x1b\x02\
    \x0e\x04\x12\x04\xe8\x01\x08\x10\n\r\n\x05\x04\x1b\x02\x0e\x05\x12\x04\
    \xe8\x01\x11\x17\n\r\n\x05\x04\x1b\x02\x0e\x01\x12\x04\xe8\x01\x18\x1d\n\
    \r\n\x05\x04\x1b\x02\x0e\x03\x12\x04\xe8\x01\x20\"\n\r\n\x05\x04\x1b\x02\
    \x0e\x08\x12\x04\xe8\x01#0\n\r\n\x05\x04\x1b\x02\x0e\x07\x12\x04\xe8\x01\
    ./\n\x0c\n\x04\x04\x1b\x02\x0f\x12\x04\xe9\x01\x087\n\r\n\x05\x04\x1b\
    \x02\x0f\x04\x12\x04\xe9\x01\x08\x10\n\r\n\x05\x04\x1b\x02\x0f\x05\x12\
    \x04\xe9\x01\x11\x17\n\r\n\x05\x04\x1b\x02\x0f\x01\x12\x04\xe9\x01\x18#\
    \n\r\n\x05\x04\x1b\x02\x0f\x03\x12\x04\xe9\x01&(\n\r\n\x05\x04\x1b\x02\
    \x0f\x08\x12\x04\xe9\x01)6\n\r\n\x05\x04\x1b\x02\x0f\x07\x12\x04\xe9\x01\
    45\n\x0c\n\x04\x04\x1b\x02\x10\x12\x04\xea\x01\x083\n\r\n\x05\x04\x1b\
    \x02\x10\x04\x12\x04\xea\x01\x08\x10\n\r\n\x05\x04\x1b\x02\x10\x05\x12\
    \x04\xea\x01\x11\x15\n\r\n\x05\x04\x1b\x02\x10\x01\x12\x04\xea\x01\x16-\
    \n\r\n\x05\x04\x1b\x02\x10\x03\x12\x04\xea\x0102\n\x0c\n\x04\x04\x1b\x02\
    \x11\x12\x04\xeb\x01\x08:\n\r\n\x05\x04\x1b\x02\x11\x04\x12\x04\xeb\x01\
    \x08\x10\n\r\n\x05\x04\x1b\x02\x11\x06\x12\x04\xeb\x01\x11%\n\r\n\x05\
    \x04\x1b\x02\x11\x01\x12\x04\xeb\x01&4\n\r\n\x05\x04\x1b\x02\x11\x03\x12\
    \x04\xeb\x0179\n\x0c\n\x04\x04\x1b\x02\x12\x12\x04\xec\x01\x086\n\r\n\
    \x05\x04\x1b\x02\x12\x04\x12\x04\xec\x01\x08\x10\n\r\n\x05\x04\x1b\x02\
    \x12\x05\x12\x04\xec\x01\x11\x15\n\r\n\x05\x04\x1b\x02\x12\x01\x12\x04\
    \xec\x01\x160\n\r\n\x05\x04\x1b\x02\x12\x03\x12\x04\xec\x0135\n\x0c\n\
    \x02\x04\x1c\x12\x06\xef\x01\0\xf3\x01\x01\n\x0b\n\x03\x04\x1c\x01\x12\
    \x04\xef\x01\x08#\n\x0c\n\x04\x04\x1c\x02\0\x12\x04\xf0\x01\x08$\n\r\n\
    \x05\x04\x1c\x02\0\x04\x12\x04\xf0\x01\x08\x10\n\r\n\x05\x04\x1c\x02\0\
    \x05\x12\x04\xf0\x01\x11\x17\n\r\n\x05\x04\x1c\x02\0\x01\x12\x04\xf0\x01\
    \x18\x1f\n\r\n\x05\x04\x1c\x02\0\x03\x12\x04\xf0\x01\"#\n\x0c\n\x04\x04\
    \x1c\x02\x01\x12\x04\xf1\x01\x08&\n\r\n\x05\x04\x1c\x02\x01\x04\x12\x04\
    \xf1\x01\x08\x10\n\r\n\x05\x04\x1c\x02\x01\x05\x12\x04\xf1\x01\x11\x17\n\
    \r\n\x05\x04\x1c\x02\x01\x01\x12\x04\xf1\x01\x18!\n\r\n\x05\x04\x1c\x02\
    \x01\x03\x12\x04\xf1\x01$%\n\x0c\n\x04\x04\x1c\x02\x02\x12\x04\xf2\x01\
    \x08%\n\r\n\x05\x04\x1c\x02\x02\x04\x12\x04\xf2\x01\x08\x10\n\r\n\x05\
    \x04\x1c\x02\x02\x05\x12\x04\xf2\x01\x11\x17\n\r\n\x05\x04\x1c\x02\x02\
    \x01\x12\x04\xf2\x01\x18\x20\n\r\n\x05\x04\x1c\x02\x02\x03\x12\x04\xf2\
    \x01#$\n\x0c\n\x02\x04\x1d\x12\x06\xf5\x01\0\xf7\x01\x01\n\x0b\n\x03\x04\
    \x1d\x01\x12\x04\xf5\x01\x08\x15\n\x0c\n\x04\x04\x1d\x02\0\x12\x04\xf6\
    \x01\x08&\n\r\n\x05\x04\x1d\x02\0\x04\x12\x04\xf6\x01\x08\x10\n\r\n\x05\
    \x04\x1d\x02\0\x05\x12\x04\xf6\x01\x11\x17\n\r\n\x05\x04\x1d\x02\0\x01\
    \x12\x04\xf6\x01\x18!\n\r\n\x05\x04\x1d\x02\0\x03\x12\x04\xf6\x01$%\n\
    \x0c\n\x02\x04\x1e\x12\x06\xf9\x01\0\xfe\x01\x01\n\x0b\n\x03\x04\x1e\x01\
    \x12\x04\xf9\x01\x08\x18\n\x0c\n\x04\x04\x1e\x02\0\x12\x04\xfa\x01\x08'\
    \n\r\n\x05\x04\x1e\x02\0\x04\x12\x04\xfa\x01\x08\x10\n\r\n\x05\x04\x1e\
    \x02\0\x05\x12\x04\xfa\x01\x11\x17\n\r\n\x05\x04\x1e\x02\0\x01\x12\x04\
    \xfa\x01\x18\"\n\r\n\x05\x04\x1e\x02\0\x03\x12\x04\xfa\x01%&\n\x0c\n\x04\
    \x04\x1e\x02\x01\x12\x04\xfb\x01\x08&\n\r\n\x05\x04\x1e\x02\x01\x04\x12\
    \x04\xfb\x01\x08\x10\n\r\n\x05\x04\x1e\x02\x01\x05\x12\x04\xfb\x01\x11\
    \x17\n\r\n\x05\x04\x1e\x02\x01\x01\x12\x04\xfb\x01\x18!\n\r\n\x05\x04\
    \x1e\x02\x01\x03\x12\x04\xfb\x01$%\n\x0c\n\x04\x04\x1e\x02\x02\x12\x04\
    \xfc\x01\x08*\n\r\n\x05\x04\x1e\x02\x02\x04\x12\x04\xfc\x01\x08\x10\n\r\
    \n\x05\x04\x1e\x02\x02\x05\x12\x04\xfc\x01\x11\x17\n\r\n\x05\x04\x1e\x02\
    \x02\x01\x12\x04\xfc\x01\x18%\n\r\n\x05\x04\x1e\x02\x02\x03\x12\x04\xfc\
    \x01()\n\x0c\n\x04\x04\x1e\x02\x03\x12\x04\xfd\x01\x08!\n\r\n\x05\x04\
    \x1e\x02\x03\x04\x12\x04\xfd\x01\x08\x10\n\r\n\x05\x04\x1e\x02\x03\x05\
    \x12\x04\xfd\x01\x11\x17\n\r\n\x05\x04\x1e\x02\x03\x01\x12\x04\xfd\x01\
    \x18\x1c\n\r\n\x05\x04\x1e\x02\x03\x03\x12\x04\xfd\x01\x1f\x20\n\x0c\n\
    \x02\x04\x1f\x12\x06\x80\x02\0\x82\x02\x01\n\x0b\n\x03\x04\x1f\x01\x12\
    \x04\x80\x02\x08\x1c\n\x0c\n\x04\x04\x1f\x02\0\x12\x04\x81\x02\x081\n\r\
    \n\x05\x04\x1f\x02\0\x04\x12\x04\x81\x02\x08\x10\n\r\n\x05\x04\x1f\x02\0\
    \x05\x12\x04\x81\x02\x11\x18\n\r\n\x05\x04\x1f\x02\0\x01\x12\x04\x81\x02\
    \x19,\n\r\n\x05\x04\x1f\x02\0\x03\x12\x04\x81\x02/0\n\x0c\n\x02\x04\x20\
    \x12\x06\x84\x02\0\x8f\x02\x01\n\x0b\n\x03\x04\x20\x01\x12\x04\x84\x02\
    \x08$\n\x0c\n\x04\x04\x20\x02\0\x12\x04\x85\x02\x08\"\n\r\n\x05\x04\x20\
    \x02\0\x04\x12\x04\x85\x02\x08\x10\n\r\n\x05\x04\x20\x02\0\x05\x12\x04\
    \x85\x02\x11\x16\n\r\n\x05\x04\x20\x02\0\x01\x12\x04\x85\x02\x17\x1d\n\r\
    \n\x05\x04\x20\x02\0\x03\x12\x04\x85\x02\x20!\n\x0c\n\x04\x04\x20\x02\
    \x01\x12\x04\x86\x02\x08$\n\r\n\x05\x04\x20\x02\x01\x04\x12\x04\x86\x02\
    \x08\x10\n\r\n\x05\x04\x20\x02\x01\x05\x12\x04\x86\x02\x11\x16\n\r\n\x05\
    \x04\x20\x02\x01\x01\x12\x04\x86\x02\x17\x1f\n\r\n\x05\x04\x20\x02\x01\
    \x03\x12\x04\x86\x02\"#\n\x0c\n\x04\x04\x20\x02\x02\x12\x04\x87\x02\x08$\
    \n\r\n\x05\x04\x20\x02\x02\x04\x12\x04\x87\x02\x08\x10\n\r\n\x05\x04\x20\
    \x02\x02\x05\x12\x04\x87\x02\x11\x17\n\r\n\x05\x04\x20\x02\x02\x01\x12\
    \x04\x87\x02\x18\x1f\n\r\n\x05\x04\x20\x02\x02\x03\x12\x04\x87\x02\"#\n\
    \x0c\n\x04\x04\x20\x02\x03\x12\x04\x88\x02\x081\n\r\n\x05\x04\x20\x02\
    \x03\x04\x12\x04\x88\x02\x08\x10\n\r\n\x05\x04\x20\x02\x03\x05\x12\x04\
    \x88\x02\x11\x18\n\r\n\x05\x04\x20\x02\x03\x01\x12\x04\x88\x02\x19,\n\r\
    \n\x05\x04\x20\x02\x03\x03\x12\x04\x88\x02/0\n\x0c\n\x04\x04\x20\x02\x04\
    \x12\x04\x89\x02\x08:\n\r\n\x05\x04\x20\x02\x04\x04\x12\x04\x89\x02\x08\
    \x10\n\r\n\x05\x04\x20\x02\x04\x05\x12\x04\x89\x02\x11\x17\n\r\n\x05\x04\
    \x20\x02\x04\x01\x12\x04\x89\x02\x18'\n\r\n\x05\x04\x20\x02\x04\x03\x12\
    \x04\x89\x02*+\n\r\n\x05\x04\x20\x02\x04\x08\x12\x04\x89\x02,9\n\r\n\x05\
    \x04\x20\x02\x04\x07\x12\x04\x89\x0278\n\x0c\n\x04\x04\x20\x02\x05\x12\
    \x04\x8a\x02\x08-\n\r\n\x05\x04\x20\x02\x05\x04\x12\x04\x8a\x02\x08\x10\
    \n\r\n\x05\x04\x20\x02\x05\x05\x12\x04\x8a\x02\x11\x16\n\r\n\x05\x04\x20\
    \x02\x05\x01\x12\x04\x8a\x02\x17(\n\r\n\x05\x04\x20\x02\x05\x03\x12\x04\
    \x8a\x02+,\n\x0c\n\x04\x04\x20\x02\x06\x12\x04\x8b\x02\x08A\n\r\n\x05\
    \x04\x20\x02\x06\x04\x12\x04\x8b\x02\x08\x10\n\r\n\x05\x04\x20\x02\x06\
    \x05\x12\x04\x8b\x02\x11\x15\n\r\n\x05\x04\x20\x02\x06\x01\x12\x04\x8b\
    \x02\x16+\n\r\n\x05\x04\x20\x02\x06\x03\x12\x04\x8b\x02./\n\r\n\x05\x04\
    \x20\x02\x06\x08\x12\x04\x8b\x020@\n\r\n\x05\x04\x20\x02\x06\x07\x12\x04\
    \x8b\x02;?\n\x0c\n\x04\x04\x20\x02\x07\x12\x04\x8c\x02\x08'\n\r\n\x05\
    \x04\x20\x02\x07\x04\x12\x04\x8c\x02\x08\x10\n\r\n\x05\x04\x20\x02\x07\
    \x05\x12\x04\x8c\x02\x11\x16\n\r\n\x05\x04\x20\x02\x07\x01\x12\x04\x8c\
    \x02\x17\"\n\r\n\x05\x04\x20\x02\x07\x03\x12\x04\x8c\x02%&\n\x0c\n\x04\
    \x04\x20\x02\x08\x12\x04\x8d\x02\x08;\n\r\n\x05\x04\x20\x02\x08\x04\x12\
    \x04\x8d\x02\x08\x10\n\r\n\x05\x04\x20\x02\x08\x05\x12\x04\x8d\x02\x11\
    \x16\n\r\n\x05\x04\x20\x02\x08\x01\x12\x04\x8d\x02\x17(\n\r\n\x05\x04\
    \x20\x02\x08\x03\x12\x04\x8d\x02+,\n\r\n\x05\x04\x20\x02\x08\x08\x12\x04\
    \x8d\x02-:\n\r\n\x05\x04\x20\x02\x08\x07\x12\x04\x8d\x0289\n\x0c\n\x04\
    \x04\x20\x02\t\x12\x04\x8e\x02\x08+\n\r\n\x05\x04\x20\x02\t\x04\x12\x04\
    \x8e\x02\x08\x10\n\r\n\x05\x04\x20\x02\t\x05\x12\x04\x8e\x02\x11\x17\n\r\
    \n\x05\x04\x20\x02\t\x01\x12\x04\x8e\x02\x18%\n\r\n\x05\x04\x20\x02\t\
    \x03\x12\x04\x8e\x02(*\n\x0c\n\x02\x04!\x12\x06\x91\x02\0\x96\x02\x01\n\
    \x0b\n\x03\x04!\x01\x12\x04\x91\x02\x08\x1c\n\x0c\n\x04\x04!\x02\0\x12\
    \x04\x92\x02\x08&\n\r\n\x05\x04!\x02\0\x04\x12\x04\x92\x02\x08\x10\n\r\n\
    \x05\x04!\x02\0\x05\x12\x04\x92\x02\x11\x16\n\r\n\x05\x04!\x02\0\x01\x12\
    \x04\x92\x02\x17!\n\r\n\x05\x04!\x02\0\x03\x12\x04\x92\x02$%\n\x0c\n\x04\
    \x04!\x02\x01\x12\x04\x93\x02\x081\n\r\n\x05\x04!\x02\x01\x04\x12\x04\
    \x93\x02\x08\x10\n\r\n\x05\x04!\x02\x01\x05\x12\x04\x93\x02\x11\x18\n\r\
    \n\x05\x04!\x02\x01\x01\x12\x04\x93\x02\x19,\n\r\n\x05\x04!\x02\x01\x03\
    \x12\x04\x93\x02/0\n\x0c\n\x04\x04!\x02\x02\x12\x04\x94\x02\x08+\n\r\n\
    \x05\x04!\x02\x02\x04\x12\x04\x94\x02\x08\x10\n\r\n\x05\x04!\x02\x02\x05\
    \x12\x04\x94\x02\x11\x17\n\r\n\x05\x04!\x02\x02\x01\x12\x04\x94\x02\x18&\
    \n\r\n\x05\x04!\x02\x02\x03\x12\x04\x94\x02)*\n\x0c\n\x04\x04!\x02\x03\
    \x12\x04\x95\x02\x08%\n\r\n\x05\x04!\x02\x03\x04\x12\x04\x95\x02\x08\x10\
    \n\r\n\x05\x04!\x02\x03\x05\x12\x04\x95\x02\x11\x16\n\r\n\x05\x04!\x02\
    \x03\x01\x12\x04\x95\x02\x17\x20\n\r\n\x05\x04!\x02\x03\x03\x12\x04\x95\
    \x02#$\n\x0c\n\x02\x04\"\x12\x06\x98\x02\0\x9a\x02\x01\n\x0b\n\x03\x04\"\
    \x01\x12\x04\x98\x02\x08\x13\n\x0c\n\x04\x04\"\x02\0\x12\x04\x99\x02\x08\
    '\n\r\n\x05\x04\"\x02\0\x04\x12\x04\x99\x02\x08\x10\n\r\n\x05\x04\"\x02\
    \0\x05\x12\x04\x99\x02\x11\x17\n\r\n\x05\x04\"\x02\0\x01\x12\x04\x99\x02\
    \x18\"\n\r\n\x05\x04\"\x02\0\x03\x12\x04\x99\x02%&\n\x0c\n\x02\x04#\x12\
    \x06\x9c\x02\0\x9d\x02\x01\n\x0b\n\x03\x04#\x01\x12\x04\x9c\x02\x08#\n\
    \x0c\n\x02\x04$\x12\x06\x9f\x02\0\xa2\x02\x01\n\x0b\n\x03\x04$\x01\x12\
    \x04\x9f\x02\x08\x17\n\x0c\n\x04\x04$\x02\0\x12\x04\xa0\x02\x08!\n\r\n\
    \x05\x04$\x02\0\x04\x12\x04\xa0\x02\x08\x10\n\r\n\x05\x04$\x02\0\x05\x12\
    \x04\xa0\x02\x11\x17\n\r\n\x05\x04$\x02\0\x01\x12\x04\xa0\x02\x18\x1c\n\
    \r\n\x05\x04$\x02\0\x03\x12\x04\xa0\x02\x1f\x20\n\x0c\n\x04\x04$\x02\x01\
    \x12\x04\xa1\x02\x08\"\n\r\n\x05\x04$\x02\x01\x04\x12\x04\xa1\x02\x08\
    \x10\n\r\n\x05\x04$\x02\x01\x05\x12\x04\xa1\x02\x11\x17\n\r\n\x05\x04$\
    \x02\x01\x01\x12\x04\xa1\x02\x18\x1d\n\r\n\x05\x04$\x02\x01\x03\x12\x04\
    \xa1\x02\x20!\n\x0c\n\x02\x04%\x12\x06\xa4\x02\0\xa6\x02\x01\n\x0b\n\x03\
    \x04%\x01\x12\x04\xa4\x02\x08\x1c\n\x0c\n\x04\x04%\x02\0\x12\x04\xa5\x02\
    \x08.\n\r\n\x05\x04%\x02\0\x04\x12\x04\xa5\x02\x08\x10\n\r\n\x05\x04%\
    \x02\0\x06\x12\x04\xa5\x02\x11!\n\r\n\x05\x04%\x02\0\x01\x12\x04\xa5\x02\
    \")\n\r\n\x05\x04%\x02\0\x03\x12\x04\xa5\x02,-\n\x0c\n\x02\x04&\x12\x06\
    \xa8\x02\0\xaf\x02\x01\n\x0b\n\x03\x04&\x01\x12\x04\xa8\x02\x08\x13\n\
    \x0c\n\x04\x04&\x02\0\x12\x04\xa9\x02\x08$\n\r\n\x05\x04&\x02\0\x04\x12\
    \x04\xa9\x02\x08\x10\n\r\n\x05\x04&\x02\0\x05\x12\x04\xa9\x02\x11\x17\n\
    \r\n\x05\x04&\x02\0\x01\x12\x04\xa9\x02\x18\x1f\n\r\n\x05\x04&\x02\0\x03\
    \x12\x04\xa9\x02\"#\n\x0c\n\x04\x04&\x02\x01\x12\x04\xaa\x02\x08-\n\r\n\
    \x05\x04&\x02\x01\x04\x12\x04\xaa\x02\x08\x10\n\r\n\x05\x04&\x02\x01\x05\
    \x12\x04\xaa\x02\x11\x18\n\r\n\x05\x04&\x02\x01\x01\x12\x04\xaa\x02\x19(\
    \n\r\n\x05\x04&\x02\x01\x03\x12\x04\xaa\x02+,\n\x0c\n\x04\x04&\x02\x02\
    \x12\x04\xab\x02\x084\n\r\n\x05\x04&\x02\x02\x04\x12\x04\xab\x02\x08\x10\
    \n\r\n\x05\x04&\x02\x02\x05\x12\x04\xab\x02\x11\x17\n\r\n\x05\x04&\x02\
    \x02\x01\x12\x04\xab\x02\x18/\n\r\n\x05\x04&\x02\x02\x03\x12\x04\xab\x02\
    23\n\x0c\n\x04\x04&\x02\x03\x12\x04\xac\x02\x08-\n\r\n\x05\x04&\x02\x03\
    \x04\x12\x04\xac\x02\x08\x10\n\r\n\x05\x04&\x02\x03\x05\x12\x04\xac\x02\
    \x11\x17\n\r\n\x05\x04&\x02\x03\x01\x12\x04\xac\x02\x18(\n\r\n\x05\x04&\
    \x02\x03\x03\x12\x04\xac\x02+,\n\x0c\n\x04\x04&\x02\x04\x12\x04\xad\x02\
    \x080\n\r\n\x05\x04&\x02\x04\x04\x12\x04\xad\x02\x08\x10\n\r\n\x05\x04&\
    \x02\x04\x05\x12\x04\xad\x02\x11\x18\n\r\n\x05\x04&\x02\x04\x01\x12\x04\
    \xad\x02\x19+\n\r\n\x05\x04&\x02\x04\x03\x12\x04\xad\x02./\n\x0c\n\x04\
    \x04&\x02\x05\x12\x04\xae\x02\x084\n\r\n\x05\x04&\x02\x05\x04\x12\x04\
    \xae\x02\x08\x10\n\r\n\x05\x04&\x02\x05\x05\x12\x04\xae\x02\x11\x15\n\r\
    \n\x05\x04&\x02\x05\x01\x12\x04\xae\x02\x16/\n\r\n\x05\x04&\x02\x05\x03\
    \x12\x04\xae\x0223\n\x0c\n\x02\x04'\x12\x06\xb1\x02\0\xb5\x02\x01\n\x0b\
    \n\x03\x04'\x01\x12\x04\xb1\x02\x08#\n\x0c\n\x04\x04'\x02\0\x12\x04\xb2\
    \x02\x08(\n\r\n\x05\x04'\x02\0\x04\x12\x04\xb2\x02\x08\x10\n\r\n\x05\x04\
    '\x02\0\x05\x12\x04\xb2\x02\x11\x17\n\r\n\x05\x04'\x02\0\x01\x12\x04\xb2\
    \x02\x18#\n\r\n\x05\x04'\x02\0\x03\x12\x04\xb2\x02&'\n\x0c\n\x04\x04'\
    \x02\x01\x12\x04\xb3\x02\x081\n\r\n\x05\x04'\x02\x01\x04\x12\x04\xb3\x02\
    \x08\x10\n\r\n\x05\x04'\x02\x01\x05\x12\x04\xb3\x02\x11\x17\n\r\n\x05\
    \x04'\x02\x01\x01\x12\x04\xb3\x02\x18,\n\r\n\x05\x04'\x02\x01\x03\x12\
    \x04\xb3\x02/0\n\x0c\n\x04\x04'\x02\x02\x12\x04\xb4\x02\x08'\n\r\n\x05\
    \x04'\x02\x02\x04\x12\x04\xb4\x02\x08\x10\n\r\n\x05\x04'\x02\x02\x05\x12\
    \x04\xb4\x02\x11\x17\n\r\n\x05\x04'\x02\x02\x01\x12\x04\xb4\x02\x18\"\n\
    \r\n\x05\x04'\x02\x02\x03\x12\x04\xb4\x02%&\n\x0c\n\x02\x04(\x12\x06\xb7\
    \x02\0\xb9\x02\x01\n\x0b\n\x03\x04(\x01\x12\x04\xb7\x02\x08\x1f\n\x0c\n\
    \x04\x04(\x02\0\x12\x04\xb8\x02\x08'\n\r\n\x05\x04(\x02\0\x04\x12\x04\
    \xb8\x02\x08\x10\n\r\n\x05\x04(\x02\0\x05\x12\x04\xb8\x02\x11\x16\n\r\n\
    \x05\x04(\x02\0\x01\x12\x04\xb8\x02\x17\"\n\r\n\x05\x04(\x02\0\x03\x12\
    \x04\xb8\x02%&\n\x0c\n\x02\x04)\x12\x06\xbb\x02\0\xc5\x02\x01\n\x0b\n\
    \x03\x04)\x01\x12\x04\xbb\x02\x08\x1c\n\x0c\n\x04\x04)\x02\0\x12\x04\xbc\
    \x02\x08'\n\r\n\x05\x04)\x02\0\x04\x12\x04\xbc\x02\x08\x10\n\r\n\x05\x04\
    )\x02\0\x05\x12\x04\xbc\x02\x11\x17\n\r\n\x05\x04)\x02\0\x01\x12\x04\xbc\
    \x02\x18\"\n\r\n\x05\x04)\x02\0\x03\x12\x04\xbc\x02%&\n\x0c\n\x04\x04)\
    \x02\x01\x12\x04\xbd\x02\x08&\n\r\n\x05\x04)\x02\x01\x04\x12\x04\xbd\x02\
    \x08\x10\n\r\n\x05\x04)\x02\x01\x05\x12\x04\xbd\x02\x11\x17\n\r\n\x05\
    \x04)\x02\x01\x01\x12\x04\xbd\x02\x18!\n\r\n\x05\x04)\x02\x01\x03\x12\
    \x04\xbd\x02$%\n\x0c\n\x04\x04)\x02\x02\x12\x04\xbe\x02\x08&\n\r\n\x05\
    \x04)\x02\x02\x04\x12\x04\xbe\x02\x08\x10\n\r\n\x05\x04)\x02\x02\x05\x12\
    \x04\xbe\x02\x11\x17\n\r\n\x05\x04)\x02\x02\x01\x12\x04\xbe\x02\x18!\n\r\
    \n\x05\x04)\x02\x02\x03\x12\x04\xbe\x02$%\n\x0c\n\x04\x04)\x02\x03\x12\
    \x04\xbf\x02\x08$\n\r\n\x05\x04)\x02\x03\x04\x12\x04\xbf\x02\x08\x10\n\r\
    \n\x05\x04)\x02\x03\x05\x12\x04\xbf\x02\x11\x17\n\r\n\x05\x04)\x02\x03\
    \x01\x12\x04\xbf\x02\x18\x1f\n\r\n\x05\x04)\x02\x03\x03\x12\x04\xbf\x02\
    \"#\n\x0c\n\x04\x04)\x02\x04\x12\x04\xc0\x02\x08#\n\r\n\x05\x04)\x02\x04\
    \x04\x12\x04\xc0\x02\x08\x10\n\r\n\x05\x04)\x02\x04\x05\x12\x04\xc0\x02\
    \x11\x17\n\r\n\x05\x04)\x02\x04\x01\x12\x04\xc0\x02\x18\x1e\n\r\n\x05\
    \x04)\x02\x04\x03\x12\x04\xc0\x02!\"\n\x0c\n\x04\x04)\x02\x05\x12\x04\
    \xc1\x02\x08#\n\r\n\x05\x04)\x02\x05\x04\x12\x04\xc1\x02\x08\x10\n\r\n\
    \x05\x04)\x02\x05\x05\x12\x04\xc1\x02\x11\x17\n\r\n\x05\x04)\x02\x05\x01\
    \x12\x04\xc1\x02\x18\x1e\n\r\n\x05\x04)\x02\x05\x03\x12\x04\xc1\x02!\"\n\
    \x0c\n\x04\x04)\x02\x06\x12\x04\xc2\x02\x08'\n\r\n\x05\x04)\x02\x06\x04\
    \x12\x04\xc2\x02\x08\x10\n\r\n\x05\x04)\x02\x06\x05\x12\x04\xc2\x02\x11\
    \x17\n\r\n\x05\x04)\x02\x06\x01\x12\x04\xc2\x02\x18\"\n\r\n\x05\x04)\x02\
    \x06\x03\x12\x04\xc2\x02%&\n\x0c\n\x04\x04)\x02\x07\x12\x04\xc3\x02\x08'\
    \n\r\n\x05\x04)\x02\x07\x04\x12\x04\xc3\x02\x08\x10\n\r\n\x05\x04)\x02\
    \x07\x05\x12\x04\xc3\x02\x11\x17\n\r\n\x05\x04)\x02\x07\x01\x12\x04\xc3\
    \x02\x18\"\n\r\n\x05\x04)\x02\x07\x03\x12\x04\xc3\x02%&\n\x0c\n\x04\x04)\
    \x02\x08\x12\x04\xc4\x02\x08\x20\n\r\n\x05\x04)\x02\x08\x04\x12\x04\xc4\
    \x02\x08\x10\n\r\n\x05\x04)\x02\x08\x05\x12\x04\xc4\x02\x11\x16\n\r\n\
    \x05\x04)\x02\x08\x01\x12\x04\xc4\x02\x17\x1b\n\r\n\x05\x04)\x02\x08\x03\
    \x12\x04\xc4\x02\x1e\x1f\n\x0c\n\x02\x04*\x12\x06\xc7\x02\0\xcc\x02\x01\
    \n\x0b\n\x03\x04*\x01\x12\x04\xc7\x02\x08!\n\x0c\n\x04\x04*\x02\0\x12\
    \x04\xc8\x02\x08%\n\r\n\x05\x04*\x02\0\x04\x12\x04\xc8\x02\x08\x10\n\r\n\
    \x05\x04*\x02\0\x05\x12\x04\xc8\x02\x11\x17\n\r\n\x05\x04*\x02\0\x01\x12\
    \x04\xc8\x02\x18\x20\n\r\n\x05\x04*\x02\0\x03\x12\x04\xc8\x02#$\n\x0c\n\
    \x04\x04*\x02\x01\x12\x04\xc9\x02\x08&\n\r\n\x05\x04*\x02\x01\x04\x12\
    \x04\xc9\x02\x08\x10\n\r\n\x05\x04*\x02\x01\x05\x12\x04\xc9\x02\x11\x17\
    \n\r\n\x05\x04*\x02\x01\x01\x12\x04\xc9\x02\x18!\n\r\n\x05\x04*\x02\x01\
    \x03\x12\x04\xc9\x02$%\n\x0c\n\x04\x04*\x02\x02\x12\x04\xca\x02\x08$\n\r\
    \n\x05\x04*\x02\x02\x04\x12\x04\xca\x02\x08\x10\n\r\n\x05\x04*\x02\x02\
    \x05\x12\x04\xca\x02\x11\x17\n\r\n\x05\x04*\x02\x02\x01\x12\x04\xca\x02\
    \x18\x1f\n\r\n\x05\x04*\x02\x02\x03\x12\x04\xca\x02\"#\n\x0c\n\x04\x04*\
    \x02\x03\x12\x04\xcb\x02\x08$\n\r\n\x05\x04*\x02\x03\x04\x12\x04\xcb\x02\
    \x08\x10\n\r\n\x05\x04*\x02\x03\x05\x12\x04\xcb\x02\x11\x17\n\r\n\x05\
    \x04*\x02\x03\x01\x12\x04\xcb\x02\x18\x1f\n\r\n\x05\x04*\x02\x03\x03\x12\
    \x04\xcb\x02\"#\n\x0c\n\x02\x04+\x12\x06\xce\x02\0\xd5\x02\x01\n\x0b\n\
    \x03\x04+\x01\x12\x04\xce\x02\x08\x1c\n\x0e\n\x04\x04+\x03\0\x12\x06\xcf\
    \x02\x08\xd2\x02\t\n\r\n\x05\x04+\x03\0\x01\x12\x04\xcf\x02\x10\x1c\n\
    \x0e\n\x06\x04+\x03\0\x02\0\x12\x04\xd0\x02\x10,\n\x0f\n\x07\x04+\x03\0\
    \x02\0\x04\x12\x04\xd0\x02\x10\x18\n\x0f\n\x07\x04+\x03\0\x02\0\x05\x12\
    \x04\xd0\x02\x19\x1f\n\x0f\n\x07\x04+\x03\0\x02\0\x01\x12\x04\xd0\x02\
    \x20'\n\x0f\n\x07\x04+\x03\0\x02\0\x03\x12\x04\xd0\x02*+\n\x0e\n\x06\x04\
    +\x03\0\x02\x01\x12\x04\xd1\x02\x10-\n\x0f\n\x07\x04+\x03\0\x02\x01\x04\
    \x12\x04\xd1\x02\x10\x18\n\x0f\n\x07\x04+\x03\0\x02\x01\x05\x12\x04\xd1\
    \x02\x19\x1f\n\x0f\n\x07\x04+\x03\0\x02\x01\x01\x12\x04\xd1\x02\x20(\n\
    \x0f\n\x07\x04+\x03\0\x02\x01\x03\x12\x04\xd1\x02+,\n\x0c\n\x04\x04+\x02\
    \0\x12\x04\xd4\x02\x08G\n\r\n\x05\x04+\x02\0\x04\x12\x04\xd4\x02\x08\x10\
    \n\r\n\x05\x04+\x02\0\x06\x12\x04\xd4\x02\x113\n\r\n\x05\x04+\x02\0\x01\
    \x12\x04\xd4\x024B\n\r\n\x05\x04+\x02\0\x03\x12\x04\xd4\x02EF\n\x0c\n\
    \x02\x04,\x12\x06\xd7\x02\0\xdc\x02\x01\n\x0b\n\x03\x04,\x01\x12\x04\xd7\
    \x02\x08!\n\x0c\n\x04\x04,\x02\0\x12\x04\xd8\x02\x08:\n\r\n\x05\x04,\x02\
    \0\x04\x12\x04\xd8\x02\x08\x10\n\r\n\x05\x04,\x02\0\x05\x12\x04\xd8\x02\
    \x11\x17\n\r\n\x05\x04,\x02\0\x01\x12\x04\xd8\x02\x18\x20\n\r\n\x05\x04,\
    \x02\0\x03\x12\x04\xd8\x02#$\n\r\n\x05\x04,\x02\0\x08\x12\x04\xd8\x02%9\
    \n\x10\n\x08\x04,\x02\0\x08\xe0\xd4\x03\x12\x04\xd8\x02&8\n\x0c\n\x04\
    \x04,\x02\x01\x12\x04\xd9\x02\x08;\n\r\n\x05\x04,\x02\x01\x04\x12\x04\
    \xd9\x02\x08\x10\n\r\n\x05\x04,\x02\x01\x05\x12\x04\xd9\x02\x11\x17\n\r\
    \n\x05\x04,\x02\x01\x01\x12\x04\xd9\x02\x18!\n\r\n\x05\x04,\x02\x01\x03\
    \x12\x04\xd9\x02$%\n\r\n\x05\x04,\x02\x01\x08\x12\x04\xd9\x02&:\n\x10\n\
    \x08\x04,\x02\x01\x08\xe0\xd4\x03\x12\x04\xd9\x02'9\n\x0c\n\x04\x04,\x02\
    \x02\x12\x04\xda\x02\x089\n\r\n\x05\x04,\x02\x02\x04\x12\x04\xda\x02\x08\
    \x10\n\r\n\x05\x04,\x02\x02\x05\x12\x04\xda\x02\x11\x17\n\r\n\x05\x04,\
    \x02\x02\x01\x12\x04\xda\x02\x18\x1f\n\r\n\x05\x04,\x02\x02\x03\x12\x04\
    \xda\x02\"#\n\r\n\x05\x04,\x02\x02\x08\x12\x04\xda\x02$8\n\x10\n\x08\x04\
    ,\x02\x02\x08\xe0\xd4\x03\x12\x04\xda\x02%7\n\x0c\n\x04\x04,\x02\x03\x12\
    \x04\xdb\x02\x08$\n\r\n\x05\x04,\x02\x03\x04\x12\x04\xdb\x02\x08\x10\n\r\
    \n\x05\x04,\x02\x03\x05\x12\x04\xdb\x02\x11\x17\n\r\n\x05\x04,\x02\x03\
    \x01\x12\x04\xdb\x02\x18\x1f\n\r\n\x05\x04,\x02\x03\x03\x12\x04\xdb\x02\
    \"#\n\x0c\n\x02\x04-\x12\x06\xde\x02\0\xe1\x02\x01\n\x0b\n\x03\x04-\x01\
    \x12\x04\xde\x02\x08\x20\n\x0c\n\x04\x04-\x02\0\x12\x04\xdf\x02\x08%\n\r\
    \n\x05\x04-\x02\0\x04\x12\x04\xdf\x02\x08\x10\n\r\n\x05\x04-\x02\0\x05\
    \x12\x04\xdf\x02\x11\x17\n\r\n\x05\x04-\x02\0\x01\x12\x04\xdf\x02\x18\
    \x20\n\r\n\x05\x04-\x02\0\x03\x12\x04\xdf\x02#$\n\x0c\n\x04\x04-\x02\x01\
    \x12\x04\xe0\x02\x08&\n\r\n\x05\x04-\x02\x01\x04\x12\x04\xe0\x02\x08\x10\
    \n\r\n\x05\x04-\x02\x01\x05\x12\x04\xe0\x02\x11\x17\n\r\n\x05\x04-\x02\
    \x01\x01\x12\x04\xe0\x02\x18!\n\r\n\x05\x04-\x02\x01\x03\x12\x04\xe0\x02\
    $%\n\x0c\n\x02\x04.\x12\x06\xe3\x02\0\xe7\x02\x01\n\x0b\n\x03\x04.\x01\
    \x12\x04\xe3\x02\x08\x20\n\x0c\n\x04\x04.\x02\0\x12\x04\xe4\x02\x08'\n\r\
    \n\x05\x04.\x02\0\x04\x12\x04\xe4\x02\x08\x10\n\r\n\x05\x04.\x02\0\x05\
    \x12\x04\xe4\x02\x11\x17\n\r\n\x05\x04.\x02\0\x01\x12\x04\xe4\x02\x18\"\
    \n\r\n\x05\x04.\x02\0\x03\x12\x04\xe4\x02%&\n\x0c\n\x04\x04.\x02\x01\x12\
    \x04\xe5\x02\x08%\n\r\n\x05\x04.\x02\x01\x04\x12\x04\xe5\x02\x08\x10\n\r\
    \n\x05\x04.\x02\x01\x05\x12\x04\xe5\x02\x11\x17\n\r\n\x05\x04.\x02\x01\
    \x01\x12\x04\xe5\x02\x18\x20\n\r\n\x05\x04.\x02\x01\x03\x12\x04\xe5\x02#\
    $\n\x0c\n\x04\x04.\x02\x02\x12\x04\xe6\x02\x08-\n\r\n\x05\x04.\x02\x02\
    \x04\x12\x04\xe6\x02\x08\x10\n\r\n\x05\x04.\x02\x02\x05\x12\x04\xe6\x02\
    \x11\x17\n\r\n\x05\x04.\x02\x02\x01\x12\x04\xe6\x02\x18(\n\r\n\x05\x04.\
    \x02\x02\x03\x12\x04\xe6\x02+,\n\x0c\n\x02\x04/\x12\x06\xe9\x02\0\xf1\
    \x02\x01\n\x0b\n\x03\x04/\x01\x12\x04\xe9\x02\x08\x19\n\x0c\n\x04\x04/\
    \x02\0\x12\x04\xea\x02\x08-\n\r\n\x05\x04/\x02\0\x04\x12\x04\xea\x02\x08\
    \x10\n\r\n\x05\x04/\x02\0\x05\x12\x04\xea\x02\x11\x18\n\r\n\x05\x04/\x02\
    \0\x01\x12\x04\xea\x02\x19(\n\r\n\x05\x04/\x02\0\x03\x12\x04\xea\x02+,\n\
    \x0c\n\x04\x04/\x02\x01\x12\x04\xeb\x02\x08(\n\r\n\x05\x04/\x02\x01\x04\
    \x12\x04\xeb\x02\x08\x10\n\r\n\x05\x04/\x02\x01\x05\x12\x04\xeb\x02\x11\
    \x17\n\r\n\x05\x04/\x02\x01\x01\x12\x04\xeb\x02\x18#\n\r\n\x05\x04/\x02\
    \x01\x03\x12\x04\xeb\x02&'\n\x0c\n\x04\x04/\x02\x02\x12\x04\xec\x02\x08\
    \x20\n\r\n\x05\x04/\x02\x02\x04\x12\x04\xec\x02\x08\x10\n\r\n\x05\x04/\
    \x02\x02\x05\x12\x04\xec\x02\x11\x17\n\r\n\x05\x04/\x02\x02\x01\x12\x04\
    \xec\x02\x18\x1b\n\r\n\x05\x04/\x02\x02\x03\x12\x04\xec\x02\x1e\x1f\n\
    \x0c\n\x04\x04/\x02\x03\x12\x04\xed\x02\x08'\n\r\n\x05\x04/\x02\x03\x04\
    \x12\x04\xed\x02\x08\x10\n\r\n\x05\x04/\x02\x03\x05\x12\x04\xed\x02\x11\
    \x17\n\r\n\x05\x04/\x02\x03\x01\x12\x04\xed\x02\x18\"\n\r\n\x05\x04/\x02\
    \x03\x03\x12\x04\xed\x02%&\n\x0c\n\x04\x04/\x02\x04\x12\x04\xee\x02\x08)\
    \n\r\n\x05\x04/\x02\x04\x04\x12\x04\xee\x02\x08\x10\n\r\n\x05\x04/\x02\
    \x04\x05\x12\x04\xee\x02\x11\x17\n\r\n\x05\x04/\x02\x04\x01\x12\x04\xee\
    \x02\x18$\n\r\n\x05\x04/\x02\x04\x03\x12\x04\xee\x02'(\n\x0c\n\x04\x04/\
    \x02\x05\x12\x04\xef\x02\x083\n\r\n\x05\x04/\x02\x05\x04\x12\x04\xef\x02\
    \x08\x10\n\r\n\x05\x04/\x02\x05\x05\x12\x04\xef\x02\x11\x18\n\r\n\x05\
    \x04/\x02\x05\x01\x12\x04\xef\x02\x19.\n\r\n\x05\x04/\x02\x05\x03\x12\
    \x04\xef\x0212\n\x0c\n\x04\x04/\x02\x06\x12\x04\xf0\x02\x084\n\r\n\x05\
    \x04/\x02\x06\x04\x12\x04\xf0\x02\x08\x10\n\r\n\x05\x04/\x02\x06\x05\x12\
    \x04\xf0\x02\x11\x17\n\r\n\x05\x04/\x02\x06\x01\x12\x04\xf0\x02\x18/\n\r\
    \n\x05\x04/\x02\x06\x03\x12\x04\xf0\x0223\n\x0c\n\x02\x040\x12\x06\xf3\
    \x02\0\xf7\x02\x01\n\x0b\n\x03\x040\x01\x12\x04\xf3\x02\x08!\n\x0c\n\x04\
    \x040\x02\0\x12\x04\xf4\x02\x08-\n\r\n\x05\x040\x02\0\x04\x12\x04\xf4\
    \x02\x08\x10\n\r\n\x05\x040\x02\0\x05\x12\x04\xf4\x02\x11\x18\n\r\n\x05\
    \x040\x02\0\x01\x12\x04\xf4\x02\x19(\n\r\n\x05\x040\x02\0\x03\x12\x04\
    \xf4\x02+,\n\x0c\n\x04\x040\x02\x01\x12\x04\xf5\x02\x08#\n\r\n\x05\x040\
    \x02\x01\x04\x12\x04\xf5\x02\x08\x10\n\r\n\x05\x040\x02\x01\x05\x12\x04\
    \xf5\x02\x11\x17\n\r\n\x05\x040\x02\x01\x01\x12\x04\xf5\x02\x18\x1e\n\r\
    \n\x05\x040\x02\x01\x03\x12\x04\xf5\x02!\"\n\x0c\n\x04\x040\x02\x02\x12\
    \x04\xf6\x02\x08*\n\r\n\x05\x040\x02\x02\x04\x12\x04\xf6\x02\x08\x10\n\r\
    \n\x05\x040\x02\x02\x05\x12\x04\xf6\x02\x11\x17\n\r\n\x05\x040\x02\x02\
    \x01\x12\x04\xf6\x02\x18%\n\r\n\x05\x040\x02\x02\x03\x12\x04\xf6\x02()\n\
    \x0c\n\x02\x041\x12\x06\xf9\x02\0\xfd\x02\x01\n\x0b\n\x03\x041\x01\x12\
    \x04\xf9\x02\x08\"\n\x0c\n\x04\x041\x02\0\x12\x04\xfa\x02\x08,\n\r\n\x05\
    \x041\x02\0\x04\x12\x04\xfa\x02\x08\x10\n\r\n\x05\x041\x02\0\x05\x12\x04\
    \xfa\x02\x11\x18\n\r\n\x05\x041\x02\0\x01\x12\x04\xfa\x02\x19'\n\r\n\x05\
    \x041\x02\0\x03\x12\x04\xfa\x02*+\n\x0c\n\x04\x041\x02\x01\x12\x04\xfb\
    \x02\x08+\n\r\n\x05\x041\x02\x01\x04\x12\x04\xfb\x02\x08\x10\n\r\n\x05\
    \x041\x02\x01\x05\x12\x04\xfb\x02\x11\x17\n\r\n\x05\x041\x02\x01\x01\x12\
    \x04\xfb\x02\x18&\n\r\n\x05\x041\x02\x01\x03\x12\x04\xfb\x02)*\n\x0c\n\
    \x04\x041\x02\x02\x12\x04\xfc\x02\x08-\n\r\n\x05\x041\x02\x02\x04\x12\
    \x04\xfc\x02\x08\x10\n\r\n\x05\x041\x02\x02\x05\x12\x04\xfc\x02\x11\x17\
    \n\r\n\x05\x041\x02\x02\x01\x12\x04\xfc\x02\x18(\n\r\n\x05\x041\x02\x02\
    \x03\x12\x04\xfc\x02+,\n\x0c\n\x02\x042\x12\x06\xff\x02\0\x84\x03\x01\n\
    \x0b\n\x03\x042\x01\x12\x04\xff\x02\x08'\n\x0c\n\x04\x042\x02\0\x12\x04\
    \x80\x03\x08@\n\r\n\x05\x042\x02\0\x04\x12\x04\x80\x03\x08\x10\n\r\n\x05\
    \x042\x02\0\x05\x12\x04\x80\x03\x11\x17\n\r\n\x05\x042\x02\0\x01\x12\x04\
    \x80\x03\x18;\n\r\n\x05\x042\x02\0\x03\x12\x04\x80\x03>?\n\x0c\n\x04\x04\
    2\x02\x01\x12\x04\x81\x03\x08?\n\r\n\x05\x042\x02\x01\x04\x12\x04\x81\
    \x03\x08\x10\n\r\n\x05\x042\x02\x01\x05\x12\x04\x81\x03\x11\x17\n\r\n\
    \x05\x042\x02\x01\x01\x12\x04\x81\x03\x18:\n\r\n\x05\x042\x02\x01\x03\
    \x12\x04\x81\x03=>\n\x0c\n\x04\x042\x02\x02\x12\x04\x82\x03\x080\n\r\n\
    \x05\x042\x02\x02\x04\x12\x04\x82\x03\x08\x10\n\r\n\x05\x042\x02\x02\x05\
    \x12\x04\x82\x03\x11\x17\n\r\n\x05\x042\x02\x02\x01\x12\x04\x82\x03\x18+\
    \n\r\n\x05\x042\x02\x02\x03\x12\x04\x82\x03./\n\x0c\n\x04\x042\x02\x03\
    \x12\x04\x83\x03\x082\n\r\n\x05\x042\x02\x03\x04\x12\x04\x83\x03\x08\x10\
    \n\r\n\x05\x042\x02\x03\x05\x12\x04\x83\x03\x11\x17\n\r\n\x05\x042\x02\
    \x03\x01\x12\x04\x83\x03\x18-\n\r\n\x05\x042\x02\x03\x03\x12\x04\x83\x03\
    01\n\x0c\n\x02\x043\x12\x06\x86\x03\0\x88\x03\x01\n\x0b\n\x03\x043\x01\
    \x12\x04\x86\x03\x08\x1f\n\x0c\n\x04\x043\x02\0\x12\x04\x87\x03\x08,\n\r\
    \n\x05\x043\x02\0\x04\x12\x04\x87\x03\x08\x10\n\r\n\x05\x043\x02\0\x05\
    \x12\x04\x87\x03\x11\x18\n\r\n\x05\x043\x02\0\x01\x12\x04\x87\x03\x19'\n\
    \r\n\x05\x043\x02\0\x03\x12\x04\x87\x03*+\n\x0c\n\x02\x044\x12\x06\x8a\
    \x03\0\x8e\x03\x01\n\x0b\n\x03\x044\x01\x12\x04\x8a\x03\x08\x1f\n\x0c\n\
    \x04\x044\x02\0\x12\x04\x8b\x03\x08'\n\r\n\x05\x044\x02\0\x04\x12\x04\
    \x8b\x03\x08\x10\n\r\n\x05\x044\x02\0\x05\x12\x04\x8b\x03\x11\x17\n\r\n\
    \x05\x044\x02\0\x01\x12\x04\x8b\x03\x18\"\n\r\n\x05\x044\x02\0\x03\x12\
    \x04\x8b\x03%&\n\x0c\n\x04\x044\x02\x01\x12\x04\x8c\x03\x08'\n\r\n\x05\
    \x044\x02\x01\x04\x12\x04\x8c\x03\x08\x10\n\r\n\x05\x044\x02\x01\x05\x12\
    \x04\x8c\x03\x11\x17\n\r\n\x05\x044\x02\x01\x01\x12\x04\x8c\x03\x18\"\n\
    \r\n\x05\x044\x02\x01\x03\x12\x04\x8c\x03%&\n\x0c\n\x04\x044\x02\x02\x12\
    \x04\x8d\x03\x08#\n\r\n\x05\x044\x02\x02\x04\x12\x04\x8d\x03\x08\x10\n\r\
    \n\x05\x044\x02\x02\x05\x12\x04\x8d\x03\x11\x17\n\r\n\x05\x044\x02\x02\
    \x01\x12\x04\x8d\x03\x18\x1e\n\r\n\x05\x044\x02\x02\x03\x12\x04\x8d\x03!\
    \"\n\x0c\n\x02\x045\x12\x06\x90\x03\0\x95\x03\x01\n\x0b\n\x03\x045\x01\
    \x12\x04\x90\x03\x08(\n\x0c\n\x04\x045\x02\0\x12\x04\x91\x03\x08C\n\r\n\
    \x05\x045\x02\0\x04\x12\x04\x91\x03\x08\x10\n\r\n\x05\x045\x02\0\x05\x12\
    \x04\x91\x03\x11\x17\n\r\n\x05\x045\x02\0\x01\x12\x04\x91\x03\x18)\n\r\n\
    \x05\x045\x02\0\x03\x12\x04\x91\x03,-\n\r\n\x05\x045\x02\0\x08\x12\x04\
    \x91\x03.B\n\x10\n\x08\x045\x02\0\x08\xe0\xd4\x03\x12\x04\x91\x03/A\n\
    \x0c\n\x04\x045\x02\x01\x12\x04\x92\x03\x08&\n\r\n\x05\x045\x02\x01\x04\
    \x12\x04\x92\x03\x08\x10\n\r\n\x05\x045\x02\x01\x05\x12\x04\x92\x03\x11\
    \x17\n\r\n\x05\x045\x02\x01\x01\x12\x04\x92\x03\x18!\n\r\n\x05\x045\x02\
    \x01\x03\x12\x04\x92\x03$%\n\x0c\n\x04\x045\x02\x02\x12\x04\x93\x03\x08%\
    \n\r\n\x05\x045\x02\x02\x04\x12\x04\x93\x03\x08\x10\n\r\n\x05\x045\x02\
    \x02\x05\x12\x04\x93\x03\x11\x17\n\r\n\x05\x045\x02\x02\x01\x12\x04\x93\
    \x03\x18\x20\n\r\n\x05\x045\x02\x02\x03\x12\x04\x93\x03#$\n\x0c\n\x04\
    \x045\x02\x03\x12\x04\x94\x03\x08'\n\r\n\x05\x045\x02\x03\x04\x12\x04\
    \x94\x03\x08\x10\n\r\n\x05\x045\x02\x03\x05\x12\x04\x94\x03\x11\x17\n\r\
    \n\x05\x045\x02\x03\x01\x12\x04\x94\x03\x18\"\n\r\n\x05\x045\x02\x03\x03\
    \x12\x04\x94\x03%&\n\x0c\n\x02\x046\x12\x06\x97\x03\0\x9a\x03\x01\n\x0b\
    \n\x03\x046\x01\x12\x04\x97\x03\x08\x1f\n\x0c\n\x04\x046\x02\0\x12\x04\
    \x98\x03\x08$\n\r\n\x05\x046\x02\0\x04\x12\x04\x98\x03\x08\x10\n\r\n\x05\
    \x046\x02\0\x05\x12\x04\x98\x03\x11\x17\n\r\n\x05\x046\x02\0\x01\x12\x04\
    \x98\x03\x18\x1f\n\r\n\x05\x046\x02\0\x03\x12\x04\x98\x03\"#\n\x0c\n\x04\
    \x046\x02\x01\x12\x04\x99\x03\x084\n\r\n\x05\x046\x02\x01\x04\x12\x04\
    \x99\x03\x08\x10\n\r\n\x05\x046\x02\x01\x05\x12\x04\x99\x03\x11\x17\n\r\
    \n\x05\x046\x02\x01\x01\x12\x04\x99\x03\x18/\n\r\n\x05\x046\x02\x01\x03\
    \x12\x04\x99\x0323\n\x0c\n\x02\x047\x12\x06\x9c\x03\0\x9f\x03\x01\n\x0b\
    \n\x03\x047\x01\x12\x04\x9c\x03\x08\x1f\n\x0c\n\x04\x047\x02\0\x12\x04\
    \x9d\x03\x08$\n\r\n\x05\x047\x02\0\x04\x12\x04\x9d\x03\x08\x10\n\r\n\x05\
    \x047\x02\0\x05\x12\x04\x9d\x03\x11\x17\n\r\n\x05\x047\x02\0\x01\x12\x04\
    \x9d\x03\x18\x1f\n\r\n\x05\x047\x02\0\x03\x12\x04\x9d\x03\"#\n\x0c\n\x04\
    \x047\x02\x01\x12\x04\x9e\x03\x08,\n\r\n\x05\x047\x02\x01\x04\x12\x04\
    \x9e\x03\x08\x10\n\r\n\x05\x047\x02\x01\x05\x12\x04\x9e\x03\x11\x17\n\r\
    \n\x05\x047\x02\x01\x01\x12\x04\x9e\x03\x18'\n\r\n\x05\x047\x02\x01\x03\
    \x12\x04\x9e\x03*+\n\x0c\n\x02\x048\x12\x06\xa1\x03\0\xa3\x03\x01\n\x0b\
    \n\x03\x048\x01\x12\x04\xa1\x03\x080\n\x0c\n\x04\x048\x02\0\x12\x04\xa2\
    \x03\x08$\n\r\n\x05\x048\x02\0\x04\x12\x04\xa2\x03\x08\x10\n\r\n\x05\x04\
    8\x02\0\x05\x12\x04\xa2\x03\x11\x17\n\r\n\x05\x048\x02\0\x01\x12\x04\xa2\
    \x03\x18\x1f\n\r\n\x05\x048\x02\0\x03\x12\x04\xa2\x03\"#\n\x0c\n\x02\x04\
    9\x12\x06\xa5\x03\0\xa7\x03\x01\n\x0b\n\x03\x049\x01\x12\x04\xa5\x03\x08\
    \x20\n\x0c\n\x04\x049\x02\0\x12\x04\xa6\x03\x08$\n\r\n\x05\x049\x02\0\
    \x04\x12\x04\xa6\x03\x08\x10\n\r\n\x05\x049\x02\0\x05\x12\x04\xa6\x03\
    \x11\x17\n\r\n\x05\x049\x02\0\x01\x12\x04\xa6\x03\x18\x1f\n\r\n\x05\x049\
    \x02\0\x03\x12\x04\xa6\x03\"#\n\x0c\n\x02\x04:\x12\x06\xa9\x03\0\xab\x03\
    \x01\n\x0b\n\x03\x04:\x01\x12\x04\xa9\x03\x08/\n\x0c\n\x04\x04:\x02\0\
    \x12\x04\xaa\x03\x08+\n\r\n\x05\x04:\x02\0\x04\x12\x04\xaa\x03\x08\x10\n\
    \r\n\x05\x04:\x02\0\x05\x12\x04\xaa\x03\x11\x17\n\r\n\x05\x04:\x02\0\x01\
    \x12\x04\xaa\x03\x18&\n\r\n\x05\x04:\x02\0\x03\x12\x04\xaa\x03)*\n\x0c\n\
    \x02\x04;\x12\x06\xad\x03\0\xaf\x03\x01\n\x0b\n\x03\x04;\x01\x12\x04\xad\
    \x03\x08!\n\x0c\n\x04\x04;\x02\0\x12\x04\xae\x03\x08#\n\r\n\x05\x04;\x02\
    \0\x04\x12\x04\xae\x03\x08\x10\n\r\n\x05\x04;\x02\0\x05\x12\x04\xae\x03\
    \x11\x17\n\r\n\x05\x04;\x02\0\x01\x12\x04\xae\x03\x18\x1e\n\r\n\x05\x04;\
    \x02\0\x03\x12\x04\xae\x03!\"\n\x0c\n\x02\x04<\x12\x06\xb1\x03\0\xb3\x03\
    \x01\n\x0b\n\x03\x04<\x01\x12\x04\xb1\x03\x08)\n\x0c\n\x04\x04<\x02\0\
    \x12\x04\xb2\x03\x08#\n\r\n\x05\x04<\x02\0\x04\x12\x04\xb2\x03\x08\x10\n\
    \r\n\x05\x04<\x02\0\x05\x12\x04\xb2\x03\x11\x17\n\r\n\x05\x04<\x02\0\x01\
    \x12\x04\xb2\x03\x18\x1e\n\r\n\x05\x04<\x02\0\x03\x12\x04\xb2\x03!\"\n\
    \x0c\n\x02\x04=\x12\x06\xb5\x03\0\xb7\x03\x01\n\x0b\n\x03\x04=\x01\x12\
    \x04\xb5\x03\x08#\n\x0c\n\x04\x04=\x02\0\x12\x04\xb6\x03\x08#\n\r\n\x05\
    \x04=\x02\0\x04\x12\x04\xb6\x03\x08\x10\n\r\n\x05\x04=\x02\0\x05\x12\x04\
    \xb6\x03\x11\x17\n\r\n\x05\x04=\x02\0\x01\x12\x04\xb6\x03\x18\x1e\n\r\n\
    \x05\x04=\x02\0\x03\x12\x04\xb6\x03!\"\n\x0c\n\x02\x04>\x12\x06\xb9\x03\
    \0\xbc\x03\x01\n\x0b\n\x03\x04>\x01\x12\x04\xb9\x03\x08+\n\x0c\n\x04\x04\
    >\x02\0\x12\x04\xba\x03\x08#\n\r\n\x05\x04>\x02\0\x04\x12\x04\xba\x03\
    \x08\x10\n\r\n\x05\x04>\x02\0\x05\x12\x04\xba\x03\x11\x17\n\r\n\x05\x04>\
    \x02\0\x01\x12\x04\xba\x03\x18\x1e\n\r\n\x05\x04>\x02\0\x03\x12\x04\xba\
    \x03!\"\n\x0c\n\x04\x04>\x02\x01\x12\x04\xbb\x03\x08%\n\r\n\x05\x04>\x02\
    \x01\x04\x12\x04\xbb\x03\x08\x10\n\r\n\x05\x04>\x02\x01\x05\x12\x04\xbb\
    \x03\x11\x17\n\r\n\x05\x04>\x02\x01\x01\x12\x04\xbb\x03\x18\x20\n\r\n\
    \x05\x04>\x02\x01\x03\x12\x04\xbb\x03#$\n\x0c\n\x02\x04?\x12\x06\xbe\x03\
    \0\xc1\x03\x01\n\x0b\n\x03\x04?\x01\x12\x04\xbe\x03\x08#\n\x0c\n\x04\x04\
    ?\x02\0\x12\x04\xbf\x03\x08.\n\r\n\x05\x04?\x02\0\x04\x12\x04\xbf\x03\
    \x08\x10\n\r\n\x05\x04?\x02\0\x05\x12\x04\xbf\x03\x11\x17\n\r\n\x05\x04?\
    \x02\0\x01\x12\x04\xbf\x03\x18)\n\r\n\x05\x04?\x02\0\x03\x12\x04\xbf\x03\
    ,-\n\x0c\n\x04\x04?\x02\x01\x12\x04\xc0\x03\x08$\n\r\n\x05\x04?\x02\x01\
    \x04\x12\x04\xc0\x03\x08\x10\n\r\n\x05\x04?\x02\x01\x05\x12\x04\xc0\x03\
    \x11\x17\n\r\n\x05\x04?\x02\x01\x01\x12\x04\xc0\x03\x18\x1f\n\r\n\x05\
    \x04?\x02\x01\x03\x12\x04\xc0\x03\"#\n\x0c\n\x02\x04@\x12\x06\xc3\x03\0\
    \xc7\x03\x01\n\x0b\n\x03\x04@\x01\x12\x04\xc3\x03\x08\x19\n\x0c\n\x04\
    \x04@\x02\0\x12\x04\xc4\x03\x08,\n\r\n\x05\x04@\x02\0\x04\x12\x04\xc4\
    \x03\x08\x10\n\r\n\x05\x04@\x02\0\x05\x12\x04\xc4\x03\x11\x17\n\r\n\x05\
    \x04@\x02\0\x01\x12\x04\xc4\x03\x18'\n\r\n\x05\x04@\x02\0\x03\x12\x04\
    \xc4\x03*+\n\x0c\n\x04\x04@\x02\x01\x12\x04\xc5\x03\x08,\n\r\n\x05\x04@\
    \x02\x01\x04\x12\x04\xc5\x03\x08\x10\n\r\n\x05\x04@\x02\x01\x05\x12\x04\
    \xc5\x03\x11\x15\n\r\n\x05\x04@\x02\x01\x01\x12\x04\xc5\x03\x16'\n\r\n\
    \x05\x04@\x02\x01\x03\x12\x04\xc5\x03*+\n\x0c\n\x04\x04@\x02\x02\x12\x04\
    \xc6\x03\x082\n\r\n\x05\x04@\x02\x02\x04\x12\x04\xc6\x03\x08\x10\n\r\n\
    \x05\x04@\x02\x02\x05\x12\x04\xc6\x03\x11\x17\n\r\n\x05\x04@\x02\x02\x01\
    \x12\x04\xc6\x03\x18-\n\r\n\x05\x04@\x02\x02\x03\x12\x04\xc6\x0301\n\x0c\
    \n\x02\x04A\x12\x06\xc9\x03\0\xcc\x03\x01\n\x0b\n\x03\x04A\x01\x12\x04\
    \xc9\x03\x08\x19\n\x0c\n\x04\x04A\x02\0\x12\x04\xca\x03\x08/\n\r\n\x05\
    \x04A\x02\0\x04\x12\x04\xca\x03\x08\x10\n\r\n\x05\x04A\x02\0\x05\x12\x04\
    \xca\x03\x11\x17\n\r\n\x05\x04A\x02\0\x01\x12\x04\xca\x03\x18*\n\r\n\x05\
    \x04A\x02\0\x03\x12\x04\xca\x03-.\n\x0c\n\x04\x04A\x02\x01\x12\x04\xcb\
    \x03\x08,\n\r\n\x05\x04A\x02\x01\x04\x12\x04\xcb\x03\x08\x10\n\r\n\x05\
    \x04A\x02\x01\x05\x12\x04\xcb\x03\x11\x17\n\r\n\x05\x04A\x02\x01\x01\x12\
    \x04\xcb\x03\x18'\n\r\n\x05\x04A\x02\x01\x03\x12\x04\xcb\x03*+\n\x0c\n\
    \x02\x04B\x12\x06\xce\x03\0\xd0\x03\x01\n\x0b\n\x03\x04B\x01\x12\x04\xce\
    \x03\x08%\n\x0c\n\x04\x04B\x02\0\x12\x04\xcf\x03\x08*\n\r\n\x05\x04B\x02\
    \0\x04\x12\x04\xcf\x03\x08\x10\n\r\n\x05\x04B\x02\0\x05\x12\x04\xcf\x03\
    \x11\x17\n\r\n\x05\x04B\x02\0\x01\x12\x04\xcf\x03\x18%\n\r\n\x05\x04B\
    \x02\0\x03\x12\x04\xcf\x03()\n\x0c\n\x02\x04C\x12\x06\xd2\x03\0\xd7\x03\
    \x01\n\x0b\n\x03\x04C\x01\x12\x04\xd2\x03\x08#\n\x0c\n\x04\x04C\x02\0\
    \x12\x04\xd3\x03\x08+\n\r\n\x05\x04C\x02\0\x04\x12\x04\xd3\x03\x08\x10\n\
    \r\n\x05\x04C\x02\0\x05\x12\x04\xd3\x03\x11\x17\n\r\n\x05\x04C\x02\0\x01\
    \x12\x04\xd3\x03\x18&\n\r\n\x05\x04C\x02\0\x03\x12\x04\xd3\x03)*\n\x0c\n\
    \x04\x04C\x02\x01\x12\x04\xd4\x03\x08)\n\r\n\x05\x04C\x02\x01\x04\x12\
    \x04\xd4\x03\x08\x10\n\r\n\x05\x04C\x02\x01\x05\x12\x04\xd4\x03\x11\x17\
    \n\r\n\x05\x04C\x02\x01\x01\x12\x04\xd4\x03\x18$\n\r\n\x05\x04C\x02\x01\
    \x03\x12\x04\xd4\x03'(\n\x0c\n\x04\x04C\x02\x02\x12\x04\xd5\x03\x08/\n\r\
    \n\x05\x04C\x02\x02\x04\x12\x04\xd5\x03\x08\x10\n\r\n\x05\x04C\x02\x02\
    \x05\x12\x04\xd5\x03\x11\x17\n\r\n\x05\x04C\x02\x02\x01\x12\x04\xd5\x03\
    \x18*\n\r\n\x05\x04C\x02\x02\x03\x12\x04\xd5\x03-.\n\x0c\n\x04\x04C\x02\
    \x03\x12\x04\xd6\x03\x084\n\r\n\x05\x04C\x02\x03\x04\x12\x04\xd6\x03\x08\
    \x10\n\r\n\x05\x04C\x02\x03\x05\x12\x04\xd6\x03\x11\x17\n\r\n\x05\x04C\
    \x02\x03\x01\x12\x04\xd6\x03\x18/\n\r\n\x05\x04C\x02\x03\x03\x12\x04\xd6\
    \x0323\n\x0c\n\x02\x04D\x12\x06\xd9\x03\0\xdb\x03\x01\n\x0b\n\x03\x04D\
    \x01\x12\x04\xd9\x03\x08\x1e\n\x0c\n\x04\x04D\x02\0\x12\x04\xda\x03\x08:\
    \n\r\n\x05\x04D\x02\0\x04\x12\x04\xda\x03\x08\x10\n\r\n\x05\x04D\x02\0\
    \x06\x12\x04\xda\x03\x11-\n\r\n\x05\x04D\x02\0\x01\x12\x04\xda\x03.5\n\r\
    \n\x05\x04D\x02\0\x03\x12\x04\xda\x0389\n\x0c\n\x02\x04E\x12\x06\xdd\x03\
    \0\xe0\x03\x01\n\x0b\n\x03\x04E\x01\x12\x04\xdd\x03\x08\x1b\n\x0c\n\x04\
    \x04E\x02\0\x12\x04\xde\x03\x08)\n\r\n\x05\x04E\x02\0\x04\x12\x04\xde\
    \x03\x08\x10\n\r\n\x05\x04E\x02\0\x05\x12\x04\xde\x03\x11\x17\n\r\n\x05\
    \x04E\x02\0\x01\x12\x04\xde\x03\x18$\n\r\n\x05\x04E\x02\0\x03\x12\x04\
    \xde\x03'(\n\x0c\n\x04\x04E\x02\x01\x12\x04\xdf\x03\x08,\n\r\n\x05\x04E\
    \x02\x01\x04\x12\x04\xdf\x03\x08\x10\n\r\n\x05\x04E\x02\x01\x05\x12\x04\
    \xdf\x03\x11\x17\n\r\n\x05\x04E\x02\x01\x01\x12\x04\xdf\x03\x18'\n\r\n\
    \x05\x04E\x02\x01\x03\x12\x04\xdf\x03*+\n\x0c\n\x02\x04F\x12\x06\xe2\x03\
    \0\xe5\x03\x01\n\x0b\n\x03\x04F\x01\x12\x04\xe2\x03\x08\x1f\n\x0c\n\x04\
    \x04F\x02\0\x12\x04\xe3\x03\x08)\n\r\n\x05\x04F\x02\0\x04\x12\x04\xe3\
    \x03\x08\x10\n\r\n\x05\x04F\x02\0\x05\x12\x04\xe3\x03\x11\x17\n\r\n\x05\
    \x04F\x02\0\x01\x12\x04\xe3\x03\x18$\n\r\n\x05\x04F\x02\0\x03\x12\x04\
    \xe3\x03'(\n\x0c\n\x04\x04F\x02\x01\x12\x04\xe4\x03\x08/\n\r\n\x05\x04F\
    \x02\x01\x04\x12\x04\xe4\x03\x08\x10\n\r\n\x05\x04F\x02\x01\x05\x12\x04\
    \xe4\x03\x11\x17\n\r\n\x05\x04F\x02\x01\x01\x12\x04\xe4\x03\x18*\n\r\n\
    \x05\x04F\x02\x01\x03\x12\x04\xe4\x03-.\n\x0c\n\x02\x04G\x12\x06\xe7\x03\
    \0\xea\x03\x01\n\x0b\n\x03\x04G\x01\x12\x04\xe7\x03\x08\x1b\n\x0c\n\x04\
    \x04G\x02\0\x12\x04\xe8\x03\x08,\n\r\n\x05\x04G\x02\0\x04\x12\x04\xe8\
    \x03\x08\x10\n\r\n\x05\x04G\x02\0\x05\x12\x04\xe8\x03\x11\x17\n\r\n\x05\
    \x04G\x02\0\x01\x12\x04\xe8\x03\x18'\n\r\n\x05\x04G\x02\0\x03\x12\x04\
    \xe8\x03*+\n\x0c\n\x04\x04G\x02\x01\x12\x04\xe9\x03\x08,\n\r\n\x05\x04G\
    \x02\x01\x04\x12\x04\xe9\x03\x08\x10\n\r\n\x05\x04G\x02\x01\x05\x12\x04\
    \xe9\x03\x11\x17\n\r\n\x05\x04G\x02\x01\x01\x12\x04\xe9\x03\x18'\n\r\n\
    \x05\x04G\x02\x01\x03\x12\x04\xe9\x03*+\n\x0c\n\x02\x04H\x12\x06\xec\x03\
    \0\xef\x03\x01\n\x0b\n\x03\x04H\x01\x12\x04\xec\x03\x08)\n\x0c\n\x04\x04\
    H\x02\0\x12\x04\xed\x03\x08)\n\r\n\x05\x04H\x02\0\x04\x12\x04\xed\x03\
    \x08\x10\n\r\n\x05\x04H\x02\0\x05\x12\x04\xed\x03\x11\x17\n\r\n\x05\x04H\
    \x02\0\x01\x12\x04\xed\x03\x18$\n\r\n\x05\x04H\x02\0\x03\x12\x04\xed\x03\
    '(\n\x0c\n\x04\x04H\x02\x01\x12\x04\xee\x03\x08A\n\r\n\x05\x04H\x02\x01\
    \x04\x12\x04\xee\x03\x08\x10\n\r\n\x05\x04H\x02\x01\x06\x12\x04\xee\x03\
    \x11%\n\r\n\x05\x04H\x02\x01\x01\x12\x04\xee\x03&<\n\r\n\x05\x04H\x02\
    \x01\x03\x12\x04\xee\x03?@\n\x0c\n\x02\x04I\x12\x06\xf1\x03\0\xf4\x03\
    \x01\n\x0b\n\x03\x04I\x01\x12\x04\xf1\x03\x08'\n\x0c\n\x04\x04I\x02\0\
    \x12\x04\xf2\x03\x08$\n\r\n\x05\x04I\x02\0\x04\x12\x04\xf2\x03\x08\x10\n\
    \r\n\x05\x04I\x02\0\x05\x12\x04\xf2\x03\x11\x17\n\r\n\x05\x04I\x02\0\x01\
    \x12\x04\xf2\x03\x18\x1f\n\r\n\x05\x04I\x02\0\x03\x12\x04\xf2\x03\"#\n\
    \x0c\n\x04\x04I\x02\x01\x12\x04\xf3\x03\x08\"\n\r\n\x05\x04I\x02\x01\x04\
    \x12\x04\xf3\x03\x08\x10\n\r\n\x05\x04I\x02\x01\x05\x12\x04\xf3\x03\x11\
    \x16\n\r\n\x05\x04I\x02\x01\x01\x12\x04\xf3\x03\x17\x1d\n\r\n\x05\x04I\
    \x02\x01\x03\x12\x04\xf3\x03\x20!\n\x0c\n\x02\x04J\x12\x06\xf6\x03\0\xf9\
    \x03\x01\n\x0b\n\x03\x04J\x01\x12\x04\xf6\x03\x08%\n\x0c\n\x04\x04J\x02\
    \0\x12\x04\xf7\x03\x08$\n\r\n\x05\x04J\x02\0\x04\x12\x04\xf7\x03\x08\x10\
    \n\r\n\x05\x04J\x02\0\x05\x12\x04\xf7\x03\x11\x17\n\r\n\x05\x04J\x02\0\
    \x01\x12\x04\xf7\x03\x18\x1f\n\r\n\x05\x04J\x02\0\x03\x12\x04\xf7\x03\"#\
    \n\x0c\n\x04\x04J\x02\x01\x12\x04\xf8\x03\x08#\n\r\n\x05\x04J\x02\x01\
    \x04\x12\x04\xf8\x03\x08\x10\n\r\n\x05\x04J\x02\x01\x05\x12\x04\xf8\x03\
    \x11\x15\n\r\n\x05\x04J\x02\x01\x01\x12\x04\xf8\x03\x16\x1e\n\r\n\x05\
    \x04J\x02\x01\x03\x12\x04\xf8\x03!\"\n\x0c\n\x02\x04K\x12\x06\xfb\x03\0\
    \xfe\x03\x01\n\x0b\n\x03\x04K\x01\x12\x04\xfb\x03\x08$\n\x0c\n\x04\x04K\
    \x02\0\x12\x04\xfc\x03\x08*\n\r\n\x05\x04K\x02\0\x04\x12\x04\xfc\x03\x08\
    \x10\n\r\n\x05\x04K\x02\0\x05\x12\x04\xfc\x03\x11\x17\n\r\n\x05\x04K\x02\
    \0\x01\x12\x04\xfc\x03\x18%\n\r\n\x05\x04K\x02\0\x03\x12\x04\xfc\x03()\n\
    \x0c\n\x04\x04K\x02\x01\x12\x04\xfd\x03\x082\n\r\n\x05\x04K\x02\x01\x04\
    \x12\x04\xfd\x03\x08\x10\n\r\n\x05\x04K\x02\x01\x05\x12\x04\xfd\x03\x11\
    \x17\n\r\n\x05\x04K\x02\x01\x01\x12\x04\xfd\x03\x18-\n\r\n\x05\x04K\x02\
    \x01\x03\x12\x04\xfd\x0301\n\x0c\n\x02\x04L\x12\x06\x80\x04\0\x82\x04\
    \x01\n\x0b\n\x03\x04L\x01\x12\x04\x80\x04\x08(\n\x0c\n\x04\x04L\x02\0\
    \x12\x04\x81\x04\x08I\n\r\n\x05\x04L\x02\0\x04\x12\x04\x81\x04\x08\x10\n\
    \r\n\x05\x04L\x02\0\x05\x12\x04\x81\x04\x11\x15\n\r\n\x05\x04L\x02\0\x01\
    \x12\x04\x81\x04\x162\n\r\n\x05\x04L\x02\0\x03\x12\x04\x81\x0456\n\r\n\
    \x05\x04L\x02\0\x08\x12\x04\x81\x047H\n\r\n\x05\x04L\x02\0\x07\x12\x04\
    \x81\x04BG\n\x0c\n\x02\x04M\x12\x06\x84\x04\0\x91\x04\x01\n\x0b\n\x03\
    \x04M\x01\x12\x04\x84\x04\x082\n\x0e\n\x04\x04M\x03\0\x12\x06\x85\x04\
    \x08\x88\x04\t\n\r\n\x05\x04M\x03\0\x01\x12\x04\x85\x04\x10%\n\x0e\n\x06\
    \x04M\x03\0\x02\0\x12\x04\x86\x04\x10/\n\x0f\n\x07\x04M\x03\0\x02\0\x04\
    \x12\x04\x86\x04\x10\x18\n\x0f\n\x07\x04M\x03\0\x02\0\x05\x12\x04\x86\
    \x04\x19\x1f\n\x0f\n\x07\x04M\x03\0\x02\0\x01\x12\x04\x86\x04\x20*\n\x0f\
    \n\x07\x04M\x03\0\x02\0\x03\x12\x04\x86\x04-.\n\x0e\n\x06\x04M\x03\0\x02\
    \x01\x12\x04\x87\x04\x105\n\x0f\n\x07\x04M\x03\0\x02\x01\x04\x12\x04\x87\
    \x04\x10\x18\n\x0f\n\x07\x04M\x03\0\x02\x01\x05\x12\x04\x87\x04\x19\x1f\
    \n\x0f\n\x07\x04M\x03\0\x02\x01\x01\x12\x04\x87\x04\x200\n\x0f\n\x07\x04\
    M\x03\0\x02\x01\x03\x12\x04\x87\x0434\n\x0e\n\x04\x04M\x03\x01\x12\x06\
    \x8a\x04\x08\x8d\x04\t\n\r\n\x05\x04M\x03\x01\x01\x12\x04\x8a\x04\x10-\n\
    \x0e\n\x06\x04M\x03\x01\x02\0\x12\x04\x8b\x04\x10-\n\x0f\n\x07\x04M\x03\
    \x01\x02\0\x04\x12\x04\x8b\x04\x10\x18\n\x0f\n\x07\x04M\x03\x01\x02\0\
    \x05\x12\x04\x8b\x04\x19\x1f\n\x0f\n\x07\x04M\x03\x01\x02\0\x01\x12\x04\
    \x8b\x04\x20(\n\x0f\n\x07\x04M\x03\x01\x02\0\x03\x12\x04\x8b\x04+,\n\x0e\
    \n\x06\x04M\x03\x01\x02\x01\x12\x04\x8c\x04\x10l\n\x0f\n\x07\x04M\x03\
    \x01\x02\x01\x04\x12\x04\x8c\x04\x10\x18\n\x0f\n\x07\x04M\x03\x01\x02\
    \x01\x06\x12\x04\x8c\x04\x19Z\n\x0f\n\x07\x04M\x03\x01\x02\x01\x01\x12\
    \x04\x8c\x04[g\n\x0f\n\x07\x04M\x03\x01\x02\x01\x03\x12\x04\x8c\x04jk\n\
    \x0c\n\x04\x04M\x02\0\x12\x04\x8f\x04\x08\"\n\r\n\x05\x04M\x02\0\x04\x12\
    \x04\x8f\x04\x08\x10\n\r\n\x05\x04M\x02\0\x05\x12\x04\x8f\x04\x11\x17\n\
    \r\n\x05\x04M\x02\0\x01\x12\x04\x8f\x04\x18\x1d\n\r\n\x05\x04M\x02\0\x03\
    \x12\x04\x8f\x04\x20!\n\x0c\n\x04\x04M\x02\x01\x12\x04\x90\x04\x08i\n\r\
    \n\x05\x04M\x02\x01\x04\x12\x04\x90\x04\x08\x10\n\r\n\x05\x04M\x02\x01\
    \x06\x12\x04\x90\x04\x11Z\n\r\n\x05\x04M\x02\x01\x01\x12\x04\x90\x04[d\n\
    \r\n\x05\x04M\x02\x01\x03\x12\x04\x90\x04gh\n\x0c\n\x02\x04N\x12\x06\x93\
    \x04\0\x96\x04\x01\n\x0b\n\x03\x04N\x01\x12\x04\x93\x04\x08)\n\x0c\n\x04\
    \x04N\x02\0\x12\x04\x94\x04\x08\"\n\r\n\x05\x04N\x02\0\x04\x12\x04\x94\
    \x04\x08\x10\n\r\n\x05\x04N\x02\0\x05\x12\x04\x94\x04\x11\x17\n\r\n\x05\
    \x04N\x02\0\x01\x12\x04\x94\x04\x18\x1d\n\r\n\x05\x04N\x02\0\x03\x12\x04\
    \x94\x04\x20!\n\x0c\n\x04\x04N\x02\x01\x12\x04\x95\x04\x08'\n\r\n\x05\
    \x04N\x02\x01\x04\x12\x04\x95\x04\x08\x10\n\r\n\x05\x04N\x02\x01\x05\x12\
    \x04\x95\x04\x11\x17\n\r\n\x05\x04N\x02\x01\x01\x12\x04\x95\x04\x18\"\n\
    \r\n\x05\x04N\x02\x01\x03\x12\x04\x95\x04%&\n\x0c\n\x02\x04O\x12\x06\x98\
    \x04\0\x9a\x04\x01\n\x0b\n\x03\x04O\x01\x12\x04\x98\x04\x08*\n\x0c\n\x04\
    \x04O\x02\0\x12\x04\x99\x04\x08*\n\r\n\x05\x04O\x02\0\x04\x12\x04\x99\
    \x04\x08\x10\n\r\n\x05\x04O\x02\0\x05\x12\x04\x99\x04\x11\x18\n\r\n\x05\
    \x04O\x02\0\x01\x12\x04\x99\x04\x19%\n\r\n\x05\x04O\x02\0\x03\x12\x04\
    \x99\x04()\n\x0c\n\x02\x04P\x12\x06\x9c\x04\0\xad\x04\x01\n\x0b\n\x03\
    \x04P\x01\x12\x04\x9c\x04\x08-\n\x0e\n\x04\x04P\x03\0\x12\x06\x9d\x04\
    \x08\xa1\x04\t\n\r\n\x05\x04P\x03\0\x01\x12\x04\x9d\x04\x10'\n\x0e\n\x06\
    \x04P\x03\0\x02\0\x12\x04\x9e\x04\x105\n\x0f\n\x07\x04P\x03\0\x02\0\x04\
    \x12\x04\x9e\x04\x10\x18\n\x0f\n\x07\x04P\x03\0\x02\0\x05\x12\x04\x9e\
    \x04\x19\x1f\n\x0f\n\x07\x04P\x03\0\x02\0\x01\x12\x04\x9e\x04\x200\n\x0f\
    \n\x07\x04P\x03\0\x02\0\x03\x12\x04\x9e\x0434\n\x0e\n\x06\x04P\x03\0\x02\
    \x01\x12\x04\x9f\x04\x106\n\x0f\n\x07\x04P\x03\0\x02\x01\x04\x12\x04\x9f\
    \x04\x10\x18\n\x0f\n\x07\x04P\x03\0\x02\x01\x05\x12\x04\x9f\x04\x19\x1e\
    \n\x0f\n\x07\x04P\x03\0\x02\x01\x01\x12\x04\x9f\x04\x1f1\n\x0f\n\x07\x04\
    P\x03\0\x02\x01\x03\x12\x04\x9f\x0445\n\x0e\n\x06\x04P\x03\0\x02\x02\x12\
    \x04\xa0\x04\x105\n\x0f\n\x07\x04P\x03\0\x02\x02\x04\x12\x04\xa0\x04\x10\
    \x18\n\x0f\n\x07\x04P\x03\0\x02\x02\x05\x12\x04\xa0\x04\x19\x1f\n\x0f\n\
    \x07\x04P\x03\0\x02\x02\x01\x12\x04\xa0\x04\x200\n\x0f\n\x07\x04P\x03\0\
    \x02\x02\x03\x12\x04\xa0\x0434\n\x0e\n\x04\x04P\x03\x01\x12\x06\xa3\x04\
    \x08\xa7\x04\t\n\r\n\x05\x04P\x03\x01\x01\x12\x04\xa3\x04\x10&\n\x0e\n\
    \x06\x04P\x03\x01\x02\0\x12\x04\xa4\x04\x10/\n\x0f\n\x07\x04P\x03\x01\
    \x02\0\x04\x12\x04\xa4\x04\x10\x18\n\x0f\n\x07\x04P\x03\x01\x02\0\x05\
    \x12\x04\xa4\x04\x19\x1f\n\x0f\n\x07\x04P\x03\x01\x02\0\x01\x12\x04\xa4\
    \x04\x20*\n\x0f\n\x07\x04P\x03\x01\x02\0\x03\x12\x04\xa4\x04-.\n\x0e\n\
    \x06\x04P\x03\x01\x02\x01\x12\x04\xa5\x04\x106\n\x0f\n\x07\x04P\x03\x01\
    \x02\x01\x04\x12\x04\xa5\x04\x10\x18\n\x0f\n\x07\x04P\x03\x01\x02\x01\
    \x05\x12\x04\xa5\x04\x19\x1e\n\x0f\n\x07\x04P\x03\x01\x02\x01\x01\x12\
    \x04\xa5\x04\x1f1\n\x0f\n\x07\x04P\x03\x01\x02\x01\x03\x12\x04\xa5\x0445\
    \n\x0e\n\x06\x04P\x03\x01\x02\x02\x12\x04\xa6\x04\x105\n\x0f\n\x07\x04P\
    \x03\x01\x02\x02\x04\x12\x04\xa6\x04\x10\x18\n\x0f\n\x07\x04P\x03\x01\
    \x02\x02\x05\x12\x04\xa6\x04\x19\x1f\n\x0f\n\x07\x04P\x03\x01\x02\x02\
    \x01\x12\x04\xa6\x04\x200\n\x0f\n\x07\x04P\x03\x01\x02\x02\x03\x12\x04\
    \xa6\x0434\n\x0c\n\x04\x04P\x02\0\x12\x04\xa9\x04\x08\"\n\r\n\x05\x04P\
    \x02\0\x04\x12\x04\xa9\x04\x08\x10\n\r\n\x05\x04P\x02\0\x05\x12\x04\xa9\
    \x04\x11\x17\n\r\n\x05\x04P\x02\0\x01\x12\x04\xa9\x04\x18\x1d\n\r\n\x05\
    \x04P\x02\0\x03\x12\x04\xa9\x04\x20!\n\x0c\n\x04\x04P\x02\x01\x12\x04\
    \xaa\x04\x08'\n\r\n\x05\x04P\x02\x01\x04\x12\x04\xaa\x04\x08\x10\n\r\n\
    \x05\x04P\x02\x01\x05\x12\x04\xaa\x04\x11\x17\n\r\n\x05\x04P\x02\x01\x01\
    \x12\x04\xaa\x04\x18\"\n\r\n\x05\x04P\x02\x01\x03\x12\x04\xaa\x04%&\n\
    \x0c\n\x04\x04P\x02\x02\x12\x04\xab\x04\x08n\n\r\n\x05\x04P\x02\x02\x04\
    \x12\x04\xab\x04\x08\x10\n\r\n\x05\x04P\x02\x02\x06\x12\x04\xab\x04\x11O\
    \n\r\n\x05\x04P\x02\x02\x01\x12\x04\xab\x04Pi\n\r\n\x05\x04P\x02\x02\x03\
    \x12\x04\xab\x04lm\n\x0c\n\x04\x04P\x02\x03\x12\x04\xac\x04\x08d\n\r\n\
    \x05\x04P\x02\x03\x04\x12\x04\xac\x04\x08\x10\n\r\n\x05\x04P\x02\x03\x06\
    \x12\x04\xac\x04\x11N\n\r\n\x05\x04P\x02\x03\x01\x12\x04\xac\x04O_\n\r\n\
    \x05\x04P\x02\x03\x03\x12\x04\xac\x04bc\n\x0c\n\x02\x04Q\x12\x06\xaf\x04\
    \0\xb0\x04\x01\n\x0b\n\x03\x04Q\x01\x12\x04\xaf\x04\x08.\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(1);
            deps.push(super::steammessages::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(87);
            messages.push(CGCStorePurchaseInit_LineItem::generated_message_descriptor_data());
            messages.push(CMsgGCStorePurchaseInit::generated_message_descriptor_data());
            messages.push(CMsgGCStorePurchaseInitResponse::generated_message_descriptor_data());
            messages.push(CMsgSystemBroadcast::generated_message_descriptor_data());
            messages.push(CMsgClientHello::generated_message_descriptor_data());
            messages.push(CMsgServerHello::generated_message_descriptor_data());
            messages.push(CMsgClientWelcome::generated_message_descriptor_data());
            messages.push(CMsgServerWelcome::generated_message_descriptor_data());
            messages.push(CMsgClientGoodbye::generated_message_descriptor_data());
            messages.push(CMsgServerGoodbye::generated_message_descriptor_data());
            messages.push(CMsgServerAvailable::generated_message_descriptor_data());
            messages.push(CMsgLANServerAvailable::generated_message_descriptor_data());
            messages.push(CSOEconGameAccountClient::generated_message_descriptor_data());
            messages.push(CSOItemCriteriaCondition::generated_message_descriptor_data());
            messages.push(CSOItemCriteria::generated_message_descriptor_data());
            messages.push(CSOItemRecipe::generated_message_descriptor_data());
            messages.push(CMsgDevNewItemRequest::generated_message_descriptor_data());
            messages.push(CMsgDevDebugRollLootRequest::generated_message_descriptor_data());
            messages.push(CMsgIncrementKillCountAttribute::generated_message_descriptor_data());
            messages.push(CMsgIncrementKillCountAttribute_Multiple::generated_message_descriptor_data());
            messages.push(CMsgTrackUniquePlayerPairEvent::generated_message_descriptor_data());
            messages.push(CMsgApplyStrangeCountTransfer::generated_message_descriptor_data());
            messages.push(CMsgApplyStrangePart::generated_message_descriptor_data());
            messages.push(CMsgApplyStrangeRestriction::generated_message_descriptor_data());
            messages.push(CMsgApplyUpgradeCard::generated_message_descriptor_data());
            messages.push(CSOEconItemAttribute::generated_message_descriptor_data());
            messages.push(CSOEconItemEquipped::generated_message_descriptor_data());
            messages.push(CSOEconItem::generated_message_descriptor_data());
            messages.push(CMsgAdjustItemEquippedState::generated_message_descriptor_data());
            messages.push(CMsgSortItems::generated_message_descriptor_data());
            messages.push(CSOEconClaimCode::generated_message_descriptor_data());
            messages.push(CMsgStoreGetUserData::generated_message_descriptor_data());
            messages.push(CMsgStoreGetUserDataResponse::generated_message_descriptor_data());
            messages.push(CMsgUpdateItemSchema::generated_message_descriptor_data());
            messages.push(CMsgGCError::generated_message_descriptor_data());
            messages.push(CMsgRequestInventoryRefresh::generated_message_descriptor_data());
            messages.push(CMsgConVarValue::generated_message_descriptor_data());
            messages.push(CMsgReplicateConVars::generated_message_descriptor_data());
            messages.push(CMsgUseItem::generated_message_descriptor_data());
            messages.push(CMsgReplayUploadedToYouTube::generated_message_descriptor_data());
            messages.push(CMsgConsumableExhausted::generated_message_descriptor_data());
            messages.push(CMsgItemAcknowledged::generated_message_descriptor_data());
            messages.push(CMsgSetPresetItemPosition::generated_message_descriptor_data());
            messages.push(CMsgSetItemPositions::generated_message_descriptor_data());
            messages.push(CSOEconItemPresetInstance::generated_message_descriptor_data());
            messages.push(CMsgSelectPresetForClass::generated_message_descriptor_data());
            messages.push(CSOClassPresetClientData::generated_message_descriptor_data());
            messages.push(CMsgGCReportAbuse::generated_message_descriptor_data());
            messages.push(CMsgGCReportAbuseResponse::generated_message_descriptor_data());
            messages.push(CMsgGCNameItemNotification::generated_message_descriptor_data());
            messages.push(CMsgGCClientDisplayNotification::generated_message_descriptor_data());
            messages.push(CMsgGCShowItemsPickedUp::generated_message_descriptor_data());
            messages.push(CMsgUpdatePeriodicEvent::generated_message_descriptor_data());
            messages.push(CMsgGCIncrementKillCountResponse::generated_message_descriptor_data());
            messages.push(CMsgGCRemoveStrangePart::generated_message_descriptor_data());
            messages.push(CMsgGCRemoveUpgradeCard::generated_message_descriptor_data());
            messages.push(CMsgGCRemoveCustomizationAttributeSimple::generated_message_descriptor_data());
            messages.push(CMsgGCResetStrangeScores::generated_message_descriptor_data());
            messages.push(CMsgGCItemPreviewItemBoughtNotification::generated_message_descriptor_data());
            messages.push(CMsgGCStorePurchaseCancel::generated_message_descriptor_data());
            messages.push(CMsgGCStorePurchaseCancelResponse::generated_message_descriptor_data());
            messages.push(CMsgGCStorePurchaseFinalize::generated_message_descriptor_data());
            messages.push(CMsgGCStorePurchaseFinalizeResponse::generated_message_descriptor_data());
            messages.push(CMsgGCBannedWordListRequest::generated_message_descriptor_data());
            messages.push(CMsgGCGiftedItems::generated_message_descriptor_data());
            messages.push(CMsgGCCollectItem::generated_message_descriptor_data());
            messages.push(CMsgGCClientMarketDataRequest::generated_message_descriptor_data());
            messages.push(CMsgGCClientMarketDataEntry::generated_message_descriptor_data());
            messages.push(CMsgGCClientMarketData::generated_message_descriptor_data());
            messages.push(CMsgApplyToolToItem::generated_message_descriptor_data());
            messages.push(CMsgApplyToolToBaseItem::generated_message_descriptor_data());
            messages.push(CMsgRecipeComponent::generated_message_descriptor_data());
            messages.push(CMsgFulfillDynamicRecipeComponent::generated_message_descriptor_data());
            messages.push(CMsgSetItemEffectVerticalOffset::generated_message_descriptor_data());
            messages.push(CMsgSetHatEffectUseHeadOrigin::generated_message_descriptor_data());
            messages.push(CMsgDeliverGiftResponseGiver::generated_message_descriptor_data());
            messages.push(CSOEconGameAccountForGameServers::generated_message_descriptor_data());
            messages.push(CWorkshop_PopulateItemDescriptions_Request::generated_message_descriptor_data());
            messages.push(CWorkshop_GetContributors_Request::generated_message_descriptor_data());
            messages.push(CWorkshop_GetContributors_Response::generated_message_descriptor_data());
            messages.push(CWorkshop_SetItemPaymentRules_Request::generated_message_descriptor_data());
            messages.push(CWorkshop_SetItemPaymentRules_Response::generated_message_descriptor_data());
            messages.push(cmsg_set_item_positions::ItemPosition::generated_message_descriptor_data());
            messages.push(cworkshop_populate_item_descriptions_request::SingleItemDescription::generated_message_descriptor_data());
            messages.push(cworkshop_populate_item_descriptions_request::ItemDescriptionsLanguageBlock::generated_message_descriptor_data());
            messages.push(cworkshop_set_item_payment_rules_request::WorkshopItemPaymentRule::generated_message_descriptor_data());
            messages.push(cworkshop_set_item_payment_rules_request::PartnerItemPaymentRule::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(3);
            enums.push(EGCBaseMsg::generated_enum_descriptor_data());
            enums.push(EGCBaseProtoObjectTypes::generated_enum_descriptor_data());
            enums.push(GCGoodbyeReason::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
